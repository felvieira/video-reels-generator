"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-fetch-native-with-agent";
exports.ids = ["vendor-chunks/node-fetch-native-with-agent"];
exports.modules = {

/***/ "(rsc)/./node_modules/node-fetch-native-with-agent/dist/agent.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/node-fetch-native-with-agent/dist/agent.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar u = Object.defineProperty;\nvar o = (e, t)=>u(e, \"name\", {\n        value: t,\n        configurable: !0\n    });\nconst http = __webpack_require__(/*! node:http */ \"node:http\"), https = __webpack_require__(/*! node:https */ \"node:https\"), index = __webpack_require__(/*! ./shared/node-fetch-native-with-agent.df7e6bd6.cjs */ \"(rsc)/./node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.df7e6bd6.cjs\"), nodeFetchNativeWithAgent = __webpack_require__(/*! node-fetch-native-with-agent */ \"(rsc)/./node_modules/node-fetch-native-with-agent/lib/index.cjs\");\n__webpack_require__(/*! node:assert */ \"node:assert\"), __webpack_require__(/*! node:net */ \"node:net\"), __webpack_require__(/*! node:stream */ \"node:stream\"), __webpack_require__(/*! node:buffer */ \"node:buffer\"), __webpack_require__(/*! node:util */ \"node:util\"), __webpack_require__(/*! node:querystring */ \"node:querystring\"), __webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\"), __webpack_require__(/*! node:events */ \"node:events\"), __webpack_require__(/*! ./shared/node-fetch-native-with-agent.61758d11.cjs */ \"(rsc)/./node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.61758d11.cjs\"), __webpack_require__(/*! node:tls */ \"node:tls\"), __webpack_require__(/*! node:zlib */ \"node:zlib\"), __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\"), __webpack_require__(/*! node:util/types */ \"node:util/types\"), __webpack_require__(/*! node:os */ \"node:os\"), __webpack_require__(/*! node:url */ \"node:url\"), __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\"), __webpack_require__(/*! node:console */ \"node:console\"), __webpack_require__(/*! string_decoder */ \"string_decoder\"), __webpack_require__(/*! node:worker_threads */ \"node:worker_threads\");\nvar i = Object.defineProperty, r = o((e, t)=>i(e, \"name\", {\n        value: t,\n        configurable: !0\n    }), \"r\");\nfunction createAgent(e, t = {}) {\n    const n = {\n        rejectUnauthorized: t.rejectUnauthorized\n    }, c = e?.startsWith(\"https:\") ? new https.Agent(n) : new http.Agent, s = new index.Agent_1({\n        connect: n\n    });\n    return {\n        agent: c,\n        dispatcher: s\n    };\n}\no(createAgent, \"createAgent\"), r(createAgent, \"createAgent\");\nfunction createFetch(e = {}) {\n    const t = createAgent(void 0, e);\n    return (n, c)=>nodeFetchNativeWithAgent.fetch(n, {\n            ...t,\n            ...c\n        });\n}\no(createFetch, \"createFetch\"), r(createFetch, \"createFetch\");\nconst fetch = createFetch({});\nexports.createAgent = createAgent, exports.createFetch = createFetch, exports.fetch = fetch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudC9kaXN0L2FnZW50LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUFBLElBQUlBLElBQUVDLE9BQU9DLGNBQWM7QUFBQyxJQUFJQyxJQUFFLENBQUNDLEdBQUVDLElBQUlMLEVBQUVJLEdBQUUsUUFBTztRQUFDRSxPQUFNRDtRQUFFRSxjQUFhLENBQUM7SUFBQztBQUFHLE1BQU1DLE9BQUtDLG1CQUFPQSxDQUFDLDRCQUFXLEdBQUVDLFFBQU1ELG1CQUFPQSxDQUFDLDhCQUFZLEdBQUVFLFFBQU1GLG1CQUFPQSxDQUFDLG1LQUFvRCxHQUFFRywyQkFBeUJILG1CQUFPQSxDQUFDLHFHQUE4QjtBQUFFQSxtQkFBT0EsQ0FBQyxnQ0FBYSxHQUFFQSxtQkFBT0EsQ0FBQywwQkFBVSxHQUFFQSxtQkFBT0EsQ0FBQyxnQ0FBYSxHQUFFQSxtQkFBT0EsQ0FBQyxnQ0FBYSxHQUFFQSxtQkFBT0EsQ0FBQyw0QkFBVyxHQUFFQSxtQkFBT0EsQ0FBQywwQ0FBa0IsR0FBRUEsbUJBQU9BLENBQUMsMERBQTBCLEdBQUVBLG1CQUFPQSxDQUFDLGdDQUFhLEdBQUVBLG1CQUFPQSxDQUFDLG1LQUFvRCxHQUFFQSxtQkFBT0EsQ0FBQywwQkFBVSxHQUFFQSxtQkFBT0EsQ0FBQyw0QkFBVyxHQUFFQSxtQkFBT0EsQ0FBQyx3Q0FBaUIsR0FBRUEsbUJBQU9BLENBQUMsd0NBQWlCLEdBQUVBLG1CQUFPQSxDQUFDLHdCQUFTLEdBQUVBLG1CQUFPQSxDQUFDLDBCQUFVLEdBQUVBLG1CQUFPQSxDQUFDLDBDQUFrQixHQUFFQSxtQkFBT0EsQ0FBQyxrQ0FBYyxHQUFFQSxtQkFBT0EsQ0FBQyxzQ0FBZ0IsR0FBRUEsbUJBQU9BLENBQUMsZ0RBQXFCO0FBQUUsSUFBSUksSUFBRVosT0FBT0MsY0FBYyxFQUFDWSxJQUFFWCxFQUFFLENBQUNDLEdBQUVDLElBQUlRLEVBQUVULEdBQUUsUUFBTztRQUFDRSxPQUFNRDtRQUFFRSxjQUFhLENBQUM7SUFBQyxJQUFHO0FBQUssU0FBU1EsWUFBWVgsQ0FBQyxFQUFDQyxJQUFFLENBQUMsQ0FBQztJQUFFLE1BQU1XLElBQUU7UUFBQ0Msb0JBQW1CWixFQUFFWSxrQkFBa0I7SUFBQSxHQUFFQyxJQUFFZCxHQUFHZSxXQUFXLFlBQVUsSUFBSVQsTUFBTVUsS0FBSyxDQUFDSixLQUFHLElBQUlSLEtBQUtZLEtBQUssRUFBQ0MsSUFBRSxJQUFJVixNQUFNVyxPQUFPLENBQUM7UUFBQ0MsU0FBUVA7SUFBQztJQUFHLE9BQU07UUFBQ1EsT0FBTU47UUFBRU8sWUFBV0o7SUFBQztBQUFDO0FBQUNsQixFQUFFWSxhQUFZLGdCQUFlRCxFQUFFQyxhQUFZO0FBQWUsU0FBU1csWUFBWXRCLElBQUUsQ0FBQyxDQUFDO0lBQUUsTUFBTUMsSUFBRVUsWUFBWSxLQUFLLEdBQUVYO0lBQUcsT0FBTSxDQUFDWSxHQUFFRSxJQUFJTix5QkFBeUJlLEtBQUssQ0FBQ1gsR0FBRTtZQUFDLEdBQUdYLENBQUM7WUFBQyxHQUFHYSxDQUFDO1FBQUE7QUFBRTtBQUFDZixFQUFFdUIsYUFBWSxnQkFBZVosRUFBRVksYUFBWTtBQUFlLE1BQU1DLFFBQU1ELFlBQVksQ0FBQztBQUFHRSxtQkFBbUIsR0FBQ2IsYUFBWWEsbUJBQW1CLEdBQUNGLGFBQVlFLGFBQWEsR0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlby1lZGl0b3ItYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gtbmF0aXZlLXdpdGgtYWdlbnQvZGlzdC9hZ2VudC5janM/YWE5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjt2YXIgdT1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIG89KGUsdCk9PnUoZSxcIm5hbWVcIix7dmFsdWU6dCxjb25maWd1cmFibGU6ITB9KTtjb25zdCBodHRwPXJlcXVpcmUoXCJub2RlOmh0dHBcIiksaHR0cHM9cmVxdWlyZShcIm5vZGU6aHR0cHNcIiksaW5kZXg9cmVxdWlyZShcIi4vc2hhcmVkL25vZGUtZmV0Y2gtbmF0aXZlLXdpdGgtYWdlbnQuZGY3ZTZiZDYuY2pzXCIpLG5vZGVGZXRjaE5hdGl2ZVdpdGhBZ2VudD1yZXF1aXJlKFwibm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudFwiKTtyZXF1aXJlKFwibm9kZTphc3NlcnRcIikscmVxdWlyZShcIm5vZGU6bmV0XCIpLHJlcXVpcmUoXCJub2RlOnN0cmVhbVwiKSxyZXF1aXJlKFwibm9kZTpidWZmZXJcIikscmVxdWlyZShcIm5vZGU6dXRpbFwiKSxyZXF1aXJlKFwibm9kZTpxdWVyeXN0cmluZ1wiKSxyZXF1aXJlKFwibm9kZTpkaWFnbm9zdGljc19jaGFubmVsXCIpLHJlcXVpcmUoXCJub2RlOmV2ZW50c1wiKSxyZXF1aXJlKFwiLi9zaGFyZWQvbm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudC42MTc1OGQxMS5janNcIikscmVxdWlyZShcIm5vZGU6dGxzXCIpLHJlcXVpcmUoXCJub2RlOnpsaWJcIikscmVxdWlyZShcIm5vZGU6cGVyZl9ob29rc1wiKSxyZXF1aXJlKFwibm9kZTp1dGlsL3R5cGVzXCIpLHJlcXVpcmUoXCJub2RlOm9zXCIpLHJlcXVpcmUoXCJub2RlOnVybFwiKSxyZXF1aXJlKFwibm9kZTphc3luY19ob29rc1wiKSxyZXF1aXJlKFwibm9kZTpjb25zb2xlXCIpLHJlcXVpcmUoXCJzdHJpbmdfZGVjb2RlclwiKSxyZXF1aXJlKFwibm9kZTp3b3JrZXJfdGhyZWFkc1wiKTt2YXIgaT1PYmplY3QuZGVmaW5lUHJvcGVydHkscj1vKChlLHQpPT5pKGUsXCJuYW1lXCIse3ZhbHVlOnQsY29uZmlndXJhYmxlOiEwfSksXCJyXCIpO2Z1bmN0aW9uIGNyZWF0ZUFnZW50KGUsdD17fSl7Y29uc3Qgbj17cmVqZWN0VW5hdXRob3JpemVkOnQucmVqZWN0VW5hdXRob3JpemVkfSxjPWU/LnN0YXJ0c1dpdGgoXCJodHRwczpcIik/bmV3IGh0dHBzLkFnZW50KG4pOm5ldyBodHRwLkFnZW50LHM9bmV3IGluZGV4LkFnZW50XzEoe2Nvbm5lY3Q6bn0pO3JldHVybnthZ2VudDpjLGRpc3BhdGNoZXI6c319byhjcmVhdGVBZ2VudCxcImNyZWF0ZUFnZW50XCIpLHIoY3JlYXRlQWdlbnQsXCJjcmVhdGVBZ2VudFwiKTtmdW5jdGlvbiBjcmVhdGVGZXRjaChlPXt9KXtjb25zdCB0PWNyZWF0ZUFnZW50KHZvaWQgMCxlKTtyZXR1cm4obixjKT0+bm9kZUZldGNoTmF0aXZlV2l0aEFnZW50LmZldGNoKG4sey4uLnQsLi4uY30pfW8oY3JlYXRlRmV0Y2gsXCJjcmVhdGVGZXRjaFwiKSxyKGNyZWF0ZUZldGNoLFwiY3JlYXRlRmV0Y2hcIik7Y29uc3QgZmV0Y2g9Y3JlYXRlRmV0Y2goe30pO2V4cG9ydHMuY3JlYXRlQWdlbnQ9Y3JlYXRlQWdlbnQsZXhwb3J0cy5jcmVhdGVGZXRjaD1jcmVhdGVGZXRjaCxleHBvcnRzLmZldGNoPWZldGNoO1xuIl0sIm5hbWVzIjpbInUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIm8iLCJlIiwidCIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiaHR0cCIsInJlcXVpcmUiLCJodHRwcyIsImluZGV4Iiwibm9kZUZldGNoTmF0aXZlV2l0aEFnZW50IiwiaSIsInIiLCJjcmVhdGVBZ2VudCIsIm4iLCJyZWplY3RVbmF1dGhvcml6ZWQiLCJjIiwic3RhcnRzV2l0aCIsIkFnZW50IiwicyIsIkFnZW50XzEiLCJjb25uZWN0IiwiYWdlbnQiLCJkaXNwYXRjaGVyIiwiY3JlYXRlRmV0Y2giLCJmZXRjaCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native-with-agent/dist/agent.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native-with-agent/dist/chunks/multipart-parser.cjs":
/*!************************************************************************************!*\
  !*** ./node_modules/node-fetch-native-with-agent/dist/chunks/multipart-parser.cjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar y = Object.defineProperty;\nvar c = (R, o)=>y(R, \"name\", {\n        value: o,\n        configurable: !0\n    });\n__webpack_require__(/*! node:fs */ \"node:fs\"), __webpack_require__(/*! node:path */ \"node:path\");\nconst node = __webpack_require__(/*! ../node.cjs */ \"(rsc)/./node_modules/node-fetch-native-with-agent/dist/node.cjs\");\n__webpack_require__(/*! node:http */ \"node:http\"), __webpack_require__(/*! node:https */ \"node:https\"), __webpack_require__(/*! node:zlib */ \"node:zlib\"), __webpack_require__(/*! node:stream */ \"node:stream\"), __webpack_require__(/*! node:buffer */ \"node:buffer\"), __webpack_require__(/*! node:util */ \"node:util\"), __webpack_require__(/*! ../shared/node-fetch-native-with-agent.61758d11.cjs */ \"(rsc)/./node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.61758d11.cjs\"), __webpack_require__(/*! node:url */ \"node:url\"), __webpack_require__(/*! node:net */ \"node:net\");\nlet s = 0;\nconst S = {\n    START_BOUNDARY: s++,\n    HEADER_FIELD_START: s++,\n    HEADER_FIELD: s++,\n    HEADER_VALUE_START: s++,\n    HEADER_VALUE: s++,\n    HEADER_VALUE_ALMOST_DONE: s++,\n    HEADERS_ALMOST_DONE: s++,\n    PART_DATA_START: s++,\n    PART_DATA: s++,\n    END: s++\n};\nlet f = 1;\nconst F = {\n    PART_BOUNDARY: f,\n    LAST_BOUNDARY: f *= 2\n}, LF = 10, CR = 13, SPACE = 32, HYPHEN = 45, COLON = 58, A = 97, Z = 122, lower = c((R)=>R | 32, \"lower\"), noop = c(()=>{}, \"noop\"), O = class O {\n    constructor(o){\n        this.index = 0, this.flags = 0, this.onHeaderEnd = noop, this.onHeaderField = noop, this.onHeadersEnd = noop, this.onHeaderValue = noop, this.onPartBegin = noop, this.onPartData = noop, this.onPartEnd = noop, this.boundaryChars = {}, o = `\\r\n--` + o;\n        const t = new Uint8Array(o.length);\n        for(let n = 0; n < o.length; n++)t[n] = o.charCodeAt(n), this.boundaryChars[t[n]] = !0;\n        this.boundary = t, this.lookbehind = new Uint8Array(this.boundary.length + 8), this.state = S.START_BOUNDARY;\n    }\n    write(o) {\n        let t = 0;\n        const n = o.length;\n        let E = this.index, { lookbehind: l, boundary: h, boundaryChars: H, index: e, state: a, flags: d } = this;\n        const b = this.boundary.length, g = b - 1, m = o.length;\n        let r, P;\n        const u = c((D)=>{\n            this[D + \"Mark\"] = t;\n        }, \"mark\"), i = c((D)=>{\n            delete this[D + \"Mark\"];\n        }, \"clear\"), T = c((D, p, _, N)=>{\n            (p === void 0 || p !== _) && this[D](N && N.subarray(p, _));\n        }, \"callback\"), L = c((D, p)=>{\n            const _ = D + \"Mark\";\n            _ in this && (p ? (T(D, this[_], t, o), delete this[_]) : (T(D, this[_], o.length, o), this[_] = 0));\n        }, \"dataCallback\");\n        for(t = 0; t < n; t++)switch(r = o[t], a){\n            case S.START_BOUNDARY:\n                if (e === h.length - 2) {\n                    if (r === HYPHEN) d |= F.LAST_BOUNDARY;\n                    else if (r !== CR) return;\n                    e++;\n                    break;\n                } else if (e - 1 === h.length - 2) {\n                    if (d & F.LAST_BOUNDARY && r === HYPHEN) a = S.END, d = 0;\n                    else if (!(d & F.LAST_BOUNDARY) && r === LF) e = 0, T(\"onPartBegin\"), a = S.HEADER_FIELD_START;\n                    else return;\n                    break;\n                }\n                r !== h[e + 2] && (e = -2), r === h[e + 2] && e++;\n                break;\n            case S.HEADER_FIELD_START:\n                a = S.HEADER_FIELD, u(\"onHeaderField\"), e = 0;\n            case S.HEADER_FIELD:\n                if (r === CR) {\n                    i(\"onHeaderField\"), a = S.HEADERS_ALMOST_DONE;\n                    break;\n                }\n                if (e++, r === HYPHEN) break;\n                if (r === COLON) {\n                    if (e === 1) return;\n                    L(\"onHeaderField\", !0), a = S.HEADER_VALUE_START;\n                    break;\n                }\n                if (P = lower(r), P < A || P > Z) return;\n                break;\n            case S.HEADER_VALUE_START:\n                if (r === SPACE) break;\n                u(\"onHeaderValue\"), a = S.HEADER_VALUE;\n            case S.HEADER_VALUE:\n                r === CR && (L(\"onHeaderValue\", !0), T(\"onHeaderEnd\"), a = S.HEADER_VALUE_ALMOST_DONE);\n                break;\n            case S.HEADER_VALUE_ALMOST_DONE:\n                if (r !== LF) return;\n                a = S.HEADER_FIELD_START;\n                break;\n            case S.HEADERS_ALMOST_DONE:\n                if (r !== LF) return;\n                T(\"onHeadersEnd\"), a = S.PART_DATA_START;\n                break;\n            case S.PART_DATA_START:\n                a = S.PART_DATA, u(\"onPartData\");\n            case S.PART_DATA:\n                if (E = e, e === 0) {\n                    for(t += g; t < m && !(o[t] in H);)t += b;\n                    t -= g, r = o[t];\n                }\n                if (e < h.length) h[e] === r ? (e === 0 && L(\"onPartData\", !0), e++) : e = 0;\n                else if (e === h.length) e++, r === CR ? d |= F.PART_BOUNDARY : r === HYPHEN ? d |= F.LAST_BOUNDARY : e = 0;\n                else if (e - 1 === h.length) if (d & F.PART_BOUNDARY) {\n                    if (e = 0, r === LF) {\n                        d &= ~F.PART_BOUNDARY, T(\"onPartEnd\"), T(\"onPartBegin\"), a = S.HEADER_FIELD_START;\n                        break;\n                    }\n                } else d & F.LAST_BOUNDARY && r === HYPHEN ? (T(\"onPartEnd\"), a = S.END, d = 0) : e = 0;\n                if (e > 0) l[e - 1] = r;\n                else if (E > 0) {\n                    const D = new Uint8Array(l.buffer, l.byteOffset, l.byteLength);\n                    T(\"onPartData\", 0, E, D), E = 0, u(\"onPartData\"), t--;\n                }\n                break;\n            case S.END:\n                break;\n            default:\n                throw new Error(`Unexpected state entered: ${a}`);\n        }\n        L(\"onHeaderField\"), L(\"onHeaderValue\"), L(\"onPartData\"), this.index = e, this.state = a, this.flags = d;\n    }\n    end() {\n        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) this.onPartEnd();\n        else if (this.state !== S.END) throw new Error(\"MultipartParser.end(): stream ended unexpectedly\");\n    }\n};\nc(O, \"MultipartParser\");\nlet MultipartParser = O;\nfunction _fileName(R) {\n    const o = R.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n    if (!o) return;\n    const t = o[2] || o[3] || \"\";\n    let n = t.slice(t.lastIndexOf(\"\\\\\") + 1);\n    return n = n.replace(/%22/g, '\"'), n = n.replace(/&#(\\d{4});/g, (E, l)=>String.fromCharCode(l)), n;\n}\nc(_fileName, \"_fileName\");\nasync function toFormData(R, o) {\n    if (!/multipart/i.test(o)) throw new TypeError(\"Failed to fetch\");\n    const t = o.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n    if (!t) throw new TypeError(\"no or bad content-type header, no multipart boundary\");\n    const n = new MultipartParser(t[1] || t[2]);\n    let E, l, h, H, e, a;\n    const d = [], b = new node.FormData, g = c((i)=>{\n        h += u.decode(i, {\n            stream: !0\n        });\n    }, \"onPartData\"), m = c((i)=>{\n        d.push(i);\n    }, \"appendToFile\"), r = c(()=>{\n        const i = new node.File(d, a, {\n            type: e\n        });\n        b.append(H, i);\n    }, \"appendFileToFormData\"), P = c(()=>{\n        b.append(H, h);\n    }, \"appendEntryToFormData\"), u = new TextDecoder(\"utf-8\");\n    u.decode(), n.onPartBegin = function() {\n        n.onPartData = g, n.onPartEnd = P, E = \"\", l = \"\", h = \"\", H = \"\", e = \"\", a = null, d.length = 0;\n    }, n.onHeaderField = function(i) {\n        E += u.decode(i, {\n            stream: !0\n        });\n    }, n.onHeaderValue = function(i) {\n        l += u.decode(i, {\n            stream: !0\n        });\n    }, n.onHeaderEnd = function() {\n        if (l += u.decode(), E = E.toLowerCase(), E === \"content-disposition\") {\n            const i = l.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n            i && (H = i[2] || i[3] || \"\"), a = _fileName(l), a && (n.onPartData = m, n.onPartEnd = r);\n        } else E === \"content-type\" && (e = l);\n        l = \"\", E = \"\";\n    };\n    for await (const i of R)n.write(i);\n    return n.end(), b;\n}\nc(toFormData, \"toFormData\"), exports.toFormData = toFormData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudC9kaXN0L2NodW5rcy9tdWx0aXBhcnQtcGFyc2VyLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUFBLElBQUlBLElBQUVDLE9BQU9DLGNBQWM7QUFBQyxJQUFJQyxJQUFFLENBQUNDLEdBQUVDLElBQUlMLEVBQUVJLEdBQUUsUUFBTztRQUFDRSxPQUFNRDtRQUFFRSxjQUFhLENBQUM7SUFBQztBQUFHQyxtQkFBT0EsQ0FBQyx3QkFBUyxHQUFFQSxtQkFBT0EsQ0FBQyw0QkFBVztBQUFFLE1BQU1DLE9BQUtELG1CQUFPQSxDQUFDLG9GQUFhO0FBQUVBLG1CQUFPQSxDQUFDLDRCQUFXLEdBQUVBLG1CQUFPQSxDQUFDLDhCQUFZLEdBQUVBLG1CQUFPQSxDQUFDLDRCQUFXLEdBQUVBLG1CQUFPQSxDQUFDLGdDQUFhLEdBQUVBLG1CQUFPQSxDQUFDLGdDQUFhLEdBQUVBLG1CQUFPQSxDQUFDLDRCQUFXLEdBQUVBLG1CQUFPQSxDQUFDLG9LQUFxRCxHQUFFQSxtQkFBT0EsQ0FBQywwQkFBVSxHQUFFQSxtQkFBT0EsQ0FBQywwQkFBVTtBQUFFLElBQUlFLElBQUU7QUFBRSxNQUFNQyxJQUFFO0lBQUNDLGdCQUFlRjtJQUFJRyxvQkFBbUJIO0lBQUlJLGNBQWFKO0lBQUlLLG9CQUFtQkw7SUFBSU0sY0FBYU47SUFBSU8sMEJBQXlCUDtJQUFJUSxxQkFBb0JSO0lBQUlTLGlCQUFnQlQ7SUFBSVUsV0FBVVY7SUFBSVcsS0FBSVg7QUFBRztBQUFFLElBQUlZLElBQUU7QUFBRSxNQUFNQyxJQUFFO0lBQUNDLGVBQWNGO0lBQUVHLGVBQWNILEtBQUc7QUFBQyxHQUFFSSxLQUFHLElBQUdDLEtBQUcsSUFBR0MsUUFBTSxJQUFHQyxTQUFPLElBQUdDLFFBQU0sSUFBR0MsSUFBRSxJQUFHQyxJQUFFLEtBQUlDLFFBQU05QixFQUFFQyxDQUFBQSxJQUFHQSxJQUFFLElBQUcsVUFBUzhCLE9BQUsvQixF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VSxNQUFNYyxLQUFLbEUsRUFBRThDLEVBQUVLLEtBQUssQ0FBQ2U7SUFBRyxPQUFPcEIsRUFBRStCLEdBQUcsSUFBR2xCO0FBQUM7QUFBQzVELEVBQUV1RixZQUFXLGVBQWNZLGtCQUFrQixHQUFDWiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVvLWVkaXRvci1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudC9kaXN0L2NodW5rcy9tdWx0aXBhcnQtcGFyc2VyLmNqcz9kODY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO3ZhciB5PU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgYz0oUixvKT0+eShSLFwibmFtZVwiLHt2YWx1ZTpvLGNvbmZpZ3VyYWJsZTohMH0pO3JlcXVpcmUoXCJub2RlOmZzXCIpLHJlcXVpcmUoXCJub2RlOnBhdGhcIik7Y29uc3Qgbm9kZT1yZXF1aXJlKFwiLi4vbm9kZS5janNcIik7cmVxdWlyZShcIm5vZGU6aHR0cFwiKSxyZXF1aXJlKFwibm9kZTpodHRwc1wiKSxyZXF1aXJlKFwibm9kZTp6bGliXCIpLHJlcXVpcmUoXCJub2RlOnN0cmVhbVwiKSxyZXF1aXJlKFwibm9kZTpidWZmZXJcIikscmVxdWlyZShcIm5vZGU6dXRpbFwiKSxyZXF1aXJlKFwiLi4vc2hhcmVkL25vZGUtZmV0Y2gtbmF0aXZlLXdpdGgtYWdlbnQuNjE3NThkMTEuY2pzXCIpLHJlcXVpcmUoXCJub2RlOnVybFwiKSxyZXF1aXJlKFwibm9kZTpuZXRcIik7bGV0IHM9MDtjb25zdCBTPXtTVEFSVF9CT1VOREFSWTpzKyssSEVBREVSX0ZJRUxEX1NUQVJUOnMrKyxIRUFERVJfRklFTEQ6cysrLEhFQURFUl9WQUxVRV9TVEFSVDpzKyssSEVBREVSX1ZBTFVFOnMrKyxIRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU6cysrLEhFQURFUlNfQUxNT1NUX0RPTkU6cysrLFBBUlRfREFUQV9TVEFSVDpzKyssUEFSVF9EQVRBOnMrKyxFTkQ6cysrfTtsZXQgZj0xO2NvbnN0IEY9e1BBUlRfQk9VTkRBUlk6ZixMQVNUX0JPVU5EQVJZOmYqPTJ9LExGPTEwLENSPTEzLFNQQUNFPTMyLEhZUEhFTj00NSxDT0xPTj01OCxBPTk3LFo9MTIyLGxvd2VyPWMoUj0+UnwzMixcImxvd2VyXCIpLG5vb3A9YygoKT0+e30sXCJub29wXCIpLE89Y2xhc3MgT3tjb25zdHJ1Y3RvcihvKXt0aGlzLmluZGV4PTAsdGhpcy5mbGFncz0wLHRoaXMub25IZWFkZXJFbmQ9bm9vcCx0aGlzLm9uSGVhZGVyRmllbGQ9bm9vcCx0aGlzLm9uSGVhZGVyc0VuZD1ub29wLHRoaXMub25IZWFkZXJWYWx1ZT1ub29wLHRoaXMub25QYXJ0QmVnaW49bm9vcCx0aGlzLm9uUGFydERhdGE9bm9vcCx0aGlzLm9uUGFydEVuZD1ub29wLHRoaXMuYm91bmRhcnlDaGFycz17fSxvPWBcXHJcbi0tYCtvO2NvbnN0IHQ9bmV3IFVpbnQ4QXJyYXkoby5sZW5ndGgpO2ZvcihsZXQgbj0wO248by5sZW5ndGg7bisrKXRbbl09by5jaGFyQ29kZUF0KG4pLHRoaXMuYm91bmRhcnlDaGFyc1t0W25dXT0hMDt0aGlzLmJvdW5kYXJ5PXQsdGhpcy5sb29rYmVoaW5kPW5ldyBVaW50OEFycmF5KHRoaXMuYm91bmRhcnkubGVuZ3RoKzgpLHRoaXMuc3RhdGU9Uy5TVEFSVF9CT1VOREFSWX13cml0ZShvKXtsZXQgdD0wO2NvbnN0IG49by5sZW5ndGg7bGV0IEU9dGhpcy5pbmRleCx7bG9va2JlaGluZDpsLGJvdW5kYXJ5OmgsYm91bmRhcnlDaGFyczpILGluZGV4OmUsc3RhdGU6YSxmbGFnczpkfT10aGlzO2NvbnN0IGI9dGhpcy5ib3VuZGFyeS5sZW5ndGgsZz1iLTEsbT1vLmxlbmd0aDtsZXQgcixQO2NvbnN0IHU9YyhEPT57dGhpc1tEK1wiTWFya1wiXT10fSxcIm1hcmtcIiksaT1jKEQ9PntkZWxldGUgdGhpc1tEK1wiTWFya1wiXX0sXCJjbGVhclwiKSxUPWMoKEQscCxfLE4pPT57KHA9PT12b2lkIDB8fHAhPT1fKSYmdGhpc1tEXShOJiZOLnN1YmFycmF5KHAsXykpfSxcImNhbGxiYWNrXCIpLEw9YygoRCxwKT0+e2NvbnN0IF89RCtcIk1hcmtcIjtfIGluIHRoaXMmJihwPyhUKEQsdGhpc1tfXSx0LG8pLGRlbGV0ZSB0aGlzW19dKTooVChELHRoaXNbX10sby5sZW5ndGgsbyksdGhpc1tfXT0wKSl9LFwiZGF0YUNhbGxiYWNrXCIpO2Zvcih0PTA7dDxuO3QrKylzd2l0Y2gocj1vW3RdLGEpe2Nhc2UgUy5TVEFSVF9CT1VOREFSWTppZihlPT09aC5sZW5ndGgtMil7aWYocj09PUhZUEhFTilkfD1GLkxBU1RfQk9VTkRBUlk7ZWxzZSBpZihyIT09Q1IpcmV0dXJuO2UrKzticmVha31lbHNlIGlmKGUtMT09PWgubGVuZ3RoLTIpe2lmKGQmRi5MQVNUX0JPVU5EQVJZJiZyPT09SFlQSEVOKWE9Uy5FTkQsZD0wO2Vsc2UgaWYoIShkJkYuTEFTVF9CT1VOREFSWSkmJnI9PT1MRillPTAsVChcIm9uUGFydEJlZ2luXCIpLGE9Uy5IRUFERVJfRklFTERfU1RBUlQ7ZWxzZSByZXR1cm47YnJlYWt9ciE9PWhbZSsyXSYmKGU9LTIpLHI9PT1oW2UrMl0mJmUrKzticmVhaztjYXNlIFMuSEVBREVSX0ZJRUxEX1NUQVJUOmE9Uy5IRUFERVJfRklFTEQsdShcIm9uSGVhZGVyRmllbGRcIiksZT0wO2Nhc2UgUy5IRUFERVJfRklFTEQ6aWYocj09PUNSKXtpKFwib25IZWFkZXJGaWVsZFwiKSxhPVMuSEVBREVSU19BTE1PU1RfRE9ORTticmVha31pZihlKysscj09PUhZUEhFTilicmVhaztpZihyPT09Q09MT04pe2lmKGU9PT0xKXJldHVybjtMKFwib25IZWFkZXJGaWVsZFwiLCEwKSxhPVMuSEVBREVSX1ZBTFVFX1NUQVJUO2JyZWFrfWlmKFA9bG93ZXIociksUDxBfHxQPlopcmV0dXJuO2JyZWFrO2Nhc2UgUy5IRUFERVJfVkFMVUVfU1RBUlQ6aWYocj09PVNQQUNFKWJyZWFrO3UoXCJvbkhlYWRlclZhbHVlXCIpLGE9Uy5IRUFERVJfVkFMVUU7Y2FzZSBTLkhFQURFUl9WQUxVRTpyPT09Q1ImJihMKFwib25IZWFkZXJWYWx1ZVwiLCEwKSxUKFwib25IZWFkZXJFbmRcIiksYT1TLkhFQURFUl9WQUxVRV9BTE1PU1RfRE9ORSk7YnJlYWs7Y2FzZSBTLkhFQURFUl9WQUxVRV9BTE1PU1RfRE9ORTppZihyIT09TEYpcmV0dXJuO2E9Uy5IRUFERVJfRklFTERfU1RBUlQ7YnJlYWs7Y2FzZSBTLkhFQURFUlNfQUxNT1NUX0RPTkU6aWYociE9PUxGKXJldHVybjtUKFwib25IZWFkZXJzRW5kXCIpLGE9Uy5QQVJUX0RBVEFfU1RBUlQ7YnJlYWs7Y2FzZSBTLlBBUlRfREFUQV9TVEFSVDphPVMuUEFSVF9EQVRBLHUoXCJvblBhcnREYXRhXCIpO2Nhc2UgUy5QQVJUX0RBVEE6aWYoRT1lLGU9PT0wKXtmb3IodCs9Zzt0PG0mJiEob1t0XWluIEgpOyl0Kz1iO3QtPWcscj1vW3RdfWlmKGU8aC5sZW5ndGgpaFtlXT09PXI/KGU9PT0wJiZMKFwib25QYXJ0RGF0YVwiLCEwKSxlKyspOmU9MDtlbHNlIGlmKGU9PT1oLmxlbmd0aCllKysscj09PUNSP2R8PUYuUEFSVF9CT1VOREFSWTpyPT09SFlQSEVOP2R8PUYuTEFTVF9CT1VOREFSWTplPTA7ZWxzZSBpZihlLTE9PT1oLmxlbmd0aClpZihkJkYuUEFSVF9CT1VOREFSWSl7aWYoZT0wLHI9PT1MRil7ZCY9fkYuUEFSVF9CT1VOREFSWSxUKFwib25QYXJ0RW5kXCIpLFQoXCJvblBhcnRCZWdpblwiKSxhPVMuSEVBREVSX0ZJRUxEX1NUQVJUO2JyZWFrfX1lbHNlIGQmRi5MQVNUX0JPVU5EQVJZJiZyPT09SFlQSEVOPyhUKFwib25QYXJ0RW5kXCIpLGE9Uy5FTkQsZD0wKTplPTA7aWYoZT4wKWxbZS0xXT1yO2Vsc2UgaWYoRT4wKXtjb25zdCBEPW5ldyBVaW50OEFycmF5KGwuYnVmZmVyLGwuYnl0ZU9mZnNldCxsLmJ5dGVMZW5ndGgpO1QoXCJvblBhcnREYXRhXCIsMCxFLEQpLEU9MCx1KFwib25QYXJ0RGF0YVwiKSx0LS19YnJlYWs7Y2FzZSBTLkVORDpicmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBzdGF0ZSBlbnRlcmVkOiAke2F9YCl9TChcIm9uSGVhZGVyRmllbGRcIiksTChcIm9uSGVhZGVyVmFsdWVcIiksTChcIm9uUGFydERhdGFcIiksdGhpcy5pbmRleD1lLHRoaXMuc3RhdGU9YSx0aGlzLmZsYWdzPWR9ZW5kKCl7aWYodGhpcy5zdGF0ZT09PVMuSEVBREVSX0ZJRUxEX1NUQVJUJiZ0aGlzLmluZGV4PT09MHx8dGhpcy5zdGF0ZT09PVMuUEFSVF9EQVRBJiZ0aGlzLmluZGV4PT09dGhpcy5ib3VuZGFyeS5sZW5ndGgpdGhpcy5vblBhcnRFbmQoKTtlbHNlIGlmKHRoaXMuc3RhdGUhPT1TLkVORCl0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBhcnRQYXJzZXIuZW5kKCk6IHN0cmVhbSBlbmRlZCB1bmV4cGVjdGVkbHlcIil9fTtjKE8sXCJNdWx0aXBhcnRQYXJzZXJcIik7bGV0IE11bHRpcGFydFBhcnNlcj1PO2Z1bmN0aW9uIF9maWxlTmFtZShSKXtjb25zdCBvPVIubWF0Y2goL1xcYmZpbGVuYW1lPShcIiguKj8pXCJ8KFteKCk8PkAsOzpcXFxcXCIvW1xcXT89e31cXHNcXHRdKykpKCR8O1xccykvaSk7aWYoIW8pcmV0dXJuO2NvbnN0IHQ9b1syXXx8b1szXXx8XCJcIjtsZXQgbj10LnNsaWNlKHQubGFzdEluZGV4T2YoXCJcXFxcXCIpKzEpO3JldHVybiBuPW4ucmVwbGFjZSgvJTIyL2csJ1wiJyksbj1uLnJlcGxhY2UoLyYjKFxcZHs0fSk7L2csKEUsbCk9PlN0cmluZy5mcm9tQ2hhckNvZGUobCkpLG59YyhfZmlsZU5hbWUsXCJfZmlsZU5hbWVcIik7YXN5bmMgZnVuY3Rpb24gdG9Gb3JtRGF0YShSLG8pe2lmKCEvbXVsdGlwYXJ0L2kudGVzdChvKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGZldGNoXCIpO2NvbnN0IHQ9by5tYXRjaCgvYm91bmRhcnk9KD86XCIoW15cIl0rKVwifChbXjtdKykpL2kpO2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJubyBvciBiYWQgY29udGVudC10eXBlIGhlYWRlciwgbm8gbXVsdGlwYXJ0IGJvdW5kYXJ5XCIpO2NvbnN0IG49bmV3IE11bHRpcGFydFBhcnNlcih0WzFdfHx0WzJdKTtsZXQgRSxsLGgsSCxlLGE7Y29uc3QgZD1bXSxiPW5ldyBub2RlLkZvcm1EYXRhLGc9YyhpPT57aCs9dS5kZWNvZGUoaSx7c3RyZWFtOiEwfSl9LFwib25QYXJ0RGF0YVwiKSxtPWMoaT0+e2QucHVzaChpKX0sXCJhcHBlbmRUb0ZpbGVcIikscj1jKCgpPT57Y29uc3QgaT1uZXcgbm9kZS5GaWxlKGQsYSx7dHlwZTplfSk7Yi5hcHBlbmQoSCxpKX0sXCJhcHBlbmRGaWxlVG9Gb3JtRGF0YVwiKSxQPWMoKCk9PntiLmFwcGVuZChILGgpfSxcImFwcGVuZEVudHJ5VG9Gb3JtRGF0YVwiKSx1PW5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO3UuZGVjb2RlKCksbi5vblBhcnRCZWdpbj1mdW5jdGlvbigpe24ub25QYXJ0RGF0YT1nLG4ub25QYXJ0RW5kPVAsRT1cIlwiLGw9XCJcIixoPVwiXCIsSD1cIlwiLGU9XCJcIixhPW51bGwsZC5sZW5ndGg9MH0sbi5vbkhlYWRlckZpZWxkPWZ1bmN0aW9uKGkpe0UrPXUuZGVjb2RlKGkse3N0cmVhbTohMH0pfSxuLm9uSGVhZGVyVmFsdWU9ZnVuY3Rpb24oaSl7bCs9dS5kZWNvZGUoaSx7c3RyZWFtOiEwfSl9LG4ub25IZWFkZXJFbmQ9ZnVuY3Rpb24oKXtpZihsKz11LmRlY29kZSgpLEU9RS50b0xvd2VyQ2FzZSgpLEU9PT1cImNvbnRlbnQtZGlzcG9zaXRpb25cIil7Y29uc3QgaT1sLm1hdGNoKC9cXGJuYW1lPShcIihbXlwiXSopXCJ8KFteKCk8PkAsOzpcXFxcXCIvW1xcXT89e31cXHNcXHRdKykpL2kpO2kmJihIPWlbMl18fGlbM118fFwiXCIpLGE9X2ZpbGVOYW1lKGwpLGEmJihuLm9uUGFydERhdGE9bSxuLm9uUGFydEVuZD1yKX1lbHNlIEU9PT1cImNvbnRlbnQtdHlwZVwiJiYoZT1sKTtsPVwiXCIsRT1cIlwifTtmb3IgYXdhaXQoY29uc3QgaSBvZiBSKW4ud3JpdGUoaSk7cmV0dXJuIG4uZW5kKCksYn1jKHRvRm9ybURhdGEsXCJ0b0Zvcm1EYXRhXCIpLGV4cG9ydHMudG9Gb3JtRGF0YT10b0Zvcm1EYXRhO1xuIl0sIm5hbWVzIjpbInkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImMiLCJSIiwibyIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwicmVxdWlyZSIsIm5vZGUiLCJzIiwiUyIsIlNUQVJUX0JPVU5EQVJZIiwiSEVBREVSX0ZJRUxEX1NUQVJUIiwiSEVBREVSX0ZJRUxEIiwiSEVBREVSX1ZBTFVFX1NUQVJUIiwiSEVBREVSX1ZBTFVFIiwiSEVBREVSX1ZBTFVFX0FMTU9TVF9ET05FIiwiSEVBREVSU19BTE1PU1RfRE9ORSIsIlBBUlRfREFUQV9TVEFSVCIsIlBBUlRfREFUQSIsIkVORCIsImYiLCJGIiwiUEFSVF9CT1VOREFSWSIsIkxBU1RfQk9VTkRBUlkiLCJMRiIsIkNSIiwiU1BBQ0UiLCJIWVBIRU4iLCJDT0xPTiIsIkEiLCJaIiwibG93ZXIiLCJub29wIiwiTyIsImNvbnN0cnVjdG9yIiwiaW5kZXgiLCJmbGFncyIsIm9uSGVhZGVyRW5kIiwib25IZWFkZXJGaWVsZCIsIm9uSGVhZGVyc0VuZCIsIm9uSGVhZGVyVmFsdWUiLCJvblBhcnRCZWdpbiIsIm9uUGFydERhdGEiLCJvblBhcnRFbmQiLCJib3VuZGFyeUNoYXJzIiwidCIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJuIiwiY2hhckNvZGVBdCIsImJvdW5kYXJ5IiwibG9va2JlaGluZCIsInN0YXRlIiwid3JpdGUiLCJFIiwibCIsImgiLCJIIiwiZSIsImEiLCJkIiwiYiIsImciLCJtIiwiciIsIlAiLCJ1IiwiRCIsImkiLCJUIiwicCIsIl8iLCJOIiwic3ViYXJyYXkiLCJMIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJFcnJvciIsImVuZCIsIk11bHRpcGFydFBhcnNlciIsIl9maWxlTmFtZSIsIm1hdGNoIiwic2xpY2UiLCJsYXN0SW5kZXhPZiIsInJlcGxhY2UiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ0b0Zvcm1EYXRhIiwidGVzdCIsIlR5cGVFcnJvciIsIkZvcm1EYXRhIiwiZGVjb2RlIiwic3RyZWFtIiwicHVzaCIsIkZpbGUiLCJ0eXBlIiwiYXBwZW5kIiwiVGV4dERlY29kZXIiLCJ0b0xvd2VyQ2FzZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native-with-agent/dist/chunks/multipart-parser.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native-with-agent/dist/index.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/node-fetch-native-with-agent/dist/index.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar i = Object.defineProperty;\nvar l = (r, t)=>i(r, \"name\", {\n        value: t,\n        configurable: !0\n    });\nObject.defineProperty(exports, \"__esModule\", ({\n    value: !0\n}));\nconst node = __webpack_require__(/*! ./node.cjs */ \"(rsc)/./node_modules/node-fetch-native-with-agent/dist/node.cjs\");\n__webpack_require__(/*! node:http */ \"node:http\"), __webpack_require__(/*! node:https */ \"node:https\"), __webpack_require__(/*! node:zlib */ \"node:zlib\"), __webpack_require__(/*! node:stream */ \"node:stream\"), __webpack_require__(/*! node:buffer */ \"node:buffer\"), __webpack_require__(/*! node:util */ \"node:util\"), __webpack_require__(/*! ./shared/node-fetch-native-with-agent.61758d11.cjs */ \"(rsc)/./node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.61758d11.cjs\"), __webpack_require__(/*! node:url */ \"node:url\"), __webpack_require__(/*! node:net */ \"node:net\"), __webpack_require__(/*! node:fs */ \"node:fs\"), __webpack_require__(/*! node:path */ \"node:path\");\nvar s = Object.defineProperty, e = l((r, t)=>s(r, \"name\", {\n        value: t,\n        configurable: !0\n    }), \"e\");\nconst o = !!globalThis.process?.env?.FORCE_NODE_FETCH;\nfunction p() {\n    return !o && globalThis.fetch ? globalThis.fetch : node.fetch;\n}\nl(p, \"p\"), e(p, \"_getFetch\");\nconst fetch = p(), Blob = !o && globalThis.Blob || node.Blob, File = !o && globalThis.File || node.File, FormData = !o && globalThis.FormData || node.FormData, Headers = !o && globalThis.Headers || node.Headers, Request = !o && globalThis.Request || node.Request, Response = !o && globalThis.Response || node.Response, AbortController = !o && globalThis.AbortController || node.AbortController;\nexports.AbortError = node.AbortError, exports.FetchError = node.FetchError, exports.blobFrom = node.blobFrom, exports.blobFromSync = node.blobFromSync, exports.fileFrom = node.fileFrom, exports.fileFromSync = node.fileFromSync, exports.isRedirect = node.isRedirect, exports.AbortController = AbortController, exports.Blob = Blob, exports.File = File, exports.FormData = FormData, exports.Headers = Headers, exports.Request = Request, exports.Response = Response, exports[\"default\"] = fetch, exports.fetch = fetch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudC9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUFBLElBQUlBLElBQUVDLE9BQU9DLGNBQWM7QUFBQyxJQUFJQyxJQUFFLENBQUNDLEdBQUVDLElBQUlMLEVBQUVJLEdBQUUsUUFBTztRQUFDRSxPQUFNRDtRQUFFRSxjQUFhLENBQUM7SUFBQztBQUFHTiw4Q0FBMkM7SUFBQ0ssT0FBTSxDQUFDO0FBQUMsQ0FBQyxFQUFDO0FBQUMsTUFBTUcsT0FBS0MsbUJBQU9BLENBQUMsbUZBQVk7QUFBRUEsbUJBQU9BLENBQUMsNEJBQVcsR0FBRUEsbUJBQU9BLENBQUMsOEJBQVksR0FBRUEsbUJBQU9BLENBQUMsNEJBQVcsR0FBRUEsbUJBQU9BLENBQUMsZ0NBQWEsR0FBRUEsbUJBQU9BLENBQUMsZ0NBQWEsR0FBRUEsbUJBQU9BLENBQUMsNEJBQVcsR0FBRUEsbUJBQU9BLENBQUMsbUtBQW9ELEdBQUVBLG1CQUFPQSxDQUFDLDBCQUFVLEdBQUVBLG1CQUFPQSxDQUFDLDBCQUFVLEdBQUVBLG1CQUFPQSxDQUFDLHdCQUFTLEdBQUVBLG1CQUFPQSxDQUFDLDRCQUFXO0FBQUUsSUFBSUMsSUFBRVYsT0FBT0MsY0FBYyxFQUFDVSxJQUFFVCxFQUFFLENBQUNDLEdBQUVDLElBQUlNLEVBQUVQLEdBQUUsUUFBTztRQUFDRSxPQUFNRDtRQUFFRSxjQUFhLENBQUM7SUFBQyxJQUFHO0FBQUssTUFBTU0sSUFBRSxDQUFDLENBQUNDLFdBQVdDLE9BQU8sRUFBRUMsS0FBS0M7QUFBaUIsU0FBU0M7SUFBSSxPQUFNLENBQUNMLEtBQUdDLFdBQVdLLEtBQUssR0FBQ0wsV0FBV0ssS0FBSyxHQUFDVixLQUFLVSxLQUFLO0FBQUE7QUFBQ2hCLEVBQUVlLEdBQUUsTUFBS04sRUFBRU0sR0FBRTtBQUFhLE1BQU1DLFFBQU1ELEtBQUlFLE9BQUssQ0FBQ1AsS0FBR0MsV0FBV00sSUFBSSxJQUFFWCxLQUFLVyxJQUFJLEVBQUNDLE9BQUssQ0FBQ1IsS0FBR0MsV0FBV08sSUFBSSxJQUFFWixLQUFLWSxJQUFJLEVBQUNDLFdBQVMsQ0FBQ1QsS0FBR0MsV0FBV1EsUUFBUSxJQUFFYixLQUFLYSxRQUFRLEVBQUNDLFVBQVEsQ0FBQ1YsS0FBR0MsV0FBV1MsT0FBTyxJQUFFZCxLQUFLYyxPQUFPLEVBQUNDLFVBQVEsQ0FBQ1gsS0FBR0MsV0FBV1UsT0FBTyxJQUFFZixLQUFLZSxPQUFPLEVBQUNDLFdBQVMsQ0FBQ1osS0FBR0MsV0FBV1csUUFBUSxJQUFFaEIsS0FBS2dCLFFBQVEsRUFBQ0Msa0JBQWdCLENBQUNiLEtBQUdDLFdBQVdZLGVBQWUsSUFBRWpCLEtBQUtpQixlQUFlO0FBQUNsQixrQkFBa0IsR0FBQ0MsS0FBS2tCLFVBQVUsRUFBQ25CLGtCQUFrQixHQUFDQyxLQUFLbUIsVUFBVSxFQUFDcEIsZ0JBQWdCLEdBQUNDLEtBQUtvQixRQUFRLEVBQUNyQixvQkFBb0IsR0FBQ0MsS0FBS3FCLFlBQVksRUFBQ3RCLGdCQUFnQixHQUFDQyxLQUFLc0IsUUFBUSxFQUFDdkIsb0JBQW9CLEdBQUNDLEtBQUt1QixZQUFZLEVBQUN4QixrQkFBa0IsR0FBQ0MsS0FBS3dCLFVBQVUsRUFBQ3pCLHVCQUF1QixHQUFDa0IsaUJBQWdCbEIsWUFBWSxHQUFDWSxNQUFLWixZQUFZLEdBQUNhLE1BQUtiLGdCQUFnQixHQUFDYyxVQUFTZCxlQUFlLEdBQUNlLFNBQVFmLGVBQWUsR0FBQ2dCLFNBQVFoQixnQkFBZ0IsR0FBQ2lCLFVBQVNqQixrQkFBZSxHQUFDVyxPQUFNWCxhQUFhLEdBQUNXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlkZW8tZWRpdG9yLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoLW5hdGl2ZS13aXRoLWFnZW50L2Rpc3QvaW5kZXguY2pzP2VlMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7dmFyIGk9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBsPShyLHQpPT5pKHIsXCJuYW1lXCIse3ZhbHVlOnQsY29uZmlndXJhYmxlOiEwfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbm9kZT1yZXF1aXJlKFwiLi9ub2RlLmNqc1wiKTtyZXF1aXJlKFwibm9kZTpodHRwXCIpLHJlcXVpcmUoXCJub2RlOmh0dHBzXCIpLHJlcXVpcmUoXCJub2RlOnpsaWJcIikscmVxdWlyZShcIm5vZGU6c3RyZWFtXCIpLHJlcXVpcmUoXCJub2RlOmJ1ZmZlclwiKSxyZXF1aXJlKFwibm9kZTp1dGlsXCIpLHJlcXVpcmUoXCIuL3NoYXJlZC9ub2RlLWZldGNoLW5hdGl2ZS13aXRoLWFnZW50LjYxNzU4ZDExLmNqc1wiKSxyZXF1aXJlKFwibm9kZTp1cmxcIikscmVxdWlyZShcIm5vZGU6bmV0XCIpLHJlcXVpcmUoXCJub2RlOmZzXCIpLHJlcXVpcmUoXCJub2RlOnBhdGhcIik7dmFyIHM9T2JqZWN0LmRlZmluZVByb3BlcnR5LGU9bCgocix0KT0+cyhyLFwibmFtZVwiLHt2YWx1ZTp0LGNvbmZpZ3VyYWJsZTohMH0pLFwiZVwiKTtjb25zdCBvPSEhZ2xvYmFsVGhpcy5wcm9jZXNzPy5lbnY/LkZPUkNFX05PREVfRkVUQ0g7ZnVuY3Rpb24gcCgpe3JldHVybiFvJiZnbG9iYWxUaGlzLmZldGNoP2dsb2JhbFRoaXMuZmV0Y2g6bm9kZS5mZXRjaH1sKHAsXCJwXCIpLGUocCxcIl9nZXRGZXRjaFwiKTtjb25zdCBmZXRjaD1wKCksQmxvYj0hbyYmZ2xvYmFsVGhpcy5CbG9ifHxub2RlLkJsb2IsRmlsZT0hbyYmZ2xvYmFsVGhpcy5GaWxlfHxub2RlLkZpbGUsRm9ybURhdGE9IW8mJmdsb2JhbFRoaXMuRm9ybURhdGF8fG5vZGUuRm9ybURhdGEsSGVhZGVycz0hbyYmZ2xvYmFsVGhpcy5IZWFkZXJzfHxub2RlLkhlYWRlcnMsUmVxdWVzdD0hbyYmZ2xvYmFsVGhpcy5SZXF1ZXN0fHxub2RlLlJlcXVlc3QsUmVzcG9uc2U9IW8mJmdsb2JhbFRoaXMuUmVzcG9uc2V8fG5vZGUuUmVzcG9uc2UsQWJvcnRDb250cm9sbGVyPSFvJiZnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcnx8bm9kZS5BYm9ydENvbnRyb2xsZXI7ZXhwb3J0cy5BYm9ydEVycm9yPW5vZGUuQWJvcnRFcnJvcixleHBvcnRzLkZldGNoRXJyb3I9bm9kZS5GZXRjaEVycm9yLGV4cG9ydHMuYmxvYkZyb209bm9kZS5ibG9iRnJvbSxleHBvcnRzLmJsb2JGcm9tU3luYz1ub2RlLmJsb2JGcm9tU3luYyxleHBvcnRzLmZpbGVGcm9tPW5vZGUuZmlsZUZyb20sZXhwb3J0cy5maWxlRnJvbVN5bmM9bm9kZS5maWxlRnJvbVN5bmMsZXhwb3J0cy5pc1JlZGlyZWN0PW5vZGUuaXNSZWRpcmVjdCxleHBvcnRzLkFib3J0Q29udHJvbGxlcj1BYm9ydENvbnRyb2xsZXIsZXhwb3J0cy5CbG9iPUJsb2IsZXhwb3J0cy5GaWxlPUZpbGUsZXhwb3J0cy5Gb3JtRGF0YT1Gb3JtRGF0YSxleHBvcnRzLkhlYWRlcnM9SGVhZGVycyxleHBvcnRzLlJlcXVlc3Q9UmVxdWVzdCxleHBvcnRzLlJlc3BvbnNlPVJlc3BvbnNlLGV4cG9ydHMuZGVmYXVsdD1mZXRjaCxleHBvcnRzLmZldGNoPWZldGNoO1xuIl0sIm5hbWVzIjpbImkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImwiLCJyIiwidCIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiZXhwb3J0cyIsIm5vZGUiLCJyZXF1aXJlIiwicyIsImUiLCJvIiwiZ2xvYmFsVGhpcyIsInByb2Nlc3MiLCJlbnYiLCJGT1JDRV9OT0RFX0ZFVENIIiwicCIsImZldGNoIiwiQmxvYiIsIkZpbGUiLCJGb3JtRGF0YSIsIkhlYWRlcnMiLCJSZXF1ZXN0IiwiUmVzcG9uc2UiLCJBYm9ydENvbnRyb2xsZXIiLCJBYm9ydEVycm9yIiwiRmV0Y2hFcnJvciIsImJsb2JGcm9tIiwiYmxvYkZyb21TeW5jIiwiZmlsZUZyb20iLCJmaWxlRnJvbVN5bmMiLCJpc1JlZGlyZWN0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native-with-agent/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native-with-agent/dist/node.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/node-fetch-native-with-agent/dist/node.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(rsc)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar ms = Object.defineProperty;\nvar u = (c1, l)=>ms(c1, \"name\", {\n        value: l,\n        configurable: !0\n    });\nvar Po = (c1, l, d)=>{\n    if (!l.has(c1)) throw TypeError(\"Cannot \" + d);\n};\nvar D = (c1, l, d)=>(Po(c1, l, \"read from private field\"), d ? d.call(c1) : l.get(c1)), ye = (c1, l, d)=>{\n    if (l.has(c1)) throw TypeError(\"Cannot add the same private member more than once\");\n    l instanceof WeakSet ? l.add(c1) : l.set(c1, d);\n}, ne = (c1, l, d, y)=>(Po(c1, l, \"write to private field\"), y ? y.call(c1, d) : l.set(c1, d), d);\nvar Pe, bt, ot, Zt, Ue, mt, yt, gt, oe, _t, Me, xe, St;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: !0\n}));\nconst http = __webpack_require__(/*! node:http */ \"node:http\"), https = __webpack_require__(/*! node:https */ \"node:https\"), zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\"), Stream = __webpack_require__(/*! node:stream */ \"node:stream\"), require$$6 = __webpack_require__(/*! node:buffer */ \"node:buffer\"), require$$0 = __webpack_require__(/*! node:util */ \"node:util\"), _commonjsHelpers = __webpack_require__(/*! ./shared/node-fetch-native-with-agent.61758d11.cjs */ \"(rsc)/./node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.61758d11.cjs\"), require$$1 = __webpack_require__(/*! node:url */ \"node:url\"), require$$4 = __webpack_require__(/*! node:net */ \"node:net\"), node_fs = __webpack_require__(/*! node:fs */ \"node:fs\"), node_path = __webpack_require__(/*! node:path */ \"node:path\");\nfunction _interopDefaultCompat(c1) {\n    return c1 && typeof c1 == \"object\" && \"default\" in c1 ? c1.default : c1;\n}\nu(_interopDefaultCompat, \"_interopDefaultCompat\");\nconst http__default = _interopDefaultCompat(http), https__default = _interopDefaultCompat(https), zlib__default = _interopDefaultCompat(zlib), Stream__default = _interopDefaultCompat(Stream);\nfunction dataUriToBuffer(c1) {\n    if (!/^data:/i.test(c1)) throw new TypeError('`uri` does not appear to be a Data URI (must begin with \"data:\")');\n    c1 = c1.replace(/\\r?\\n/g, \"\");\n    const l = c1.indexOf(\",\");\n    if (l === -1 || l <= 4) throw new TypeError(\"malformed data: URI\");\n    const d = c1.substring(5, l).split(\";\");\n    let y = \"\", b = !1;\n    const R = d[0] || \"text/plain\";\n    let w = R;\n    for(let F = 1; F < d.length; F++)d[F] === \"base64\" ? b = !0 : d[F] && (w += `;${d[F]}`, d[F].indexOf(\"charset=\") === 0 && (y = d[F].substring(8)));\n    !d[0] && !y.length && (w += \";charset=US-ASCII\", y = \"US-ASCII\");\n    const v = b ? \"base64\" : \"ascii\", I = unescape(c1.substring(l + 1)), B = Buffer.from(I, v);\n    return B.type = R, B.typeFull = w, B.charset = y, B;\n}\nu(dataUriToBuffer, \"dataUriToBuffer\");\nvar ponyfill_es2018 = {\n    exports: {}\n}; /**\n * @license\n * web-streams-polyfill v3.3.3\n * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.\n * This code is released under the MIT license.\n * SPDX-License-Identifier: MIT\n */ \nvar hasRequiredPonyfill_es2018;\nfunction requirePonyfill_es2018() {\n    return hasRequiredPonyfill_es2018 || (hasRequiredPonyfill_es2018 = 1, function(c1, l) {\n        (function(d, y) {\n            y(l);\n        })(_commonjsHelpers.commonjsGlobal, function(d) {\n            function y() {}\n            u(y, \"noop\");\n            function b(n) {\n                return typeof n == \"object\" && n !== null || typeof n == \"function\";\n            }\n            u(b, \"typeIsObject\");\n            const R = y;\n            function w(n, o) {\n                try {\n                    Object.defineProperty(n, \"name\", {\n                        value: o,\n                        configurable: !0\n                    });\n                } catch  {}\n            }\n            u(w, \"setFunctionName\");\n            const v = Promise, I = Promise.prototype.then, B = Promise.reject.bind(v);\n            function F(n) {\n                return new v(n);\n            }\n            u(F, \"newPromise\");\n            function k(n) {\n                return F((o)=>o(n));\n            }\n            u(k, \"promiseResolvedWith\");\n            function T(n) {\n                return B(n);\n            }\n            u(T, \"promiseRejectedWith\");\n            function $(n, o, a) {\n                return I.call(n, o, a);\n            }\n            u($, \"PerformPromiseThen\");\n            function E(n, o, a) {\n                $($(n, o, a), void 0, R);\n            }\n            u(E, \"uponPromise\");\n            function K(n, o) {\n                E(n, o);\n            }\n            u(K, \"uponFulfillment\");\n            function U(n, o) {\n                E(n, void 0, o);\n            }\n            u(U, \"uponRejection\");\n            function N(n, o, a) {\n                return $(n, o, a);\n            }\n            u(N, \"transformPromiseWith\");\n            function J(n) {\n                $(n, void 0, R);\n            }\n            u(J, \"setPromiseIsHandledToTrue\");\n            let ge = u((n)=>{\n                if (typeof queueMicrotask == \"function\") ge = queueMicrotask;\n                else {\n                    const o = k(void 0);\n                    ge = u((a)=>$(o, a), \"_queueMicrotask\");\n                }\n                return ge(n);\n            }, \"_queueMicrotask\");\n            function M(n, o, a) {\n                if (typeof n != \"function\") throw new TypeError(\"Argument is not a function\");\n                return Function.prototype.apply.call(n, o, a);\n            }\n            u(M, \"reflectCall\");\n            function H(n, o, a) {\n                try {\n                    return k(M(n, o, a));\n                } catch (p) {\n                    return T(p);\n                }\n            }\n            u(H, \"promiseCall\");\n            const G = 16384, Dr = class Dr {\n                constructor(){\n                    this._cursor = 0, this._size = 0, this._front = {\n                        _elements: [],\n                        _next: void 0\n                    }, this._back = this._front, this._cursor = 0, this._size = 0;\n                }\n                get length() {\n                    return this._size;\n                }\n                push(o) {\n                    const a = this._back;\n                    let p = a;\n                    a._elements.length === G - 1 && (p = {\n                        _elements: [],\n                        _next: void 0\n                    }), a._elements.push(o), p !== a && (this._back = p, a._next = p), ++this._size;\n                }\n                shift() {\n                    const o = this._front;\n                    let a = o;\n                    const p = this._cursor;\n                    let g = p + 1;\n                    const _ = o._elements, S = _[p];\n                    return g === G && (a = o._next, g = 0), --this._size, this._cursor = g, o !== a && (this._front = a), _[p] = void 0, S;\n                }\n                forEach(o) {\n                    let a = this._cursor, p = this._front, g = p._elements;\n                    for(; (a !== g.length || p._next !== void 0) && !(a === g.length && (p = p._next, g = p._elements, a = 0, g.length === 0));)o(g[a]), ++a;\n                }\n                peek() {\n                    const o = this._front, a = this._cursor;\n                    return o._elements[a];\n                }\n            };\n            u(Dr, \"SimpleQueue\");\n            let Q = Dr;\n            const wt = Symbol(\"[[AbortSteps]]\"), un = Symbol(\"[[ErrorSteps]]\"), er = Symbol(\"[[CancelSteps]]\"), tr = Symbol(\"[[PullSteps]]\"), rr = Symbol(\"[[ReleaseSteps]]\");\n            function ln(n, o) {\n                n._ownerReadableStream = o, o._reader = n, o._state === \"readable\" ? or(n) : o._state === \"closed\" ? vo(n) : fn(n, o._storedError);\n            }\n            u(ln, \"ReadableStreamReaderGenericInitialize\");\n            function nr(n, o) {\n                const a = n._ownerReadableStream;\n                return le(a, o);\n            }\n            u(nr, \"ReadableStreamReaderGenericCancel\");\n            function _e(n) {\n                const o = n._ownerReadableStream;\n                o._state === \"readable\" ? ir(n, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")) : Eo(n, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")), o._readableStreamController[rr](), o._reader = void 0, n._ownerReadableStream = void 0;\n            }\n            u(_e, \"ReadableStreamReaderGenericRelease\");\n            function Rt(n) {\n                return new TypeError(\"Cannot \" + n + \" a stream using a released reader\");\n            }\n            u(Rt, \"readerLockException\");\n            function or(n) {\n                n._closedPromise = F((o, a)=>{\n                    n._closedPromise_resolve = o, n._closedPromise_reject = a;\n                });\n            }\n            u(or, \"defaultReaderClosedPromiseInitialize\");\n            function fn(n, o) {\n                or(n), ir(n, o);\n            }\n            u(fn, \"defaultReaderClosedPromiseInitializeAsRejected\");\n            function vo(n) {\n                or(n), cn(n);\n            }\n            u(vo, \"defaultReaderClosedPromiseInitializeAsResolved\");\n            function ir(n, o) {\n                n._closedPromise_reject !== void 0 && (J(n._closedPromise), n._closedPromise_reject(o), n._closedPromise_resolve = void 0, n._closedPromise_reject = void 0);\n            }\n            u(ir, \"defaultReaderClosedPromiseReject\");\n            function Eo(n, o) {\n                fn(n, o);\n            }\n            u(Eo, \"defaultReaderClosedPromiseResetToRejected\");\n            function cn(n) {\n                n._closedPromise_resolve !== void 0 && (n._closedPromise_resolve(void 0), n._closedPromise_resolve = void 0, n._closedPromise_reject = void 0);\n            }\n            u(cn, \"defaultReaderClosedPromiseResolve\");\n            const dn = Number.isFinite || function(n) {\n                return typeof n == \"number\" && isFinite(n);\n            }, Ao = Math.trunc || function(n) {\n                return n < 0 ? Math.ceil(n) : Math.floor(n);\n            };\n            function Bo(n) {\n                return typeof n == \"object\" || typeof n == \"function\";\n            }\n            u(Bo, \"isDictionary\");\n            function ce(n, o) {\n                if (n !== void 0 && !Bo(n)) throw new TypeError(`${o} is not an object.`);\n            }\n            u(ce, \"assertDictionary\");\n            function ee(n, o) {\n                if (typeof n != \"function\") throw new TypeError(`${o} is not a function.`);\n            }\n            u(ee, \"assertFunction\");\n            function qo(n) {\n                return typeof n == \"object\" && n !== null || typeof n == \"function\";\n            }\n            u(qo, \"isObject\");\n            function hn(n, o) {\n                if (!qo(n)) throw new TypeError(`${o} is not an object.`);\n            }\n            u(hn, \"assertObject\");\n            function Se(n, o, a) {\n                if (n === void 0) throw new TypeError(`Parameter ${o} is required in '${a}'.`);\n            }\n            u(Se, \"assertRequiredArgument\");\n            function sr(n, o, a) {\n                if (n === void 0) throw new TypeError(`${o} is required in '${a}'.`);\n            }\n            u(sr, \"assertRequiredField\");\n            function ar(n) {\n                return Number(n);\n            }\n            u(ar, \"convertUnrestrictedDouble\");\n            function pn(n) {\n                return n === 0 ? 0 : n;\n            }\n            u(pn, \"censorNegativeZero\");\n            function ko(n) {\n                return pn(Ao(n));\n            }\n            u(ko, \"integerPart\");\n            function ur(n, o) {\n                const p = Number.MAX_SAFE_INTEGER;\n                let g = Number(n);\n                if (g = pn(g), !dn(g)) throw new TypeError(`${o} is not a finite number`);\n                if (g = ko(g), g < 0 || g > p) throw new TypeError(`${o} is outside the accepted range of 0 to ${p}, inclusive`);\n                return !dn(g) || g === 0 ? 0 : g;\n            }\n            u(ur, \"convertUnsignedLongLongWithEnforceRange\");\n            function lr(n, o) {\n                if (!qe(n)) throw new TypeError(`${o} is not a ReadableStream.`);\n            }\n            u(lr, \"assertReadableStream\");\n            function Ne(n) {\n                return new de(n);\n            }\n            u(Ne, \"AcquireReadableStreamDefaultReader\");\n            function bn(n, o) {\n                n._reader._readRequests.push(o);\n            }\n            u(bn, \"ReadableStreamAddReadRequest\");\n            function fr(n, o, a) {\n                const g = n._reader._readRequests.shift();\n                a ? g._closeSteps() : g._chunkSteps(o);\n            }\n            u(fr, \"ReadableStreamFulfillReadRequest\");\n            function Tt(n) {\n                return n._reader._readRequests.length;\n            }\n            u(Tt, \"ReadableStreamGetNumReadRequests\");\n            function mn(n) {\n                const o = n._reader;\n                return !(o === void 0 || !ve(o));\n            }\n            u(mn, \"ReadableStreamHasDefaultReader\");\n            const Mr = class Mr {\n                constructor(o){\n                    if (Se(o, 1, \"ReadableStreamDefaultReader\"), lr(o, \"First parameter\"), ke(o)) throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n                    ln(this, o), this._readRequests = new Q;\n                }\n                get closed() {\n                    return ve(this) ? this._closedPromise : T(Ct(\"closed\"));\n                }\n                cancel(o = void 0) {\n                    return ve(this) ? this._ownerReadableStream === void 0 ? T(Rt(\"cancel\")) : nr(this, o) : T(Ct(\"cancel\"));\n                }\n                read() {\n                    if (!ve(this)) return T(Ct(\"read\"));\n                    if (this._ownerReadableStream === void 0) return T(Rt(\"read from\"));\n                    let o, a;\n                    const p = F((_, S)=>{\n                        o = _, a = S;\n                    });\n                    return it(this, {\n                        _chunkSteps: (_)=>o({\n                                value: _,\n                                done: !1\n                            }),\n                        _closeSteps: ()=>o({\n                                value: void 0,\n                                done: !0\n                            }),\n                        _errorSteps: (_)=>a(_)\n                    }), p;\n                }\n                releaseLock() {\n                    if (!ve(this)) throw Ct(\"releaseLock\");\n                    this._ownerReadableStream !== void 0 && Wo(this);\n                }\n            };\n            u(Mr, \"ReadableStreamDefaultReader\");\n            let de = Mr;\n            Object.defineProperties(de.prototype, {\n                cancel: {\n                    enumerable: !0\n                },\n                read: {\n                    enumerable: !0\n                },\n                releaseLock: {\n                    enumerable: !0\n                },\n                closed: {\n                    enumerable: !0\n                }\n            }), w(de.prototype.cancel, \"cancel\"), w(de.prototype.read, \"read\"), w(de.prototype.releaseLock, \"releaseLock\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(de.prototype, Symbol.toStringTag, {\n                value: \"ReadableStreamDefaultReader\",\n                configurable: !0\n            });\n            function ve(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_readRequests\") ? !1 : n instanceof de;\n            }\n            u(ve, \"IsReadableStreamDefaultReader\");\n            function it(n, o) {\n                const a = n._ownerReadableStream;\n                a._disturbed = !0, a._state === \"closed\" ? o._closeSteps() : a._state === \"errored\" ? o._errorSteps(a._storedError) : a._readableStreamController[tr](o);\n            }\n            u(it, \"ReadableStreamDefaultReaderRead\");\n            function Wo(n) {\n                _e(n);\n                const o = new TypeError(\"Reader was released\");\n                yn(n, o);\n            }\n            u(Wo, \"ReadableStreamDefaultReaderRelease\");\n            function yn(n, o) {\n                const a = n._readRequests;\n                n._readRequests = new Q, a.forEach((p)=>{\n                    p._errorSteps(o);\n                });\n            }\n            u(yn, \"ReadableStreamDefaultReaderErrorReadRequests\");\n            function Ct(n) {\n                return new TypeError(`ReadableStreamDefaultReader.prototype.${n} can only be used on a ReadableStreamDefaultReader`);\n            }\n            u(Ct, \"defaultReaderBrandCheckException\");\n            const Oo = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype), xr = class xr {\n                constructor(o, a){\n                    this._ongoingPromise = void 0, this._isFinished = !1, this._reader = o, this._preventCancel = a;\n                }\n                next() {\n                    const o = u(()=>this._nextSteps(), \"nextSteps\");\n                    return this._ongoingPromise = this._ongoingPromise ? N(this._ongoingPromise, o, o) : o(), this._ongoingPromise;\n                }\n                return(o) {\n                    const a = u(()=>this._returnSteps(o), \"returnSteps\");\n                    return this._ongoingPromise ? N(this._ongoingPromise, a, a) : a();\n                }\n                _nextSteps() {\n                    if (this._isFinished) return Promise.resolve({\n                        value: void 0,\n                        done: !0\n                    });\n                    const o = this._reader;\n                    let a, p;\n                    const g = F((S, C)=>{\n                        a = S, p = C;\n                    });\n                    return it(o, {\n                        _chunkSteps: (S)=>{\n                            this._ongoingPromise = void 0, ge(()=>a({\n                                    value: S,\n                                    done: !1\n                                }));\n                        },\n                        _closeSteps: ()=>{\n                            this._ongoingPromise = void 0, this._isFinished = !0, _e(o), a({\n                                value: void 0,\n                                done: !0\n                            });\n                        },\n                        _errorSteps: (S)=>{\n                            this._ongoingPromise = void 0, this._isFinished = !0, _e(o), p(S);\n                        }\n                    }), g;\n                }\n                _returnSteps(o) {\n                    if (this._isFinished) return Promise.resolve({\n                        value: o,\n                        done: !0\n                    });\n                    this._isFinished = !0;\n                    const a = this._reader;\n                    if (!this._preventCancel) {\n                        const p = nr(a, o);\n                        return _e(a), N(p, ()=>({\n                                value: o,\n                                done: !0\n                            }));\n                    }\n                    return _e(a), k({\n                        value: o,\n                        done: !0\n                    });\n                }\n            };\n            u(xr, \"ReadableStreamAsyncIteratorImpl\");\n            let Pt = xr;\n            const gn = {\n                next () {\n                    return _n(this) ? this._asyncIteratorImpl.next() : T(Sn(\"next\"));\n                },\n                return (n) {\n                    return _n(this) ? this._asyncIteratorImpl.return(n) : T(Sn(\"return\"));\n                }\n            };\n            Object.setPrototypeOf(gn, Oo);\n            function zo(n, o) {\n                const a = Ne(n), p = new Pt(a, o), g = Object.create(gn);\n                return g._asyncIteratorImpl = p, g;\n            }\n            u(zo, \"AcquireReadableStreamAsyncIterator\");\n            function _n(n) {\n                if (!b(n) || !Object.prototype.hasOwnProperty.call(n, \"_asyncIteratorImpl\")) return !1;\n                try {\n                    return n._asyncIteratorImpl instanceof Pt;\n                } catch  {\n                    return !1;\n                }\n            }\n            u(_n, \"IsReadableStreamAsyncIterator\");\n            function Sn(n) {\n                return new TypeError(`ReadableStreamAsyncIterator.${n} can only be used on a ReadableSteamAsyncIterator`);\n            }\n            u(Sn, \"streamAsyncIteratorBrandCheckException\");\n            const wn = Number.isNaN || function(n) {\n                return n !== n;\n            };\n            var cr, dr, hr;\n            function st(n) {\n                return n.slice();\n            }\n            u(st, \"CreateArrayFromList\");\n            function Rn(n, o, a, p, g) {\n                new Uint8Array(n).set(new Uint8Array(a, p, g), o);\n            }\n            u(Rn, \"CopyDataBlockBytes\");\n            let we = u((n)=>(typeof n.transfer == \"function\" ? we = u((o)=>o.transfer(), \"TransferArrayBuffer\") : typeof structuredClone == \"function\" ? we = u((o)=>structuredClone(o, {\n                        transfer: [\n                            o\n                        ]\n                    }), \"TransferArrayBuffer\") : we = u((o)=>o, \"TransferArrayBuffer\"), we(n)), \"TransferArrayBuffer\"), Ee = u((n)=>(typeof n.detached == \"boolean\" ? Ee = u((o)=>o.detached, \"IsDetachedBuffer\") : Ee = u((o)=>o.byteLength === 0, \"IsDetachedBuffer\"), Ee(n)), \"IsDetachedBuffer\");\n            function Tn(n, o, a) {\n                if (n.slice) return n.slice(o, a);\n                const p = a - o, g = new ArrayBuffer(p);\n                return Rn(g, 0, n, o, p), g;\n            }\n            u(Tn, \"ArrayBufferSlice\");\n            function vt(n, o) {\n                const a = n[o];\n                if (a != null) {\n                    if (typeof a != \"function\") throw new TypeError(`${String(o)} is not a function`);\n                    return a;\n                }\n            }\n            u(vt, \"GetMethod\");\n            function Fo(n) {\n                const o = {\n                    [Symbol.iterator]: ()=>n.iterator\n                }, a = async function*() {\n                    return yield* o;\n                }(), p = a.next;\n                return {\n                    iterator: a,\n                    nextMethod: p,\n                    done: !1\n                };\n            }\n            u(Fo, \"CreateAsyncFromSyncIterator\");\n            const pr = (hr = (cr = Symbol.asyncIterator) !== null && cr !== void 0 ? cr : (dr = Symbol.for) === null || dr === void 0 ? void 0 : dr.call(Symbol, \"Symbol.asyncIterator\")) !== null && hr !== void 0 ? hr : \"@@asyncIterator\";\n            function Cn(n, o = \"sync\", a) {\n                if (a === void 0) if (o === \"async\") {\n                    if (a = vt(n, pr), a === void 0) {\n                        const _ = vt(n, Symbol.iterator), S = Cn(n, \"sync\", _);\n                        return Fo(S);\n                    }\n                } else a = vt(n, Symbol.iterator);\n                if (a === void 0) throw new TypeError(\"The object is not iterable\");\n                const p = M(a, n, []);\n                if (!b(p)) throw new TypeError(\"The iterator method must return an object\");\n                const g = p.next;\n                return {\n                    iterator: p,\n                    nextMethod: g,\n                    done: !1\n                };\n            }\n            u(Cn, \"GetIterator\");\n            function Io(n) {\n                const o = M(n.nextMethod, n.iterator, []);\n                if (!b(o)) throw new TypeError(\"The iterator.next() method must return an object\");\n                return o;\n            }\n            u(Io, \"IteratorNext\");\n            function jo(n) {\n                return !!n.done;\n            }\n            u(jo, \"IteratorComplete\");\n            function Lo(n) {\n                return n.value;\n            }\n            u(Lo, \"IteratorValue\");\n            function $o(n) {\n                return !(typeof n != \"number\" || wn(n) || n < 0);\n            }\n            u($o, \"IsNonNegativeNumber\");\n            function Pn(n) {\n                const o = Tn(n.buffer, n.byteOffset, n.byteOffset + n.byteLength);\n                return new Uint8Array(o);\n            }\n            u(Pn, \"CloneAsUint8Array\");\n            function br(n) {\n                const o = n._queue.shift();\n                return n._queueTotalSize -= o.size, n._queueTotalSize < 0 && (n._queueTotalSize = 0), o.value;\n            }\n            u(br, \"DequeueValue\");\n            function mr(n, o, a) {\n                if (!$o(a) || a === 1 / 0) throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n                n._queue.push({\n                    value: o,\n                    size: a\n                }), n._queueTotalSize += a;\n            }\n            u(mr, \"EnqueueValueWithSize\");\n            function Do(n) {\n                return n._queue.peek().value;\n            }\n            u(Do, \"PeekQueueValue\");\n            function Ae(n) {\n                n._queue = new Q, n._queueTotalSize = 0;\n            }\n            u(Ae, \"ResetQueue\");\n            function vn(n) {\n                return n === DataView;\n            }\n            u(vn, \"isDataViewConstructor\");\n            function Mo(n) {\n                return vn(n.constructor);\n            }\n            u(Mo, \"isDataView\");\n            function xo(n) {\n                return vn(n) ? 1 : n.BYTES_PER_ELEMENT;\n            }\n            u(xo, \"arrayBufferViewElementSize\");\n            const Ur = class Ur {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                get view() {\n                    if (!yr(this)) throw Rr(\"view\");\n                    return this._view;\n                }\n                respond(o) {\n                    if (!yr(this)) throw Rr(\"respond\");\n                    if (Se(o, 1, \"respond\"), o = ur(o, \"First parameter\"), this._associatedReadableByteStreamController === void 0) throw new TypeError(\"This BYOB request has been invalidated\");\n                    if (Ee(this._view.buffer)) throw new TypeError(\"The BYOB request's buffer has been detached and so cannot be used as a response\");\n                    qt(this._associatedReadableByteStreamController, o);\n                }\n                respondWithNewView(o) {\n                    if (!yr(this)) throw Rr(\"respondWithNewView\");\n                    if (Se(o, 1, \"respondWithNewView\"), !ArrayBuffer.isView(o)) throw new TypeError(\"You can only respond with array buffer views\");\n                    if (this._associatedReadableByteStreamController === void 0) throw new TypeError(\"This BYOB request has been invalidated\");\n                    if (Ee(o.buffer)) throw new TypeError(\"The given view's buffer has been detached and so cannot be used as a response\");\n                    kt(this._associatedReadableByteStreamController, o);\n                }\n            };\n            u(Ur, \"ReadableStreamBYOBRequest\");\n            let Re = Ur;\n            Object.defineProperties(Re.prototype, {\n                respond: {\n                    enumerable: !0\n                },\n                respondWithNewView: {\n                    enumerable: !0\n                },\n                view: {\n                    enumerable: !0\n                }\n            }), w(Re.prototype.respond, \"respond\"), w(Re.prototype.respondWithNewView, \"respondWithNewView\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(Re.prototype, Symbol.toStringTag, {\n                value: \"ReadableStreamBYOBRequest\",\n                configurable: !0\n            });\n            const Nr = class Nr {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                get byobRequest() {\n                    if (!Oe(this)) throw ut(\"byobRequest\");\n                    return wr(this);\n                }\n                get desiredSize() {\n                    if (!Oe(this)) throw ut(\"desiredSize\");\n                    return In(this);\n                }\n                close() {\n                    if (!Oe(this)) throw ut(\"close\");\n                    if (this._closeRequested) throw new TypeError(\"The stream has already been closed; do not close it again!\");\n                    const o = this._controlledReadableByteStream._state;\n                    if (o !== \"readable\") throw new TypeError(`The stream (in ${o} state) is not in the readable state and cannot be closed`);\n                    at(this);\n                }\n                enqueue(o) {\n                    if (!Oe(this)) throw ut(\"enqueue\");\n                    if (Se(o, 1, \"enqueue\"), !ArrayBuffer.isView(o)) throw new TypeError(\"chunk must be an array buffer view\");\n                    if (o.byteLength === 0) throw new TypeError(\"chunk must have non-zero byteLength\");\n                    if (o.buffer.byteLength === 0) throw new TypeError(\"chunk's buffer must have non-zero byteLength\");\n                    if (this._closeRequested) throw new TypeError(\"stream is closed or draining\");\n                    const a = this._controlledReadableByteStream._state;\n                    if (a !== \"readable\") throw new TypeError(`The stream (in ${a} state) is not in the readable state and cannot be enqueued to`);\n                    Bt(this, o);\n                }\n                error(o = void 0) {\n                    if (!Oe(this)) throw ut(\"error\");\n                    te(this, o);\n                }\n                [er](o) {\n                    En(this), Ae(this);\n                    const a = this._cancelAlgorithm(o);\n                    return At(this), a;\n                }\n                [tr](o) {\n                    const a = this._controlledReadableByteStream;\n                    if (this._queueTotalSize > 0) {\n                        Fn(this, o);\n                        return;\n                    }\n                    const p = this._autoAllocateChunkSize;\n                    if (p !== void 0) {\n                        let g;\n                        try {\n                            g = new ArrayBuffer(p);\n                        } catch (S) {\n                            o._errorSteps(S);\n                            return;\n                        }\n                        const _ = {\n                            buffer: g,\n                            bufferByteLength: p,\n                            byteOffset: 0,\n                            byteLength: p,\n                            bytesFilled: 0,\n                            minimumFill: 1,\n                            elementSize: 1,\n                            viewConstructor: Uint8Array,\n                            readerType: \"default\"\n                        };\n                        this._pendingPullIntos.push(_);\n                    }\n                    bn(a, o), ze(this);\n                }\n                [rr]() {\n                    if (this._pendingPullIntos.length > 0) {\n                        const o = this._pendingPullIntos.peek();\n                        o.readerType = \"none\", this._pendingPullIntos = new Q, this._pendingPullIntos.push(o);\n                    }\n                }\n            };\n            u(Nr, \"ReadableByteStreamController\");\n            let ie = Nr;\n            Object.defineProperties(ie.prototype, {\n                close: {\n                    enumerable: !0\n                },\n                enqueue: {\n                    enumerable: !0\n                },\n                error: {\n                    enumerable: !0\n                },\n                byobRequest: {\n                    enumerable: !0\n                },\n                desiredSize: {\n                    enumerable: !0\n                }\n            }), w(ie.prototype.close, \"close\"), w(ie.prototype.enqueue, \"enqueue\"), w(ie.prototype.error, \"error\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(ie.prototype, Symbol.toStringTag, {\n                value: \"ReadableByteStreamController\",\n                configurable: !0\n            });\n            function Oe(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_controlledReadableByteStream\") ? !1 : n instanceof ie;\n            }\n            u(Oe, \"IsReadableByteStreamController\");\n            function yr(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_associatedReadableByteStreamController\") ? !1 : n instanceof Re;\n            }\n            u(yr, \"IsReadableStreamBYOBRequest\");\n            function ze(n) {\n                if (!Qo(n)) return;\n                if (n._pulling) {\n                    n._pullAgain = !0;\n                    return;\n                }\n                n._pulling = !0;\n                const a = n._pullAlgorithm();\n                E(a, ()=>(n._pulling = !1, n._pullAgain && (n._pullAgain = !1, ze(n)), null), (p)=>(te(n, p), null));\n            }\n            u(ze, \"ReadableByteStreamControllerCallPullIfNeeded\");\n            function En(n) {\n                _r(n), n._pendingPullIntos = new Q;\n            }\n            u(En, \"ReadableByteStreamControllerClearPendingPullIntos\");\n            function gr(n, o) {\n                let a = !1;\n                n._state === \"closed\" && (a = !0);\n                const p = An(o);\n                o.readerType === \"default\" ? fr(n, p, a) : Xo(n, p, a);\n            }\n            u(gr, \"ReadableByteStreamControllerCommitPullIntoDescriptor\");\n            function An(n) {\n                const o = n.bytesFilled, a = n.elementSize;\n                return new n.viewConstructor(n.buffer, n.byteOffset, o / a);\n            }\n            u(An, \"ReadableByteStreamControllerConvertPullIntoDescriptor\");\n            function Et(n, o, a, p) {\n                n._queue.push({\n                    buffer: o,\n                    byteOffset: a,\n                    byteLength: p\n                }), n._queueTotalSize += p;\n            }\n            u(Et, \"ReadableByteStreamControllerEnqueueChunkToQueue\");\n            function Bn(n, o, a, p) {\n                let g;\n                try {\n                    g = Tn(o, a, a + p);\n                } catch (_) {\n                    throw te(n, _), _;\n                }\n                Et(n, g, 0, p);\n            }\n            u(Bn, \"ReadableByteStreamControllerEnqueueClonedChunkToQueue\");\n            function qn(n, o) {\n                o.bytesFilled > 0 && Bn(n, o.buffer, o.byteOffset, o.bytesFilled), He(n);\n            }\n            u(qn, \"ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue\");\n            function kn(n, o) {\n                const a = Math.min(n._queueTotalSize, o.byteLength - o.bytesFilled), p = o.bytesFilled + a;\n                let g = a, _ = !1;\n                const S = p % o.elementSize, C = p - S;\n                C >= o.minimumFill && (g = C - o.bytesFilled, _ = !0);\n                const q = n._queue;\n                for(; g > 0;){\n                    const P = q.peek(), W = Math.min(g, P.byteLength), O = o.byteOffset + o.bytesFilled;\n                    Rn(o.buffer, O, P.buffer, P.byteOffset, W), P.byteLength === W ? q.shift() : (P.byteOffset += W, P.byteLength -= W), n._queueTotalSize -= W, Wn(n, W, o), g -= W;\n                }\n                return _;\n            }\n            u(kn, \"ReadableByteStreamControllerFillPullIntoDescriptorFromQueue\");\n            function Wn(n, o, a) {\n                a.bytesFilled += o;\n            }\n            u(Wn, \"ReadableByteStreamControllerFillHeadPullIntoDescriptor\");\n            function On(n) {\n                n._queueTotalSize === 0 && n._closeRequested ? (At(n), pt(n._controlledReadableByteStream)) : ze(n);\n            }\n            u(On, \"ReadableByteStreamControllerHandleQueueDrain\");\n            function _r(n) {\n                n._byobRequest !== null && (n._byobRequest._associatedReadableByteStreamController = void 0, n._byobRequest._view = null, n._byobRequest = null);\n            }\n            u(_r, \"ReadableByteStreamControllerInvalidateBYOBRequest\");\n            function Sr(n) {\n                for(; n._pendingPullIntos.length > 0;){\n                    if (n._queueTotalSize === 0) return;\n                    const o = n._pendingPullIntos.peek();\n                    kn(n, o) && (He(n), gr(n._controlledReadableByteStream, o));\n                }\n            }\n            u(Sr, \"ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue\");\n            function Uo(n) {\n                const o = n._controlledReadableByteStream._reader;\n                for(; o._readRequests.length > 0;){\n                    if (n._queueTotalSize === 0) return;\n                    const a = o._readRequests.shift();\n                    Fn(n, a);\n                }\n            }\n            u(Uo, \"ReadableByteStreamControllerProcessReadRequestsUsingQueue\");\n            function No(n, o, a, p) {\n                const g = n._controlledReadableByteStream, _ = o.constructor, S = xo(_), { byteOffset: C, byteLength: q } = o, P = a * S;\n                let W;\n                try {\n                    W = we(o.buffer);\n                } catch (j) {\n                    p._errorSteps(j);\n                    return;\n                }\n                const O = {\n                    buffer: W,\n                    bufferByteLength: W.byteLength,\n                    byteOffset: C,\n                    byteLength: q,\n                    bytesFilled: 0,\n                    minimumFill: P,\n                    elementSize: S,\n                    viewConstructor: _,\n                    readerType: \"byob\"\n                };\n                if (n._pendingPullIntos.length > 0) {\n                    n._pendingPullIntos.push(O), $n(g, p);\n                    return;\n                }\n                if (g._state === \"closed\") {\n                    const j = new _(O.buffer, O.byteOffset, 0);\n                    p._closeSteps(j);\n                    return;\n                }\n                if (n._queueTotalSize > 0) {\n                    if (kn(n, O)) {\n                        const j = An(O);\n                        On(n), p._chunkSteps(j);\n                        return;\n                    }\n                    if (n._closeRequested) {\n                        const j = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                        te(n, j), p._errorSteps(j);\n                        return;\n                    }\n                }\n                n._pendingPullIntos.push(O), $n(g, p), ze(n);\n            }\n            u(No, \"ReadableByteStreamControllerPullInto\");\n            function Ho(n, o) {\n                o.readerType === \"none\" && He(n);\n                const a = n._controlledReadableByteStream;\n                if (Tr(a)) for(; Dn(a) > 0;){\n                    const p = He(n);\n                    gr(a, p);\n                }\n            }\n            u(Ho, \"ReadableByteStreamControllerRespondInClosedState\");\n            function Vo(n, o, a) {\n                if (Wn(n, o, a), a.readerType === \"none\") {\n                    qn(n, a), Sr(n);\n                    return;\n                }\n                if (a.bytesFilled < a.minimumFill) return;\n                He(n);\n                const p = a.bytesFilled % a.elementSize;\n                if (p > 0) {\n                    const g = a.byteOffset + a.bytesFilled;\n                    Bn(n, a.buffer, g - p, p);\n                }\n                a.bytesFilled -= p, gr(n._controlledReadableByteStream, a), Sr(n);\n            }\n            u(Vo, \"ReadableByteStreamControllerRespondInReadableState\");\n            function zn(n, o) {\n                const a = n._pendingPullIntos.peek();\n                _r(n), n._controlledReadableByteStream._state === \"closed\" ? Ho(n, a) : Vo(n, o, a), ze(n);\n            }\n            u(zn, \"ReadableByteStreamControllerRespondInternal\");\n            function He(n) {\n                return n._pendingPullIntos.shift();\n            }\n            u(He, \"ReadableByteStreamControllerShiftPendingPullInto\");\n            function Qo(n) {\n                const o = n._controlledReadableByteStream;\n                return o._state !== \"readable\" || n._closeRequested || !n._started ? !1 : !!(mn(o) && Tt(o) > 0 || Tr(o) && Dn(o) > 0 || In(n) > 0);\n            }\n            u(Qo, \"ReadableByteStreamControllerShouldCallPull\");\n            function At(n) {\n                n._pullAlgorithm = void 0, n._cancelAlgorithm = void 0;\n            }\n            u(At, \"ReadableByteStreamControllerClearAlgorithms\");\n            function at(n) {\n                const o = n._controlledReadableByteStream;\n                if (!(n._closeRequested || o._state !== \"readable\")) {\n                    if (n._queueTotalSize > 0) {\n                        n._closeRequested = !0;\n                        return;\n                    }\n                    if (n._pendingPullIntos.length > 0) {\n                        const a = n._pendingPullIntos.peek();\n                        if (a.bytesFilled % a.elementSize !== 0) {\n                            const p = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                            throw te(n, p), p;\n                        }\n                    }\n                    At(n), pt(o);\n                }\n            }\n            u(at, \"ReadableByteStreamControllerClose\");\n            function Bt(n, o) {\n                const a = n._controlledReadableByteStream;\n                if (n._closeRequested || a._state !== \"readable\") return;\n                const { buffer: p, byteOffset: g, byteLength: _ } = o;\n                if (Ee(p)) throw new TypeError(\"chunk's buffer is detached and so cannot be enqueued\");\n                const S = we(p);\n                if (n._pendingPullIntos.length > 0) {\n                    const C = n._pendingPullIntos.peek();\n                    if (Ee(C.buffer)) throw new TypeError(\"The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk\");\n                    _r(n), C.buffer = we(C.buffer), C.readerType === \"none\" && qn(n, C);\n                }\n                if (mn(a)) if (Uo(n), Tt(a) === 0) Et(n, S, g, _);\n                else {\n                    n._pendingPullIntos.length > 0 && He(n);\n                    const C = new Uint8Array(S, g, _);\n                    fr(a, C, !1);\n                }\n                else Tr(a) ? (Et(n, S, g, _), Sr(n)) : Et(n, S, g, _);\n                ze(n);\n            }\n            u(Bt, \"ReadableByteStreamControllerEnqueue\");\n            function te(n, o) {\n                const a = n._controlledReadableByteStream;\n                a._state === \"readable\" && (En(n), Ae(n), At(n), fo(a, o));\n            }\n            u(te, \"ReadableByteStreamControllerError\");\n            function Fn(n, o) {\n                const a = n._queue.shift();\n                n._queueTotalSize -= a.byteLength, On(n);\n                const p = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n                o._chunkSteps(p);\n            }\n            u(Fn, \"ReadableByteStreamControllerFillReadRequestFromQueue\");\n            function wr(n) {\n                if (n._byobRequest === null && n._pendingPullIntos.length > 0) {\n                    const o = n._pendingPullIntos.peek(), a = new Uint8Array(o.buffer, o.byteOffset + o.bytesFilled, o.byteLength - o.bytesFilled), p = Object.create(Re.prototype);\n                    Yo(p, n, a), n._byobRequest = p;\n                }\n                return n._byobRequest;\n            }\n            u(wr, \"ReadableByteStreamControllerGetBYOBRequest\");\n            function In(n) {\n                const o = n._controlledReadableByteStream._state;\n                return o === \"errored\" ? null : o === \"closed\" ? 0 : n._strategyHWM - n._queueTotalSize;\n            }\n            u(In, \"ReadableByteStreamControllerGetDesiredSize\");\n            function qt(n, o) {\n                const a = n._pendingPullIntos.peek();\n                if (n._controlledReadableByteStream._state === \"closed\") {\n                    if (o !== 0) throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n                } else {\n                    if (o === 0) throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n                    if (a.bytesFilled + o > a.byteLength) throw new RangeError(\"bytesWritten out of range\");\n                }\n                a.buffer = we(a.buffer), zn(n, o);\n            }\n            u(qt, \"ReadableByteStreamControllerRespond\");\n            function kt(n, o) {\n                const a = n._pendingPullIntos.peek();\n                if (n._controlledReadableByteStream._state === \"closed\") {\n                    if (o.byteLength !== 0) throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n                } else if (o.byteLength === 0) throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n                if (a.byteOffset + a.bytesFilled !== o.byteOffset) throw new RangeError(\"The region specified by view does not match byobRequest\");\n                if (a.bufferByteLength !== o.buffer.byteLength) throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n                if (a.bytesFilled + o.byteLength > a.byteLength) throw new RangeError(\"The region specified by view is larger than byobRequest\");\n                const g = o.byteLength;\n                a.buffer = we(o.buffer), zn(n, g);\n            }\n            u(kt, \"ReadableByteStreamControllerRespondWithNewView\");\n            function jn(n, o, a, p, g, _, S) {\n                o._controlledReadableByteStream = n, o._pullAgain = !1, o._pulling = !1, o._byobRequest = null, o._queue = o._queueTotalSize = void 0, Ae(o), o._closeRequested = !1, o._started = !1, o._strategyHWM = _, o._pullAlgorithm = p, o._cancelAlgorithm = g, o._autoAllocateChunkSize = S, o._pendingPullIntos = new Q, n._readableStreamController = o;\n                const C = a();\n                E(k(C), ()=>(o._started = !0, ze(o), null), (q)=>(te(o, q), null));\n            }\n            u(jn, \"SetUpReadableByteStreamController\");\n            function Go(n, o, a) {\n                const p = Object.create(ie.prototype);\n                let g, _, S;\n                o.start !== void 0 ? g = u(()=>o.start(p), \"startAlgorithm\") : g = u(()=>{}, \"startAlgorithm\"), o.pull !== void 0 ? _ = u(()=>o.pull(p), \"pullAlgorithm\") : _ = u(()=>k(void 0), \"pullAlgorithm\"), o.cancel !== void 0 ? S = u((q)=>o.cancel(q), \"cancelAlgorithm\") : S = u(()=>k(void 0), \"cancelAlgorithm\");\n                const C = o.autoAllocateChunkSize;\n                if (C === 0) throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n                jn(n, p, g, _, S, a, C);\n            }\n            u(Go, \"SetUpReadableByteStreamControllerFromUnderlyingSource\");\n            function Yo(n, o, a) {\n                n._associatedReadableByteStreamController = o, n._view = a;\n            }\n            u(Yo, \"SetUpReadableStreamBYOBRequest\");\n            function Rr(n) {\n                return new TypeError(`ReadableStreamBYOBRequest.prototype.${n} can only be used on a ReadableStreamBYOBRequest`);\n            }\n            u(Rr, \"byobRequestBrandCheckException\");\n            function ut(n) {\n                return new TypeError(`ReadableByteStreamController.prototype.${n} can only be used on a ReadableByteStreamController`);\n            }\n            u(ut, \"byteStreamControllerBrandCheckException\");\n            function Zo(n, o) {\n                ce(n, o);\n                const a = n?.mode;\n                return {\n                    mode: a === void 0 ? void 0 : Ko(a, `${o} has member 'mode' that`)\n                };\n            }\n            u(Zo, \"convertReaderOptions\");\n            function Ko(n, o) {\n                if (n = `${n}`, n !== \"byob\") throw new TypeError(`${o} '${n}' is not a valid enumeration value for ReadableStreamReaderMode`);\n                return n;\n            }\n            u(Ko, \"convertReadableStreamReaderMode\");\n            function Jo(n, o) {\n                var a;\n                ce(n, o);\n                const p = (a = n?.min) !== null && a !== void 0 ? a : 1;\n                return {\n                    min: ur(p, `${o} has member 'min' that`)\n                };\n            }\n            u(Jo, \"convertByobReadOptions\");\n            function Ln(n) {\n                return new he(n);\n            }\n            u(Ln, \"AcquireReadableStreamBYOBReader\");\n            function $n(n, o) {\n                n._reader._readIntoRequests.push(o);\n            }\n            u($n, \"ReadableStreamAddReadIntoRequest\");\n            function Xo(n, o, a) {\n                const g = n._reader._readIntoRequests.shift();\n                a ? g._closeSteps(o) : g._chunkSteps(o);\n            }\n            u(Xo, \"ReadableStreamFulfillReadIntoRequest\");\n            function Dn(n) {\n                return n._reader._readIntoRequests.length;\n            }\n            u(Dn, \"ReadableStreamGetNumReadIntoRequests\");\n            function Tr(n) {\n                const o = n._reader;\n                return !(o === void 0 || !Fe(o));\n            }\n            u(Tr, \"ReadableStreamHasBYOBReader\");\n            const Hr = class Hr {\n                constructor(o){\n                    if (Se(o, 1, \"ReadableStreamBYOBReader\"), lr(o, \"First parameter\"), ke(o)) throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n                    if (!Oe(o._readableStreamController)) throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source\");\n                    ln(this, o), this._readIntoRequests = new Q;\n                }\n                get closed() {\n                    return Fe(this) ? this._closedPromise : T(Wt(\"closed\"));\n                }\n                cancel(o = void 0) {\n                    return Fe(this) ? this._ownerReadableStream === void 0 ? T(Rt(\"cancel\")) : nr(this, o) : T(Wt(\"cancel\"));\n                }\n                read(o, a = {}) {\n                    if (!Fe(this)) return T(Wt(\"read\"));\n                    if (!ArrayBuffer.isView(o)) return T(new TypeError(\"view must be an array buffer view\"));\n                    if (o.byteLength === 0) return T(new TypeError(\"view must have non-zero byteLength\"));\n                    if (o.buffer.byteLength === 0) return T(new TypeError(\"view's buffer must have non-zero byteLength\"));\n                    if (Ee(o.buffer)) return T(new TypeError(\"view's buffer has been detached\"));\n                    let p;\n                    try {\n                        p = Jo(a, \"options\");\n                    } catch (P) {\n                        return T(P);\n                    }\n                    const g = p.min;\n                    if (g === 0) return T(new TypeError(\"options.min must be greater than 0\"));\n                    if (Mo(o)) {\n                        if (g > o.byteLength) return T(new RangeError(\"options.min must be less than or equal to view's byteLength\"));\n                    } else if (g > o.length) return T(new RangeError(\"options.min must be less than or equal to view's length\"));\n                    if (this._ownerReadableStream === void 0) return T(Rt(\"read from\"));\n                    let _, S;\n                    const C = F((P, W)=>{\n                        _ = P, S = W;\n                    });\n                    return Mn(this, o, g, {\n                        _chunkSteps: (P)=>_({\n                                value: P,\n                                done: !1\n                            }),\n                        _closeSteps: (P)=>_({\n                                value: P,\n                                done: !0\n                            }),\n                        _errorSteps: (P)=>S(P)\n                    }), C;\n                }\n                releaseLock() {\n                    if (!Fe(this)) throw Wt(\"releaseLock\");\n                    this._ownerReadableStream !== void 0 && ei(this);\n                }\n            };\n            u(Hr, \"ReadableStreamBYOBReader\");\n            let he = Hr;\n            Object.defineProperties(he.prototype, {\n                cancel: {\n                    enumerable: !0\n                },\n                read: {\n                    enumerable: !0\n                },\n                releaseLock: {\n                    enumerable: !0\n                },\n                closed: {\n                    enumerable: !0\n                }\n            }), w(he.prototype.cancel, \"cancel\"), w(he.prototype.read, \"read\"), w(he.prototype.releaseLock, \"releaseLock\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(he.prototype, Symbol.toStringTag, {\n                value: \"ReadableStreamBYOBReader\",\n                configurable: !0\n            });\n            function Fe(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_readIntoRequests\") ? !1 : n instanceof he;\n            }\n            u(Fe, \"IsReadableStreamBYOBReader\");\n            function Mn(n, o, a, p) {\n                const g = n._ownerReadableStream;\n                g._disturbed = !0, g._state === \"errored\" ? p._errorSteps(g._storedError) : No(g._readableStreamController, o, a, p);\n            }\n            u(Mn, \"ReadableStreamBYOBReaderRead\");\n            function ei(n) {\n                _e(n);\n                const o = new TypeError(\"Reader was released\");\n                xn(n, o);\n            }\n            u(ei, \"ReadableStreamBYOBReaderRelease\");\n            function xn(n, o) {\n                const a = n._readIntoRequests;\n                n._readIntoRequests = new Q, a.forEach((p)=>{\n                    p._errorSteps(o);\n                });\n            }\n            u(xn, \"ReadableStreamBYOBReaderErrorReadIntoRequests\");\n            function Wt(n) {\n                return new TypeError(`ReadableStreamBYOBReader.prototype.${n} can only be used on a ReadableStreamBYOBReader`);\n            }\n            u(Wt, \"byobReaderBrandCheckException\");\n            function lt(n, o) {\n                const { highWaterMark: a } = n;\n                if (a === void 0) return o;\n                if (wn(a) || a < 0) throw new RangeError(\"Invalid highWaterMark\");\n                return a;\n            }\n            u(lt, \"ExtractHighWaterMark\");\n            function Ot(n) {\n                const { size: o } = n;\n                return o || (()=>1);\n            }\n            u(Ot, \"ExtractSizeAlgorithm\");\n            function zt(n, o) {\n                ce(n, o);\n                const a = n?.highWaterMark, p = n?.size;\n                return {\n                    highWaterMark: a === void 0 ? void 0 : ar(a),\n                    size: p === void 0 ? void 0 : ti(p, `${o} has member 'size' that`)\n                };\n            }\n            u(zt, \"convertQueuingStrategy\");\n            function ti(n, o) {\n                return ee(n, o), (a)=>ar(n(a));\n            }\n            u(ti, \"convertQueuingStrategySize\");\n            function ri(n, o) {\n                ce(n, o);\n                const a = n?.abort, p = n?.close, g = n?.start, _ = n?.type, S = n?.write;\n                return {\n                    abort: a === void 0 ? void 0 : ni(a, n, `${o} has member 'abort' that`),\n                    close: p === void 0 ? void 0 : oi(p, n, `${o} has member 'close' that`),\n                    start: g === void 0 ? void 0 : ii(g, n, `${o} has member 'start' that`),\n                    write: S === void 0 ? void 0 : si(S, n, `${o} has member 'write' that`),\n                    type: _\n                };\n            }\n            u(ri, \"convertUnderlyingSink\");\n            function ni(n, o, a) {\n                return ee(n, a), (p)=>H(n, o, [\n                        p\n                    ]);\n            }\n            u(ni, \"convertUnderlyingSinkAbortCallback\");\n            function oi(n, o, a) {\n                return ee(n, a), ()=>H(n, o, []);\n            }\n            u(oi, \"convertUnderlyingSinkCloseCallback\");\n            function ii(n, o, a) {\n                return ee(n, a), (p)=>M(n, o, [\n                        p\n                    ]);\n            }\n            u(ii, \"convertUnderlyingSinkStartCallback\");\n            function si(n, o, a) {\n                return ee(n, a), (p, g)=>H(n, o, [\n                        p,\n                        g\n                    ]);\n            }\n            u(si, \"convertUnderlyingSinkWriteCallback\");\n            function Un(n, o) {\n                if (!Ve(n)) throw new TypeError(`${o} is not a WritableStream.`);\n            }\n            u(Un, \"assertWritableStream\");\n            function ai(n) {\n                if (typeof n != \"object\" || n === null) return !1;\n                try {\n                    return typeof n.aborted == \"boolean\";\n                } catch  {\n                    return !1;\n                }\n            }\n            u(ai, \"isAbortSignal\");\n            const ui = typeof AbortController == \"function\";\n            function li() {\n                if (ui) return new AbortController;\n            }\n            u(li, \"createAbortController\");\n            const Vr = class Vr {\n                constructor(o = {}, a = {}){\n                    o === void 0 ? o = null : hn(o, \"First parameter\");\n                    const p = zt(a, \"Second parameter\"), g = ri(o, \"First parameter\");\n                    if (Hn(this), g.type !== void 0) throw new RangeError(\"Invalid type is specified\");\n                    const S = Ot(p), C = lt(p, 1);\n                    Ti(this, g, C, S);\n                }\n                get locked() {\n                    if (!Ve(this)) throw $t(\"locked\");\n                    return Qe(this);\n                }\n                abort(o = void 0) {\n                    return Ve(this) ? Qe(this) ? T(new TypeError(\"Cannot abort a stream that already has a writer\")) : Ft(this, o) : T($t(\"abort\"));\n                }\n                close() {\n                    return Ve(this) ? Qe(this) ? T(new TypeError(\"Cannot close a stream that already has a writer\")) : be(this) ? T(new TypeError(\"Cannot close an already-closing stream\")) : Vn(this) : T($t(\"close\"));\n                }\n                getWriter() {\n                    if (!Ve(this)) throw $t(\"getWriter\");\n                    return Nn(this);\n                }\n            };\n            u(Vr, \"WritableStream\");\n            let pe = Vr;\n            Object.defineProperties(pe.prototype, {\n                abort: {\n                    enumerable: !0\n                },\n                close: {\n                    enumerable: !0\n                },\n                getWriter: {\n                    enumerable: !0\n                },\n                locked: {\n                    enumerable: !0\n                }\n            }), w(pe.prototype.abort, \"abort\"), w(pe.prototype.close, \"close\"), w(pe.prototype.getWriter, \"getWriter\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(pe.prototype, Symbol.toStringTag, {\n                value: \"WritableStream\",\n                configurable: !0\n            });\n            function Nn(n) {\n                return new se(n);\n            }\n            u(Nn, \"AcquireWritableStreamDefaultWriter\");\n            function fi(n, o, a, p, g = 1, _ = ()=>1) {\n                const S = Object.create(pe.prototype);\n                Hn(S);\n                const C = Object.create(Be.prototype);\n                return Jn(S, C, n, o, a, p, g, _), S;\n            }\n            u(fi, \"CreateWritableStream\");\n            function Hn(n) {\n                n._state = \"writable\", n._storedError = void 0, n._writer = void 0, n._writableStreamController = void 0, n._writeRequests = new Q, n._inFlightWriteRequest = void 0, n._closeRequest = void 0, n._inFlightCloseRequest = void 0, n._pendingAbortRequest = void 0, n._backpressure = !1;\n            }\n            u(Hn, \"InitializeWritableStream\");\n            function Ve(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_writableStreamController\") ? !1 : n instanceof pe;\n            }\n            u(Ve, \"IsWritableStream\");\n            function Qe(n) {\n                return n._writer !== void 0;\n            }\n            u(Qe, \"IsWritableStreamLocked\");\n            function Ft(n, o) {\n                var a;\n                if (n._state === \"closed\" || n._state === \"errored\") return k(void 0);\n                n._writableStreamController._abortReason = o, (a = n._writableStreamController._abortController) === null || a === void 0 || a.abort(o);\n                const p = n._state;\n                if (p === \"closed\" || p === \"errored\") return k(void 0);\n                if (n._pendingAbortRequest !== void 0) return n._pendingAbortRequest._promise;\n                let g = !1;\n                p === \"erroring\" && (g = !0, o = void 0);\n                const _ = F((S, C)=>{\n                    n._pendingAbortRequest = {\n                        _promise: void 0,\n                        _resolve: S,\n                        _reject: C,\n                        _reason: o,\n                        _wasAlreadyErroring: g\n                    };\n                });\n                return n._pendingAbortRequest._promise = _, g || Pr(n, o), _;\n            }\n            u(Ft, \"WritableStreamAbort\");\n            function Vn(n) {\n                const o = n._state;\n                if (o === \"closed\" || o === \"errored\") return T(new TypeError(`The stream (in ${o} state) is not in the writable state and cannot be closed`));\n                const a = F((g, _)=>{\n                    const S = {\n                        _resolve: g,\n                        _reject: _\n                    };\n                    n._closeRequest = S;\n                }), p = n._writer;\n                return p !== void 0 && n._backpressure && o === \"writable\" && Or(p), Ci(n._writableStreamController), a;\n            }\n            u(Vn, \"WritableStreamClose\");\n            function ci(n) {\n                return F((a, p)=>{\n                    const g = {\n                        _resolve: a,\n                        _reject: p\n                    };\n                    n._writeRequests.push(g);\n                });\n            }\n            u(ci, \"WritableStreamAddWriteRequest\");\n            function Cr(n, o) {\n                if (n._state === \"writable\") {\n                    Pr(n, o);\n                    return;\n                }\n                vr(n);\n            }\n            u(Cr, \"WritableStreamDealWithRejection\");\n            function Pr(n, o) {\n                const a = n._writableStreamController;\n                n._state = \"erroring\", n._storedError = o;\n                const p = n._writer;\n                p !== void 0 && Gn(p, o), !mi(n) && a._started && vr(n);\n            }\n            u(Pr, \"WritableStreamStartErroring\");\n            function vr(n) {\n                n._state = \"errored\", n._writableStreamController[un]();\n                const o = n._storedError;\n                if (n._writeRequests.forEach((g)=>{\n                    g._reject(o);\n                }), n._writeRequests = new Q, n._pendingAbortRequest === void 0) {\n                    It(n);\n                    return;\n                }\n                const a = n._pendingAbortRequest;\n                if (n._pendingAbortRequest = void 0, a._wasAlreadyErroring) {\n                    a._reject(o), It(n);\n                    return;\n                }\n                const p = n._writableStreamController[wt](a._reason);\n                E(p, ()=>(a._resolve(), It(n), null), (g)=>(a._reject(g), It(n), null));\n            }\n            u(vr, \"WritableStreamFinishErroring\");\n            function di(n) {\n                n._inFlightWriteRequest._resolve(void 0), n._inFlightWriteRequest = void 0;\n            }\n            u(di, \"WritableStreamFinishInFlightWrite\");\n            function hi(n, o) {\n                n._inFlightWriteRequest._reject(o), n._inFlightWriteRequest = void 0, Cr(n, o);\n            }\n            u(hi, \"WritableStreamFinishInFlightWriteWithError\");\n            function pi(n) {\n                n._inFlightCloseRequest._resolve(void 0), n._inFlightCloseRequest = void 0, n._state === \"erroring\" && (n._storedError = void 0, n._pendingAbortRequest !== void 0 && (n._pendingAbortRequest._resolve(), n._pendingAbortRequest = void 0)), n._state = \"closed\";\n                const a = n._writer;\n                a !== void 0 && ro(a);\n            }\n            u(pi, \"WritableStreamFinishInFlightClose\");\n            function bi(n, o) {\n                n._inFlightCloseRequest._reject(o), n._inFlightCloseRequest = void 0, n._pendingAbortRequest !== void 0 && (n._pendingAbortRequest._reject(o), n._pendingAbortRequest = void 0), Cr(n, o);\n            }\n            u(bi, \"WritableStreamFinishInFlightCloseWithError\");\n            function be(n) {\n                return !(n._closeRequest === void 0 && n._inFlightCloseRequest === void 0);\n            }\n            u(be, \"WritableStreamCloseQueuedOrInFlight\");\n            function mi(n) {\n                return !(n._inFlightWriteRequest === void 0 && n._inFlightCloseRequest === void 0);\n            }\n            u(mi, \"WritableStreamHasOperationMarkedInFlight\");\n            function yi(n) {\n                n._inFlightCloseRequest = n._closeRequest, n._closeRequest = void 0;\n            }\n            u(yi, \"WritableStreamMarkCloseRequestInFlight\");\n            function gi(n) {\n                n._inFlightWriteRequest = n._writeRequests.shift();\n            }\n            u(gi, \"WritableStreamMarkFirstWriteRequestInFlight\");\n            function It(n) {\n                n._closeRequest !== void 0 && (n._closeRequest._reject(n._storedError), n._closeRequest = void 0);\n                const o = n._writer;\n                o !== void 0 && kr(o, n._storedError);\n            }\n            u(It, \"WritableStreamRejectCloseAndClosedPromiseIfNeeded\");\n            function Er(n, o) {\n                const a = n._writer;\n                a !== void 0 && o !== n._backpressure && (o ? ki(a) : Or(a)), n._backpressure = o;\n            }\n            u(Er, \"WritableStreamUpdateBackpressure\");\n            const Qr = class Qr {\n                constructor(o){\n                    if (Se(o, 1, \"WritableStreamDefaultWriter\"), Un(o, \"First parameter\"), Qe(o)) throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n                    this._ownerWritableStream = o, o._writer = this;\n                    const a = o._state;\n                    if (a === \"writable\") !be(o) && o._backpressure ? Mt(this) : no(this), Dt(this);\n                    else if (a === \"erroring\") Wr(this, o._storedError), Dt(this);\n                    else if (a === \"closed\") no(this), Bi(this);\n                    else {\n                        const p = o._storedError;\n                        Wr(this, p), to(this, p);\n                    }\n                }\n                get closed() {\n                    return Ie(this) ? this._closedPromise : T(je(\"closed\"));\n                }\n                get desiredSize() {\n                    if (!Ie(this)) throw je(\"desiredSize\");\n                    if (this._ownerWritableStream === void 0) throw ct(\"desiredSize\");\n                    return Ri(this);\n                }\n                get ready() {\n                    return Ie(this) ? this._readyPromise : T(je(\"ready\"));\n                }\n                abort(o = void 0) {\n                    return Ie(this) ? this._ownerWritableStream === void 0 ? T(ct(\"abort\")) : _i(this, o) : T(je(\"abort\"));\n                }\n                close() {\n                    if (!Ie(this)) return T(je(\"close\"));\n                    const o = this._ownerWritableStream;\n                    return o === void 0 ? T(ct(\"close\")) : be(o) ? T(new TypeError(\"Cannot close an already-closing stream\")) : Qn(this);\n                }\n                releaseLock() {\n                    if (!Ie(this)) throw je(\"releaseLock\");\n                    this._ownerWritableStream !== void 0 && Yn(this);\n                }\n                write(o = void 0) {\n                    return Ie(this) ? this._ownerWritableStream === void 0 ? T(ct(\"write to\")) : Zn(this, o) : T(je(\"write\"));\n                }\n            };\n            u(Qr, \"WritableStreamDefaultWriter\");\n            let se = Qr;\n            Object.defineProperties(se.prototype, {\n                abort: {\n                    enumerable: !0\n                },\n                close: {\n                    enumerable: !0\n                },\n                releaseLock: {\n                    enumerable: !0\n                },\n                write: {\n                    enumerable: !0\n                },\n                closed: {\n                    enumerable: !0\n                },\n                desiredSize: {\n                    enumerable: !0\n                },\n                ready: {\n                    enumerable: !0\n                }\n            }), w(se.prototype.abort, \"abort\"), w(se.prototype.close, \"close\"), w(se.prototype.releaseLock, \"releaseLock\"), w(se.prototype.write, \"write\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(se.prototype, Symbol.toStringTag, {\n                value: \"WritableStreamDefaultWriter\",\n                configurable: !0\n            });\n            function Ie(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_ownerWritableStream\") ? !1 : n instanceof se;\n            }\n            u(Ie, \"IsWritableStreamDefaultWriter\");\n            function _i(n, o) {\n                const a = n._ownerWritableStream;\n                return Ft(a, o);\n            }\n            u(_i, \"WritableStreamDefaultWriterAbort\");\n            function Qn(n) {\n                const o = n._ownerWritableStream;\n                return Vn(o);\n            }\n            u(Qn, \"WritableStreamDefaultWriterClose\");\n            function Si(n) {\n                const o = n._ownerWritableStream, a = o._state;\n                return be(o) || a === \"closed\" ? k(void 0) : a === \"errored\" ? T(o._storedError) : Qn(n);\n            }\n            u(Si, \"WritableStreamDefaultWriterCloseWithErrorPropagation\");\n            function wi(n, o) {\n                n._closedPromiseState === \"pending\" ? kr(n, o) : qi(n, o);\n            }\n            u(wi, \"WritableStreamDefaultWriterEnsureClosedPromiseRejected\");\n            function Gn(n, o) {\n                n._readyPromiseState === \"pending\" ? oo(n, o) : Wi(n, o);\n            }\n            u(Gn, \"WritableStreamDefaultWriterEnsureReadyPromiseRejected\");\n            function Ri(n) {\n                const o = n._ownerWritableStream, a = o._state;\n                return a === \"errored\" || a === \"erroring\" ? null : a === \"closed\" ? 0 : Xn(o._writableStreamController);\n            }\n            u(Ri, \"WritableStreamDefaultWriterGetDesiredSize\");\n            function Yn(n) {\n                const o = n._ownerWritableStream, a = new TypeError(\"Writer was released and can no longer be used to monitor the stream's closedness\");\n                Gn(n, a), wi(n, a), o._writer = void 0, n._ownerWritableStream = void 0;\n            }\n            u(Yn, \"WritableStreamDefaultWriterRelease\");\n            function Zn(n, o) {\n                const a = n._ownerWritableStream, p = a._writableStreamController, g = Pi(p, o);\n                if (a !== n._ownerWritableStream) return T(ct(\"write to\"));\n                const _ = a._state;\n                if (_ === \"errored\") return T(a._storedError);\n                if (be(a) || _ === \"closed\") return T(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n                if (_ === \"erroring\") return T(a._storedError);\n                const S = ci(a);\n                return vi(p, o, g), S;\n            }\n            u(Zn, \"WritableStreamDefaultWriterWrite\");\n            const Kn = {}, Gr = class Gr {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                get abortReason() {\n                    if (!Ar(this)) throw qr(\"abortReason\");\n                    return this._abortReason;\n                }\n                get signal() {\n                    if (!Ar(this)) throw qr(\"signal\");\n                    if (this._abortController === void 0) throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n                    return this._abortController.signal;\n                }\n                error(o = void 0) {\n                    if (!Ar(this)) throw qr(\"error\");\n                    this._controlledWritableStream._state === \"writable\" && eo(this, o);\n                }\n                [wt](o) {\n                    const a = this._abortAlgorithm(o);\n                    return jt(this), a;\n                }\n                [un]() {\n                    Ae(this);\n                }\n            };\n            u(Gr, \"WritableStreamDefaultController\");\n            let Be = Gr;\n            Object.defineProperties(Be.prototype, {\n                abortReason: {\n                    enumerable: !0\n                },\n                signal: {\n                    enumerable: !0\n                },\n                error: {\n                    enumerable: !0\n                }\n            }), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(Be.prototype, Symbol.toStringTag, {\n                value: \"WritableStreamDefaultController\",\n                configurable: !0\n            });\n            function Ar(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_controlledWritableStream\") ? !1 : n instanceof Be;\n            }\n            u(Ar, \"IsWritableStreamDefaultController\");\n            function Jn(n, o, a, p, g, _, S, C) {\n                o._controlledWritableStream = n, n._writableStreamController = o, o._queue = void 0, o._queueTotalSize = void 0, Ae(o), o._abortReason = void 0, o._abortController = li(), o._started = !1, o._strategySizeAlgorithm = C, o._strategyHWM = S, o._writeAlgorithm = p, o._closeAlgorithm = g, o._abortAlgorithm = _;\n                const q = Br(o);\n                Er(n, q);\n                const P = a(), W = k(P);\n                E(W, ()=>(o._started = !0, Lt(o), null), (O)=>(o._started = !0, Cr(n, O), null));\n            }\n            u(Jn, \"SetUpWritableStreamDefaultController\");\n            function Ti(n, o, a, p) {\n                const g = Object.create(Be.prototype);\n                let _, S, C, q;\n                o.start !== void 0 ? _ = u(()=>o.start(g), \"startAlgorithm\") : _ = u(()=>{}, \"startAlgorithm\"), o.write !== void 0 ? S = u((P)=>o.write(P, g), \"writeAlgorithm\") : S = u(()=>k(void 0), \"writeAlgorithm\"), o.close !== void 0 ? C = u(()=>o.close(), \"closeAlgorithm\") : C = u(()=>k(void 0), \"closeAlgorithm\"), o.abort !== void 0 ? q = u((P)=>o.abort(P), \"abortAlgorithm\") : q = u(()=>k(void 0), \"abortAlgorithm\"), Jn(n, g, _, S, C, q, a, p);\n            }\n            u(Ti, \"SetUpWritableStreamDefaultControllerFromUnderlyingSink\");\n            function jt(n) {\n                n._writeAlgorithm = void 0, n._closeAlgorithm = void 0, n._abortAlgorithm = void 0, n._strategySizeAlgorithm = void 0;\n            }\n            u(jt, \"WritableStreamDefaultControllerClearAlgorithms\");\n            function Ci(n) {\n                mr(n, Kn, 0), Lt(n);\n            }\n            u(Ci, \"WritableStreamDefaultControllerClose\");\n            function Pi(n, o) {\n                try {\n                    return n._strategySizeAlgorithm(o);\n                } catch (a) {\n                    return ft(n, a), 1;\n                }\n            }\n            u(Pi, \"WritableStreamDefaultControllerGetChunkSize\");\n            function Xn(n) {\n                return n._strategyHWM - n._queueTotalSize;\n            }\n            u(Xn, \"WritableStreamDefaultControllerGetDesiredSize\");\n            function vi(n, o, a) {\n                try {\n                    mr(n, o, a);\n                } catch (g) {\n                    ft(n, g);\n                    return;\n                }\n                const p = n._controlledWritableStream;\n                if (!be(p) && p._state === \"writable\") {\n                    const g = Br(n);\n                    Er(p, g);\n                }\n                Lt(n);\n            }\n            u(vi, \"WritableStreamDefaultControllerWrite\");\n            function Lt(n) {\n                const o = n._controlledWritableStream;\n                if (!n._started || o._inFlightWriteRequest !== void 0) return;\n                if (o._state === \"erroring\") {\n                    vr(o);\n                    return;\n                }\n                if (n._queue.length === 0) return;\n                const p = Do(n);\n                p === Kn ? Ei(n) : Ai(n, p);\n            }\n            u(Lt, \"WritableStreamDefaultControllerAdvanceQueueIfNeeded\");\n            function ft(n, o) {\n                n._controlledWritableStream._state === \"writable\" && eo(n, o);\n            }\n            u(ft, \"WritableStreamDefaultControllerErrorIfNeeded\");\n            function Ei(n) {\n                const o = n._controlledWritableStream;\n                yi(o), br(n);\n                const a = n._closeAlgorithm();\n                jt(n), E(a, ()=>(pi(o), null), (p)=>(bi(o, p), null));\n            }\n            u(Ei, \"WritableStreamDefaultControllerProcessClose\");\n            function Ai(n, o) {\n                const a = n._controlledWritableStream;\n                gi(a);\n                const p = n._writeAlgorithm(o);\n                E(p, ()=>{\n                    di(a);\n                    const g = a._state;\n                    if (br(n), !be(a) && g === \"writable\") {\n                        const _ = Br(n);\n                        Er(a, _);\n                    }\n                    return Lt(n), null;\n                }, (g)=>(a._state === \"writable\" && jt(n), hi(a, g), null));\n            }\n            u(Ai, \"WritableStreamDefaultControllerProcessWrite\");\n            function Br(n) {\n                return Xn(n) <= 0;\n            }\n            u(Br, \"WritableStreamDefaultControllerGetBackpressure\");\n            function eo(n, o) {\n                const a = n._controlledWritableStream;\n                jt(n), Pr(a, o);\n            }\n            u(eo, \"WritableStreamDefaultControllerError\");\n            function $t(n) {\n                return new TypeError(`WritableStream.prototype.${n} can only be used on a WritableStream`);\n            }\n            u($t, \"streamBrandCheckException$2\");\n            function qr(n) {\n                return new TypeError(`WritableStreamDefaultController.prototype.${n} can only be used on a WritableStreamDefaultController`);\n            }\n            u(qr, \"defaultControllerBrandCheckException$2\");\n            function je(n) {\n                return new TypeError(`WritableStreamDefaultWriter.prototype.${n} can only be used on a WritableStreamDefaultWriter`);\n            }\n            u(je, \"defaultWriterBrandCheckException\");\n            function ct(n) {\n                return new TypeError(\"Cannot \" + n + \" a stream using a released writer\");\n            }\n            u(ct, \"defaultWriterLockException\");\n            function Dt(n) {\n                n._closedPromise = F((o, a)=>{\n                    n._closedPromise_resolve = o, n._closedPromise_reject = a, n._closedPromiseState = \"pending\";\n                });\n            }\n            u(Dt, \"defaultWriterClosedPromiseInitialize\");\n            function to(n, o) {\n                Dt(n), kr(n, o);\n            }\n            u(to, \"defaultWriterClosedPromiseInitializeAsRejected\");\n            function Bi(n) {\n                Dt(n), ro(n);\n            }\n            u(Bi, \"defaultWriterClosedPromiseInitializeAsResolved\");\n            function kr(n, o) {\n                n._closedPromise_reject !== void 0 && (J(n._closedPromise), n._closedPromise_reject(o), n._closedPromise_resolve = void 0, n._closedPromise_reject = void 0, n._closedPromiseState = \"rejected\");\n            }\n            u(kr, \"defaultWriterClosedPromiseReject\");\n            function qi(n, o) {\n                to(n, o);\n            }\n            u(qi, \"defaultWriterClosedPromiseResetToRejected\");\n            function ro(n) {\n                n._closedPromise_resolve !== void 0 && (n._closedPromise_resolve(void 0), n._closedPromise_resolve = void 0, n._closedPromise_reject = void 0, n._closedPromiseState = \"resolved\");\n            }\n            u(ro, \"defaultWriterClosedPromiseResolve\");\n            function Mt(n) {\n                n._readyPromise = F((o, a)=>{\n                    n._readyPromise_resolve = o, n._readyPromise_reject = a;\n                }), n._readyPromiseState = \"pending\";\n            }\n            u(Mt, \"defaultWriterReadyPromiseInitialize\");\n            function Wr(n, o) {\n                Mt(n), oo(n, o);\n            }\n            u(Wr, \"defaultWriterReadyPromiseInitializeAsRejected\");\n            function no(n) {\n                Mt(n), Or(n);\n            }\n            u(no, \"defaultWriterReadyPromiseInitializeAsResolved\");\n            function oo(n, o) {\n                n._readyPromise_reject !== void 0 && (J(n._readyPromise), n._readyPromise_reject(o), n._readyPromise_resolve = void 0, n._readyPromise_reject = void 0, n._readyPromiseState = \"rejected\");\n            }\n            u(oo, \"defaultWriterReadyPromiseReject\");\n            function ki(n) {\n                Mt(n);\n            }\n            u(ki, \"defaultWriterReadyPromiseReset\");\n            function Wi(n, o) {\n                Wr(n, o);\n            }\n            u(Wi, \"defaultWriterReadyPromiseResetToRejected\");\n            function Or(n) {\n                n._readyPromise_resolve !== void 0 && (n._readyPromise_resolve(void 0), n._readyPromise_resolve = void 0, n._readyPromise_reject = void 0, n._readyPromiseState = \"fulfilled\");\n            }\n            u(Or, \"defaultWriterReadyPromiseResolve\");\n            function Oi() {\n                if (typeof globalThis < \"u\") return globalThis;\n                if (typeof self < \"u\") return self;\n                if (typeof _commonjsHelpers.commonjsGlobal < \"u\") return _commonjsHelpers.commonjsGlobal;\n            }\n            u(Oi, \"getGlobals\");\n            const zr = Oi();\n            function zi(n) {\n                if (!(typeof n == \"function\" || typeof n == \"object\") || n.name !== \"DOMException\") return !1;\n                try {\n                    return new n, !0;\n                } catch  {\n                    return !1;\n                }\n            }\n            u(zi, \"isDOMExceptionConstructor\");\n            function Fi() {\n                const n = zr?.DOMException;\n                return zi(n) ? n : void 0;\n            }\n            u(Fi, \"getFromGlobal\");\n            function Ii() {\n                const n = u(function(a, p) {\n                    this.message = a || \"\", this.name = p || \"Error\", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n                }, \"DOMException\");\n                return w(n, \"DOMException\"), n.prototype = Object.create(Error.prototype), Object.defineProperty(n.prototype, \"constructor\", {\n                    value: n,\n                    writable: !0,\n                    configurable: !0\n                }), n;\n            }\n            u(Ii, \"createPolyfill\");\n            const ji = Fi() || Ii();\n            function io(n, o, a, p, g, _) {\n                const S = Ne(n), C = Nn(o);\n                n._disturbed = !0;\n                let q = !1, P = k(void 0);\n                return F((W, O)=>{\n                    let j;\n                    if (_ !== void 0) {\n                        if (j = u(()=>{\n                            const A = _.reason !== void 0 ? _.reason : new ji(\"Aborted\", \"AbortError\"), z = [];\n                            p || z.push(()=>o._state === \"writable\" ? Ft(o, A) : k(void 0)), g || z.push(()=>n._state === \"readable\" ? le(n, A) : k(void 0)), Z(()=>Promise.all(z.map((L)=>L())), !0, A);\n                        }, \"abortAlgorithm\"), _.aborted) {\n                            j();\n                            return;\n                        }\n                        _.addEventListener(\"abort\", j);\n                    }\n                    function fe() {\n                        return F((A, z)=>{\n                            function L(X) {\n                                X ? A() : $(et(), L, z);\n                            }\n                            u(L, \"next\"), L(!1);\n                        });\n                    }\n                    u(fe, \"pipeLoop\");\n                    function et() {\n                        return q ? k(!0) : $(C._readyPromise, ()=>F((A, z)=>{\n                                it(S, {\n                                    _chunkSteps: (L)=>{\n                                        P = $(Zn(C, L), void 0, y), A(!1);\n                                    },\n                                    _closeSteps: ()=>A(!0),\n                                    _errorSteps: z\n                                });\n                            }));\n                    }\n                    if (u(et, \"pipeStep\"), Te(n, S._closedPromise, (A)=>(p ? re(!0, A) : Z(()=>Ft(o, A), !0, A), null)), Te(o, C._closedPromise, (A)=>(g ? re(!0, A) : Z(()=>le(n, A), !0, A), null)), Y(n, S._closedPromise, ()=>(a ? re() : Z(()=>Si(C)), null)), be(o) || o._state === \"closed\") {\n                        const A = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n                        g ? re(!0, A) : Z(()=>le(n, A), !0, A);\n                    }\n                    J(fe());\n                    function We() {\n                        const A = P;\n                        return $(P, ()=>A !== P ? We() : void 0);\n                    }\n                    u(We, \"waitForWritesToFinish\");\n                    function Te(A, z, L) {\n                        A._state === \"errored\" ? L(A._storedError) : U(z, L);\n                    }\n                    u(Te, \"isOrBecomesErrored\");\n                    function Y(A, z, L) {\n                        A._state === \"closed\" ? L() : K(z, L);\n                    }\n                    u(Y, \"isOrBecomesClosed\");\n                    function Z(A, z, L) {\n                        if (q) return;\n                        q = !0, o._state === \"writable\" && !be(o) ? K(We(), X) : X();\n                        function X() {\n                            return E(A(), ()=>Ce(z, L), (tt)=>Ce(!0, tt)), null;\n                        }\n                        u(X, \"doTheRest\");\n                    }\n                    u(Z, \"shutdownWithAction\");\n                    function re(A, z) {\n                        q || (q = !0, o._state === \"writable\" && !be(o) ? K(We(), ()=>Ce(A, z)) : Ce(A, z));\n                    }\n                    u(re, \"shutdown\");\n                    function Ce(A, z) {\n                        return Yn(C), _e(S), _ !== void 0 && _.removeEventListener(\"abort\", j), A ? O(z) : W(void 0), null;\n                    }\n                    u(Ce, \"finalize\");\n                });\n            }\n            u(io, \"ReadableStreamPipeTo\");\n            const Yr = class Yr {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                get desiredSize() {\n                    if (!xt(this)) throw Nt(\"desiredSize\");\n                    return Fr(this);\n                }\n                close() {\n                    if (!xt(this)) throw Nt(\"close\");\n                    if (!Ye(this)) throw new TypeError(\"The stream is not in a state that permits close\");\n                    Le(this);\n                }\n                enqueue(o = void 0) {\n                    if (!xt(this)) throw Nt(\"enqueue\");\n                    if (!Ye(this)) throw new TypeError(\"The stream is not in a state that permits enqueue\");\n                    return Ge(this, o);\n                }\n                error(o = void 0) {\n                    if (!xt(this)) throw Nt(\"error\");\n                    ue(this, o);\n                }\n                [er](o) {\n                    Ae(this);\n                    const a = this._cancelAlgorithm(o);\n                    return Ut(this), a;\n                }\n                [tr](o) {\n                    const a = this._controlledReadableStream;\n                    if (this._queue.length > 0) {\n                        const p = br(this);\n                        this._closeRequested && this._queue.length === 0 ? (Ut(this), pt(a)) : dt(this), o._chunkSteps(p);\n                    } else bn(a, o), dt(this);\n                }\n                [rr]() {}\n            };\n            u(Yr, \"ReadableStreamDefaultController\");\n            let ae = Yr;\n            Object.defineProperties(ae.prototype, {\n                close: {\n                    enumerable: !0\n                },\n                enqueue: {\n                    enumerable: !0\n                },\n                error: {\n                    enumerable: !0\n                },\n                desiredSize: {\n                    enumerable: !0\n                }\n            }), w(ae.prototype.close, \"close\"), w(ae.prototype.enqueue, \"enqueue\"), w(ae.prototype.error, \"error\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(ae.prototype, Symbol.toStringTag, {\n                value: \"ReadableStreamDefaultController\",\n                configurable: !0\n            });\n            function xt(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_controlledReadableStream\") ? !1 : n instanceof ae;\n            }\n            u(xt, \"IsReadableStreamDefaultController\");\n            function dt(n) {\n                if (!so(n)) return;\n                if (n._pulling) {\n                    n._pullAgain = !0;\n                    return;\n                }\n                n._pulling = !0;\n                const a = n._pullAlgorithm();\n                E(a, ()=>(n._pulling = !1, n._pullAgain && (n._pullAgain = !1, dt(n)), null), (p)=>(ue(n, p), null));\n            }\n            u(dt, \"ReadableStreamDefaultControllerCallPullIfNeeded\");\n            function so(n) {\n                const o = n._controlledReadableStream;\n                return !Ye(n) || !n._started ? !1 : !!(ke(o) && Tt(o) > 0 || Fr(n) > 0);\n            }\n            u(so, \"ReadableStreamDefaultControllerShouldCallPull\");\n            function Ut(n) {\n                n._pullAlgorithm = void 0, n._cancelAlgorithm = void 0, n._strategySizeAlgorithm = void 0;\n            }\n            u(Ut, \"ReadableStreamDefaultControllerClearAlgorithms\");\n            function Le(n) {\n                if (!Ye(n)) return;\n                const o = n._controlledReadableStream;\n                n._closeRequested = !0, n._queue.length === 0 && (Ut(n), pt(o));\n            }\n            u(Le, \"ReadableStreamDefaultControllerClose\");\n            function Ge(n, o) {\n                if (!Ye(n)) return;\n                const a = n._controlledReadableStream;\n                if (ke(a) && Tt(a) > 0) fr(a, o, !1);\n                else {\n                    let p;\n                    try {\n                        p = n._strategySizeAlgorithm(o);\n                    } catch (g) {\n                        throw ue(n, g), g;\n                    }\n                    try {\n                        mr(n, o, p);\n                    } catch (g) {\n                        throw ue(n, g), g;\n                    }\n                }\n                dt(n);\n            }\n            u(Ge, \"ReadableStreamDefaultControllerEnqueue\");\n            function ue(n, o) {\n                const a = n._controlledReadableStream;\n                a._state === \"readable\" && (Ae(n), Ut(n), fo(a, o));\n            }\n            u(ue, \"ReadableStreamDefaultControllerError\");\n            function Fr(n) {\n                const o = n._controlledReadableStream._state;\n                return o === \"errored\" ? null : o === \"closed\" ? 0 : n._strategyHWM - n._queueTotalSize;\n            }\n            u(Fr, \"ReadableStreamDefaultControllerGetDesiredSize\");\n            function Li(n) {\n                return !so(n);\n            }\n            u(Li, \"ReadableStreamDefaultControllerHasBackpressure\");\n            function Ye(n) {\n                const o = n._controlledReadableStream._state;\n                return !n._closeRequested && o === \"readable\";\n            }\n            u(Ye, \"ReadableStreamDefaultControllerCanCloseOrEnqueue\");\n            function ao(n, o, a, p, g, _, S) {\n                o._controlledReadableStream = n, o._queue = void 0, o._queueTotalSize = void 0, Ae(o), o._started = !1, o._closeRequested = !1, o._pullAgain = !1, o._pulling = !1, o._strategySizeAlgorithm = S, o._strategyHWM = _, o._pullAlgorithm = p, o._cancelAlgorithm = g, n._readableStreamController = o;\n                const C = a();\n                E(k(C), ()=>(o._started = !0, dt(o), null), (q)=>(ue(o, q), null));\n            }\n            u(ao, \"SetUpReadableStreamDefaultController\");\n            function $i(n, o, a, p) {\n                const g = Object.create(ae.prototype);\n                let _, S, C;\n                o.start !== void 0 ? _ = u(()=>o.start(g), \"startAlgorithm\") : _ = u(()=>{}, \"startAlgorithm\"), o.pull !== void 0 ? S = u(()=>o.pull(g), \"pullAlgorithm\") : S = u(()=>k(void 0), \"pullAlgorithm\"), o.cancel !== void 0 ? C = u((q)=>o.cancel(q), \"cancelAlgorithm\") : C = u(()=>k(void 0), \"cancelAlgorithm\"), ao(n, g, _, S, C, a, p);\n            }\n            u($i, \"SetUpReadableStreamDefaultControllerFromUnderlyingSource\");\n            function Nt(n) {\n                return new TypeError(`ReadableStreamDefaultController.prototype.${n} can only be used on a ReadableStreamDefaultController`);\n            }\n            u(Nt, \"defaultControllerBrandCheckException$1\");\n            function Di(n, o) {\n                return Oe(n._readableStreamController) ? xi(n) : Mi(n);\n            }\n            u(Di, \"ReadableStreamTee\");\n            function Mi(n, o) {\n                const a = Ne(n);\n                let p = !1, g = !1, _ = !1, S = !1, C, q, P, W, O;\n                const j = F((Y)=>{\n                    O = Y;\n                });\n                function fe() {\n                    return p ? (g = !0, k(void 0)) : (p = !0, it(a, {\n                        _chunkSteps: (Z)=>{\n                            ge(()=>{\n                                g = !1;\n                                const re = Z, Ce = Z;\n                                _ || Ge(P._readableStreamController, re), S || Ge(W._readableStreamController, Ce), p = !1, g && fe();\n                            });\n                        },\n                        _closeSteps: ()=>{\n                            p = !1, _ || Le(P._readableStreamController), S || Le(W._readableStreamController), (!_ || !S) && O(void 0);\n                        },\n                        _errorSteps: ()=>{\n                            p = !1;\n                        }\n                    }), k(void 0));\n                }\n                u(fe, \"pullAlgorithm\");\n                function et(Y) {\n                    if (_ = !0, C = Y, S) {\n                        const Z = st([\n                            C,\n                            q\n                        ]), re = le(n, Z);\n                        O(re);\n                    }\n                    return j;\n                }\n                u(et, \"cancel1Algorithm\");\n                function We(Y) {\n                    if (S = !0, q = Y, _) {\n                        const Z = st([\n                            C,\n                            q\n                        ]), re = le(n, Z);\n                        O(re);\n                    }\n                    return j;\n                }\n                u(We, \"cancel2Algorithm\");\n                function Te() {}\n                return u(Te, \"startAlgorithm\"), P = ht(Te, fe, et), W = ht(Te, fe, We), U(a._closedPromise, (Y)=>(ue(P._readableStreamController, Y), ue(W._readableStreamController, Y), (!_ || !S) && O(void 0), null)), [\n                    P,\n                    W\n                ];\n            }\n            u(Mi, \"ReadableStreamDefaultTee\");\n            function xi(n) {\n                let o = Ne(n), a = !1, p = !1, g = !1, _ = !1, S = !1, C, q, P, W, O;\n                const j = F((A)=>{\n                    O = A;\n                });\n                function fe(A) {\n                    U(A._closedPromise, (z)=>(A !== o || (te(P._readableStreamController, z), te(W._readableStreamController, z), (!_ || !S) && O(void 0)), null));\n                }\n                u(fe, \"forwardReaderError\");\n                function et() {\n                    Fe(o) && (_e(o), o = Ne(n), fe(o)), it(o, {\n                        _chunkSteps: (z)=>{\n                            ge(()=>{\n                                p = !1, g = !1;\n                                const L = z;\n                                let X = z;\n                                if (!_ && !S) try {\n                                    X = Pn(z);\n                                } catch (tt) {\n                                    te(P._readableStreamController, tt), te(W._readableStreamController, tt), O(le(n, tt));\n                                    return;\n                                }\n                                _ || Bt(P._readableStreamController, L), S || Bt(W._readableStreamController, X), a = !1, p ? Te() : g && Y();\n                            });\n                        },\n                        _closeSteps: ()=>{\n                            a = !1, _ || at(P._readableStreamController), S || at(W._readableStreamController), P._readableStreamController._pendingPullIntos.length > 0 && qt(P._readableStreamController, 0), W._readableStreamController._pendingPullIntos.length > 0 && qt(W._readableStreamController, 0), (!_ || !S) && O(void 0);\n                        },\n                        _errorSteps: ()=>{\n                            a = !1;\n                        }\n                    });\n                }\n                u(et, \"pullWithDefaultReader\");\n                function We(A, z) {\n                    ve(o) && (_e(o), o = Ln(n), fe(o));\n                    const L = z ? W : P, X = z ? P : W;\n                    Mn(o, A, 1, {\n                        _chunkSteps: (rt)=>{\n                            ge(()=>{\n                                p = !1, g = !1;\n                                const nt = z ? S : _;\n                                if (z ? _ : S) nt || kt(L._readableStreamController, rt);\n                                else {\n                                    let Co;\n                                    try {\n                                        Co = Pn(rt);\n                                    } catch (tn) {\n                                        te(L._readableStreamController, tn), te(X._readableStreamController, tn), O(le(n, tn));\n                                        return;\n                                    }\n                                    nt || kt(L._readableStreamController, rt), Bt(X._readableStreamController, Co);\n                                }\n                                a = !1, p ? Te() : g && Y();\n                            });\n                        },\n                        _closeSteps: (rt)=>{\n                            a = !1;\n                            const nt = z ? S : _, Yt = z ? _ : S;\n                            nt || at(L._readableStreamController), Yt || at(X._readableStreamController), rt !== void 0 && (nt || kt(L._readableStreamController, rt), !Yt && X._readableStreamController._pendingPullIntos.length > 0 && qt(X._readableStreamController, 0)), (!nt || !Yt) && O(void 0);\n                        },\n                        _errorSteps: ()=>{\n                            a = !1;\n                        }\n                    });\n                }\n                u(We, \"pullWithBYOBReader\");\n                function Te() {\n                    if (a) return p = !0, k(void 0);\n                    a = !0;\n                    const A = wr(P._readableStreamController);\n                    return A === null ? et() : We(A._view, !1), k(void 0);\n                }\n                u(Te, \"pull1Algorithm\");\n                function Y() {\n                    if (a) return g = !0, k(void 0);\n                    a = !0;\n                    const A = wr(W._readableStreamController);\n                    return A === null ? et() : We(A._view, !0), k(void 0);\n                }\n                u(Y, \"pull2Algorithm\");\n                function Z(A) {\n                    if (_ = !0, C = A, S) {\n                        const z = st([\n                            C,\n                            q\n                        ]), L = le(n, z);\n                        O(L);\n                    }\n                    return j;\n                }\n                u(Z, \"cancel1Algorithm\");\n                function re(A) {\n                    if (S = !0, q = A, _) {\n                        const z = st([\n                            C,\n                            q\n                        ]), L = le(n, z);\n                        O(L);\n                    }\n                    return j;\n                }\n                u(re, \"cancel2Algorithm\");\n                function Ce() {}\n                return u(Ce, \"startAlgorithm\"), P = lo(Ce, Te, Z), W = lo(Ce, Y, re), fe(o), [\n                    P,\n                    W\n                ];\n            }\n            u(xi, \"ReadableByteStreamTee\");\n            function Ui(n) {\n                return b(n) && typeof n.getReader < \"u\";\n            }\n            u(Ui, \"isReadableStreamLike\");\n            function Ni(n) {\n                return Ui(n) ? Vi(n.getReader()) : Hi(n);\n            }\n            u(Ni, \"ReadableStreamFrom\");\n            function Hi(n) {\n                let o;\n                const a = Cn(n, \"async\"), p = y;\n                function g() {\n                    let S;\n                    try {\n                        S = Io(a);\n                    } catch (q) {\n                        return T(q);\n                    }\n                    const C = k(S);\n                    return N(C, (q)=>{\n                        if (!b(q)) throw new TypeError(\"The promise returned by the iterator.next() method must fulfill with an object\");\n                        if (jo(q)) Le(o._readableStreamController);\n                        else {\n                            const W = Lo(q);\n                            Ge(o._readableStreamController, W);\n                        }\n                    });\n                }\n                u(g, \"pullAlgorithm\");\n                function _(S) {\n                    const C = a.iterator;\n                    let q;\n                    try {\n                        q = vt(C, \"return\");\n                    } catch (O) {\n                        return T(O);\n                    }\n                    if (q === void 0) return k(void 0);\n                    let P;\n                    try {\n                        P = M(q, C, [\n                            S\n                        ]);\n                    } catch (O) {\n                        return T(O);\n                    }\n                    const W = k(P);\n                    return N(W, (O)=>{\n                        if (!b(O)) throw new TypeError(\"The promise returned by the iterator.return() method must fulfill with an object\");\n                    });\n                }\n                return u(_, \"cancelAlgorithm\"), o = ht(p, g, _, 0), o;\n            }\n            u(Hi, \"ReadableStreamFromIterable\");\n            function Vi(n) {\n                let o;\n                const a = y;\n                function p() {\n                    let _;\n                    try {\n                        _ = n.read();\n                    } catch (S) {\n                        return T(S);\n                    }\n                    return N(_, (S)=>{\n                        if (!b(S)) throw new TypeError(\"The promise returned by the reader.read() method must fulfill with an object\");\n                        if (S.done) Le(o._readableStreamController);\n                        else {\n                            const C = S.value;\n                            Ge(o._readableStreamController, C);\n                        }\n                    });\n                }\n                u(p, \"pullAlgorithm\");\n                function g(_) {\n                    try {\n                        return k(n.cancel(_));\n                    } catch (S) {\n                        return T(S);\n                    }\n                }\n                return u(g, \"cancelAlgorithm\"), o = ht(a, p, g, 0), o;\n            }\n            u(Vi, \"ReadableStreamFromDefaultReader\");\n            function Qi(n, o) {\n                ce(n, o);\n                const a = n, p = a?.autoAllocateChunkSize, g = a?.cancel, _ = a?.pull, S = a?.start, C = a?.type;\n                return {\n                    autoAllocateChunkSize: p === void 0 ? void 0 : ur(p, `${o} has member 'autoAllocateChunkSize' that`),\n                    cancel: g === void 0 ? void 0 : Gi(g, a, `${o} has member 'cancel' that`),\n                    pull: _ === void 0 ? void 0 : Yi(_, a, `${o} has member 'pull' that`),\n                    start: S === void 0 ? void 0 : Zi(S, a, `${o} has member 'start' that`),\n                    type: C === void 0 ? void 0 : Ki(C, `${o} has member 'type' that`)\n                };\n            }\n            u(Qi, \"convertUnderlyingDefaultOrByteSource\");\n            function Gi(n, o, a) {\n                return ee(n, a), (p)=>H(n, o, [\n                        p\n                    ]);\n            }\n            u(Gi, \"convertUnderlyingSourceCancelCallback\");\n            function Yi(n, o, a) {\n                return ee(n, a), (p)=>H(n, o, [\n                        p\n                    ]);\n            }\n            u(Yi, \"convertUnderlyingSourcePullCallback\");\n            function Zi(n, o, a) {\n                return ee(n, a), (p)=>M(n, o, [\n                        p\n                    ]);\n            }\n            u(Zi, \"convertUnderlyingSourceStartCallback\");\n            function Ki(n, o) {\n                if (n = `${n}`, n !== \"bytes\") throw new TypeError(`${o} '${n}' is not a valid enumeration value for ReadableStreamType`);\n                return n;\n            }\n            u(Ki, \"convertReadableStreamType\");\n            function Ji(n, o) {\n                return ce(n, o), {\n                    preventCancel: !!n?.preventCancel\n                };\n            }\n            u(Ji, \"convertIteratorOptions\");\n            function uo(n, o) {\n                ce(n, o);\n                const a = n?.preventAbort, p = n?.preventCancel, g = n?.preventClose, _ = n?.signal;\n                return _ !== void 0 && Xi(_, `${o} has member 'signal' that`), {\n                    preventAbort: !!a,\n                    preventCancel: !!p,\n                    preventClose: !!g,\n                    signal: _\n                };\n            }\n            u(uo, \"convertPipeOptions\");\n            function Xi(n, o) {\n                if (!ai(n)) throw new TypeError(`${o} is not an AbortSignal.`);\n            }\n            u(Xi, \"assertAbortSignal\");\n            function es(n, o) {\n                ce(n, o);\n                const a = n?.readable;\n                sr(a, \"readable\", \"ReadableWritablePair\"), lr(a, `${o} has member 'readable' that`);\n                const p = n?.writable;\n                return sr(p, \"writable\", \"ReadableWritablePair\"), Un(p, `${o} has member 'writable' that`), {\n                    readable: a,\n                    writable: p\n                };\n            }\n            u(es, \"convertReadableWritablePair\");\n            const Zr = class Zr {\n                constructor(o = {}, a = {}){\n                    o === void 0 ? o = null : hn(o, \"First parameter\");\n                    const p = zt(a, \"Second parameter\"), g = Qi(o, \"First parameter\");\n                    if (Ir(this), g.type === \"bytes\") {\n                        if (p.size !== void 0) throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n                        const _ = lt(p, 0);\n                        Go(this, g, _);\n                    } else {\n                        const _ = Ot(p), S = lt(p, 1);\n                        $i(this, g, S, _);\n                    }\n                }\n                get locked() {\n                    if (!qe(this)) throw $e(\"locked\");\n                    return ke(this);\n                }\n                cancel(o = void 0) {\n                    return qe(this) ? ke(this) ? T(new TypeError(\"Cannot cancel a stream that already has a reader\")) : le(this, o) : T($e(\"cancel\"));\n                }\n                getReader(o = void 0) {\n                    if (!qe(this)) throw $e(\"getReader\");\n                    return Zo(o, \"First parameter\").mode === void 0 ? Ne(this) : Ln(this);\n                }\n                pipeThrough(o, a = {}) {\n                    if (!qe(this)) throw $e(\"pipeThrough\");\n                    Se(o, 1, \"pipeThrough\");\n                    const p = es(o, \"First parameter\"), g = uo(a, \"Second parameter\");\n                    if (ke(this)) throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n                    if (Qe(p.writable)) throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n                    const _ = io(this, p.writable, g.preventClose, g.preventAbort, g.preventCancel, g.signal);\n                    return J(_), p.readable;\n                }\n                pipeTo(o, a = {}) {\n                    if (!qe(this)) return T($e(\"pipeTo\"));\n                    if (o === void 0) return T(\"Parameter 1 is required in 'pipeTo'.\");\n                    if (!Ve(o)) return T(new TypeError(\"ReadableStream.prototype.pipeTo's first argument must be a WritableStream\"));\n                    let p;\n                    try {\n                        p = uo(a, \"Second parameter\");\n                    } catch (g) {\n                        return T(g);\n                    }\n                    return ke(this) ? T(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\")) : Qe(o) ? T(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\")) : io(this, o, p.preventClose, p.preventAbort, p.preventCancel, p.signal);\n                }\n                tee() {\n                    if (!qe(this)) throw $e(\"tee\");\n                    const o = Di(this);\n                    return st(o);\n                }\n                values(o = void 0) {\n                    if (!qe(this)) throw $e(\"values\");\n                    const a = Ji(o, \"First parameter\");\n                    return zo(this, a.preventCancel);\n                }\n                [pr](o) {\n                    return this.values(o);\n                }\n                static from(o) {\n                    return Ni(o);\n                }\n            };\n            u(Zr, \"ReadableStream\");\n            let V = Zr;\n            Object.defineProperties(V, {\n                from: {\n                    enumerable: !0\n                }\n            }), Object.defineProperties(V.prototype, {\n                cancel: {\n                    enumerable: !0\n                },\n                getReader: {\n                    enumerable: !0\n                },\n                pipeThrough: {\n                    enumerable: !0\n                },\n                pipeTo: {\n                    enumerable: !0\n                },\n                tee: {\n                    enumerable: !0\n                },\n                values: {\n                    enumerable: !0\n                },\n                locked: {\n                    enumerable: !0\n                }\n            }), w(V.from, \"from\"), w(V.prototype.cancel, \"cancel\"), w(V.prototype.getReader, \"getReader\"), w(V.prototype.pipeThrough, \"pipeThrough\"), w(V.prototype.pipeTo, \"pipeTo\"), w(V.prototype.tee, \"tee\"), w(V.prototype.values, \"values\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(V.prototype, Symbol.toStringTag, {\n                value: \"ReadableStream\",\n                configurable: !0\n            }), Object.defineProperty(V.prototype, pr, {\n                value: V.prototype.values,\n                writable: !0,\n                configurable: !0\n            });\n            function ht(n, o, a, p = 1, g = ()=>1) {\n                const _ = Object.create(V.prototype);\n                Ir(_);\n                const S = Object.create(ae.prototype);\n                return ao(_, S, n, o, a, p, g), _;\n            }\n            u(ht, \"CreateReadableStream\");\n            function lo(n, o, a) {\n                const p = Object.create(V.prototype);\n                Ir(p);\n                const g = Object.create(ie.prototype);\n                return jn(p, g, n, o, a, 0, void 0), p;\n            }\n            u(lo, \"CreateReadableByteStream\");\n            function Ir(n) {\n                n._state = \"readable\", n._reader = void 0, n._storedError = void 0, n._disturbed = !1;\n            }\n            u(Ir, \"InitializeReadableStream\");\n            function qe(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_readableStreamController\") ? !1 : n instanceof V;\n            }\n            u(qe, \"IsReadableStream\");\n            function ke(n) {\n                return n._reader !== void 0;\n            }\n            u(ke, \"IsReadableStreamLocked\");\n            function le(n, o) {\n                if (n._disturbed = !0, n._state === \"closed\") return k(void 0);\n                if (n._state === \"errored\") return T(n._storedError);\n                pt(n);\n                const a = n._reader;\n                if (a !== void 0 && Fe(a)) {\n                    const g = a._readIntoRequests;\n                    a._readIntoRequests = new Q, g.forEach((_)=>{\n                        _._closeSteps(void 0);\n                    });\n                }\n                const p = n._readableStreamController[er](o);\n                return N(p, y);\n            }\n            u(le, \"ReadableStreamCancel\");\n            function pt(n) {\n                n._state = \"closed\";\n                const o = n._reader;\n                if (o !== void 0 && (cn(o), ve(o))) {\n                    const a = o._readRequests;\n                    o._readRequests = new Q, a.forEach((p)=>{\n                        p._closeSteps();\n                    });\n                }\n            }\n            u(pt, \"ReadableStreamClose\");\n            function fo(n, o) {\n                n._state = \"errored\", n._storedError = o;\n                const a = n._reader;\n                a !== void 0 && (ir(a, o), ve(a) ? yn(a, o) : xn(a, o));\n            }\n            u(fo, \"ReadableStreamError\");\n            function $e(n) {\n                return new TypeError(`ReadableStream.prototype.${n} can only be used on a ReadableStream`);\n            }\n            u($e, \"streamBrandCheckException$1\");\n            function co(n, o) {\n                ce(n, o);\n                const a = n?.highWaterMark;\n                return sr(a, \"highWaterMark\", \"QueuingStrategyInit\"), {\n                    highWaterMark: ar(a)\n                };\n            }\n            u(co, \"convertQueuingStrategyInit\");\n            const ho = u((n)=>n.byteLength, \"byteLengthSizeFunction\");\n            w(ho, \"size\");\n            const Kr = class Kr {\n                constructor(o){\n                    Se(o, 1, \"ByteLengthQueuingStrategy\"), o = co(o, \"First parameter\"), this._byteLengthQueuingStrategyHighWaterMark = o.highWaterMark;\n                }\n                get highWaterMark() {\n                    if (!bo(this)) throw po(\"highWaterMark\");\n                    return this._byteLengthQueuingStrategyHighWaterMark;\n                }\n                get size() {\n                    if (!bo(this)) throw po(\"size\");\n                    return ho;\n                }\n            };\n            u(Kr, \"ByteLengthQueuingStrategy\");\n            let Ze = Kr;\n            Object.defineProperties(Ze.prototype, {\n                highWaterMark: {\n                    enumerable: !0\n                },\n                size: {\n                    enumerable: !0\n                }\n            }), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(Ze.prototype, Symbol.toStringTag, {\n                value: \"ByteLengthQueuingStrategy\",\n                configurable: !0\n            });\n            function po(n) {\n                return new TypeError(`ByteLengthQueuingStrategy.prototype.${n} can only be used on a ByteLengthQueuingStrategy`);\n            }\n            u(po, \"byteLengthBrandCheckException\");\n            function bo(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_byteLengthQueuingStrategyHighWaterMark\") ? !1 : n instanceof Ze;\n            }\n            u(bo, \"IsByteLengthQueuingStrategy\");\n            const mo = u(()=>1, \"countSizeFunction\");\n            w(mo, \"size\");\n            const Jr = class Jr {\n                constructor(o){\n                    Se(o, 1, \"CountQueuingStrategy\"), o = co(o, \"First parameter\"), this._countQueuingStrategyHighWaterMark = o.highWaterMark;\n                }\n                get highWaterMark() {\n                    if (!go(this)) throw yo(\"highWaterMark\");\n                    return this._countQueuingStrategyHighWaterMark;\n                }\n                get size() {\n                    if (!go(this)) throw yo(\"size\");\n                    return mo;\n                }\n            };\n            u(Jr, \"CountQueuingStrategy\");\n            let Ke = Jr;\n            Object.defineProperties(Ke.prototype, {\n                highWaterMark: {\n                    enumerable: !0\n                },\n                size: {\n                    enumerable: !0\n                }\n            }), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(Ke.prototype, Symbol.toStringTag, {\n                value: \"CountQueuingStrategy\",\n                configurable: !0\n            });\n            function yo(n) {\n                return new TypeError(`CountQueuingStrategy.prototype.${n} can only be used on a CountQueuingStrategy`);\n            }\n            u(yo, \"countBrandCheckException\");\n            function go(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_countQueuingStrategyHighWaterMark\") ? !1 : n instanceof Ke;\n            }\n            u(go, \"IsCountQueuingStrategy\");\n            function ts(n, o) {\n                ce(n, o);\n                const a = n?.cancel, p = n?.flush, g = n?.readableType, _ = n?.start, S = n?.transform, C = n?.writableType;\n                return {\n                    cancel: a === void 0 ? void 0 : is(a, n, `${o} has member 'cancel' that`),\n                    flush: p === void 0 ? void 0 : rs(p, n, `${o} has member 'flush' that`),\n                    readableType: g,\n                    start: _ === void 0 ? void 0 : ns(_, n, `${o} has member 'start' that`),\n                    transform: S === void 0 ? void 0 : os(S, n, `${o} has member 'transform' that`),\n                    writableType: C\n                };\n            }\n            u(ts, \"convertTransformer\");\n            function rs(n, o, a) {\n                return ee(n, a), (p)=>H(n, o, [\n                        p\n                    ]);\n            }\n            u(rs, \"convertTransformerFlushCallback\");\n            function ns(n, o, a) {\n                return ee(n, a), (p)=>M(n, o, [\n                        p\n                    ]);\n            }\n            u(ns, \"convertTransformerStartCallback\");\n            function os(n, o, a) {\n                return ee(n, a), (p, g)=>H(n, o, [\n                        p,\n                        g\n                    ]);\n            }\n            u(os, \"convertTransformerTransformCallback\");\n            function is(n, o, a) {\n                return ee(n, a), (p)=>H(n, o, [\n                        p\n                    ]);\n            }\n            u(is, \"convertTransformerCancelCallback\");\n            const Xr = class Xr {\n                constructor(o = {}, a = {}, p = {}){\n                    o === void 0 && (o = null);\n                    const g = zt(a, \"Second parameter\"), _ = zt(p, \"Third parameter\"), S = ts(o, \"First parameter\");\n                    if (S.readableType !== void 0) throw new RangeError(\"Invalid readableType specified\");\n                    if (S.writableType !== void 0) throw new RangeError(\"Invalid writableType specified\");\n                    const C = lt(_, 0), q = Ot(_), P = lt(g, 1), W = Ot(g);\n                    let O;\n                    const j = F((fe)=>{\n                        O = fe;\n                    });\n                    ss(this, j, P, W, C, q), us(this, S), S.start !== void 0 ? O(S.start(this._transformStreamController)) : O(void 0);\n                }\n                get readable() {\n                    if (!_o(this)) throw To(\"readable\");\n                    return this._readable;\n                }\n                get writable() {\n                    if (!_o(this)) throw To(\"writable\");\n                    return this._writable;\n                }\n            };\n            u(Xr, \"TransformStream\");\n            let Je = Xr;\n            Object.defineProperties(Je.prototype, {\n                readable: {\n                    enumerable: !0\n                },\n                writable: {\n                    enumerable: !0\n                }\n            }), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(Je.prototype, Symbol.toStringTag, {\n                value: \"TransformStream\",\n                configurable: !0\n            });\n            function ss(n, o, a, p, g, _) {\n                function S() {\n                    return o;\n                }\n                u(S, \"startAlgorithm\");\n                function C(j) {\n                    return cs(n, j);\n                }\n                u(C, \"writeAlgorithm\");\n                function q(j) {\n                    return ds(n, j);\n                }\n                u(q, \"abortAlgorithm\");\n                function P() {\n                    return hs(n);\n                }\n                u(P, \"closeAlgorithm\"), n._writable = fi(S, C, P, q, a, p);\n                function W() {\n                    return ps(n);\n                }\n                u(W, \"pullAlgorithm\");\n                function O(j) {\n                    return bs(n, j);\n                }\n                u(O, \"cancelAlgorithm\"), n._readable = ht(S, W, O, g, _), n._backpressure = void 0, n._backpressureChangePromise = void 0, n._backpressureChangePromise_resolve = void 0, Ht(n, !0), n._transformStreamController = void 0;\n            }\n            u(ss, \"InitializeTransformStream\");\n            function _o(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_transformStreamController\") ? !1 : n instanceof Je;\n            }\n            u(_o, \"IsTransformStream\");\n            function So(n, o) {\n                ue(n._readable._readableStreamController, o), jr(n, o);\n            }\n            u(So, \"TransformStreamError\");\n            function jr(n, o) {\n                Qt(n._transformStreamController), ft(n._writable._writableStreamController, o), Lr(n);\n            }\n            u(jr, \"TransformStreamErrorWritableAndUnblockWrite\");\n            function Lr(n) {\n                n._backpressure && Ht(n, !1);\n            }\n            u(Lr, \"TransformStreamUnblockWrite\");\n            function Ht(n, o) {\n                n._backpressureChangePromise !== void 0 && n._backpressureChangePromise_resolve(), n._backpressureChangePromise = F((a)=>{\n                    n._backpressureChangePromise_resolve = a;\n                }), n._backpressure = o;\n            }\n            u(Ht, \"TransformStreamSetBackpressure\");\n            const en = class en {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                get desiredSize() {\n                    if (!Vt(this)) throw Gt(\"desiredSize\");\n                    const o = this._controlledTransformStream._readable._readableStreamController;\n                    return Fr(o);\n                }\n                enqueue(o = void 0) {\n                    if (!Vt(this)) throw Gt(\"enqueue\");\n                    wo(this, o);\n                }\n                error(o = void 0) {\n                    if (!Vt(this)) throw Gt(\"error\");\n                    ls(this, o);\n                }\n                terminate() {\n                    if (!Vt(this)) throw Gt(\"terminate\");\n                    fs(this);\n                }\n            };\n            u(en, \"TransformStreamDefaultController\");\n            let me = en;\n            Object.defineProperties(me.prototype, {\n                enqueue: {\n                    enumerable: !0\n                },\n                error: {\n                    enumerable: !0\n                },\n                terminate: {\n                    enumerable: !0\n                },\n                desiredSize: {\n                    enumerable: !0\n                }\n            }), w(me.prototype.enqueue, \"enqueue\"), w(me.prototype.error, \"error\"), w(me.prototype.terminate, \"terminate\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(me.prototype, Symbol.toStringTag, {\n                value: \"TransformStreamDefaultController\",\n                configurable: !0\n            });\n            function Vt(n) {\n                return !b(n) || !Object.prototype.hasOwnProperty.call(n, \"_controlledTransformStream\") ? !1 : n instanceof me;\n            }\n            u(Vt, \"IsTransformStreamDefaultController\");\n            function as(n, o, a, p, g) {\n                o._controlledTransformStream = n, n._transformStreamController = o, o._transformAlgorithm = a, o._flushAlgorithm = p, o._cancelAlgorithm = g, o._finishPromise = void 0, o._finishPromise_resolve = void 0, o._finishPromise_reject = void 0;\n            }\n            u(as, \"SetUpTransformStreamDefaultController\");\n            function us(n, o) {\n                const a = Object.create(me.prototype);\n                let p, g, _;\n                o.transform !== void 0 ? p = u((S)=>o.transform(S, a), \"transformAlgorithm\") : p = u((S)=>{\n                    try {\n                        return wo(a, S), k(void 0);\n                    } catch (C) {\n                        return T(C);\n                    }\n                }, \"transformAlgorithm\"), o.flush !== void 0 ? g = u(()=>o.flush(a), \"flushAlgorithm\") : g = u(()=>k(void 0), \"flushAlgorithm\"), o.cancel !== void 0 ? _ = u((S)=>o.cancel(S), \"cancelAlgorithm\") : _ = u(()=>k(void 0), \"cancelAlgorithm\"), as(n, a, p, g, _);\n            }\n            u(us, \"SetUpTransformStreamDefaultControllerFromTransformer\");\n            function Qt(n) {\n                n._transformAlgorithm = void 0, n._flushAlgorithm = void 0, n._cancelAlgorithm = void 0;\n            }\n            u(Qt, \"TransformStreamDefaultControllerClearAlgorithms\");\n            function wo(n, o) {\n                const a = n._controlledTransformStream, p = a._readable._readableStreamController;\n                if (!Ye(p)) throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n                try {\n                    Ge(p, o);\n                } catch (_) {\n                    throw jr(a, _), a._readable._storedError;\n                }\n                Li(p) !== a._backpressure && Ht(a, !0);\n            }\n            u(wo, \"TransformStreamDefaultControllerEnqueue\");\n            function ls(n, o) {\n                So(n._controlledTransformStream, o);\n            }\n            u(ls, \"TransformStreamDefaultControllerError\");\n            function Ro(n, o) {\n                const a = n._transformAlgorithm(o);\n                return N(a, void 0, (p)=>{\n                    throw So(n._controlledTransformStream, p), p;\n                });\n            }\n            u(Ro, \"TransformStreamDefaultControllerPerformTransform\");\n            function fs(n) {\n                const o = n._controlledTransformStream, a = o._readable._readableStreamController;\n                Le(a);\n                const p = new TypeError(\"TransformStream terminated\");\n                jr(o, p);\n            }\n            u(fs, \"TransformStreamDefaultControllerTerminate\");\n            function cs(n, o) {\n                const a = n._transformStreamController;\n                if (n._backpressure) {\n                    const p = n._backpressureChangePromise;\n                    return N(p, ()=>{\n                        const g = n._writable;\n                        if (g._state === \"erroring\") throw g._storedError;\n                        return Ro(a, o);\n                    });\n                }\n                return Ro(a, o);\n            }\n            u(cs, \"TransformStreamDefaultSinkWriteAlgorithm\");\n            function ds(n, o) {\n                const a = n._transformStreamController;\n                if (a._finishPromise !== void 0) return a._finishPromise;\n                const p = n._readable;\n                a._finishPromise = F((_, S)=>{\n                    a._finishPromise_resolve = _, a._finishPromise_reject = S;\n                });\n                const g = a._cancelAlgorithm(o);\n                return Qt(a), E(g, ()=>(p._state === \"errored\" ? Xe(a, p._storedError) : (ue(p._readableStreamController, o), $r(a)), null), (_)=>(ue(p._readableStreamController, _), Xe(a, _), null)), a._finishPromise;\n            }\n            u(ds, \"TransformStreamDefaultSinkAbortAlgorithm\");\n            function hs(n) {\n                const o = n._transformStreamController;\n                if (o._finishPromise !== void 0) return o._finishPromise;\n                const a = n._readable;\n                o._finishPromise = F((g, _)=>{\n                    o._finishPromise_resolve = g, o._finishPromise_reject = _;\n                });\n                const p = o._flushAlgorithm();\n                return Qt(o), E(p, ()=>(a._state === \"errored\" ? Xe(o, a._storedError) : (Le(a._readableStreamController), $r(o)), null), (g)=>(ue(a._readableStreamController, g), Xe(o, g), null)), o._finishPromise;\n            }\n            u(hs, \"TransformStreamDefaultSinkCloseAlgorithm\");\n            function ps(n) {\n                return Ht(n, !1), n._backpressureChangePromise;\n            }\n            u(ps, \"TransformStreamDefaultSourcePullAlgorithm\");\n            function bs(n, o) {\n                const a = n._transformStreamController;\n                if (a._finishPromise !== void 0) return a._finishPromise;\n                const p = n._writable;\n                a._finishPromise = F((_, S)=>{\n                    a._finishPromise_resolve = _, a._finishPromise_reject = S;\n                });\n                const g = a._cancelAlgorithm(o);\n                return Qt(a), E(g, ()=>(p._state === \"errored\" ? Xe(a, p._storedError) : (ft(p._writableStreamController, o), Lr(n), $r(a)), null), (_)=>(ft(p._writableStreamController, _), Lr(n), Xe(a, _), null)), a._finishPromise;\n            }\n            u(bs, \"TransformStreamDefaultSourceCancelAlgorithm\");\n            function Gt(n) {\n                return new TypeError(`TransformStreamDefaultController.prototype.${n} can only be used on a TransformStreamDefaultController`);\n            }\n            u(Gt, \"defaultControllerBrandCheckException\");\n            function $r(n) {\n                n._finishPromise_resolve !== void 0 && (n._finishPromise_resolve(), n._finishPromise_resolve = void 0, n._finishPromise_reject = void 0);\n            }\n            u($r, \"defaultControllerFinishPromiseResolve\");\n            function Xe(n, o) {\n                n._finishPromise_reject !== void 0 && (J(n._finishPromise), n._finishPromise_reject(o), n._finishPromise_resolve = void 0, n._finishPromise_reject = void 0);\n            }\n            u(Xe, \"defaultControllerFinishPromiseReject\");\n            function To(n) {\n                return new TypeError(`TransformStream.prototype.${n} can only be used on a TransformStream`);\n            }\n            u(To, \"streamBrandCheckException\"), d.ByteLengthQueuingStrategy = Ze, d.CountQueuingStrategy = Ke, d.ReadableByteStreamController = ie, d.ReadableStream = V, d.ReadableStreamBYOBReader = he, d.ReadableStreamBYOBRequest = Re, d.ReadableStreamDefaultController = ae, d.ReadableStreamDefaultReader = de, d.TransformStream = Je, d.TransformStreamDefaultController = me, d.WritableStream = pe, d.WritableStreamDefaultController = Be, d.WritableStreamDefaultWriter = se;\n        });\n    }(ponyfill_es2018, ponyfill_es2018.exports)), ponyfill_es2018.exports;\n}\nu(requirePonyfill_es2018, \"requirePonyfill_es2018\");\nconst POOL_SIZE$1 = 65536;\nif (!globalThis.ReadableStream) try {\n    const c1 = __webpack_require__(/*! node:process */ \"node:process\"), { emitWarning: l } = c1;\n    try {\n        c1.emitWarning = ()=>{}, Object.assign(globalThis, __webpack_require__(/*! node:stream/web */ \"node:stream/web\")), c1.emitWarning = l;\n    } catch (d) {\n        throw c1.emitWarning = l, d;\n    }\n} catch  {\n    Object.assign(globalThis, requirePonyfill_es2018());\n}\ntry {\n    const { Blob: c1 } = __webpack_require__(/*! buffer */ \"buffer\");\n    c1 && !c1.prototype.stream && (c1.prototype.stream = u(function(d) {\n        let y = 0;\n        const b = this;\n        return new ReadableStream({\n            type: \"bytes\",\n            async pull (R) {\n                const v = await b.slice(y, Math.min(b.size, y + POOL_SIZE$1)).arrayBuffer();\n                y += v.byteLength, R.enqueue(new Uint8Array(v)), y === b.size && R.close();\n            }\n        });\n    }, \"name\"));\n} catch  {} /*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ \nconst POOL_SIZE = 65536;\nasync function* toIterator(c1, l = !0) {\n    for (const d of c1)if (\"stream\" in d) yield* d.stream();\n    else if (ArrayBuffer.isView(d)) if (l) {\n        let y = d.byteOffset;\n        const b = d.byteOffset + d.byteLength;\n        for(; y !== b;){\n            const R = Math.min(b - y, POOL_SIZE), w = d.buffer.slice(y, y + R);\n            y += w.byteLength, yield new Uint8Array(w);\n        }\n    } else yield d;\n    else {\n        let y = 0, b = d;\n        for(; y !== b.size;){\n            const w = await b.slice(y, Math.min(b.size, y + POOL_SIZE)).arrayBuffer();\n            y += w.byteLength, yield new Uint8Array(w);\n        }\n    }\n}\nu(toIterator, \"toIterator\");\nconst _Blob = (Ue = class {\n    constructor(l = [], d = {}){\n        ye(this, Pe, []);\n        ye(this, bt, \"\");\n        ye(this, ot, 0);\n        ye(this, Zt, \"transparent\");\n        if (typeof l != \"object\" || l === null) throw new TypeError(\"Failed to construct 'Blob': The provided value cannot be converted to a sequence.\");\n        if (typeof l[Symbol.iterator] != \"function\") throw new TypeError(\"Failed to construct 'Blob': The object must have a callable @@iterator property.\");\n        if (typeof d != \"object\" && typeof d != \"function\") throw new TypeError(\"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\");\n        d === null && (d = {});\n        const y = new TextEncoder;\n        for (const R of l){\n            let w;\n            ArrayBuffer.isView(R) ? w = new Uint8Array(R.buffer.slice(R.byteOffset, R.byteOffset + R.byteLength)) : R instanceof ArrayBuffer ? w = new Uint8Array(R.slice(0)) : R instanceof Ue ? w = R : w = y.encode(`${R}`), ne(this, ot, D(this, ot) + (ArrayBuffer.isView(w) ? w.byteLength : w.size)), D(this, Pe).push(w);\n        }\n        ne(this, Zt, `${d.endings === void 0 ? \"transparent\" : d.endings}`);\n        const b = d.type === void 0 ? \"\" : String(d.type);\n        ne(this, bt, /^[\\x20-\\x7E]*$/.test(b) ? b : \"\");\n    }\n    get size() {\n        return D(this, ot);\n    }\n    get type() {\n        return D(this, bt);\n    }\n    async text() {\n        const l = new TextDecoder;\n        let d = \"\";\n        for await (const y of toIterator(D(this, Pe), !1))d += l.decode(y, {\n            stream: !0\n        });\n        return d += l.decode(), d;\n    }\n    async arrayBuffer() {\n        const l = new Uint8Array(this.size);\n        let d = 0;\n        for await (const y of toIterator(D(this, Pe), !1))l.set(y, d), d += y.length;\n        return l.buffer;\n    }\n    stream() {\n        const l = toIterator(D(this, Pe), !0);\n        return new globalThis.ReadableStream({\n            type: \"bytes\",\n            async pull (d) {\n                const y = await l.next();\n                y.done ? d.close() : d.enqueue(y.value);\n            },\n            async cancel () {\n                await l.return();\n            }\n        });\n    }\n    slice(l = 0, d = this.size, y = \"\") {\n        const { size: b } = this;\n        let R = l < 0 ? Math.max(b + l, 0) : Math.min(l, b), w = d < 0 ? Math.max(b + d, 0) : Math.min(d, b);\n        const v = Math.max(w - R, 0), I = D(this, Pe), B = [];\n        let F = 0;\n        for (const T of I){\n            if (F >= v) break;\n            const $ = ArrayBuffer.isView(T) ? T.byteLength : T.size;\n            if (R && $ <= R) R -= $, w -= $;\n            else {\n                let E;\n                ArrayBuffer.isView(T) ? (E = T.subarray(R, Math.min($, w)), F += E.byteLength) : (E = T.slice(R, Math.min($, w)), F += E.size), w -= $, B.push(E), R = 0;\n            }\n        }\n        const k = new Ue([], {\n            type: String(y).toLowerCase()\n        });\n        return ne(k, ot, v), ne(k, Pe, B), k;\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n    static [Symbol.hasInstance](l) {\n        return l && typeof l == \"object\" && typeof l.constructor == \"function\" && (typeof l.stream == \"function\" || typeof l.arrayBuffer == \"function\") && /^(Blob|File)$/.test(l[Symbol.toStringTag]);\n    }\n}, Pe = new WeakMap, bt = new WeakMap, ot = new WeakMap, Zt = new WeakMap, u(Ue, \"Blob\"), Ue);\nObject.defineProperties(_Blob.prototype, {\n    size: {\n        enumerable: !0\n    },\n    type: {\n        enumerable: !0\n    },\n    slice: {\n        enumerable: !0\n    }\n});\nconst Blob = _Blob, r$1 = Blob, _File = (gt = class extends r$1 {\n    constructor(d, y, b = {}){\n        if (arguments.length < 2) throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);\n        super(d, b);\n        ye(this, mt, 0);\n        ye(this, yt, \"\");\n        b === null && (b = {});\n        const R = b.lastModified === void 0 ? Date.now() : Number(b.lastModified);\n        Number.isNaN(R) || ne(this, mt, R), ne(this, yt, String(y));\n    }\n    get name() {\n        return D(this, yt);\n    }\n    get lastModified() {\n        return D(this, mt);\n    }\n    get [Symbol.toStringTag]() {\n        return \"File\";\n    }\n    static [Symbol.hasInstance](d) {\n        return !!d && d instanceof r$1 && /^(File)$/.test(d[Symbol.toStringTag]);\n    }\n}, mt = new WeakMap, yt = new WeakMap, u(gt, \"File\"), gt), File = _File, File$1 = File; /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ \nvar { toStringTag: t$1, iterator: i, hasInstance: h } = Symbol, r = Math.random, m = \"append,set,get,getAll,delete,keys,values,entries,forEach,constructor\".split(\",\"), f = u((c1, l, d)=>(c1 += \"\", /^(Blob|File)$/.test(l && l[t$1]) ? [\n        (d = d !== void 0 ? d + \"\" : l[t$1] == \"File\" ? l.name : \"blob\", c1),\n        l.name !== d || l[t$1] == \"blob\" ? new File$1([\n            l\n        ], d, l) : l\n    ] : [\n        c1,\n        l + \"\"\n    ]), \"f\"), e$1 = u((c1, l)=>(l ? c1 : c1.replace(/\\r?\\n|\\r/g, `\\r\n`)).replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\"), \"e$1\"), x = u((c1, l, d)=>{\n    if (l.length < d) throw new TypeError(`Failed to execute '${c1}' on 'FormData': ${d} arguments required, but only ${l.length} present.`);\n}, \"x\");\nconst FormData = (_t = class {\n    constructor(...l){\n        ye(this, oe, []);\n        if (l.length) throw new TypeError(\"Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.\");\n    }\n    get [t$1]() {\n        return \"FormData\";\n    }\n    [i]() {\n        return this.entries();\n    }\n    static [h](l) {\n        return l && typeof l == \"object\" && l[t$1] === \"FormData\" && !m.some((d)=>typeof l[d] != \"function\");\n    }\n    append(...l) {\n        x(\"append\", arguments, 2), D(this, oe).push(f(...l));\n    }\n    delete(l) {\n        x(\"delete\", arguments, 1), l += \"\", ne(this, oe, D(this, oe).filter(([d])=>d !== l));\n    }\n    get(l) {\n        x(\"get\", arguments, 1), l += \"\";\n        for(var d = D(this, oe), y = d.length, b = 0; b < y; b++)if (d[b][0] === l) return d[b][1];\n        return null;\n    }\n    getAll(l, d) {\n        return x(\"getAll\", arguments, 1), d = [], l += \"\", D(this, oe).forEach((y)=>y[0] === l && d.push(y[1])), d;\n    }\n    has(l) {\n        return x(\"has\", arguments, 1), l += \"\", D(this, oe).some((d)=>d[0] === l);\n    }\n    forEach(l, d) {\n        x(\"forEach\", arguments, 1);\n        for (var [y, b] of this)l.call(d, b, y, this);\n    }\n    set(...l) {\n        x(\"set\", arguments, 2);\n        var d = [], y = !0;\n        l = f(...l), D(this, oe).forEach((b)=>{\n            b[0] === l[0] ? y && (y = !d.push(l)) : d.push(b);\n        }), y && d.push(l), ne(this, oe, d);\n    }\n    *entries() {\n        yield* D(this, oe);\n    }\n    *keys() {\n        for (var [l] of this)yield l;\n    }\n    *values() {\n        for (var [, l] of this)yield l;\n    }\n}, oe = new WeakMap, u(_t, \"FormData\"), _t);\nfunction formDataToBlob(c1, l = r$1) {\n    var d = `${r()}${r()}`.replace(/\\./g, \"\").slice(-28).padStart(32, \"-\"), y = [], b = `--${d}\\r\nContent-Disposition: form-data; name=\"`;\n    return c1.forEach((R, w)=>typeof R == \"string\" ? y.push(b + e$1(w) + `\"\\r\n\\r\n${R.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, `\\r\n`)}\\r\n`) : y.push(b + e$1(w) + `\"; filename=\"${e$1(R.name, 1)}\"\\r\nContent-Type: ${R.type || \"application/octet-stream\"}\\r\n\\r\n`, R, `\\r\n`)), y.push(`--${d}--`), new l(y, {\n        type: \"multipart/form-data; boundary=\" + d\n    });\n}\nu(formDataToBlob, \"formDataToBlob\");\nconst rn = class rn extends Error {\n    constructor(l, d){\n        super(l), Error.captureStackTrace(this, this.constructor), this.type = d;\n    }\n    get name() {\n        return this.constructor.name;\n    }\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n};\nu(rn, \"FetchBaseError\");\nlet FetchBaseError = rn;\nconst nn = class nn extends FetchBaseError {\n    constructor(l, d, y){\n        super(l, d), y && (this.code = this.errno = y.code, this.erroredSysCall = y.syscall);\n    }\n};\nu(nn, \"FetchError\");\nlet FetchError = nn;\nconst NAME = Symbol.toStringTag, isURLSearchParameters = u((c1)=>typeof c1 == \"object\" && typeof c1.append == \"function\" && typeof c1.delete == \"function\" && typeof c1.get == \"function\" && typeof c1.getAll == \"function\" && typeof c1.has == \"function\" && typeof c1.set == \"function\" && typeof c1.sort == \"function\" && c1[NAME] === \"URLSearchParams\", \"isURLSearchParameters\"), isBlob = u((c1)=>c1 && typeof c1 == \"object\" && typeof c1.arrayBuffer == \"function\" && typeof c1.type == \"string\" && typeof c1.stream == \"function\" && typeof c1.constructor == \"function\" && /^(Blob|File)$/.test(c1[NAME]), \"isBlob\"), isAbortSignal = u((c1)=>typeof c1 == \"object\" && (c1[NAME] === \"AbortSignal\" || c1[NAME] === \"EventTarget\"), \"isAbortSignal\"), isDomainOrSubdomain = u((c1, l)=>{\n    const d = new URL(l).hostname, y = new URL(c1).hostname;\n    return d === y || d.endsWith(`.${y}`);\n}, \"isDomainOrSubdomain\"), isSameProtocol = u((c1, l)=>{\n    const d = new URL(l).protocol, y = new URL(c1).protocol;\n    return d === y;\n}, \"isSameProtocol\"), pipeline = require$$0.promisify(Stream__default.pipeline), INTERNALS$2 = Symbol(\"Body internals\"), on = class on {\n    constructor(l, { size: d = 0 } = {}){\n        let y = null;\n        l === null ? l = null : isURLSearchParameters(l) ? l = require$$6.Buffer.from(l.toString()) : isBlob(l) || require$$6.Buffer.isBuffer(l) || (require$$0.types.isAnyArrayBuffer(l) ? l = require$$6.Buffer.from(l) : ArrayBuffer.isView(l) ? l = require$$6.Buffer.from(l.buffer, l.byteOffset, l.byteLength) : l instanceof Stream__default || (l instanceof FormData ? (l = formDataToBlob(l), y = l.type.split(\"=\")[1]) : l = require$$6.Buffer.from(String(l))));\n        let b = l;\n        require$$6.Buffer.isBuffer(l) ? b = Stream__default.Readable.from(l) : isBlob(l) && (b = Stream__default.Readable.from(l.stream())), this[INTERNALS$2] = {\n            body: l,\n            stream: b,\n            boundary: y,\n            disturbed: !1,\n            error: null\n        }, this.size = d, l instanceof Stream__default && l.on(\"error\", (R)=>{\n            const w = R instanceof FetchBaseError ? R : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${R.message}`, \"system\", R);\n            this[INTERNALS$2].error = w;\n        });\n    }\n    get body() {\n        return this[INTERNALS$2].stream;\n    }\n    get bodyUsed() {\n        return this[INTERNALS$2].disturbed;\n    }\n    async arrayBuffer() {\n        const { buffer: l, byteOffset: d, byteLength: y } = await consumeBody(this);\n        return l.slice(d, d + y);\n    }\n    async formData() {\n        const l = this.headers.get(\"content-type\");\n        if (l.startsWith(\"application/x-www-form-urlencoded\")) {\n            const y = new FormData, b = new URLSearchParams(await this.text());\n            for (const [R, w] of b)y.append(R, w);\n            return y;\n        }\n        const { toFormData: d } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./chunks/multipart-parser.cjs */ \"(rsc)/./node_modules/node-fetch-native-with-agent/dist/chunks/multipart-parser.cjs\")));\n        return d(this.body, l);\n    }\n    async blob() {\n        const l = this.headers && this.headers.get(\"content-type\") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || \"\", d = await this.arrayBuffer();\n        return new r$1([\n            d\n        ], {\n            type: l\n        });\n    }\n    async json() {\n        const l = await this.text();\n        return JSON.parse(l);\n    }\n    async text() {\n        const l = await consumeBody(this);\n        return new TextDecoder().decode(l);\n    }\n    buffer() {\n        return consumeBody(this);\n    }\n};\nu(on, \"Body\");\nlet Body = on;\nBody.prototype.buffer = require$$0.deprecate(Body.prototype.buffer, \"Please use 'response.arrayBuffer()' instead of 'response.buffer()'\", \"node-fetch#buffer\"), Object.defineProperties(Body.prototype, {\n    body: {\n        enumerable: !0\n    },\n    bodyUsed: {\n        enumerable: !0\n    },\n    arrayBuffer: {\n        enumerable: !0\n    },\n    blob: {\n        enumerable: !0\n    },\n    json: {\n        enumerable: !0\n    },\n    text: {\n        enumerable: !0\n    },\n    data: {\n        get: require$$0.deprecate(()=>{}, \"data doesn't exist, use json(), text(), arrayBuffer(), or body instead\", \"https://github.com/node-fetch/node-fetch/issues/1000 (response)\")\n    }\n});\nasync function consumeBody(c1) {\n    if (c1[INTERNALS$2].disturbed) throw new TypeError(`body used already for: ${c1.url}`);\n    if (c1[INTERNALS$2].disturbed = !0, c1[INTERNALS$2].error) throw c1[INTERNALS$2].error;\n    const { body: l } = c1;\n    if (l === null || !(l instanceof Stream__default)) return require$$6.Buffer.alloc(0);\n    const d = [];\n    let y = 0;\n    try {\n        for await (const b of l){\n            if (c1.size > 0 && y + b.length > c1.size) {\n                const R = new FetchError(`content size at ${c1.url} over limit: ${c1.size}`, \"max-size\");\n                throw l.destroy(R), R;\n            }\n            y += b.length, d.push(b);\n        }\n    } catch (b) {\n        throw b instanceof FetchBaseError ? b : new FetchError(`Invalid response body while trying to fetch ${c1.url}: ${b.message}`, \"system\", b);\n    }\n    if (l.readableEnded === !0 || l._readableState.ended === !0) try {\n        return d.every((b)=>typeof b == \"string\") ? require$$6.Buffer.from(d.join(\"\")) : require$$6.Buffer.concat(d, y);\n    } catch (b) {\n        throw new FetchError(`Could not create Buffer from response body for ${c1.url}: ${b.message}`, \"system\", b);\n    }\n    else throw new FetchError(`Premature close of server response while trying to fetch ${c1.url}`);\n}\nu(consumeBody, \"consumeBody\");\nconst clone = u((c1, l)=>{\n    let d, y, { body: b } = c1[INTERNALS$2];\n    if (c1.bodyUsed) throw new Error(\"cannot clone body after it is used\");\n    return b instanceof Stream__default && typeof b.getBoundary != \"function\" && (d = new Stream.PassThrough({\n        highWaterMark: l\n    }), y = new Stream.PassThrough({\n        highWaterMark: l\n    }), b.pipe(d), b.pipe(y), c1[INTERNALS$2].stream = d, b = y), b;\n}, \"clone\"), getNonSpecFormDataBoundary = require$$0.deprecate((c1)=>c1.getBoundary(), \"form-data doesn't follow the spec and requires special treatment. Use alternative package\", \"https://github.com/node-fetch/node-fetch/issues/1167\"), extractContentType = u((c1, l)=>c1 === null ? null : typeof c1 == \"string\" ? \"text/plain;charset=UTF-8\" : isURLSearchParameters(c1) ? \"application/x-www-form-urlencoded;charset=UTF-8\" : isBlob(c1) ? c1.type || null : require$$6.Buffer.isBuffer(c1) || require$$0.types.isAnyArrayBuffer(c1) || ArrayBuffer.isView(c1) ? null : c1 instanceof FormData ? `multipart/form-data; boundary=${l[INTERNALS$2].boundary}` : c1 && typeof c1.getBoundary == \"function\" ? `multipart/form-data;boundary=${getNonSpecFormDataBoundary(c1)}` : c1 instanceof Stream__default ? null : \"text/plain;charset=UTF-8\", \"extractContentType\"), getTotalBytes = u((c1)=>{\n    const { body: l } = c1[INTERNALS$2];\n    return l === null ? 0 : isBlob(l) ? l.size : require$$6.Buffer.isBuffer(l) ? l.length : l && typeof l.getLengthSync == \"function\" && l.hasKnownLength && l.hasKnownLength() ? l.getLengthSync() : null;\n}, \"getTotalBytes\"), writeToStream = u(async (c1, { body: l })=>{\n    l === null ? c1.end() : await pipeline(l, c1);\n}, \"writeToStream\"), validateHeaderName = typeof http__default.validateHeaderName == \"function\" ? http__default.validateHeaderName : (c1)=>{\n    if (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(c1)) {\n        const l = new TypeError(`Header name must be a valid HTTP token [${c1}]`);\n        throw Object.defineProperty(l, \"code\", {\n            value: \"ERR_INVALID_HTTP_TOKEN\"\n        }), l;\n    }\n}, validateHeaderValue = typeof http__default.validateHeaderValue == \"function\" ? http__default.validateHeaderValue : (c1, l)=>{\n    if (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(l)) {\n        const d = new TypeError(`Invalid character in header content [\"${c1}\"]`);\n        throw Object.defineProperty(d, \"code\", {\n            value: \"ERR_INVALID_CHAR\"\n        }), d;\n    }\n}, Kt = class Kt extends URLSearchParams {\n    constructor(l){\n        let d = [];\n        if (l instanceof Kt) {\n            const y = l.raw();\n            for (const [b, R] of Object.entries(y))d.push(...R.map((w)=>[\n                    b,\n                    w\n                ]));\n        } else if (l != null) if (typeof l == \"object\" && !require$$0.types.isBoxedPrimitive(l)) {\n            const y = l[Symbol.iterator];\n            if (y == null) d.push(...Object.entries(l));\n            else {\n                if (typeof y != \"function\") throw new TypeError(\"Header pairs must be iterable\");\n                d = [\n                    ...l\n                ].map((b)=>{\n                    if (typeof b != \"object\" || require$$0.types.isBoxedPrimitive(b)) throw new TypeError(\"Each header pair must be an iterable object\");\n                    return [\n                        ...b\n                    ];\n                }).map((b)=>{\n                    if (b.length !== 2) throw new TypeError(\"Each header pair must be a name/value tuple\");\n                    return [\n                        ...b\n                    ];\n                });\n            }\n        } else throw new TypeError(\"Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)\");\n        return d = d.length > 0 ? d.map(([y, b])=>(validateHeaderName(y), validateHeaderValue(y, String(b)), [\n                String(y).toLowerCase(),\n                String(b)\n            ])) : void 0, super(d), new Proxy(this, {\n            get (y, b, R) {\n                switch(b){\n                    case \"append\":\n                    case \"set\":\n                        return (w, v)=>(validateHeaderName(w), validateHeaderValue(w, String(v)), URLSearchParams.prototype[b].call(y, String(w).toLowerCase(), String(v)));\n                    case \"delete\":\n                    case \"has\":\n                    case \"getAll\":\n                        return (w)=>(validateHeaderName(w), URLSearchParams.prototype[b].call(y, String(w).toLowerCase()));\n                    case \"keys\":\n                        return ()=>(y.sort(), new Set(URLSearchParams.prototype.keys.call(y)).keys());\n                    default:\n                        return Reflect.get(y, b, R);\n                }\n            }\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n    toString() {\n        return Object.prototype.toString.call(this);\n    }\n    get(l) {\n        const d = this.getAll(l);\n        if (d.length === 0) return null;\n        let y = d.join(\", \");\n        return /^content-encoding$/i.test(l) && (y = y.toLowerCase()), y;\n    }\n    forEach(l, d = void 0) {\n        for (const y of this.keys())Reflect.apply(l, d, [\n            this.get(y),\n            y,\n            this\n        ]);\n    }\n    *values() {\n        for (const l of this.keys())yield this.get(l);\n    }\n    *entries() {\n        for (const l of this.keys())yield [\n            l,\n            this.get(l)\n        ];\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    raw() {\n        return [\n            ...this.keys()\n        ].reduce((l, d)=>(l[d] = this.getAll(d), l), {});\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return [\n            ...this.keys()\n        ].reduce((l, d)=>{\n            const y = this.getAll(d);\n            return d === \"host\" ? l[d] = y[0] : l[d] = y.length > 1 ? y : y[0], l;\n        }, {});\n    }\n};\nu(Kt, \"Headers\");\nlet Headers = Kt;\nObject.defineProperties(Headers.prototype, [\n    \"get\",\n    \"entries\",\n    \"forEach\",\n    \"values\"\n].reduce((c1, l)=>(c1[l] = {\n        enumerable: !0\n    }, c1), {}));\nfunction fromRawHeaders(c1 = []) {\n    return new Headers(c1.reduce((l, d, y, b)=>(y % 2 === 0 && l.push(b.slice(y, y + 2)), l), []).filter(([l, d])=>{\n        try {\n            return validateHeaderName(l), validateHeaderValue(l, String(d)), !0;\n        } catch  {\n            return !1;\n        }\n    }));\n}\nu(fromRawHeaders, \"fromRawHeaders\");\nconst redirectStatus = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]), isRedirect = u((c1)=>redirectStatus.has(c1), \"isRedirect\"), INTERNALS$1 = Symbol(\"Response internals\"), De = class De extends Body {\n    constructor(l = null, d = {}){\n        super(l, d);\n        const y = d.status != null ? d.status : 200, b = new Headers(d.headers);\n        if (l !== null && !b.has(\"Content-Type\")) {\n            const R = extractContentType(l, this);\n            R && b.append(\"Content-Type\", R);\n        }\n        this[INTERNALS$1] = {\n            type: \"default\",\n            url: d.url,\n            status: y,\n            statusText: d.statusText || \"\",\n            headers: b,\n            counter: d.counter,\n            highWaterMark: d.highWaterMark\n        };\n    }\n    get type() {\n        return this[INTERNALS$1].type;\n    }\n    get url() {\n        return this[INTERNALS$1].url || \"\";\n    }\n    get status() {\n        return this[INTERNALS$1].status;\n    }\n    get ok() {\n        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n    }\n    get redirected() {\n        return this[INTERNALS$1].counter > 0;\n    }\n    get statusText() {\n        return this[INTERNALS$1].statusText;\n    }\n    get headers() {\n        return this[INTERNALS$1].headers;\n    }\n    get highWaterMark() {\n        return this[INTERNALS$1].highWaterMark;\n    }\n    clone() {\n        return new De(clone(this, this.highWaterMark), {\n            type: this.type,\n            url: this.url,\n            status: this.status,\n            statusText: this.statusText,\n            headers: this.headers,\n            ok: this.ok,\n            redirected: this.redirected,\n            size: this.size,\n            highWaterMark: this.highWaterMark\n        });\n    }\n    static redirect(l, d = 302) {\n        if (!isRedirect(d)) throw new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n        return new De(null, {\n            headers: {\n                location: new URL(l).toString()\n            },\n            status: d\n        });\n    }\n    static error() {\n        const l = new De(null, {\n            status: 0,\n            statusText: \"\"\n        });\n        return l[INTERNALS$1].type = \"error\", l;\n    }\n    static json(l = void 0, d = {}) {\n        const y = JSON.stringify(l);\n        if (y === void 0) throw new TypeError(\"data is not JSON serializable\");\n        const b = new Headers(d && d.headers);\n        return b.has(\"content-type\") || b.set(\"content-type\", \"application/json\"), new De(y, {\n            ...d,\n            headers: b\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Response\";\n    }\n};\nu(De, \"Response\");\nlet Response = De;\nObject.defineProperties(Response.prototype, {\n    type: {\n        enumerable: !0\n    },\n    url: {\n        enumerable: !0\n    },\n    status: {\n        enumerable: !0\n    },\n    ok: {\n        enumerable: !0\n    },\n    redirected: {\n        enumerable: !0\n    },\n    statusText: {\n        enumerable: !0\n    },\n    headers: {\n        enumerable: !0\n    },\n    clone: {\n        enumerable: !0\n    }\n});\nconst getSearch = u((c1)=>{\n    if (c1.search) return c1.search;\n    const l = c1.href.length - 1, d = c1.hash || (c1.href[l] === \"#\" ? \"#\" : \"\");\n    return c1.href[l - d.length] === \"?\" ? \"?\" : \"\";\n}, \"getSearch\");\nfunction stripURLForUseAsAReferrer(c1, l = !1) {\n    return c1 == null || (c1 = new URL(c1), /^(about|blob|data):$/.test(c1.protocol)) ? \"no-referrer\" : (c1.username = \"\", c1.password = \"\", c1.hash = \"\", l && (c1.pathname = \"\", c1.search = \"\"), c1);\n}\nu(stripURLForUseAsAReferrer, \"stripURLForUseAsAReferrer\");\nconst ReferrerPolicy = new Set([\n    \"\",\n    \"no-referrer\",\n    \"no-referrer-when-downgrade\",\n    \"same-origin\",\n    \"origin\",\n    \"strict-origin\",\n    \"origin-when-cross-origin\",\n    \"strict-origin-when-cross-origin\",\n    \"unsafe-url\"\n]), DEFAULT_REFERRER_POLICY = \"strict-origin-when-cross-origin\";\nfunction validateReferrerPolicy(c1) {\n    if (!ReferrerPolicy.has(c1)) throw new TypeError(`Invalid referrerPolicy: ${c1}`);\n    return c1;\n}\nu(validateReferrerPolicy, \"validateReferrerPolicy\");\nfunction isOriginPotentiallyTrustworthy(c1) {\n    if (/^(http|ws)s:$/.test(c1.protocol)) return !0;\n    const l = c1.host.replace(/(^\\[)|(]$)/g, \"\"), d = require$$4.isIP(l);\n    return d === 4 && /^127\\./.test(l) || d === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(l) ? !0 : c1.host === \"localhost\" || c1.host.endsWith(\".localhost\") ? !1 : c1.protocol === \"file:\";\n}\nu(isOriginPotentiallyTrustworthy, \"isOriginPotentiallyTrustworthy\");\nfunction isUrlPotentiallyTrustworthy(c1) {\n    return /^about:(blank|srcdoc)$/.test(c1) || c1.protocol === \"data:\" || /^(blob|filesystem):$/.test(c1.protocol) ? !0 : isOriginPotentiallyTrustworthy(c1);\n}\nu(isUrlPotentiallyTrustworthy, \"isUrlPotentiallyTrustworthy\");\nfunction determineRequestsReferrer(c1, { referrerURLCallback: l, referrerOriginCallback: d } = {}) {\n    if (c1.referrer === \"no-referrer\" || c1.referrerPolicy === \"\") return null;\n    const y = c1.referrerPolicy;\n    if (c1.referrer === \"about:client\") return \"no-referrer\";\n    const b = c1.referrer;\n    let R = stripURLForUseAsAReferrer(b), w = stripURLForUseAsAReferrer(b, !0);\n    R.toString().length > 4096 && (R = w), l && (R = l(R)), d && (w = d(w));\n    const v = new URL(c1.url);\n    switch(y){\n        case \"no-referrer\":\n            return \"no-referrer\";\n        case \"origin\":\n            return w;\n        case \"unsafe-url\":\n            return R;\n        case \"strict-origin\":\n            return isUrlPotentiallyTrustworthy(R) && !isUrlPotentiallyTrustworthy(v) ? \"no-referrer\" : w.toString();\n        case \"strict-origin-when-cross-origin\":\n            return R.origin === v.origin ? R : isUrlPotentiallyTrustworthy(R) && !isUrlPotentiallyTrustworthy(v) ? \"no-referrer\" : w;\n        case \"same-origin\":\n            return R.origin === v.origin ? R : \"no-referrer\";\n        case \"origin-when-cross-origin\":\n            return R.origin === v.origin ? R : w;\n        case \"no-referrer-when-downgrade\":\n            return isUrlPotentiallyTrustworthy(R) && !isUrlPotentiallyTrustworthy(v) ? \"no-referrer\" : R;\n        default:\n            throw new TypeError(`Invalid referrerPolicy: ${y}`);\n    }\n}\nu(determineRequestsReferrer, \"determineRequestsReferrer\");\nfunction parseReferrerPolicyFromHeader(c1) {\n    const l = (c1.get(\"referrer-policy\") || \"\").split(/[,\\s]+/);\n    let d = \"\";\n    for (const y of l)y && ReferrerPolicy.has(y) && (d = y);\n    return d;\n}\nu(parseReferrerPolicyFromHeader, \"parseReferrerPolicyFromHeader\");\nconst INTERNALS = Symbol(\"Request internals\"), isRequest = u((c1)=>typeof c1 == \"object\" && typeof c1[INTERNALS] == \"object\", \"isRequest\"), doBadDataWarn = require$$0.deprecate(()=>{}, \".data is not a valid RequestInit property, use .body instead\", \"https://github.com/node-fetch/node-fetch/issues/1000 (request)\"), Jt = class Jt extends Body {\n    constructor(l, d = {}){\n        let y;\n        if (isRequest(l) ? y = new URL(l.url) : (y = new URL(l), l = {}), y.username !== \"\" || y.password !== \"\") throw new TypeError(`${y} is an url with embedded credentials.`);\n        let b = d.method || l.method || \"GET\";\n        if (/^(delete|get|head|options|post|put)$/i.test(b) && (b = b.toUpperCase()), !isRequest(d) && \"data\" in d && doBadDataWarn(), (d.body != null || isRequest(l) && l.body !== null) && (b === \"GET\" || b === \"HEAD\")) throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n        const R = d.body ? d.body : isRequest(l) && l.body !== null ? clone(l) : null;\n        super(R, {\n            size: d.size || l.size || 0\n        });\n        const w = new Headers(d.headers || l.headers || {});\n        if (R !== null && !w.has(\"Content-Type\")) {\n            const B = extractContentType(R, this);\n            B && w.set(\"Content-Type\", B);\n        }\n        let v = isRequest(l) ? l.signal : null;\n        if (\"signal\" in d && (v = d.signal), v != null && !isAbortSignal(v)) throw new TypeError(\"Expected signal to be an instanceof AbortSignal or EventTarget\");\n        let I = d.referrer == null ? l.referrer : d.referrer;\n        if (I === \"\") I = \"no-referrer\";\n        else if (I) {\n            const B = new URL(I);\n            I = /^about:(\\/\\/)?client$/.test(B) ? \"client\" : B;\n        } else I = void 0;\n        this[INTERNALS] = {\n            method: b,\n            redirect: d.redirect || l.redirect || \"follow\",\n            headers: w,\n            parsedURL: y,\n            signal: v,\n            referrer: I\n        }, this.follow = d.follow === void 0 ? l.follow === void 0 ? 20 : l.follow : d.follow, this.compress = d.compress === void 0 ? l.compress === void 0 ? !0 : l.compress : d.compress, this.counter = d.counter || l.counter || 0, this.agent = d.agent || l.agent, this.highWaterMark = d.highWaterMark || l.highWaterMark || 16384, this.insecureHTTPParser = d.insecureHTTPParser || l.insecureHTTPParser || !1, this.referrerPolicy = d.referrerPolicy || l.referrerPolicy || \"\";\n    }\n    get method() {\n        return this[INTERNALS].method;\n    }\n    get url() {\n        return require$$1.format(this[INTERNALS].parsedURL);\n    }\n    get headers() {\n        return this[INTERNALS].headers;\n    }\n    get redirect() {\n        return this[INTERNALS].redirect;\n    }\n    get signal() {\n        return this[INTERNALS].signal;\n    }\n    get referrer() {\n        if (this[INTERNALS].referrer === \"no-referrer\") return \"\";\n        if (this[INTERNALS].referrer === \"client\") return \"about:client\";\n        if (this[INTERNALS].referrer) return this[INTERNALS].referrer.toString();\n    }\n    get referrerPolicy() {\n        return this[INTERNALS].referrerPolicy;\n    }\n    set referrerPolicy(l) {\n        this[INTERNALS].referrerPolicy = validateReferrerPolicy(l);\n    }\n    clone() {\n        return new Jt(this);\n    }\n    get [Symbol.toStringTag]() {\n        return \"Request\";\n    }\n};\nu(Jt, \"Request\");\nlet Request = Jt;\nObject.defineProperties(Request.prototype, {\n    method: {\n        enumerable: !0\n    },\n    url: {\n        enumerable: !0\n    },\n    headers: {\n        enumerable: !0\n    },\n    redirect: {\n        enumerable: !0\n    },\n    clone: {\n        enumerable: !0\n    },\n    signal: {\n        enumerable: !0\n    },\n    referrer: {\n        enumerable: !0\n    },\n    referrerPolicy: {\n        enumerable: !0\n    }\n});\nconst getNodeRequestOptions = u((c1)=>{\n    const { parsedURL: l } = c1[INTERNALS], d = new Headers(c1[INTERNALS].headers);\n    d.has(\"Accept\") || d.set(\"Accept\", \"*/*\");\n    let y = null;\n    if (c1.body === null && /^(post|put)$/i.test(c1.method) && (y = \"0\"), c1.body !== null) {\n        const v = getTotalBytes(c1);\n        typeof v == \"number\" && !Number.isNaN(v) && (y = String(v));\n    }\n    y && d.set(\"Content-Length\", y), c1.referrerPolicy === \"\" && (c1.referrerPolicy = DEFAULT_REFERRER_POLICY), c1.referrer && c1.referrer !== \"no-referrer\" ? c1[INTERNALS].referrer = determineRequestsReferrer(c1) : c1[INTERNALS].referrer = \"no-referrer\", c1[INTERNALS].referrer instanceof URL && d.set(\"Referer\", c1.referrer), d.has(\"User-Agent\") || d.set(\"User-Agent\", \"node-fetch\"), c1.compress && !d.has(\"Accept-Encoding\") && d.set(\"Accept-Encoding\", \"gzip, deflate, br\");\n    let { agent: b } = c1;\n    typeof b == \"function\" && (b = b(l));\n    const R = getSearch(l), w = {\n        path: l.pathname + R,\n        method: c1.method,\n        headers: d[Symbol.for(\"nodejs.util.inspect.custom\")](),\n        insecureHTTPParser: c1.insecureHTTPParser,\n        agent: b\n    };\n    return {\n        parsedURL: l,\n        options: w\n    };\n}, \"getNodeRequestOptions\"), sn = class sn extends FetchBaseError {\n    constructor(l, d = \"aborted\"){\n        super(l, d);\n    }\n};\nu(sn, \"AbortError\");\nlet AbortError = sn; /*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ \nif (!globalThis.DOMException) try {\n    const { MessageChannel: c1 } = __webpack_require__(/*! worker_threads */ \"worker_threads\"), l = new c1().port1, d = new ArrayBuffer;\n    l.postMessage(d, [\n        d,\n        d\n    ]);\n} catch (c1) {\n    c1.constructor.name === \"DOMException\" && (globalThis.DOMException = c1.constructor);\n}\nvar nodeDomexception = globalThis.DOMException;\nconst DOMException = _commonjsHelpers.getDefaultExportFromCjs(nodeDomexception), { stat } = node_fs.promises, blobFromSync = u((c1, l)=>fromBlob(node_fs.statSync(c1), c1, l), \"blobFromSync\"), blobFrom = u((c1, l)=>stat(c1).then((d)=>fromBlob(d, c1, l)), \"blobFrom\"), fileFrom = u((c1, l)=>stat(c1).then((d)=>fromFile(d, c1, l)), \"fileFrom\"), fileFromSync = u((c1, l)=>fromFile(node_fs.statSync(c1), c1, l), \"fileFromSync\"), fromBlob = u((c1, l, d = \"\")=>new r$1([\n        new BlobDataItem({\n            path: l,\n            size: c1.size,\n            lastModified: c1.mtimeMs,\n            start: 0\n        })\n    ], {\n        type: d\n    }), \"fromBlob\"), fromFile = u((c1, l, d = \"\")=>new File$1([\n        new BlobDataItem({\n            path: l,\n            size: c1.size,\n            lastModified: c1.mtimeMs,\n            start: 0\n        })\n    ], node_path.basename(l), {\n        type: d,\n        lastModified: c1.mtimeMs\n    }), \"fromFile\"), Xt = class Xt {\n    constructor(l){\n        ye(this, Me, void 0);\n        ye(this, xe, void 0);\n        ne(this, Me, l.path), ne(this, xe, l.start), this.size = l.size, this.lastModified = l.lastModified;\n    }\n    slice(l, d) {\n        return new Xt({\n            path: D(this, Me),\n            lastModified: this.lastModified,\n            size: d - l,\n            start: D(this, xe) + l\n        });\n    }\n    async *stream() {\n        const { mtimeMs: l } = await stat(D(this, Me));\n        if (l > this.lastModified) throw new DOMException(\"The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.\", \"NotReadableError\");\n        yield* node_fs.createReadStream(D(this, Me), {\n            start: D(this, xe),\n            end: D(this, xe) + this.size - 1\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n};\nMe = new WeakMap, xe = new WeakMap, u(Xt, \"BlobDataItem\");\nlet BlobDataItem = Xt;\nconst supportedSchemas = new Set([\n    \"data:\",\n    \"http:\",\n    \"https:\"\n]);\nasync function fetch$1(c1, l) {\n    return new Promise((d, y)=>{\n        const b = new Request(c1, l), { parsedURL: R, options: w } = getNodeRequestOptions(b);\n        if (!supportedSchemas.has(R.protocol)) throw new TypeError(`node-fetch cannot load ${c1}. URL scheme \"${R.protocol.replace(/:$/, \"\")}\" is not supported.`);\n        if (R.protocol === \"data:\") {\n            const E = dataUriToBuffer(b.url), K = new Response(E, {\n                headers: {\n                    \"Content-Type\": E.typeFull\n                }\n            });\n            d(K);\n            return;\n        }\n        const v = (R.protocol === \"https:\" ? https__default : http__default).request, { signal: I } = b;\n        let B = null;\n        const F = u(()=>{\n            const E = new AbortError(\"The operation was aborted.\");\n            y(E), b.body && b.body instanceof Stream__default.Readable && b.body.destroy(E), !(!B || !B.body) && B.body.emit(\"error\", E);\n        }, \"abort\");\n        if (I && I.aborted) {\n            F();\n            return;\n        }\n        const k = u(()=>{\n            F(), $();\n        }, \"abortAndFinalize\"), T = v(R.toString(), w);\n        I && I.addEventListener(\"abort\", k);\n        const $ = u(()=>{\n            T.abort(), I && I.removeEventListener(\"abort\", k);\n        }, \"finalize\");\n        T.on(\"error\", (E)=>{\n            y(new FetchError(`request to ${b.url} failed, reason: ${E.message}`, \"system\", E)), $();\n        }), fixResponseChunkedTransferBadEnding(T, (E)=>{\n            B && B.body && B.body.destroy(E);\n        }), process.version < \"v14\" && T.on(\"socket\", (E)=>{\n            let K;\n            E.prependListener(\"end\", ()=>{\n                K = E._eventsCount;\n            }), E.prependListener(\"close\", (U)=>{\n                if (B && K < E._eventsCount && !U) {\n                    const N = new Error(\"Premature close\");\n                    N.code = \"ERR_STREAM_PREMATURE_CLOSE\", B.body.emit(\"error\", N);\n                }\n            });\n        }), T.on(\"response\", (E)=>{\n            T.setTimeout(0);\n            const K = fromRawHeaders(E.rawHeaders);\n            if (isRedirect(E.statusCode)) {\n                const M = K.get(\"Location\");\n                let H = null;\n                try {\n                    H = M === null ? null : new URL(M, b.url);\n                } catch  {\n                    if (b.redirect !== \"manual\") {\n                        y(new FetchError(`uri requested responds with an invalid redirect URL: ${M}`, \"invalid-redirect\")), $();\n                        return;\n                    }\n                }\n                switch(b.redirect){\n                    case \"error\":\n                        y(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${b.url}`, \"no-redirect\")), $();\n                        return;\n                    case \"manual\":\n                        break;\n                    case \"follow\":\n                        {\n                            if (H === null) break;\n                            if (b.counter >= b.follow) {\n                                y(new FetchError(`maximum redirect reached at: ${b.url}`, \"max-redirect\")), $();\n                                return;\n                            }\n                            const G = {\n                                headers: new Headers(b.headers),\n                                follow: b.follow,\n                                counter: b.counter + 1,\n                                agent: b.agent,\n                                compress: b.compress,\n                                method: b.method,\n                                body: clone(b),\n                                signal: b.signal,\n                                size: b.size,\n                                referrer: b.referrer,\n                                referrerPolicy: b.referrerPolicy\n                            };\n                            if (!isDomainOrSubdomain(b.url, H) || !isSameProtocol(b.url, H)) for (const wt of [\n                                \"authorization\",\n                                \"www-authenticate\",\n                                \"cookie\",\n                                \"cookie2\"\n                            ])G.headers.delete(wt);\n                            if (E.statusCode !== 303 && b.body && l.body instanceof Stream__default.Readable) {\n                                y(new FetchError(\"Cannot follow redirect with body being a readable stream\", \"unsupported-redirect\")), $();\n                                return;\n                            }\n                            (E.statusCode === 303 || (E.statusCode === 301 || E.statusCode === 302) && b.method === \"POST\") && (G.method = \"GET\", G.body = void 0, G.headers.delete(\"content-length\"));\n                            const Q = parseReferrerPolicyFromHeader(K);\n                            Q && (G.referrerPolicy = Q), d(fetch$1(new Request(H, G))), $();\n                            return;\n                        }\n                    default:\n                        return y(new TypeError(`Redirect option '${b.redirect}' is not a valid value of RequestRedirect`));\n                }\n            }\n            I && E.once(\"end\", ()=>{\n                I.removeEventListener(\"abort\", k);\n            });\n            let U = Stream.pipeline(E, new Stream.PassThrough, (M)=>{\n                M && y(M);\n            });\n            process.version < \"v12.10\" && E.on(\"aborted\", k);\n            const N = {\n                url: b.url,\n                status: E.statusCode,\n                statusText: E.statusMessage,\n                headers: K,\n                size: b.size,\n                counter: b.counter,\n                highWaterMark: b.highWaterMark\n            }, J = K.get(\"Content-Encoding\");\n            if (!b.compress || b.method === \"HEAD\" || J === null || E.statusCode === 204 || E.statusCode === 304) {\n                B = new Response(U, N), d(B);\n                return;\n            }\n            const ge = {\n                flush: zlib__default.Z_SYNC_FLUSH,\n                finishFlush: zlib__default.Z_SYNC_FLUSH\n            };\n            if (J === \"gzip\" || J === \"x-gzip\") {\n                U = Stream.pipeline(U, zlib__default.createGunzip(ge), (M)=>{\n                    M && y(M);\n                }), B = new Response(U, N), d(B);\n                return;\n            }\n            if (J === \"deflate\" || J === \"x-deflate\") {\n                const M = Stream.pipeline(E, new Stream.PassThrough, (H)=>{\n                    H && y(H);\n                });\n                M.once(\"data\", (H)=>{\n                    (H[0] & 15) === 8 ? U = Stream.pipeline(U, zlib__default.createInflate(), (G)=>{\n                        G && y(G);\n                    }) : U = Stream.pipeline(U, zlib__default.createInflateRaw(), (G)=>{\n                        G && y(G);\n                    }), B = new Response(U, N), d(B);\n                }), M.once(\"end\", ()=>{\n                    B || (B = new Response(U, N), d(B));\n                });\n                return;\n            }\n            if (J === \"br\") {\n                U = Stream.pipeline(U, zlib__default.createBrotliDecompress(), (M)=>{\n                    M && y(M);\n                }), B = new Response(U, N), d(B);\n                return;\n            }\n            B = new Response(U, N), d(B);\n        }), writeToStream(T, b).catch(y);\n    });\n}\nu(fetch$1, \"fetch$1\");\nfunction fixResponseChunkedTransferBadEnding(c1, l) {\n    const d = require$$6.Buffer.from(`0\\r\n\\r\n`);\n    let y = !1, b = !1, R;\n    c1.on(\"response\", (w)=>{\n        const { headers: v } = w;\n        y = v[\"transfer-encoding\"] === \"chunked\" && !v[\"content-length\"];\n    }), c1.on(\"socket\", (w)=>{\n        const v = u(()=>{\n            if (y && !b) {\n                const B = new Error(\"Premature close\");\n                B.code = \"ERR_STREAM_PREMATURE_CLOSE\", l(B);\n            }\n        }, \"onSocketClose\"), I = u((B)=>{\n            b = require$$6.Buffer.compare(B.slice(-5), d) === 0, !b && R && (b = require$$6.Buffer.compare(R.slice(-3), d.slice(0, 3)) === 0 && require$$6.Buffer.compare(B.slice(-2), d.slice(3)) === 0), R = B;\n        }, \"onData\");\n        w.prependListener(\"close\", v), w.on(\"data\", I), c1.on(\"close\", ()=>{\n            w.removeListener(\"close\", v), w.removeListener(\"data\", I);\n        });\n    });\n}\nu(fixResponseChunkedTransferBadEnding, \"fixResponseChunkedTransferBadEnding\");\nconst privateData = new WeakMap, wrappers = new WeakMap;\nfunction pd(c1) {\n    const l = privateData.get(c1);\n    return console.assert(l != null, \"'this' is expected an Event object, but got\", c1), l;\n}\nu(pd, \"pd\");\nfunction setCancelFlag(c1) {\n    if (c1.passiveListener != null) {\n        typeof console < \"u\" && typeof console.error == \"function\" && console.error(\"Unable to preventDefault inside passive event listener invocation.\", c1.passiveListener);\n        return;\n    }\n    c1.event.cancelable && (c1.canceled = !0, typeof c1.event.preventDefault == \"function\" && c1.event.preventDefault());\n}\nu(setCancelFlag, \"setCancelFlag\");\nfunction Event(c1, l) {\n    privateData.set(this, {\n        eventTarget: c1,\n        event: l,\n        eventPhase: 2,\n        currentTarget: c1,\n        canceled: !1,\n        stopped: !1,\n        immediateStopped: !1,\n        passiveListener: null,\n        timeStamp: l.timeStamp || Date.now()\n    }), Object.defineProperty(this, \"isTrusted\", {\n        value: !1,\n        enumerable: !0\n    });\n    const d = Object.keys(l);\n    for(let y = 0; y < d.length; ++y){\n        const b = d[y];\n        b in this || Object.defineProperty(this, b, defineRedirectDescriptor(b));\n    }\n}\nu(Event, \"Event\"), Event.prototype = {\n    get type () {\n        return pd(this).event.type;\n    },\n    get target () {\n        return pd(this).eventTarget;\n    },\n    get currentTarget () {\n        return pd(this).currentTarget;\n    },\n    composedPath () {\n        const c1 = pd(this).currentTarget;\n        return c1 == null ? [] : [\n            c1\n        ];\n    },\n    get NONE () {\n        return 0;\n    },\n    get CAPTURING_PHASE () {\n        return 1;\n    },\n    get AT_TARGET () {\n        return 2;\n    },\n    get BUBBLING_PHASE () {\n        return 3;\n    },\n    get eventPhase () {\n        return pd(this).eventPhase;\n    },\n    stopPropagation () {\n        const c1 = pd(this);\n        c1.stopped = !0, typeof c1.event.stopPropagation == \"function\" && c1.event.stopPropagation();\n    },\n    stopImmediatePropagation () {\n        const c1 = pd(this);\n        c1.stopped = !0, c1.immediateStopped = !0, typeof c1.event.stopImmediatePropagation == \"function\" && c1.event.stopImmediatePropagation();\n    },\n    get bubbles () {\n        return !!pd(this).event.bubbles;\n    },\n    get cancelable () {\n        return !!pd(this).event.cancelable;\n    },\n    preventDefault () {\n        setCancelFlag(pd(this));\n    },\n    get defaultPrevented () {\n        return pd(this).canceled;\n    },\n    get composed () {\n        return !!pd(this).event.composed;\n    },\n    get timeStamp () {\n        return pd(this).timeStamp;\n    },\n    get srcElement () {\n        return pd(this).eventTarget;\n    },\n    get cancelBubble () {\n        return pd(this).stopped;\n    },\n    set cancelBubble (c){\n        if (!c) return;\n        const l = pd(this);\n        l.stopped = !0, typeof l.event.cancelBubble == \"boolean\" && (l.event.cancelBubble = !0);\n    },\n    get returnValue () {\n        return !pd(this).canceled;\n    },\n    set returnValue (c){\n        c || setCancelFlag(pd(this));\n    },\n    initEvent () {}\n}, Object.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: !0,\n    writable: !0\n}),  false && (0);\nfunction defineRedirectDescriptor(c1) {\n    return {\n        get () {\n            return pd(this).event[c1];\n        },\n        set (l) {\n            pd(this).event[c1] = l;\n        },\n        configurable: !0,\n        enumerable: !0\n    };\n}\nu(defineRedirectDescriptor, \"defineRedirectDescriptor\");\nfunction defineCallDescriptor(c1) {\n    return {\n        value () {\n            const l = pd(this).event;\n            return l[c1].apply(l, arguments);\n        },\n        configurable: !0,\n        enumerable: !0\n    };\n}\nu(defineCallDescriptor, \"defineCallDescriptor\");\nfunction defineWrapper(c1, l) {\n    const d = Object.keys(l);\n    if (d.length === 0) return c1;\n    function y(b, R) {\n        c1.call(this, b, R);\n    }\n    u(y, \"CustomEvent\"), y.prototype = Object.create(c1.prototype, {\n        constructor: {\n            value: y,\n            configurable: !0,\n            writable: !0\n        }\n    });\n    for(let b = 0; b < d.length; ++b){\n        const R = d[b];\n        if (!(R in c1.prototype)) {\n            const v = typeof Object.getOwnPropertyDescriptor(l, R).value == \"function\";\n            Object.defineProperty(y.prototype, R, v ? defineCallDescriptor(R) : defineRedirectDescriptor(R));\n        }\n    }\n    return y;\n}\nu(defineWrapper, \"defineWrapper\");\nfunction getWrapper(c1) {\n    if (c1 == null || c1 === Object.prototype) return Event;\n    let l = wrappers.get(c1);\n    return l == null && (l = defineWrapper(getWrapper(Object.getPrototypeOf(c1)), c1), wrappers.set(c1, l)), l;\n}\nu(getWrapper, \"getWrapper\");\nfunction wrapEvent(c1, l) {\n    const d = getWrapper(Object.getPrototypeOf(l));\n    return new d(c1, l);\n}\nu(wrapEvent, \"wrapEvent\");\nfunction isStopped(c1) {\n    return pd(c1).immediateStopped;\n}\nu(isStopped, \"isStopped\");\nfunction setEventPhase(c1, l) {\n    pd(c1).eventPhase = l;\n}\nu(setEventPhase, \"setEventPhase\");\nfunction setCurrentTarget(c1, l) {\n    pd(c1).currentTarget = l;\n}\nu(setCurrentTarget, \"setCurrentTarget\");\nfunction setPassiveListener(c1, l) {\n    pd(c1).passiveListener = l;\n}\nu(setPassiveListener, \"setPassiveListener\");\nconst listenersMap = new WeakMap, CAPTURE = 1, BUBBLE = 2, ATTRIBUTE = 3;\nfunction isObject(c1) {\n    return c1 !== null && typeof c1 == \"object\";\n}\nu(isObject, \"isObject\");\nfunction getListeners(c1) {\n    const l = listenersMap.get(c1);\n    if (l == null) throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n    return l;\n}\nu(getListeners, \"getListeners\");\nfunction defineEventAttributeDescriptor(c1) {\n    return {\n        get () {\n            let d = getListeners(this).get(c1);\n            for(; d != null;){\n                if (d.listenerType === ATTRIBUTE) return d.listener;\n                d = d.next;\n            }\n            return null;\n        },\n        set (l) {\n            typeof l != \"function\" && !isObject(l) && (l = null);\n            const d = getListeners(this);\n            let y = null, b = d.get(c1);\n            for(; b != null;)b.listenerType === ATTRIBUTE ? y !== null ? y.next = b.next : b.next !== null ? d.set(c1, b.next) : d.delete(c1) : y = b, b = b.next;\n            if (l !== null) {\n                const R = {\n                    listener: l,\n                    listenerType: ATTRIBUTE,\n                    passive: !1,\n                    once: !1,\n                    next: null\n                };\n                y === null ? d.set(c1, R) : y.next = R;\n            }\n        },\n        configurable: !0,\n        enumerable: !0\n    };\n}\nu(defineEventAttributeDescriptor, \"defineEventAttributeDescriptor\");\nfunction defineEventAttribute(c1, l) {\n    Object.defineProperty(c1, `on${l}`, defineEventAttributeDescriptor(l));\n}\nu(defineEventAttribute, \"defineEventAttribute\");\nfunction defineCustomEventTarget(c1) {\n    function l() {\n        EventTarget.call(this);\n    }\n    u(l, \"CustomEventTarget\"), l.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: l,\n            configurable: !0,\n            writable: !0\n        }\n    });\n    for(let d = 0; d < c1.length; ++d)defineEventAttribute(l.prototype, c1[d]);\n    return l;\n}\nu(defineCustomEventTarget, \"defineCustomEventTarget\");\nfunction EventTarget() {\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map);\n        return;\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) return defineCustomEventTarget(arguments[0]);\n    if (arguments.length > 0) {\n        const c1 = new Array(arguments.length);\n        for(let l = 0; l < arguments.length; ++l)c1[l] = arguments[l];\n        return defineCustomEventTarget(c1);\n    }\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nu(EventTarget, \"EventTarget\"), EventTarget.prototype = {\n    addEventListener (c1, l, d) {\n        if (l == null) return;\n        if (typeof l != \"function\" && !isObject(l)) throw new TypeError(\"'listener' should be a function or an object.\");\n        const y = getListeners(this), b = isObject(d), w = (b ? !!d.capture : !!d) ? CAPTURE : BUBBLE, v = {\n            listener: l,\n            listenerType: w,\n            passive: b && !!d.passive,\n            once: b && !!d.once,\n            next: null\n        };\n        let I = y.get(c1);\n        if (I === void 0) {\n            y.set(c1, v);\n            return;\n        }\n        let B = null;\n        for(; I != null;){\n            if (I.listener === l && I.listenerType === w) return;\n            B = I, I = I.next;\n        }\n        B.next = v;\n    },\n    removeEventListener (c1, l, d) {\n        if (l == null) return;\n        const y = getListeners(this), R = (isObject(d) ? !!d.capture : !!d) ? CAPTURE : BUBBLE;\n        let w = null, v = y.get(c1);\n        for(; v != null;){\n            if (v.listener === l && v.listenerType === R) {\n                w !== null ? w.next = v.next : v.next !== null ? y.set(c1, v.next) : y.delete(c1);\n                return;\n            }\n            w = v, v = v.next;\n        }\n    },\n    dispatchEvent (c1) {\n        if (c1 == null || typeof c1.type != \"string\") throw new TypeError('\"event.type\" should be a string.');\n        const l = getListeners(this), d = c1.type;\n        let y = l.get(d);\n        if (y == null) return !0;\n        const b = wrapEvent(this, c1);\n        let R = null;\n        for(; y != null;){\n            if (y.once ? R !== null ? R.next = y.next : y.next !== null ? l.set(d, y.next) : l.delete(d) : R = y, setPassiveListener(b, y.passive ? y.listener : null), typeof y.listener == \"function\") try {\n                y.listener.call(this, b);\n            } catch (w) {\n                typeof console < \"u\" && typeof console.error == \"function\" && console.error(w);\n            }\n            else y.listenerType !== ATTRIBUTE && typeof y.listener.handleEvent == \"function\" && y.listener.handleEvent(b);\n            if (isStopped(b)) break;\n            y = y.next;\n        }\n        return setPassiveListener(b, null), setEventPhase(b, 0), setCurrentTarget(b, null), !b.defaultPrevented;\n    }\n}, Object.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: !0,\n    writable: !0\n}),  false && 0;\nconst an = class an extends EventTarget {\n    constructor(){\n        throw super(), new TypeError(\"AbortSignal cannot be constructed directly\");\n    }\n    get aborted() {\n        const l = abortedFlags.get(this);\n        if (typeof l != \"boolean\") throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? \"null\" : typeof this}`);\n        return l;\n    }\n};\nu(an, \"AbortSignal\");\nlet AbortSignal = an;\ndefineEventAttribute(AbortSignal.prototype, \"abort\");\nfunction createAbortSignal() {\n    const c1 = Object.create(AbortSignal.prototype);\n    return EventTarget.call(c1), abortedFlags.set(c1, !1), c1;\n}\nu(createAbortSignal, \"createAbortSignal\");\nfunction abortSignal(c1) {\n    abortedFlags.get(c1) === !1 && (abortedFlags.set(c1, !0), c1.dispatchEvent({\n        type: \"abort\"\n    }));\n}\nu(abortSignal, \"abortSignal\");\nconst abortedFlags = new WeakMap;\nObject.defineProperties(AbortSignal.prototype, {\n    aborted: {\n        enumerable: !0\n    }\n}), typeof Symbol == \"function\" && typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {\n    configurable: !0,\n    value: \"AbortSignal\"\n});\nlet AbortController$1 = (St = class {\n    constructor(){\n        signals.set(this, createAbortSignal());\n    }\n    get signal() {\n        return getSignal(this);\n    }\n    abort() {\n        abortSignal(getSignal(this));\n    }\n}, u(St, \"AbortController\"), St);\nconst signals = new WeakMap;\nfunction getSignal(c1) {\n    const l = signals.get(c1);\n    if (l == null) throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${c1 === null ? \"null\" : typeof c1}`);\n    return l;\n}\nu(getSignal, \"getSignal\"), Object.defineProperties(AbortController$1.prototype, {\n    signal: {\n        enumerable: !0\n    },\n    abort: {\n        enumerable: !0\n    }\n}), typeof Symbol == \"function\" && typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(AbortController$1.prototype, Symbol.toStringTag, {\n    configurable: !0,\n    value: \"AbortController\"\n});\nvar t = Object.defineProperty, e = u((c1, l)=>t(c1, \"name\", {\n        value: l,\n        configurable: !0\n    }), \"e\");\nconst fetch = fetch$1;\ns();\nfunction s() {\n    !globalThis.process?.versions?.node && !globalThis.process?.env.DISABLE_NODE_FETCH_NATIVE_WARN && console.warn(\"[node-fetch-native] Node.js compatible build of `node-fetch-native` is being used in a non-Node.js environment. Please make sure you are using proper export conditions or report this issue to https://github.com/unjs/node-fetch-native. You can set `process.env.DISABLE_NODE_FETCH_NATIVE_WARN` to disable this warning.\");\n}\nu(s, \"s\"), e(s, \"checkNodeEnvironment\"), exports.AbortController = AbortController$1, exports.AbortError = AbortError, exports.Blob = r$1, exports.FetchError = FetchError, exports.File = File$1, exports.FormData = FormData, exports.Headers = Headers, exports.Request = Request, exports.Response = Response, exports.blobFrom = blobFrom, exports.blobFromSync = blobFromSync, exports[\"default\"] = fetch, exports.fetch = fetch, exports.fileFrom = fileFrom, exports.fileFromSync = fileFromSync, exports.isRedirect = isRedirect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudC9kaXN0L25vZGUuY2pzIiwibWFwcGluZ3MiOiJBQUFhOzs7OztBQUFBLElBQUlBLEtBQUdDLE9BQU9DLGNBQWM7QUFBQyxJQUFJQyxJQUFFLENBQUNDLElBQUVDLElBQUlMLEdBQUdJLElBQUUsUUFBTztRQUFDRSxPQUFNRDtRQUFFRSxjQUFhLENBQUM7SUFBQztBQUFHLElBQUlDLEtBQUcsQ0FBQ0osSUFBRUMsR0FBRUk7SUFBSyxJQUFHLENBQUNKLEVBQUVLLEdBQUcsQ0FBQ04sS0FBRyxNQUFNTyxVQUFVLFlBQVVGO0FBQUU7QUFBRSxJQUFJRyxJQUFFLENBQUNSLElBQUVDLEdBQUVJLElBQUtELENBQUFBLEdBQUdKLElBQUVDLEdBQUUsNEJBQTJCSSxJQUFFQSxFQUFFSSxJQUFJLENBQUNULE1BQUdDLEVBQUVTLEdBQUcsQ0FBQ1YsR0FBQyxHQUFHVyxLQUFHLENBQUNYLElBQUVDLEdBQUVJO0lBQUssSUFBR0osRUFBRUssR0FBRyxDQUFDTixLQUFHLE1BQU1PLFVBQVU7SUFBcUROLGFBQWFXLFVBQVFYLEVBQUVZLEdBQUcsQ0FBQ2IsTUFBR0MsRUFBRWEsR0FBRyxDQUFDZCxJQUFFSztBQUFFLEdBQUVVLEtBQUcsQ0FBQ2YsSUFBRUMsR0FBRUksR0FBRVcsSUFBS1osQ0FBQUEsR0FBR0osSUFBRUMsR0FBRSwyQkFBMEJlLElBQUVBLEVBQUVQLElBQUksQ0FBQ1QsSUFBRUssS0FBR0osRUFBRWEsR0FBRyxDQUFDZCxJQUFFSyxJQUFHQSxDQUFBQTtBQUFHLElBQUlZLElBQUdDLElBQUdDLElBQUdDLElBQUdDLElBQUdDLElBQUdDLElBQUdDLElBQUdDLElBQUdDLElBQUdDLElBQUdDLElBQUdDO0FBQUdoQyw4Q0FBMkM7SUFBQ0ssT0FBTSxDQUFDO0FBQUMsQ0FBQyxFQUFDO0FBQUMsTUFBTTZCLE9BQUtDLG1CQUFPQSxDQUFDLDRCQUFXLEdBQUVDLFFBQU1ELG1CQUFP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Z0JBQWdCLEdBQUM0d0IsVUFBUzV3QixvQkFBb0IsR0FBQ3l3QixjQUFhendCLGtCQUFlLEdBQUNxM0IsT0FBTXIzQixhQUFhLEdBQUNxM0IsT0FBTXIzQixnQkFBZ0IsR0FBQzZ3QixVQUFTN3dCLG9CQUFvQixHQUFDK3dCLGNBQWEvd0Isa0JBQWtCLEdBQUM4c0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlby1lZGl0b3ItYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gtbmF0aXZlLXdpdGgtYWdlbnQvZGlzdC9ub2RlLmNqcz9kNmZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO3ZhciBtcz1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIHU9KGMsbCk9Pm1zKGMsXCJuYW1lXCIse3ZhbHVlOmwsY29uZmlndXJhYmxlOiEwfSk7dmFyIFBvPShjLGwsZCk9PntpZighbC5oYXMoYykpdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiK2QpfTt2YXIgRD0oYyxsLGQpPT4oUG8oYyxsLFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksZD9kLmNhbGwoYyk6bC5nZXQoYykpLHllPShjLGwsZCk9PntpZihsLmhhcyhjKSl0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO2wgaW5zdGFuY2VvZiBXZWFrU2V0P2wuYWRkKGMpOmwuc2V0KGMsZCl9LG5lPShjLGwsZCx5KT0+KFBvKGMsbCxcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIikseT95LmNhbGwoYyxkKTpsLnNldChjLGQpLGQpO3ZhciBQZSxidCxvdCxadCxVZSxtdCx5dCxndCxvZSxfdCxNZSx4ZSxTdDtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBodHRwPXJlcXVpcmUoXCJub2RlOmh0dHBcIiksaHR0cHM9cmVxdWlyZShcIm5vZGU6aHR0cHNcIiksemxpYj1yZXF1aXJlKFwibm9kZTp6bGliXCIpLFN0cmVhbT1yZXF1aXJlKFwibm9kZTpzdHJlYW1cIikscmVxdWlyZSQkNj1yZXF1aXJlKFwibm9kZTpidWZmZXJcIikscmVxdWlyZSQkMD1yZXF1aXJlKFwibm9kZTp1dGlsXCIpLF9jb21tb25qc0hlbHBlcnM9cmVxdWlyZShcIi4vc2hhcmVkL25vZGUtZmV0Y2gtbmF0aXZlLXdpdGgtYWdlbnQuNjE3NThkMTEuY2pzXCIpLHJlcXVpcmUkJDE9cmVxdWlyZShcIm5vZGU6dXJsXCIpLHJlcXVpcmUkJDQ9cmVxdWlyZShcIm5vZGU6bmV0XCIpLG5vZGVfZnM9cmVxdWlyZShcIm5vZGU6ZnNcIiksbm9kZV9wYXRoPXJlcXVpcmUoXCJub2RlOnBhdGhcIik7ZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0Q29tcGF0KGMpe3JldHVybiBjJiZ0eXBlb2YgYz09XCJvYmplY3RcIiYmXCJkZWZhdWx0XCJpbiBjP2MuZGVmYXVsdDpjfXUoX2ludGVyb3BEZWZhdWx0Q29tcGF0LFwiX2ludGVyb3BEZWZhdWx0Q29tcGF0XCIpO2NvbnN0IGh0dHBfX2RlZmF1bHQ9X2ludGVyb3BEZWZhdWx0Q29tcGF0KGh0dHApLGh0dHBzX19kZWZhdWx0PV9pbnRlcm9wRGVmYXVsdENvbXBhdChodHRwcyksemxpYl9fZGVmYXVsdD1faW50ZXJvcERlZmF1bHRDb21wYXQoemxpYiksU3RyZWFtX19kZWZhdWx0PV9pbnRlcm9wRGVmYXVsdENvbXBhdChTdHJlYW0pO2Z1bmN0aW9uIGRhdGFVcmlUb0J1ZmZlcihjKXtpZighL15kYXRhOi9pLnRlc3QoYykpdGhyb3cgbmV3IFR5cGVFcnJvcignYHVyaWAgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgRGF0YSBVUkkgKG11c3QgYmVnaW4gd2l0aCBcImRhdGE6XCIpJyk7Yz1jLnJlcGxhY2UoL1xccj9cXG4vZyxcIlwiKTtjb25zdCBsPWMuaW5kZXhPZihcIixcIik7aWYobD09PS0xfHxsPD00KXRocm93IG5ldyBUeXBlRXJyb3IoXCJtYWxmb3JtZWQgZGF0YTogVVJJXCIpO2NvbnN0IGQ9Yy5zdWJzdHJpbmcoNSxsKS5zcGxpdChcIjtcIik7bGV0IHk9XCJcIixiPSExO2NvbnN0IFI9ZFswXXx8XCJ0ZXh0L3BsYWluXCI7bGV0IHc9Ujtmb3IobGV0IEY9MTtGPGQubGVuZ3RoO0YrKylkW0ZdPT09XCJiYXNlNjRcIj9iPSEwOmRbRl0mJih3Kz1gOyR7ZFtGXX1gLGRbRl0uaW5kZXhPZihcImNoYXJzZXQ9XCIpPT09MCYmKHk9ZFtGXS5zdWJzdHJpbmcoOCkpKTshZFswXSYmIXkubGVuZ3RoJiYodys9XCI7Y2hhcnNldD1VUy1BU0NJSVwiLHk9XCJVUy1BU0NJSVwiKTtjb25zdCB2PWI/XCJiYXNlNjRcIjpcImFzY2lpXCIsST11bmVzY2FwZShjLnN1YnN0cmluZyhsKzEpKSxCPUJ1ZmZlci5mcm9tKEksdik7cmV0dXJuIEIudHlwZT1SLEIudHlwZUZ1bGw9dyxCLmNoYXJzZXQ9eSxCfXUoZGF0YVVyaVRvQnVmZmVyLFwiZGF0YVVyaVRvQnVmZmVyXCIpO3ZhciBwb255ZmlsbF9lczIwMTg9e2V4cG9ydHM6e319Oy8qKlxuICogQGxpY2Vuc2VcbiAqIHdlYi1zdHJlYW1zLXBvbHlmaWxsIHYzLjMuM1xuICogQ29weXJpZ2h0IDIwMjQgTWF0dGlhcyBCdWVsZW5zLCBEaXdhbmsgU2luZ2ggVG9tZXIgYW5kIG90aGVyIGNvbnRyaWJ1dG9ycy5cbiAqIFRoaXMgY29kZSBpcyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4gKi92YXIgaGFzUmVxdWlyZWRQb255ZmlsbF9lczIwMTg7ZnVuY3Rpb24gcmVxdWlyZVBvbnlmaWxsX2VzMjAxOCgpe3JldHVybiBoYXNSZXF1aXJlZFBvbnlmaWxsX2VzMjAxOHx8KGhhc1JlcXVpcmVkUG9ueWZpbGxfZXMyMDE4PTEsZnVuY3Rpb24oYyxsKXsoZnVuY3Rpb24oZCx5KXt5KGwpfSkoX2NvbW1vbmpzSGVscGVycy5jb21tb25qc0dsb2JhbCxmdW5jdGlvbihkKXtmdW5jdGlvbiB5KCl7fXUoeSxcIm5vb3BcIik7ZnVuY3Rpb24gYihuKXtyZXR1cm4gdHlwZW9mIG49PVwib2JqZWN0XCImJm4hPT1udWxsfHx0eXBlb2Ygbj09XCJmdW5jdGlvblwifXUoYixcInR5cGVJc09iamVjdFwiKTtjb25zdCBSPXk7ZnVuY3Rpb24gdyhuLG8pe3RyeXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIm5hbWVcIix7dmFsdWU6byxjb25maWd1cmFibGU6ITB9KX1jYXRjaHt9fXUodyxcInNldEZ1bmN0aW9uTmFtZVwiKTtjb25zdCB2PVByb21pc2UsST1Qcm9taXNlLnByb3RvdHlwZS50aGVuLEI9UHJvbWlzZS5yZWplY3QuYmluZCh2KTtmdW5jdGlvbiBGKG4pe3JldHVybiBuZXcgdihuKX11KEYsXCJuZXdQcm9taXNlXCIpO2Z1bmN0aW9uIGsobil7cmV0dXJuIEYobz0+byhuKSl9dShrLFwicHJvbWlzZVJlc29sdmVkV2l0aFwiKTtmdW5jdGlvbiBUKG4pe3JldHVybiBCKG4pfXUoVCxcInByb21pc2VSZWplY3RlZFdpdGhcIik7ZnVuY3Rpb24gJChuLG8sYSl7cmV0dXJuIEkuY2FsbChuLG8sYSl9dSgkLFwiUGVyZm9ybVByb21pc2VUaGVuXCIpO2Z1bmN0aW9uIEUobixvLGEpeyQoJChuLG8sYSksdm9pZCAwLFIpfXUoRSxcInVwb25Qcm9taXNlXCIpO2Z1bmN0aW9uIEsobixvKXtFKG4sbyl9dShLLFwidXBvbkZ1bGZpbGxtZW50XCIpO2Z1bmN0aW9uIFUobixvKXtFKG4sdm9pZCAwLG8pfXUoVSxcInVwb25SZWplY3Rpb25cIik7ZnVuY3Rpb24gTihuLG8sYSl7cmV0dXJuICQobixvLGEpfXUoTixcInRyYW5zZm9ybVByb21pc2VXaXRoXCIpO2Z1bmN0aW9uIEoobil7JChuLHZvaWQgMCxSKX11KEosXCJzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlXCIpO2xldCBnZT11KG49PntpZih0eXBlb2YgcXVldWVNaWNyb3Rhc2s9PVwiZnVuY3Rpb25cIilnZT1xdWV1ZU1pY3JvdGFzaztlbHNle2NvbnN0IG89ayh2b2lkIDApO2dlPXUoYT0+JChvLGEpLFwiX3F1ZXVlTWljcm90YXNrXCIpfXJldHVybiBnZShuKX0sXCJfcXVldWVNaWNyb3Rhc2tcIik7ZnVuY3Rpb24gTShuLG8sYSl7aWYodHlwZW9mIG4hPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGEgZnVuY3Rpb25cIik7cmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKG4sbyxhKX11KE0sXCJyZWZsZWN0Q2FsbFwiKTtmdW5jdGlvbiBIKG4sbyxhKXt0cnl7cmV0dXJuIGsoTShuLG8sYSkpfWNhdGNoKHApe3JldHVybiBUKHApfX11KEgsXCJwcm9taXNlQ2FsbFwiKTtjb25zdCBHPTE2Mzg0LERyPWNsYXNzIERye2NvbnN0cnVjdG9yKCl7dGhpcy5fY3Vyc29yPTAsdGhpcy5fc2l6ZT0wLHRoaXMuX2Zyb250PXtfZWxlbWVudHM6W10sX25leHQ6dm9pZCAwfSx0aGlzLl9iYWNrPXRoaXMuX2Zyb250LHRoaXMuX2N1cnNvcj0wLHRoaXMuX3NpemU9MH1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuX3NpemV9cHVzaChvKXtjb25zdCBhPXRoaXMuX2JhY2s7bGV0IHA9YTthLl9lbGVtZW50cy5sZW5ndGg9PT1HLTEmJihwPXtfZWxlbWVudHM6W10sX25leHQ6dm9pZCAwfSksYS5fZWxlbWVudHMucHVzaChvKSxwIT09YSYmKHRoaXMuX2JhY2s9cCxhLl9uZXh0PXApLCsrdGhpcy5fc2l6ZX1zaGlmdCgpe2NvbnN0IG89dGhpcy5fZnJvbnQ7bGV0IGE9bztjb25zdCBwPXRoaXMuX2N1cnNvcjtsZXQgZz1wKzE7Y29uc3QgXz1vLl9lbGVtZW50cyxTPV9bcF07cmV0dXJuIGc9PT1HJiYoYT1vLl9uZXh0LGc9MCksLS10aGlzLl9zaXplLHRoaXMuX2N1cnNvcj1nLG8hPT1hJiYodGhpcy5fZnJvbnQ9YSksX1twXT12b2lkIDAsU31mb3JFYWNoKG8pe2xldCBhPXRoaXMuX2N1cnNvcixwPXRoaXMuX2Zyb250LGc9cC5fZWxlbWVudHM7Zm9yKDsoYSE9PWcubGVuZ3RofHxwLl9uZXh0IT09dm9pZCAwKSYmIShhPT09Zy5sZW5ndGgmJihwPXAuX25leHQsZz1wLl9lbGVtZW50cyxhPTAsZy5sZW5ndGg9PT0wKSk7KW8oZ1thXSksKythfXBlZWsoKXtjb25zdCBvPXRoaXMuX2Zyb250LGE9dGhpcy5fY3Vyc29yO3JldHVybiBvLl9lbGVtZW50c1thXX19O3UoRHIsXCJTaW1wbGVRdWV1ZVwiKTtsZXQgUT1Ecjtjb25zdCB3dD1TeW1ib2woXCJbW0Fib3J0U3RlcHNdXVwiKSx1bj1TeW1ib2woXCJbW0Vycm9yU3RlcHNdXVwiKSxlcj1TeW1ib2woXCJbW0NhbmNlbFN0ZXBzXV1cIiksdHI9U3ltYm9sKFwiW1tQdWxsU3RlcHNdXVwiKSxycj1TeW1ib2woXCJbW1JlbGVhc2VTdGVwc11dXCIpO2Z1bmN0aW9uIGxuKG4sbyl7bi5fb3duZXJSZWFkYWJsZVN0cmVhbT1vLG8uX3JlYWRlcj1uLG8uX3N0YXRlPT09XCJyZWFkYWJsZVwiP29yKG4pOm8uX3N0YXRlPT09XCJjbG9zZWRcIj92byhuKTpmbihuLG8uX3N0b3JlZEVycm9yKX11KGxuLFwiUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZVwiKTtmdW5jdGlvbiBucihuLG8pe2NvbnN0IGE9bi5fb3duZXJSZWFkYWJsZVN0cmVhbTtyZXR1cm4gbGUoYSxvKX11KG5yLFwiUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsXCIpO2Z1bmN0aW9uIF9lKG4pe2NvbnN0IG89bi5fb3duZXJSZWFkYWJsZVN0cmVhbTtvLl9zdGF0ZT09PVwicmVhZGFibGVcIj9pcihuLG5ldyBUeXBlRXJyb3IoXCJSZWFkZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc1wiKSk6RW8obixuZXcgVHlwZUVycm9yKFwiUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NcIikpLG8uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltycl0oKSxvLl9yZWFkZXI9dm9pZCAwLG4uX293bmVyUmVhZGFibGVTdHJlYW09dm9pZCAwfXUoX2UsXCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlXCIpO2Z1bmN0aW9uIFJ0KG4pe3JldHVybiBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IFwiK24rXCIgYSBzdHJlYW0gdXNpbmcgYSByZWxlYXNlZCByZWFkZXJcIil9dShSdCxcInJlYWRlckxvY2tFeGNlcHRpb25cIik7ZnVuY3Rpb24gb3Iobil7bi5fY2xvc2VkUHJvbWlzZT1GKChvLGEpPT57bi5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlPW8sbi5fY2xvc2VkUHJvbWlzZV9yZWplY3Q9YX0pfXUob3IsXCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVcIik7ZnVuY3Rpb24gZm4obixvKXtvcihuKSxpcihuLG8pfXUoZm4sXCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkXCIpO2Z1bmN0aW9uIHZvKG4pe29yKG4pLGNuKG4pfXUodm8sXCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkXCIpO2Z1bmN0aW9uIGlyKG4sbyl7bi5fY2xvc2VkUHJvbWlzZV9yZWplY3QhPT12b2lkIDAmJihKKG4uX2Nsb3NlZFByb21pc2UpLG4uX2Nsb3NlZFByb21pc2VfcmVqZWN0KG8pLG4uX2Nsb3NlZFByb21pc2VfcmVzb2x2ZT12b2lkIDAsbi5fY2xvc2VkUHJvbWlzZV9yZWplY3Q9dm9pZCAwKX11KGlyLFwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3RcIik7ZnVuY3Rpb24gRW8obixvKXtmbihuLG8pfXUoRW8sXCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZFwiKTtmdW5jdGlvbiBjbihuKXtuLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUhPT12b2lkIDAmJihuLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodm9pZCAwKSxuLl9jbG9zZWRQcm9taXNlX3Jlc29sdmU9dm9pZCAwLG4uX2Nsb3NlZFByb21pc2VfcmVqZWN0PXZvaWQgMCl9dShjbixcImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZVwiKTtjb25zdCBkbj1OdW1iZXIuaXNGaW5pdGV8fGZ1bmN0aW9uKG4pe3JldHVybiB0eXBlb2Ygbj09XCJudW1iZXJcIiYmaXNGaW5pdGUobil9LEFvPU1hdGgudHJ1bmN8fGZ1bmN0aW9uKG4pe3JldHVybiBuPDA/TWF0aC5jZWlsKG4pOk1hdGguZmxvb3Iobil9O2Z1bmN0aW9uIEJvKG4pe3JldHVybiB0eXBlb2Ygbj09XCJvYmplY3RcInx8dHlwZW9mIG49PVwiZnVuY3Rpb25cIn11KEJvLFwiaXNEaWN0aW9uYXJ5XCIpO2Z1bmN0aW9uIGNlKG4sbyl7aWYobiE9PXZvaWQgMCYmIUJvKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7b30gaXMgbm90IGFuIG9iamVjdC5gKX11KGNlLFwiYXNzZXJ0RGljdGlvbmFyeVwiKTtmdW5jdGlvbiBlZShuLG8pe2lmKHR5cGVvZiBuIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtvfSBpcyBub3QgYSBmdW5jdGlvbi5gKX11KGVlLFwiYXNzZXJ0RnVuY3Rpb25cIik7ZnVuY3Rpb24gcW8obil7cmV0dXJuIHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbHx8dHlwZW9mIG49PVwiZnVuY3Rpb25cIn11KHFvLFwiaXNPYmplY3RcIik7ZnVuY3Rpb24gaG4obixvKXtpZighcW8obikpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtvfSBpcyBub3QgYW4gb2JqZWN0LmApfXUoaG4sXCJhc3NlcnRPYmplY3RcIik7ZnVuY3Rpb24gU2UobixvLGEpe2lmKG49PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICR7b30gaXMgcmVxdWlyZWQgaW4gJyR7YX0nLmApfXUoU2UsXCJhc3NlcnRSZXF1aXJlZEFyZ3VtZW50XCIpO2Z1bmN0aW9uIHNyKG4sbyxhKXtpZihuPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7b30gaXMgcmVxdWlyZWQgaW4gJyR7YX0nLmApfXUoc3IsXCJhc3NlcnRSZXF1aXJlZEZpZWxkXCIpO2Z1bmN0aW9uIGFyKG4pe3JldHVybiBOdW1iZXIobil9dShhcixcImNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGVcIik7ZnVuY3Rpb24gcG4obil7cmV0dXJuIG49PT0wPzA6bn11KHBuLFwiY2Vuc29yTmVnYXRpdmVaZXJvXCIpO2Z1bmN0aW9uIGtvKG4pe3JldHVybiBwbihBbyhuKSl9dShrbyxcImludGVnZXJQYXJ0XCIpO2Z1bmN0aW9uIHVyKG4sbyl7Y29uc3QgcD1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtsZXQgZz1OdW1iZXIobik7aWYoZz1wbihnKSwhZG4oZykpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtvfSBpcyBub3QgYSBmaW5pdGUgbnVtYmVyYCk7aWYoZz1rbyhnKSxnPDB8fGc+cCl0aHJvdyBuZXcgVHlwZUVycm9yKGAke299IGlzIG91dHNpZGUgdGhlIGFjY2VwdGVkIHJhbmdlIG9mIDAgdG8gJHtwfSwgaW5jbHVzaXZlYCk7cmV0dXJuIWRuKGcpfHxnPT09MD8wOmd9dSh1cixcImNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZVwiKTtmdW5jdGlvbiBscihuLG8pe2lmKCFxZShuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke299IGlzIG5vdCBhIFJlYWRhYmxlU3RyZWFtLmApfXUobHIsXCJhc3NlcnRSZWFkYWJsZVN0cmVhbVwiKTtmdW5jdGlvbiBOZShuKXtyZXR1cm4gbmV3IGRlKG4pfXUoTmUsXCJBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyXCIpO2Z1bmN0aW9uIGJuKG4sbyl7bi5fcmVhZGVyLl9yZWFkUmVxdWVzdHMucHVzaChvKX11KGJuLFwiUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdFwiKTtmdW5jdGlvbiBmcihuLG8sYSl7Y29uc3QgZz1uLl9yZWFkZXIuX3JlYWRSZXF1ZXN0cy5zaGlmdCgpO2E/Zy5fY2xvc2VTdGVwcygpOmcuX2NodW5rU3RlcHMobyl9dShmcixcIlJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0XCIpO2Z1bmN0aW9uIFR0KG4pe3JldHVybiBuLl9yZWFkZXIuX3JlYWRSZXF1ZXN0cy5sZW5ndGh9dShUdCxcIlJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzXCIpO2Z1bmN0aW9uIG1uKG4pe2NvbnN0IG89bi5fcmVhZGVyO3JldHVybiEobz09PXZvaWQgMHx8IXZlKG8pKX11KG1uLFwiUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyXCIpO2NvbnN0IE1yPWNsYXNzIE1ye2NvbnN0cnVjdG9yKG8pe2lmKFNlKG8sMSxcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclwiKSxscihvLFwiRmlyc3QgcGFyYW1ldGVyXCIpLGtlKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHJlYWRpbmcgYnkgYW5vdGhlciByZWFkZXJcIik7bG4odGhpcyxvKSx0aGlzLl9yZWFkUmVxdWVzdHM9bmV3IFF9Z2V0IGNsb3NlZCgpe3JldHVybiB2ZSh0aGlzKT90aGlzLl9jbG9zZWRQcm9taXNlOlQoQ3QoXCJjbG9zZWRcIikpfWNhbmNlbChvPXZvaWQgMCl7cmV0dXJuIHZlKHRoaXMpP3RoaXMuX293bmVyUmVhZGFibGVTdHJlYW09PT12b2lkIDA/VChSdChcImNhbmNlbFwiKSk6bnIodGhpcyxvKTpUKEN0KFwiY2FuY2VsXCIpKX1yZWFkKCl7aWYoIXZlKHRoaXMpKXJldHVybiBUKEN0KFwicmVhZFwiKSk7aWYodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbT09PXZvaWQgMClyZXR1cm4gVChSdChcInJlYWQgZnJvbVwiKSk7bGV0IG8sYTtjb25zdCBwPUYoKF8sUyk9PntvPV8sYT1TfSk7cmV0dXJuIGl0KHRoaXMse19jaHVua1N0ZXBzOl89Pm8oe3ZhbHVlOl8sZG9uZTohMX0pLF9jbG9zZVN0ZXBzOigpPT5vKHt2YWx1ZTp2b2lkIDAsZG9uZTohMH0pLF9lcnJvclN0ZXBzOl89PmEoXyl9KSxwfXJlbGVhc2VMb2NrKCl7aWYoIXZlKHRoaXMpKXRocm93IEN0KFwicmVsZWFzZUxvY2tcIik7dGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSE9PXZvaWQgMCYmV28odGhpcyl9fTt1KE1yLFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyXCIpO2xldCBkZT1NcjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhkZS5wcm90b3R5cGUse2NhbmNlbDp7ZW51bWVyYWJsZTohMH0scmVhZDp7ZW51bWVyYWJsZTohMH0scmVsZWFzZUxvY2s6e2VudW1lcmFibGU6ITB9LGNsb3NlZDp7ZW51bWVyYWJsZTohMH19KSx3KGRlLnByb3RvdHlwZS5jYW5jZWwsXCJjYW5jZWxcIiksdyhkZS5wcm90b3R5cGUucmVhZCxcInJlYWRcIiksdyhkZS5wcm90b3R5cGUucmVsZWFzZUxvY2ssXCJyZWxlYXNlTG9ja1wiKSx0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT1cInN5bWJvbFwiJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZGUucHJvdG90eXBlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJcIixjb25maWd1cmFibGU6ITB9KTtmdW5jdGlvbiB2ZShuKXtyZXR1cm4hYihuKXx8IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLFwiX3JlYWRSZXF1ZXN0c1wiKT8hMTpuIGluc3RhbmNlb2YgZGV9dSh2ZSxcIklzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyXCIpO2Z1bmN0aW9uIGl0KG4sbyl7Y29uc3QgYT1uLl9vd25lclJlYWRhYmxlU3RyZWFtO2EuX2Rpc3R1cmJlZD0hMCxhLl9zdGF0ZT09PVwiY2xvc2VkXCI/by5fY2xvc2VTdGVwcygpOmEuX3N0YXRlPT09XCJlcnJvcmVkXCI/by5fZXJyb3JTdGVwcyhhLl9zdG9yZWRFcnJvcik6YS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW3RyXShvKX11KGl0LFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZFwiKTtmdW5jdGlvbiBXbyhuKXtfZShuKTtjb25zdCBvPW5ldyBUeXBlRXJyb3IoXCJSZWFkZXIgd2FzIHJlbGVhc2VkXCIpO3luKG4sbyl9dShXbyxcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlbGVhc2VcIik7ZnVuY3Rpb24geW4obixvKXtjb25zdCBhPW4uX3JlYWRSZXF1ZXN0cztuLl9yZWFkUmVxdWVzdHM9bmV3IFEsYS5mb3JFYWNoKHA9PntwLl9lcnJvclN0ZXBzKG8pfSl9dSh5bixcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlckVycm9yUmVhZFJlcXVlc3RzXCIpO2Z1bmN0aW9uIEN0KG4pe3JldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLiR7bn0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcmApfXUoQ3QsXCJkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvblwiKTtjb25zdCBPbz1PYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKGFzeW5jIGZ1bmN0aW9uKigpe30pLnByb3RvdHlwZSkseHI9Y2xhc3MgeHJ7Y29uc3RydWN0b3IobyxhKXt0aGlzLl9vbmdvaW5nUHJvbWlzZT12b2lkIDAsdGhpcy5faXNGaW5pc2hlZD0hMSx0aGlzLl9yZWFkZXI9byx0aGlzLl9wcmV2ZW50Q2FuY2VsPWF9bmV4dCgpe2NvbnN0IG89dSgoKT0+dGhpcy5fbmV4dFN0ZXBzKCksXCJuZXh0U3RlcHNcIik7cmV0dXJuIHRoaXMuX29uZ29pbmdQcm9taXNlPXRoaXMuX29uZ29pbmdQcm9taXNlP04odGhpcy5fb25nb2luZ1Byb21pc2UsbyxvKTpvKCksdGhpcy5fb25nb2luZ1Byb21pc2V9cmV0dXJuKG8pe2NvbnN0IGE9dSgoKT0+dGhpcy5fcmV0dXJuU3RlcHMobyksXCJyZXR1cm5TdGVwc1wiKTtyZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2U/Tih0aGlzLl9vbmdvaW5nUHJvbWlzZSxhLGEpOmEoKX1fbmV4dFN0ZXBzKCl7aWYodGhpcy5faXNGaW5pc2hlZClyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt2YWx1ZTp2b2lkIDAsZG9uZTohMH0pO2NvbnN0IG89dGhpcy5fcmVhZGVyO2xldCBhLHA7Y29uc3QgZz1GKChTLEMpPT57YT1TLHA9Q30pO3JldHVybiBpdChvLHtfY2h1bmtTdGVwczpTPT57dGhpcy5fb25nb2luZ1Byb21pc2U9dm9pZCAwLGdlKCgpPT5hKHt2YWx1ZTpTLGRvbmU6ITF9KSl9LF9jbG9zZVN0ZXBzOigpPT57dGhpcy5fb25nb2luZ1Byb21pc2U9dm9pZCAwLHRoaXMuX2lzRmluaXNoZWQ9ITAsX2UobyksYSh7dmFsdWU6dm9pZCAwLGRvbmU6ITB9KX0sX2Vycm9yU3RlcHM6Uz0+e3RoaXMuX29uZ29pbmdQcm9taXNlPXZvaWQgMCx0aGlzLl9pc0ZpbmlzaGVkPSEwLF9lKG8pLHAoUyl9fSksZ31fcmV0dXJuU3RlcHMobyl7aWYodGhpcy5faXNGaW5pc2hlZClyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt2YWx1ZTpvLGRvbmU6ITB9KTt0aGlzLl9pc0ZpbmlzaGVkPSEwO2NvbnN0IGE9dGhpcy5fcmVhZGVyO2lmKCF0aGlzLl9wcmV2ZW50Q2FuY2VsKXtjb25zdCBwPW5yKGEsbyk7cmV0dXJuIF9lKGEpLE4ocCwoKT0+KHt2YWx1ZTpvLGRvbmU6ITB9KSl9cmV0dXJuIF9lKGEpLGsoe3ZhbHVlOm8sZG9uZTohMH0pfX07dSh4cixcIlJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGxcIik7bGV0IFB0PXhyO2NvbnN0IGduPXtuZXh0KCl7cmV0dXJuIF9uKHRoaXMpP3RoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLm5leHQoKTpUKFNuKFwibmV4dFwiKSl9LHJldHVybihuKXtyZXR1cm4gX24odGhpcyk/dGhpcy5fYXN5bmNJdGVyYXRvckltcGwucmV0dXJuKG4pOlQoU24oXCJyZXR1cm5cIikpfX07T2JqZWN0LnNldFByb3RvdHlwZU9mKGduLE9vKTtmdW5jdGlvbiB6byhuLG8pe2NvbnN0IGE9TmUobikscD1uZXcgUHQoYSxvKSxnPU9iamVjdC5jcmVhdGUoZ24pO3JldHVybiBnLl9hc3luY0l0ZXJhdG9ySW1wbD1wLGd9dSh6byxcIkFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JcIik7ZnVuY3Rpb24gX24obil7aWYoIWIobil8fCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixcIl9hc3luY0l0ZXJhdG9ySW1wbFwiKSlyZXR1cm4hMTt0cnl7cmV0dXJuIG4uX2FzeW5jSXRlcmF0b3JJbXBsIGluc3RhbmNlb2YgUHR9Y2F0Y2h7cmV0dXJuITF9fXUoX24sXCJJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclwiKTtmdW5jdGlvbiBTbihuKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yLiR7bn0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RlYW1Bc3luY0l0ZXJhdG9yYCl9dShTbixcInN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uXCIpO2NvbnN0IHduPU51bWJlci5pc05hTnx8ZnVuY3Rpb24obil7cmV0dXJuIG4hPT1ufTt2YXIgY3IsZHIsaHI7ZnVuY3Rpb24gc3Qobil7cmV0dXJuIG4uc2xpY2UoKX11KHN0LFwiQ3JlYXRlQXJyYXlGcm9tTGlzdFwiKTtmdW5jdGlvbiBSbihuLG8sYSxwLGcpe25ldyBVaW50OEFycmF5KG4pLnNldChuZXcgVWludDhBcnJheShhLHAsZyksbyl9dShSbixcIkNvcHlEYXRhQmxvY2tCeXRlc1wiKTtsZXQgd2U9dShuPT4odHlwZW9mIG4udHJhbnNmZXI9PVwiZnVuY3Rpb25cIj93ZT11KG89Pm8udHJhbnNmZXIoKSxcIlRyYW5zZmVyQXJyYXlCdWZmZXJcIik6dHlwZW9mIHN0cnVjdHVyZWRDbG9uZT09XCJmdW5jdGlvblwiP3dlPXUobz0+c3RydWN0dXJlZENsb25lKG8se3RyYW5zZmVyOltvXX0pLFwiVHJhbnNmZXJBcnJheUJ1ZmZlclwiKTp3ZT11KG89Pm8sXCJUcmFuc2ZlckFycmF5QnVmZmVyXCIpLHdlKG4pKSxcIlRyYW5zZmVyQXJyYXlCdWZmZXJcIiksRWU9dShuPT4odHlwZW9mIG4uZGV0YWNoZWQ9PVwiYm9vbGVhblwiP0VlPXUobz0+by5kZXRhY2hlZCxcIklzRGV0YWNoZWRCdWZmZXJcIik6RWU9dShvPT5vLmJ5dGVMZW5ndGg9PT0wLFwiSXNEZXRhY2hlZEJ1ZmZlclwiKSxFZShuKSksXCJJc0RldGFjaGVkQnVmZmVyXCIpO2Z1bmN0aW9uIFRuKG4sbyxhKXtpZihuLnNsaWNlKXJldHVybiBuLnNsaWNlKG8sYSk7Y29uc3QgcD1hLW8sZz1uZXcgQXJyYXlCdWZmZXIocCk7cmV0dXJuIFJuKGcsMCxuLG8scCksZ311KFRuLFwiQXJyYXlCdWZmZXJTbGljZVwiKTtmdW5jdGlvbiB2dChuLG8pe2NvbnN0IGE9bltvXTtpZihhIT1udWxsKXtpZih0eXBlb2YgYSE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7U3RyaW5nKG8pfSBpcyBub3QgYSBmdW5jdGlvbmApO3JldHVybiBhfX11KHZ0LFwiR2V0TWV0aG9kXCIpO2Z1bmN0aW9uIEZvKG4pe2NvbnN0IG89e1tTeW1ib2wuaXRlcmF0b3JdOigpPT5uLml0ZXJhdG9yfSxhPWFzeW5jIGZ1bmN0aW9uKigpe3JldHVybiB5aWVsZCpvfSgpLHA9YS5uZXh0O3JldHVybntpdGVyYXRvcjphLG5leHRNZXRob2Q6cCxkb25lOiExfX11KEZvLFwiQ3JlYXRlQXN5bmNGcm9tU3luY0l0ZXJhdG9yXCIpO2NvbnN0IHByPShocj0oY3I9U3ltYm9sLmFzeW5jSXRlcmF0b3IpIT09bnVsbCYmY3IhPT12b2lkIDA/Y3I6KGRyPVN5bWJvbC5mb3IpPT09bnVsbHx8ZHI9PT12b2lkIDA/dm9pZCAwOmRyLmNhbGwoU3ltYm9sLFwiU3ltYm9sLmFzeW5jSXRlcmF0b3JcIikpIT09bnVsbCYmaHIhPT12b2lkIDA/aHI6XCJAQGFzeW5jSXRlcmF0b3JcIjtmdW5jdGlvbiBDbihuLG89XCJzeW5jXCIsYSl7aWYoYT09PXZvaWQgMClpZihvPT09XCJhc3luY1wiKXtpZihhPXZ0KG4scHIpLGE9PT12b2lkIDApe2NvbnN0IF89dnQobixTeW1ib2wuaXRlcmF0b3IpLFM9Q24obixcInN5bmNcIixfKTtyZXR1cm4gRm8oUyl9fWVsc2UgYT12dChuLFN5bWJvbC5pdGVyYXRvcik7aWYoYT09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIG9iamVjdCBpcyBub3QgaXRlcmFibGVcIik7Y29uc3QgcD1NKGEsbixbXSk7aWYoIWIocCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBtZXRob2QgbXVzdCByZXR1cm4gYW4gb2JqZWN0XCIpO2NvbnN0IGc9cC5uZXh0O3JldHVybntpdGVyYXRvcjpwLG5leHRNZXRob2Q6Zyxkb25lOiExfX11KENuLFwiR2V0SXRlcmF0b3JcIik7ZnVuY3Rpb24gSW8obil7Y29uc3Qgbz1NKG4ubmV4dE1ldGhvZCxuLml0ZXJhdG9yLFtdKTtpZighYihvKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yLm5leHQoKSBtZXRob2QgbXVzdCByZXR1cm4gYW4gb2JqZWN0XCIpO3JldHVybiBvfXUoSW8sXCJJdGVyYXRvck5leHRcIik7ZnVuY3Rpb24gam8obil7cmV0dXJuISFuLmRvbmV9dShqbyxcIkl0ZXJhdG9yQ29tcGxldGVcIik7ZnVuY3Rpb24gTG8obil7cmV0dXJuIG4udmFsdWV9dShMbyxcIkl0ZXJhdG9yVmFsdWVcIik7ZnVuY3Rpb24gJG8obil7cmV0dXJuISh0eXBlb2YgbiE9XCJudW1iZXJcInx8d24obil8fG48MCl9dSgkbyxcIklzTm9uTmVnYXRpdmVOdW1iZXJcIik7ZnVuY3Rpb24gUG4obil7Y29uc3Qgbz1UbihuLmJ1ZmZlcixuLmJ5dGVPZmZzZXQsbi5ieXRlT2Zmc2V0K24uYnl0ZUxlbmd0aCk7cmV0dXJuIG5ldyBVaW50OEFycmF5KG8pfXUoUG4sXCJDbG9uZUFzVWludDhBcnJheVwiKTtmdW5jdGlvbiBicihuKXtjb25zdCBvPW4uX3F1ZXVlLnNoaWZ0KCk7cmV0dXJuIG4uX3F1ZXVlVG90YWxTaXplLT1vLnNpemUsbi5fcXVldWVUb3RhbFNpemU8MCYmKG4uX3F1ZXVlVG90YWxTaXplPTApLG8udmFsdWV9dShicixcIkRlcXVldWVWYWx1ZVwiKTtmdW5jdGlvbiBtcihuLG8sYSl7aWYoISRvKGEpfHxhPT09MS8wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiU2l6ZSBtdXN0IGJlIGEgZmluaXRlLCBub24tTmFOLCBub24tbmVnYXRpdmUgbnVtYmVyLlwiKTtuLl9xdWV1ZS5wdXNoKHt2YWx1ZTpvLHNpemU6YX0pLG4uX3F1ZXVlVG90YWxTaXplKz1hfXUobXIsXCJFbnF1ZXVlVmFsdWVXaXRoU2l6ZVwiKTtmdW5jdGlvbiBEbyhuKXtyZXR1cm4gbi5fcXVldWUucGVlaygpLnZhbHVlfXUoRG8sXCJQZWVrUXVldWVWYWx1ZVwiKTtmdW5jdGlvbiBBZShuKXtuLl9xdWV1ZT1uZXcgUSxuLl9xdWV1ZVRvdGFsU2l6ZT0wfXUoQWUsXCJSZXNldFF1ZXVlXCIpO2Z1bmN0aW9uIHZuKG4pe3JldHVybiBuPT09RGF0YVZpZXd9dSh2bixcImlzRGF0YVZpZXdDb25zdHJ1Y3RvclwiKTtmdW5jdGlvbiBNbyhuKXtyZXR1cm4gdm4obi5jb25zdHJ1Y3Rvcil9dShNbyxcImlzRGF0YVZpZXdcIik7ZnVuY3Rpb24geG8obil7cmV0dXJuIHZuKG4pPzE6bi5CWVRFU19QRVJfRUxFTUVOVH11KHhvLFwiYXJyYXlCdWZmZXJWaWV3RWxlbWVudFNpemVcIik7Y29uc3QgVXI9Y2xhc3MgVXJ7Y29uc3RydWN0b3IoKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBjb25zdHJ1Y3RvclwiKX1nZXQgdmlldygpe2lmKCF5cih0aGlzKSl0aHJvdyBScihcInZpZXdcIik7cmV0dXJuIHRoaXMuX3ZpZXd9cmVzcG9uZChvKXtpZigheXIodGhpcykpdGhyb3cgUnIoXCJyZXNwb25kXCIpO2lmKFNlKG8sMSxcInJlc3BvbmRcIiksbz11cihvLFwiRmlyc3QgcGFyYW1ldGVyXCIpLHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGlzIEJZT0IgcmVxdWVzdCBoYXMgYmVlbiBpbnZhbGlkYXRlZFwiKTtpZihFZSh0aGlzLl92aWV3LmJ1ZmZlcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBCWU9CIHJlcXVlc3QncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSB1c2VkIGFzIGEgcmVzcG9uc2VcIik7cXQodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsbyl9cmVzcG9uZFdpdGhOZXdWaWV3KG8pe2lmKCF5cih0aGlzKSl0aHJvdyBScihcInJlc3BvbmRXaXRoTmV3Vmlld1wiKTtpZihTZShvLDEsXCJyZXNwb25kV2l0aE5ld1ZpZXdcIiksIUFycmF5QnVmZmVyLmlzVmlldyhvKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IGNhbiBvbmx5IHJlc3BvbmQgd2l0aCBhcnJheSBidWZmZXIgdmlld3NcIik7aWYodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkXCIpO2lmKEVlKG8uYnVmZmVyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGdpdmVuIHZpZXcncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSB1c2VkIGFzIGEgcmVzcG9uc2VcIik7a3QodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsbyl9fTt1KFVyLFwiUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdFwiKTtsZXQgUmU9VXI7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmUucHJvdG90eXBlLHtyZXNwb25kOntlbnVtZXJhYmxlOiEwfSxyZXNwb25kV2l0aE5ld1ZpZXc6e2VudW1lcmFibGU6ITB9LHZpZXc6e2VudW1lcmFibGU6ITB9fSksdyhSZS5wcm90b3R5cGUucmVzcG9uZCxcInJlc3BvbmRcIiksdyhSZS5wcm90b3R5cGUucmVzcG9uZFdpdGhOZXdWaWV3LFwicmVzcG9uZFdpdGhOZXdWaWV3XCIpLHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PVwic3ltYm9sXCImJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZS5wcm90b3R5cGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIlJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3RcIixjb25maWd1cmFibGU6ITB9KTtjb25zdCBOcj1jbGFzcyBOcntjb25zdHJ1Y3Rvcigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNvbnN0cnVjdG9yXCIpfWdldCBieW9iUmVxdWVzdCgpe2lmKCFPZSh0aGlzKSl0aHJvdyB1dChcImJ5b2JSZXF1ZXN0XCIpO3JldHVybiB3cih0aGlzKX1nZXQgZGVzaXJlZFNpemUoKXtpZighT2UodGhpcykpdGhyb3cgdXQoXCJkZXNpcmVkU2l6ZVwiKTtyZXR1cm4gSW4odGhpcyl9Y2xvc2UoKXtpZighT2UodGhpcykpdGhyb3cgdXQoXCJjbG9zZVwiKTtpZih0aGlzLl9jbG9zZVJlcXVlc3RlZCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZDsgZG8gbm90IGNsb3NlIGl0IGFnYWluIVwiKTtjb25zdCBvPXRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO2lmKG8hPT1cInJlYWRhYmxlXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtvfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApO2F0KHRoaXMpfWVucXVldWUobyl7aWYoIU9lKHRoaXMpKXRocm93IHV0KFwiZW5xdWV1ZVwiKTtpZihTZShvLDEsXCJlbnF1ZXVlXCIpLCFBcnJheUJ1ZmZlci5pc1ZpZXcobykpdGhyb3cgbmV3IFR5cGVFcnJvcihcImNodW5rIG11c3QgYmUgYW4gYXJyYXkgYnVmZmVyIHZpZXdcIik7aWYoby5ieXRlTGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2h1bmsgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhcIik7aWYoby5idWZmZXIuYnl0ZUxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcImNodW5rJ3MgYnVmZmVyIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoXCIpO2lmKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKXRocm93IG5ldyBUeXBlRXJyb3IoXCJzdHJlYW0gaXMgY2xvc2VkIG9yIGRyYWluaW5nXCIpO2NvbnN0IGE9dGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7aWYoYSE9PVwicmVhZGFibGVcIil0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke2F9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgZW5xdWV1ZWQgdG9gKTtCdCh0aGlzLG8pfWVycm9yKG89dm9pZCAwKXtpZighT2UodGhpcykpdGhyb3cgdXQoXCJlcnJvclwiKTt0ZSh0aGlzLG8pfVtlcl0obyl7RW4odGhpcyksQWUodGhpcyk7Y29uc3QgYT10aGlzLl9jYW5jZWxBbGdvcml0aG0obyk7cmV0dXJuIEF0KHRoaXMpLGF9W3RyXShvKXtjb25zdCBhPXRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07aWYodGhpcy5fcXVldWVUb3RhbFNpemU+MCl7Rm4odGhpcyxvKTtyZXR1cm59Y29uc3QgcD10aGlzLl9hdXRvQWxsb2NhdGVDaHVua1NpemU7aWYocCE9PXZvaWQgMCl7bGV0IGc7dHJ5e2c9bmV3IEFycmF5QnVmZmVyKHApfWNhdGNoKFMpe28uX2Vycm9yU3RlcHMoUyk7cmV0dXJufWNvbnN0IF89e2J1ZmZlcjpnLGJ1ZmZlckJ5dGVMZW5ndGg6cCxieXRlT2Zmc2V0OjAsYnl0ZUxlbmd0aDpwLGJ5dGVzRmlsbGVkOjAsbWluaW11bUZpbGw6MSxlbGVtZW50U2l6ZToxLHZpZXdDb25zdHJ1Y3RvcjpVaW50OEFycmF5LHJlYWRlclR5cGU6XCJkZWZhdWx0XCJ9O3RoaXMuX3BlbmRpbmdQdWxsSW50b3MucHVzaChfKX1ibihhLG8pLHplKHRoaXMpfVtycl0oKXtpZih0aGlzLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aD4wKXtjb25zdCBvPXRoaXMuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO28ucmVhZGVyVHlwZT1cIm5vbmVcIix0aGlzLl9wZW5kaW5nUHVsbEludG9zPW5ldyBRLHRoaXMuX3BlbmRpbmdQdWxsSW50b3MucHVzaChvKX19fTt1KE5yLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclwiKTtsZXQgaWU9TnI7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaWUucHJvdG90eXBlLHtjbG9zZTp7ZW51bWVyYWJsZTohMH0sZW5xdWV1ZTp7ZW51bWVyYWJsZTohMH0sZXJyb3I6e2VudW1lcmFibGU6ITB9LGJ5b2JSZXF1ZXN0OntlbnVtZXJhYmxlOiEwfSxkZXNpcmVkU2l6ZTp7ZW51bWVyYWJsZTohMH19KSx3KGllLnByb3RvdHlwZS5jbG9zZSxcImNsb3NlXCIpLHcoaWUucHJvdG90eXBlLmVucXVldWUsXCJlbnF1ZXVlXCIpLHcoaWUucHJvdG90eXBlLmVycm9yLFwiZXJyb3JcIiksdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09XCJzeW1ib2xcIiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGllLnByb3RvdHlwZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclwiLGNvbmZpZ3VyYWJsZTohMH0pO2Z1bmN0aW9uIE9lKG4pe3JldHVybiFiKG4pfHwhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJfY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbVwiKT8hMTpuIGluc3RhbmNlb2YgaWV9dShPZSxcIklzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclwiKTtmdW5jdGlvbiB5cihuKXtyZXR1cm4hYihuKXx8IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLFwiX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyXCIpPyExOm4gaW5zdGFuY2VvZiBSZX11KHlyLFwiSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0XCIpO2Z1bmN0aW9uIHplKG4pe2lmKCFRbyhuKSlyZXR1cm47aWYobi5fcHVsbGluZyl7bi5fcHVsbEFnYWluPSEwO3JldHVybn1uLl9wdWxsaW5nPSEwO2NvbnN0IGE9bi5fcHVsbEFsZ29yaXRobSgpO0UoYSwoKT0+KG4uX3B1bGxpbmc9ITEsbi5fcHVsbEFnYWluJiYobi5fcHVsbEFnYWluPSExLHplKG4pKSxudWxsKSxwPT4odGUobixwKSxudWxsKSl9dSh6ZSxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkXCIpO2Z1bmN0aW9uIEVuKG4pe19yKG4pLG4uX3BlbmRpbmdQdWxsSW50b3M9bmV3IFF9dShFbixcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3NcIik7ZnVuY3Rpb24gZ3IobixvKXtsZXQgYT0hMTtuLl9zdGF0ZT09PVwiY2xvc2VkXCImJihhPSEwKTtjb25zdCBwPUFuKG8pO28ucmVhZGVyVHlwZT09PVwiZGVmYXVsdFwiP2ZyKG4scCxhKTpYbyhuLHAsYSl9dShncixcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3JcIik7ZnVuY3Rpb24gQW4obil7Y29uc3Qgbz1uLmJ5dGVzRmlsbGVkLGE9bi5lbGVtZW50U2l6ZTtyZXR1cm4gbmV3IG4udmlld0NvbnN0cnVjdG9yKG4uYnVmZmVyLG4uYnl0ZU9mZnNldCxvL2EpfXUoQW4sXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvclwiKTtmdW5jdGlvbiBFdChuLG8sYSxwKXtuLl9xdWV1ZS5wdXNoKHtidWZmZXI6byxieXRlT2Zmc2V0OmEsYnl0ZUxlbmd0aDpwfSksbi5fcXVldWVUb3RhbFNpemUrPXB9dShFdCxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlXCIpO2Z1bmN0aW9uIEJuKG4sbyxhLHApe2xldCBnO3RyeXtnPVRuKG8sYSxhK3ApfWNhdGNoKF8pe3Rocm93IHRlKG4sXyksX31FdChuLGcsMCxwKX11KEJuLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDbG9uZWRDaHVua1RvUXVldWVcIik7ZnVuY3Rpb24gcW4obixvKXtvLmJ5dGVzRmlsbGVkPjAmJkJuKG4sby5idWZmZXIsby5ieXRlT2Zmc2V0LG8uYnl0ZXNGaWxsZWQpLEhlKG4pfXUocW4sXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZURldGFjaGVkUHVsbEludG9Ub1F1ZXVlXCIpO2Z1bmN0aW9uIGtuKG4sbyl7Y29uc3QgYT1NYXRoLm1pbihuLl9xdWV1ZVRvdGFsU2l6ZSxvLmJ5dGVMZW5ndGgtby5ieXRlc0ZpbGxlZCkscD1vLmJ5dGVzRmlsbGVkK2E7bGV0IGc9YSxfPSExO2NvbnN0IFM9cCVvLmVsZW1lbnRTaXplLEM9cC1TO0M+PW8ubWluaW11bUZpbGwmJihnPUMtby5ieXRlc0ZpbGxlZCxfPSEwKTtjb25zdCBxPW4uX3F1ZXVlO2Zvcig7Zz4wOyl7Y29uc3QgUD1xLnBlZWsoKSxXPU1hdGgubWluKGcsUC5ieXRlTGVuZ3RoKSxPPW8uYnl0ZU9mZnNldCtvLmJ5dGVzRmlsbGVkO1JuKG8uYnVmZmVyLE8sUC5idWZmZXIsUC5ieXRlT2Zmc2V0LFcpLFAuYnl0ZUxlbmd0aD09PVc/cS5zaGlmdCgpOihQLmJ5dGVPZmZzZXQrPVcsUC5ieXRlTGVuZ3RoLT1XKSxuLl9xdWV1ZVRvdGFsU2l6ZS09VyxXbihuLFcsbyksZy09V31yZXR1cm4gX311KGtuLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWVcIik7ZnVuY3Rpb24gV24obixvLGEpe2EuYnl0ZXNGaWxsZWQrPW99dShXbixcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvclwiKTtmdW5jdGlvbiBPbihuKXtuLl9xdWV1ZVRvdGFsU2l6ZT09PTAmJm4uX2Nsb3NlUmVxdWVzdGVkPyhBdChuKSxwdChuLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtKSk6emUobil9dShPbixcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluXCIpO2Z1bmN0aW9uIF9yKG4pe24uX2J5b2JSZXF1ZXN0IT09bnVsbCYmKG4uX2J5b2JSZXF1ZXN0Ll9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcj12b2lkIDAsbi5fYnlvYlJlcXVlc3QuX3ZpZXc9bnVsbCxuLl9ieW9iUmVxdWVzdD1udWxsKX11KF9yLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdFwiKTtmdW5jdGlvbiBTcihuKXtmb3IoO24uX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoPjA7KXtpZihuLl9xdWV1ZVRvdGFsU2l6ZT09PTApcmV0dXJuO2NvbnN0IG89bi5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7a24obixvKSYmKEhlKG4pLGdyKG4uX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0sbykpfX11KFNyLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZVwiKTtmdW5jdGlvbiBVbyhuKXtjb25zdCBvPW4uX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3JlYWRlcjtmb3IoO28uX3JlYWRSZXF1ZXN0cy5sZW5ndGg+MDspe2lmKG4uX3F1ZXVlVG90YWxTaXplPT09MClyZXR1cm47Y29uc3QgYT1vLl9yZWFkUmVxdWVzdHMuc2hpZnQoKTtGbihuLGEpfX11KFVvLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NSZWFkUmVxdWVzdHNVc2luZ1F1ZXVlXCIpO2Z1bmN0aW9uIE5vKG4sbyxhLHApe2NvbnN0IGc9bi5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSxfPW8uY29uc3RydWN0b3IsUz14byhfKSx7Ynl0ZU9mZnNldDpDLGJ5dGVMZW5ndGg6cX09byxQPWEqUztsZXQgVzt0cnl7Vz13ZShvLmJ1ZmZlcil9Y2F0Y2goail7cC5fZXJyb3JTdGVwcyhqKTtyZXR1cm59Y29uc3QgTz17YnVmZmVyOlcsYnVmZmVyQnl0ZUxlbmd0aDpXLmJ5dGVMZW5ndGgsYnl0ZU9mZnNldDpDLGJ5dGVMZW5ndGg6cSxieXRlc0ZpbGxlZDowLG1pbmltdW1GaWxsOlAsZWxlbWVudFNpemU6Uyx2aWV3Q29uc3RydWN0b3I6XyxyZWFkZXJUeXBlOlwiYnlvYlwifTtpZihuLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aD4wKXtuLl9wZW5kaW5nUHVsbEludG9zLnB1c2goTyksJG4oZyxwKTtyZXR1cm59aWYoZy5fc3RhdGU9PT1cImNsb3NlZFwiKXtjb25zdCBqPW5ldyBfKE8uYnVmZmVyLE8uYnl0ZU9mZnNldCwwKTtwLl9jbG9zZVN0ZXBzKGopO3JldHVybn1pZihuLl9xdWV1ZVRvdGFsU2l6ZT4wKXtpZihrbihuLE8pKXtjb25zdCBqPUFuKE8pO09uKG4pLHAuX2NodW5rU3RlcHMoaik7cmV0dXJufWlmKG4uX2Nsb3NlUmVxdWVzdGVkKXtjb25zdCBqPW5ldyBUeXBlRXJyb3IoXCJJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyXCIpO3RlKG4saikscC5fZXJyb3JTdGVwcyhqKTtyZXR1cm59fW4uX3BlbmRpbmdQdWxsSW50b3MucHVzaChPKSwkbihnLHApLHplKG4pfXUoTm8sXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG9cIik7ZnVuY3Rpb24gSG8obixvKXtvLnJlYWRlclR5cGU9PT1cIm5vbmVcIiYmSGUobik7Y29uc3QgYT1uLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO2lmKFRyKGEpKWZvcig7RG4oYSk+MDspe2NvbnN0IHA9SGUobik7Z3IoYSxwKX19dShIbyxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZVwiKTtmdW5jdGlvbiBWbyhuLG8sYSl7aWYoV24obixvLGEpLGEucmVhZGVyVHlwZT09PVwibm9uZVwiKXtxbihuLGEpLFNyKG4pO3JldHVybn1pZihhLmJ5dGVzRmlsbGVkPGEubWluaW11bUZpbGwpcmV0dXJuO0hlKG4pO2NvbnN0IHA9YS5ieXRlc0ZpbGxlZCVhLmVsZW1lbnRTaXplO2lmKHA+MCl7Y29uc3QgZz1hLmJ5dGVPZmZzZXQrYS5ieXRlc0ZpbGxlZDtCbihuLGEuYnVmZmVyLGctcCxwKX1hLmJ5dGVzRmlsbGVkLT1wLGdyKG4uX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0sYSksU3Iobil9dShWbyxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlXCIpO2Z1bmN0aW9uIHpuKG4sbyl7Y29uc3QgYT1uLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtfcihuKSxuLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZT09PVwiY2xvc2VkXCI/SG8obixhKTpWbyhuLG8sYSksemUobil9dSh6bixcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWxcIik7ZnVuY3Rpb24gSGUobil7cmV0dXJuIG4uX3BlbmRpbmdQdWxsSW50b3Muc2hpZnQoKX11KEhlLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvXCIpO2Z1bmN0aW9uIFFvKG4pe2NvbnN0IG89bi5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtyZXR1cm4gby5fc3RhdGUhPT1cInJlYWRhYmxlXCJ8fG4uX2Nsb3NlUmVxdWVzdGVkfHwhbi5fc3RhcnRlZD8hMTohIShtbihvKSYmVHQobyk+MHx8VHIobykmJkRuKG8pPjB8fEluKG4pPjApfXUoUW8sXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGxcIik7ZnVuY3Rpb24gQXQobil7bi5fcHVsbEFsZ29yaXRobT12b2lkIDAsbi5fY2FuY2VsQWxnb3JpdGhtPXZvaWQgMH11KEF0LFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtc1wiKTtmdW5jdGlvbiBhdChuKXtjb25zdCBvPW4uX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07aWYoIShuLl9jbG9zZVJlcXVlc3RlZHx8by5fc3RhdGUhPT1cInJlYWRhYmxlXCIpKXtpZihuLl9xdWV1ZVRvdGFsU2l6ZT4wKXtuLl9jbG9zZVJlcXVlc3RlZD0hMDtyZXR1cm59aWYobi5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGg+MCl7Y29uc3QgYT1uLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtpZihhLmJ5dGVzRmlsbGVkJWEuZWxlbWVudFNpemUhPT0wKXtjb25zdCBwPW5ldyBUeXBlRXJyb3IoXCJJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyXCIpO3Rocm93IHRlKG4scCkscH19QXQobikscHQobyl9fXUoYXQsXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2VcIik7ZnVuY3Rpb24gQnQobixvKXtjb25zdCBhPW4uX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07aWYobi5fY2xvc2VSZXF1ZXN0ZWR8fGEuX3N0YXRlIT09XCJyZWFkYWJsZVwiKXJldHVybjtjb25zdHtidWZmZXI6cCxieXRlT2Zmc2V0OmcsYnl0ZUxlbmd0aDpffT1vO2lmKEVlKHApKXRocm93IG5ldyBUeXBlRXJyb3IoXCJjaHVuaydzIGJ1ZmZlciBpcyBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIGVucXVldWVkXCIpO2NvbnN0IFM9d2UocCk7aWYobi5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGg+MCl7Y29uc3QgQz1uLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtpZihFZShDLmJ1ZmZlcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBCWU9CIHJlcXVlc3QncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSBmaWxsZWQgd2l0aCBhbiBlbnF1ZXVlZCBjaHVua1wiKTtfcihuKSxDLmJ1ZmZlcj13ZShDLmJ1ZmZlciksQy5yZWFkZXJUeXBlPT09XCJub25lXCImJnFuKG4sQyl9aWYobW4oYSkpaWYoVW8obiksVHQoYSk9PT0wKUV0KG4sUyxnLF8pO2Vsc2V7bi5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGg+MCYmSGUobik7Y29uc3QgQz1uZXcgVWludDhBcnJheShTLGcsXyk7ZnIoYSxDLCExKX1lbHNlIFRyKGEpPyhFdChuLFMsZyxfKSxTcihuKSk6RXQobixTLGcsXyk7emUobil9dShCdCxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlXCIpO2Z1bmN0aW9uIHRlKG4sbyl7Y29uc3QgYT1uLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO2EuX3N0YXRlPT09XCJyZWFkYWJsZVwiJiYoRW4obiksQWUobiksQXQobiksZm8oYSxvKSl9dSh0ZSxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvclwiKTtmdW5jdGlvbiBGbihuLG8pe2NvbnN0IGE9bi5fcXVldWUuc2hpZnQoKTtuLl9xdWV1ZVRvdGFsU2l6ZS09YS5ieXRlTGVuZ3RoLE9uKG4pO2NvbnN0IHA9bmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsYS5ieXRlT2Zmc2V0LGEuYnl0ZUxlbmd0aCk7by5fY2h1bmtTdGVwcyhwKX11KEZuLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxSZWFkUmVxdWVzdEZyb21RdWV1ZVwiKTtmdW5jdGlvbiB3cihuKXtpZihuLl9ieW9iUmVxdWVzdD09PW51bGwmJm4uX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoPjApe2NvbnN0IG89bi5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCksYT1uZXcgVWludDhBcnJheShvLmJ1ZmZlcixvLmJ5dGVPZmZzZXQrby5ieXRlc0ZpbGxlZCxvLmJ5dGVMZW5ndGgtby5ieXRlc0ZpbGxlZCkscD1PYmplY3QuY3JlYXRlKFJlLnByb3RvdHlwZSk7WW8ocCxuLGEpLG4uX2J5b2JSZXF1ZXN0PXB9cmV0dXJuIG4uX2J5b2JSZXF1ZXN0fXUod3IsXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3RcIik7ZnVuY3Rpb24gSW4obil7Y29uc3Qgbz1uLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtyZXR1cm4gbz09PVwiZXJyb3JlZFwiP251bGw6bz09PVwiY2xvc2VkXCI/MDpuLl9zdHJhdGVneUhXTS1uLl9xdWV1ZVRvdGFsU2l6ZX11KEluLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplXCIpO2Z1bmN0aW9uIHF0KG4sbyl7Y29uc3QgYT1uLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtpZihuLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZT09PVwiY2xvc2VkXCIpe2lmKG8hPT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJieXRlc1dyaXR0ZW4gbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSBjbG9zZWQgc3RyZWFtXCIpfWVsc2V7aWYobz09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcImJ5dGVzV3JpdHRlbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSByZWFkYWJsZSBzdHJlYW1cIik7aWYoYS5ieXRlc0ZpbGxlZCtvPmEuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImJ5dGVzV3JpdHRlbiBvdXQgb2YgcmFuZ2VcIil9YS5idWZmZXI9d2UoYS5idWZmZXIpLHpuKG4sbyl9dShxdCxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kXCIpO2Z1bmN0aW9uIGt0KG4sbyl7Y29uc3QgYT1uLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtpZihuLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZT09PVwiY2xvc2VkXCIpe2lmKG8uYnl0ZUxlbmd0aCE9PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSB2aWV3J3MgbGVuZ3RoIG11c3QgYmUgMCB3aGVuIGNhbGxpbmcgcmVzcG9uZFdpdGhOZXdWaWV3KCkgb24gYSBjbG9zZWQgc3RyZWFtXCIpfWVsc2UgaWYoby5ieXRlTGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHZpZXcncyBsZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gMCB3aGVuIGNhbGxpbmcgcmVzcG9uZFdpdGhOZXdWaWV3KCkgb24gYSByZWFkYWJsZSBzdHJlYW1cIik7aWYoYS5ieXRlT2Zmc2V0K2EuYnl0ZXNGaWxsZWQhPT1vLmJ5dGVPZmZzZXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGRvZXMgbm90IG1hdGNoIGJ5b2JSZXF1ZXN0XCIpO2lmKGEuYnVmZmVyQnl0ZUxlbmd0aCE9PW8uYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgYnVmZmVyIG9mIHZpZXcgaGFzIGRpZmZlcmVudCBjYXBhY2l0eSB0aGFuIGJ5b2JSZXF1ZXN0XCIpO2lmKGEuYnl0ZXNGaWxsZWQrby5ieXRlTGVuZ3RoPmEuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWdpb24gc3BlY2lmaWVkIGJ5IHZpZXcgaXMgbGFyZ2VyIHRoYW4gYnlvYlJlcXVlc3RcIik7Y29uc3QgZz1vLmJ5dGVMZW5ndGg7YS5idWZmZXI9d2Uoby5idWZmZXIpLHpuKG4sZyl9dShrdCxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXdcIik7ZnVuY3Rpb24gam4obixvLGEscCxnLF8sUyl7by5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbT1uLG8uX3B1bGxBZ2Fpbj0hMSxvLl9wdWxsaW5nPSExLG8uX2J5b2JSZXF1ZXN0PW51bGwsby5fcXVldWU9by5fcXVldWVUb3RhbFNpemU9dm9pZCAwLEFlKG8pLG8uX2Nsb3NlUmVxdWVzdGVkPSExLG8uX3N0YXJ0ZWQ9ITEsby5fc3RyYXRlZ3lIV009XyxvLl9wdWxsQWxnb3JpdGhtPXAsby5fY2FuY2VsQWxnb3JpdGhtPWcsby5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplPVMsby5fcGVuZGluZ1B1bGxJbnRvcz1uZXcgUSxuLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI9bztjb25zdCBDPWEoKTtFKGsoQyksKCk9PihvLl9zdGFydGVkPSEwLHplKG8pLG51bGwpLHE9Pih0ZShvLHEpLG51bGwpKX11KGpuLFwiU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyXCIpO2Z1bmN0aW9uIEdvKG4sbyxhKXtjb25zdCBwPU9iamVjdC5jcmVhdGUoaWUucHJvdG90eXBlKTtsZXQgZyxfLFM7by5zdGFydCE9PXZvaWQgMD9nPXUoKCk9Pm8uc3RhcnQocCksXCJzdGFydEFsZ29yaXRobVwiKTpnPXUoKCk9Pnt9LFwic3RhcnRBbGdvcml0aG1cIiksby5wdWxsIT09dm9pZCAwP189dSgoKT0+by5wdWxsKHApLFwicHVsbEFsZ29yaXRobVwiKTpfPXUoKCk9Pmsodm9pZCAwKSxcInB1bGxBbGdvcml0aG1cIiksby5jYW5jZWwhPT12b2lkIDA/Uz11KHE9Pm8uY2FuY2VsKHEpLFwiY2FuY2VsQWxnb3JpdGhtXCIpOlM9dSgoKT0+ayh2b2lkIDApLFwiY2FuY2VsQWxnb3JpdGhtXCIpO2NvbnN0IEM9by5hdXRvQWxsb2NhdGVDaHVua1NpemU7aWYoQz09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcImF1dG9BbGxvY2F0ZUNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO2puKG4scCxnLF8sUyxhLEMpfXUoR28sXCJTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZVwiKTtmdW5jdGlvbiBZbyhuLG8sYSl7bi5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI9byxuLl92aWV3PWF9dShZbyxcIlNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdFwiKTtmdW5jdGlvbiBScihuKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUuJHtufSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdGApfXUoUnIsXCJieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb25cIik7ZnVuY3Rpb24gdXQobil7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLiR7bn0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJgKX11KHV0LFwiYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uXCIpO2Z1bmN0aW9uIFpvKG4sbyl7Y2UobixvKTtjb25zdCBhPW4/Lm1vZGU7cmV0dXJue21vZGU6YT09PXZvaWQgMD92b2lkIDA6S28oYSxgJHtvfSBoYXMgbWVtYmVyICdtb2RlJyB0aGF0YCl9fXUoWm8sXCJjb252ZXJ0UmVhZGVyT3B0aW9uc1wiKTtmdW5jdGlvbiBLbyhuLG8pe2lmKG49YCR7bn1gLG4hPT1cImJ5b2JcIil0aHJvdyBuZXcgVHlwZUVycm9yKGAke299ICcke259JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlYCk7cmV0dXJuIG59dShLbyxcImNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGVcIik7ZnVuY3Rpb24gSm8obixvKXt2YXIgYTtjZShuLG8pO2NvbnN0IHA9KGE9bj8ubWluKSE9PW51bGwmJmEhPT12b2lkIDA/YToxO3JldHVybnttaW46dXIocCxgJHtvfSBoYXMgbWVtYmVyICdtaW4nIHRoYXRgKX19dShKbyxcImNvbnZlcnRCeW9iUmVhZE9wdGlvbnNcIik7ZnVuY3Rpb24gTG4obil7cmV0dXJuIG5ldyBoZShuKX11KExuLFwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclwiKTtmdW5jdGlvbiAkbihuLG8pe24uX3JlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5wdXNoKG8pfXUoJG4sXCJSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdFwiKTtmdW5jdGlvbiBYbyhuLG8sYSl7Y29uc3QgZz1uLl9yZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuc2hpZnQoKTthP2cuX2Nsb3NlU3RlcHMobyk6Zy5fY2h1bmtTdGVwcyhvKX11KFhvLFwiUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0XCIpO2Z1bmN0aW9uIERuKG4pe3JldHVybiBuLl9yZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RofXUoRG4sXCJSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHNcIik7ZnVuY3Rpb24gVHIobil7Y29uc3Qgbz1uLl9yZWFkZXI7cmV0dXJuIShvPT09dm9pZCAwfHwhRmUobykpfXUoVHIsXCJSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXJcIik7Y29uc3QgSHI9Y2xhc3MgSHJ7Y29uc3RydWN0b3Iobyl7aWYoU2UobywxLFwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyXCIpLGxyKG8sXCJGaXJzdCBwYXJhbWV0ZXJcIiksa2UobykpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlclwiKTtpZighT2Uoby5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnN0cnVjdCBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBmb3IgYSBzdHJlYW0gbm90IGNvbnN0cnVjdGVkIHdpdGggYSBieXRlIHNvdXJjZVwiKTtsbih0aGlzLG8pLHRoaXMuX3JlYWRJbnRvUmVxdWVzdHM9bmV3IFF9Z2V0IGNsb3NlZCgpe3JldHVybiBGZSh0aGlzKT90aGlzLl9jbG9zZWRQcm9taXNlOlQoV3QoXCJjbG9zZWRcIikpfWNhbmNlbChvPXZvaWQgMCl7cmV0dXJuIEZlKHRoaXMpP3RoaXMuX293bmVyUmVhZGFibGVTdHJlYW09PT12b2lkIDA/VChSdChcImNhbmNlbFwiKSk6bnIodGhpcyxvKTpUKFd0KFwiY2FuY2VsXCIpKX1yZWFkKG8sYT17fSl7aWYoIUZlKHRoaXMpKXJldHVybiBUKFd0KFwicmVhZFwiKSk7aWYoIUFycmF5QnVmZmVyLmlzVmlldyhvKSlyZXR1cm4gVChuZXcgVHlwZUVycm9yKFwidmlldyBtdXN0IGJlIGFuIGFycmF5IGJ1ZmZlciB2aWV3XCIpKTtpZihvLmJ5dGVMZW5ndGg9PT0wKXJldHVybiBUKG5ldyBUeXBlRXJyb3IoXCJ2aWV3IG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoXCIpKTtpZihvLmJ1ZmZlci5ieXRlTGVuZ3RoPT09MClyZXR1cm4gVChuZXcgVHlwZUVycm9yKFwidmlldydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aFwiKSk7aWYoRWUoby5idWZmZXIpKXJldHVybiBUKG5ldyBUeXBlRXJyb3IoXCJ2aWV3J3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkXCIpKTtsZXQgcDt0cnl7cD1KbyhhLFwib3B0aW9uc1wiKX1jYXRjaChQKXtyZXR1cm4gVChQKX1jb25zdCBnPXAubWluO2lmKGc9PT0wKXJldHVybiBUKG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zLm1pbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpKTtpZihNbyhvKSl7aWYoZz5vLmJ5dGVMZW5ndGgpcmV0dXJuIFQobmV3IFJhbmdlRXJyb3IoXCJvcHRpb25zLm1pbiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB2aWV3J3MgYnl0ZUxlbmd0aFwiKSl9ZWxzZSBpZihnPm8ubGVuZ3RoKXJldHVybiBUKG5ldyBSYW5nZUVycm9yKFwib3B0aW9ucy5taW4gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdmlldydzIGxlbmd0aFwiKSk7aWYodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbT09PXZvaWQgMClyZXR1cm4gVChSdChcInJlYWQgZnJvbVwiKSk7bGV0IF8sUztjb25zdCBDPUYoKFAsVyk9PntfPVAsUz1XfSk7cmV0dXJuIE1uKHRoaXMsbyxnLHtfY2h1bmtTdGVwczpQPT5fKHt2YWx1ZTpQLGRvbmU6ITF9KSxfY2xvc2VTdGVwczpQPT5fKHt2YWx1ZTpQLGRvbmU6ITB9KSxfZXJyb3JTdGVwczpQPT5TKFApfSksQ31yZWxlYXNlTG9jaygpe2lmKCFGZSh0aGlzKSl0aHJvdyBXdChcInJlbGVhc2VMb2NrXCIpO3RoaXMuX293bmVyUmVhZGFibGVTdHJlYW0hPT12b2lkIDAmJmVpKHRoaXMpfX07dShIcixcIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclwiKTtsZXQgaGU9SHI7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaGUucHJvdG90eXBlLHtjYW5jZWw6e2VudW1lcmFibGU6ITB9LHJlYWQ6e2VudW1lcmFibGU6ITB9LHJlbGVhc2VMb2NrOntlbnVtZXJhYmxlOiEwfSxjbG9zZWQ6e2VudW1lcmFibGU6ITB9fSksdyhoZS5wcm90b3R5cGUuY2FuY2VsLFwiY2FuY2VsXCIpLHcoaGUucHJvdG90eXBlLnJlYWQsXCJyZWFkXCIpLHcoaGUucHJvdG90eXBlLnJlbGVhc2VMb2NrLFwicmVsZWFzZUxvY2tcIiksdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09XCJzeW1ib2xcIiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGhlLnByb3RvdHlwZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyXCIsY29uZmlndXJhYmxlOiEwfSk7ZnVuY3Rpb24gRmUobil7cmV0dXJuIWIobil8fCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixcIl9yZWFkSW50b1JlcXVlc3RzXCIpPyExOm4gaW5zdGFuY2VvZiBoZX11KEZlLFwiSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJcIik7ZnVuY3Rpb24gTW4obixvLGEscCl7Y29uc3QgZz1uLl9vd25lclJlYWRhYmxlU3RyZWFtO2cuX2Rpc3R1cmJlZD0hMCxnLl9zdGF0ZT09PVwiZXJyb3JlZFwiP3AuX2Vycm9yU3RlcHMoZy5fc3RvcmVkRXJyb3IpOk5vKGcuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixvLGEscCl9dShNbixcIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWRcIik7ZnVuY3Rpb24gZWkobil7X2Uobik7Y29uc3Qgbz1uZXcgVHlwZUVycm9yKFwiUmVhZGVyIHdhcyByZWxlYXNlZFwiKTt4bihuLG8pfXUoZWksXCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWxlYXNlXCIpO2Z1bmN0aW9uIHhuKG4sbyl7Y29uc3QgYT1uLl9yZWFkSW50b1JlcXVlc3RzO24uX3JlYWRJbnRvUmVxdWVzdHM9bmV3IFEsYS5mb3JFYWNoKHA9PntwLl9lcnJvclN0ZXBzKG8pfSl9dSh4bixcIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlckVycm9yUmVhZEludG9SZXF1ZXN0c1wiKTtmdW5jdGlvbiBXdChuKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS4ke259IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJgKX11KFd0LFwiYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb25cIik7ZnVuY3Rpb24gbHQobixvKXtjb25zdHtoaWdoV2F0ZXJNYXJrOmF9PW47aWYoYT09PXZvaWQgMClyZXR1cm4gbztpZih3bihhKXx8YTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBoaWdoV2F0ZXJNYXJrXCIpO3JldHVybiBhfXUobHQsXCJFeHRyYWN0SGlnaFdhdGVyTWFya1wiKTtmdW5jdGlvbiBPdChuKXtjb25zdHtzaXplOm99PW47cmV0dXJuIG98fCgoKT0+MSl9dShPdCxcIkV4dHJhY3RTaXplQWxnb3JpdGhtXCIpO2Z1bmN0aW9uIHp0KG4sbyl7Y2UobixvKTtjb25zdCBhPW4/LmhpZ2hXYXRlck1hcmsscD1uPy5zaXplO3JldHVybntoaWdoV2F0ZXJNYXJrOmE9PT12b2lkIDA/dm9pZCAwOmFyKGEpLHNpemU6cD09PXZvaWQgMD92b2lkIDA6dGkocCxgJHtvfSBoYXMgbWVtYmVyICdzaXplJyB0aGF0YCl9fXUoenQsXCJjb252ZXJ0UXVldWluZ1N0cmF0ZWd5XCIpO2Z1bmN0aW9uIHRpKG4sbyl7cmV0dXJuIGVlKG4sbyksYT0+YXIobihhKSl9dSh0aSxcImNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplXCIpO2Z1bmN0aW9uIHJpKG4sbyl7Y2UobixvKTtjb25zdCBhPW4/LmFib3J0LHA9bj8uY2xvc2UsZz1uPy5zdGFydCxfPW4/LnR5cGUsUz1uPy53cml0ZTtyZXR1cm57YWJvcnQ6YT09PXZvaWQgMD92b2lkIDA6bmkoYSxuLGAke299IGhhcyBtZW1iZXIgJ2Fib3J0JyB0aGF0YCksY2xvc2U6cD09PXZvaWQgMD92b2lkIDA6b2kocCxuLGAke299IGhhcyBtZW1iZXIgJ2Nsb3NlJyB0aGF0YCksc3RhcnQ6Zz09PXZvaWQgMD92b2lkIDA6aWkoZyxuLGAke299IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksd3JpdGU6Uz09PXZvaWQgMD92b2lkIDA6c2koUyxuLGAke299IGhhcyBtZW1iZXIgJ3dyaXRlJyB0aGF0YCksdHlwZTpffX11KHJpLFwiY29udmVydFVuZGVybHlpbmdTaW5rXCIpO2Z1bmN0aW9uIG5pKG4sbyxhKXtyZXR1cm4gZWUobixhKSxwPT5IKG4sbyxbcF0pfXUobmksXCJjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrXCIpO2Z1bmN0aW9uIG9pKG4sbyxhKXtyZXR1cm4gZWUobixhKSwoKT0+SChuLG8sW10pfXUob2ksXCJjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrXCIpO2Z1bmN0aW9uIGlpKG4sbyxhKXtyZXR1cm4gZWUobixhKSxwPT5NKG4sbyxbcF0pfXUoaWksXCJjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrXCIpO2Z1bmN0aW9uIHNpKG4sbyxhKXtyZXR1cm4gZWUobixhKSwocCxnKT0+SChuLG8sW3AsZ10pfXUoc2ksXCJjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrXCIpO2Z1bmN0aW9uIFVuKG4sbyl7aWYoIVZlKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7b30gaXMgbm90IGEgV3JpdGFibGVTdHJlYW0uYCl9dShVbixcImFzc2VydFdyaXRhYmxlU3RyZWFtXCIpO2Z1bmN0aW9uIGFpKG4pe2lmKHR5cGVvZiBuIT1cIm9iamVjdFwifHxuPT09bnVsbClyZXR1cm4hMTt0cnl7cmV0dXJuIHR5cGVvZiBuLmFib3J0ZWQ9PVwiYm9vbGVhblwifWNhdGNoe3JldHVybiExfX11KGFpLFwiaXNBYm9ydFNpZ25hbFwiKTtjb25zdCB1aT10eXBlb2YgQWJvcnRDb250cm9sbGVyPT1cImZ1bmN0aW9uXCI7ZnVuY3Rpb24gbGkoKXtpZih1aSlyZXR1cm4gbmV3IEFib3J0Q29udHJvbGxlcn11KGxpLFwiY3JlYXRlQWJvcnRDb250cm9sbGVyXCIpO2NvbnN0IFZyPWNsYXNzIFZye2NvbnN0cnVjdG9yKG89e30sYT17fSl7bz09PXZvaWQgMD9vPW51bGw6aG4obyxcIkZpcnN0IHBhcmFtZXRlclwiKTtjb25zdCBwPXp0KGEsXCJTZWNvbmQgcGFyYW1ldGVyXCIpLGc9cmkobyxcIkZpcnN0IHBhcmFtZXRlclwiKTtpZihIbih0aGlzKSxnLnR5cGUhPT12b2lkIDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHR5cGUgaXMgc3BlY2lmaWVkXCIpO2NvbnN0IFM9T3QocCksQz1sdChwLDEpO1RpKHRoaXMsZyxDLFMpfWdldCBsb2NrZWQoKXtpZighVmUodGhpcykpdGhyb3cgJHQoXCJsb2NrZWRcIik7cmV0dXJuIFFlKHRoaXMpfWFib3J0KG89dm9pZCAwKXtyZXR1cm4gVmUodGhpcyk/UWUodGhpcyk/VChuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFib3J0IGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSB3cml0ZXJcIikpOkZ0KHRoaXMsbyk6VCgkdChcImFib3J0XCIpKX1jbG9zZSgpe3JldHVybiBWZSh0aGlzKT9RZSh0aGlzKT9UKG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2xvc2UgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlclwiKSk6YmUodGhpcyk/VChuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW1cIikpOlZuKHRoaXMpOlQoJHQoXCJjbG9zZVwiKSl9Z2V0V3JpdGVyKCl7aWYoIVZlKHRoaXMpKXRocm93ICR0KFwiZ2V0V3JpdGVyXCIpO3JldHVybiBObih0aGlzKX19O3UoVnIsXCJXcml0YWJsZVN0cmVhbVwiKTtsZXQgcGU9VnI7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocGUucHJvdG90eXBlLHthYm9ydDp7ZW51bWVyYWJsZTohMH0sY2xvc2U6e2VudW1lcmFibGU6ITB9LGdldFdyaXRlcjp7ZW51bWVyYWJsZTohMH0sbG9ja2VkOntlbnVtZXJhYmxlOiEwfX0pLHcocGUucHJvdG90eXBlLmFib3J0LFwiYWJvcnRcIiksdyhwZS5wcm90b3R5cGUuY2xvc2UsXCJjbG9zZVwiKSx3KHBlLnByb3RvdHlwZS5nZXRXcml0ZXIsXCJnZXRXcml0ZXJcIiksdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09XCJzeW1ib2xcIiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHBlLnByb3RvdHlwZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiV3JpdGFibGVTdHJlYW1cIixjb25maWd1cmFibGU6ITB9KTtmdW5jdGlvbiBObihuKXtyZXR1cm4gbmV3IHNlKG4pfXUoTm4sXCJBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyXCIpO2Z1bmN0aW9uIGZpKG4sbyxhLHAsZz0xLF89KCk9PjEpe2NvbnN0IFM9T2JqZWN0LmNyZWF0ZShwZS5wcm90b3R5cGUpO0huKFMpO2NvbnN0IEM9T2JqZWN0LmNyZWF0ZShCZS5wcm90b3R5cGUpO3JldHVybiBKbihTLEMsbixvLGEscCxnLF8pLFN9dShmaSxcIkNyZWF0ZVdyaXRhYmxlU3RyZWFtXCIpO2Z1bmN0aW9uIEhuKG4pe24uX3N0YXRlPVwid3JpdGFibGVcIixuLl9zdG9yZWRFcnJvcj12b2lkIDAsbi5fd3JpdGVyPXZvaWQgMCxuLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI9dm9pZCAwLG4uX3dyaXRlUmVxdWVzdHM9bmV3IFEsbi5faW5GbGlnaHRXcml0ZVJlcXVlc3Q9dm9pZCAwLG4uX2Nsb3NlUmVxdWVzdD12b2lkIDAsbi5faW5GbGlnaHRDbG9zZVJlcXVlc3Q9dm9pZCAwLG4uX3BlbmRpbmdBYm9ydFJlcXVlc3Q9dm9pZCAwLG4uX2JhY2twcmVzc3VyZT0hMX11KEhuLFwiSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtXCIpO2Z1bmN0aW9uIFZlKG4pe3JldHVybiFiKG4pfHwhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyXCIpPyExOm4gaW5zdGFuY2VvZiBwZX11KFZlLFwiSXNXcml0YWJsZVN0cmVhbVwiKTtmdW5jdGlvbiBRZShuKXtyZXR1cm4gbi5fd3JpdGVyIT09dm9pZCAwfXUoUWUsXCJJc1dyaXRhYmxlU3RyZWFtTG9ja2VkXCIpO2Z1bmN0aW9uIEZ0KG4sbyl7dmFyIGE7aWYobi5fc3RhdGU9PT1cImNsb3NlZFwifHxuLl9zdGF0ZT09PVwiZXJyb3JlZFwiKXJldHVybiBrKHZvaWQgMCk7bi5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLl9hYm9ydFJlYXNvbj1vLChhPW4uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyKT09PW51bGx8fGE9PT12b2lkIDB8fGEuYWJvcnQobyk7Y29uc3QgcD1uLl9zdGF0ZTtpZihwPT09XCJjbG9zZWRcInx8cD09PVwiZXJyb3JlZFwiKXJldHVybiBrKHZvaWQgMCk7aWYobi5fcGVuZGluZ0Fib3J0UmVxdWVzdCE9PXZvaWQgMClyZXR1cm4gbi5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcHJvbWlzZTtsZXQgZz0hMTtwPT09XCJlcnJvcmluZ1wiJiYoZz0hMCxvPXZvaWQgMCk7Y29uc3QgXz1GKChTLEMpPT57bi5fcGVuZGluZ0Fib3J0UmVxdWVzdD17X3Byb21pc2U6dm9pZCAwLF9yZXNvbHZlOlMsX3JlamVjdDpDLF9yZWFzb246byxfd2FzQWxyZWFkeUVycm9yaW5nOmd9fSk7cmV0dXJuIG4uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Byb21pc2U9XyxnfHxQcihuLG8pLF99dShGdCxcIldyaXRhYmxlU3RyZWFtQWJvcnRcIik7ZnVuY3Rpb24gVm4obil7Y29uc3Qgbz1uLl9zdGF0ZTtpZihvPT09XCJjbG9zZWRcInx8bz09PVwiZXJyb3JlZFwiKXJldHVybiBUKG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7b30gc3RhdGUpIGlzIG5vdCBpbiB0aGUgd3JpdGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBjbG9zZWRgKSk7Y29uc3QgYT1GKChnLF8pPT57Y29uc3QgUz17X3Jlc29sdmU6ZyxfcmVqZWN0Ol99O24uX2Nsb3NlUmVxdWVzdD1TfSkscD1uLl93cml0ZXI7cmV0dXJuIHAhPT12b2lkIDAmJm4uX2JhY2twcmVzc3VyZSYmbz09PVwid3JpdGFibGVcIiYmT3IocCksQ2kobi5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKSxhfXUoVm4sXCJXcml0YWJsZVN0cmVhbUNsb3NlXCIpO2Z1bmN0aW9uIGNpKG4pe3JldHVybiBGKChhLHApPT57Y29uc3QgZz17X3Jlc29sdmU6YSxfcmVqZWN0OnB9O24uX3dyaXRlUmVxdWVzdHMucHVzaChnKX0pfXUoY2ksXCJXcml0YWJsZVN0cmVhbUFkZFdyaXRlUmVxdWVzdFwiKTtmdW5jdGlvbiBDcihuLG8pe2lmKG4uX3N0YXRlPT09XCJ3cml0YWJsZVwiKXtQcihuLG8pO3JldHVybn12cihuKX11KENyLFwiV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvblwiKTtmdW5jdGlvbiBQcihuLG8pe2NvbnN0IGE9bi5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyO24uX3N0YXRlPVwiZXJyb3JpbmdcIixuLl9zdG9yZWRFcnJvcj1vO2NvbnN0IHA9bi5fd3JpdGVyO3AhPT12b2lkIDAmJkduKHAsbyksIW1pKG4pJiZhLl9zdGFydGVkJiZ2cihuKX11KFByLFwiV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nXCIpO2Z1bmN0aW9uIHZyKG4pe24uX3N0YXRlPVwiZXJyb3JlZFwiLG4uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlclt1bl0oKTtjb25zdCBvPW4uX3N0b3JlZEVycm9yO2lmKG4uX3dyaXRlUmVxdWVzdHMuZm9yRWFjaChnPT57Zy5fcmVqZWN0KG8pfSksbi5fd3JpdGVSZXF1ZXN0cz1uZXcgUSxuLl9wZW5kaW5nQWJvcnRSZXF1ZXN0PT09dm9pZCAwKXtJdChuKTtyZXR1cm59Y29uc3QgYT1uLl9wZW5kaW5nQWJvcnRSZXF1ZXN0O2lmKG4uX3BlbmRpbmdBYm9ydFJlcXVlc3Q9dm9pZCAwLGEuX3dhc0FscmVhZHlFcnJvcmluZyl7YS5fcmVqZWN0KG8pLEl0KG4pO3JldHVybn1jb25zdCBwPW4uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlclt3dF0oYS5fcmVhc29uKTtFKHAsKCk9PihhLl9yZXNvbHZlKCksSXQobiksbnVsbCksZz0+KGEuX3JlamVjdChnKSxJdChuKSxudWxsKSl9dSh2cixcIldyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3JpbmdcIik7ZnVuY3Rpb24gZGkobil7bi5faW5GbGlnaHRXcml0ZVJlcXVlc3QuX3Jlc29sdmUodm9pZCAwKSxuLl9pbkZsaWdodFdyaXRlUmVxdWVzdD12b2lkIDB9dShkaSxcIldyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVwiKTtmdW5jdGlvbiBoaShuLG8pe24uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0Ll9yZWplY3Qobyksbi5faW5GbGlnaHRXcml0ZVJlcXVlc3Q9dm9pZCAwLENyKG4sbyl9dShoaSxcIldyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvclwiKTtmdW5jdGlvbiBwaShuKXtuLl9pbkZsaWdodENsb3NlUmVxdWVzdC5fcmVzb2x2ZSh2b2lkIDApLG4uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0PXZvaWQgMCxuLl9zdGF0ZT09PVwiZXJyb3JpbmdcIiYmKG4uX3N0b3JlZEVycm9yPXZvaWQgMCxuLl9wZW5kaW5nQWJvcnRSZXF1ZXN0IT09dm9pZCAwJiYobi5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcmVzb2x2ZSgpLG4uX3BlbmRpbmdBYm9ydFJlcXVlc3Q9dm9pZCAwKSksbi5fc3RhdGU9XCJjbG9zZWRcIjtjb25zdCBhPW4uX3dyaXRlcjthIT09dm9pZCAwJiZybyhhKX11KHBpLFwiV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlXCIpO2Z1bmN0aW9uIGJpKG4sbyl7bi5faW5GbGlnaHRDbG9zZVJlcXVlc3QuX3JlamVjdChvKSxuLl9pbkZsaWdodENsb3NlUmVxdWVzdD12b2lkIDAsbi5fcGVuZGluZ0Fib3J0UmVxdWVzdCE9PXZvaWQgMCYmKG4uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3JlamVjdChvKSxuLl9wZW5kaW5nQWJvcnRSZXF1ZXN0PXZvaWQgMCksQ3IobixvKX11KGJpLFwiV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yXCIpO2Z1bmN0aW9uIGJlKG4pe3JldHVybiEobi5fY2xvc2VSZXF1ZXN0PT09dm9pZCAwJiZuLl9pbkZsaWdodENsb3NlUmVxdWVzdD09PXZvaWQgMCl9dShiZSxcIldyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0XCIpO2Z1bmN0aW9uIG1pKG4pe3JldHVybiEobi5faW5GbGlnaHRXcml0ZVJlcXVlc3Q9PT12b2lkIDAmJm4uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0PT09dm9pZCAwKX11KG1pLFwiV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodFwiKTtmdW5jdGlvbiB5aShuKXtuLl9pbkZsaWdodENsb3NlUmVxdWVzdD1uLl9jbG9zZVJlcXVlc3Qsbi5fY2xvc2VSZXF1ZXN0PXZvaWQgMH11KHlpLFwiV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHRcIik7ZnVuY3Rpb24gZ2kobil7bi5faW5GbGlnaHRXcml0ZVJlcXVlc3Q9bi5fd3JpdGVSZXF1ZXN0cy5zaGlmdCgpfXUoZ2ksXCJXcml0YWJsZVN0cmVhbU1hcmtGaXJzdFdyaXRlUmVxdWVzdEluRmxpZ2h0XCIpO2Z1bmN0aW9uIEl0KG4pe24uX2Nsb3NlUmVxdWVzdCE9PXZvaWQgMCYmKG4uX2Nsb3NlUmVxdWVzdC5fcmVqZWN0KG4uX3N0b3JlZEVycm9yKSxuLl9jbG9zZVJlcXVlc3Q9dm9pZCAwKTtjb25zdCBvPW4uX3dyaXRlcjtvIT09dm9pZCAwJiZrcihvLG4uX3N0b3JlZEVycm9yKX11KEl0LFwiV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZFwiKTtmdW5jdGlvbiBFcihuLG8pe2NvbnN0IGE9bi5fd3JpdGVyO2EhPT12b2lkIDAmJm8hPT1uLl9iYWNrcHJlc3N1cmUmJihvP2tpKGEpOk9yKGEpKSxuLl9iYWNrcHJlc3N1cmU9b311KEVyLFwiV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmVcIik7Y29uc3QgUXI9Y2xhc3MgUXJ7Y29uc3RydWN0b3Iobyl7aWYoU2UobywxLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyXCIpLFVuKG8sXCJGaXJzdCBwYXJhbWV0ZXJcIiksUWUobykpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgd3JpdGluZyBieSBhbm90aGVyIHdyaXRlclwiKTt0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtPW8sby5fd3JpdGVyPXRoaXM7Y29uc3QgYT1vLl9zdGF0ZTtpZihhPT09XCJ3cml0YWJsZVwiKSFiZShvKSYmby5fYmFja3ByZXNzdXJlP010KHRoaXMpOm5vKHRoaXMpLER0KHRoaXMpO2Vsc2UgaWYoYT09PVwiZXJyb3JpbmdcIilXcih0aGlzLG8uX3N0b3JlZEVycm9yKSxEdCh0aGlzKTtlbHNlIGlmKGE9PT1cImNsb3NlZFwiKW5vKHRoaXMpLEJpKHRoaXMpO2Vsc2V7Y29uc3QgcD1vLl9zdG9yZWRFcnJvcjtXcih0aGlzLHApLHRvKHRoaXMscCl9fWdldCBjbG9zZWQoKXtyZXR1cm4gSWUodGhpcyk/dGhpcy5fY2xvc2VkUHJvbWlzZTpUKGplKFwiY2xvc2VkXCIpKX1nZXQgZGVzaXJlZFNpemUoKXtpZighSWUodGhpcykpdGhyb3cgamUoXCJkZXNpcmVkU2l6ZVwiKTtpZih0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtPT09dm9pZCAwKXRocm93IGN0KFwiZGVzaXJlZFNpemVcIik7cmV0dXJuIFJpKHRoaXMpfWdldCByZWFkeSgpe3JldHVybiBJZSh0aGlzKT90aGlzLl9yZWFkeVByb21pc2U6VChqZShcInJlYWR5XCIpKX1hYm9ydChvPXZvaWQgMCl7cmV0dXJuIEllKHRoaXMpP3RoaXMuX293bmVyV3JpdGFibGVTdHJlYW09PT12b2lkIDA/VChjdChcImFib3J0XCIpKTpfaSh0aGlzLG8pOlQoamUoXCJhYm9ydFwiKSl9Y2xvc2UoKXtpZighSWUodGhpcykpcmV0dXJuIFQoamUoXCJjbG9zZVwiKSk7Y29uc3Qgbz10aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtO3JldHVybiBvPT09dm9pZCAwP1QoY3QoXCJjbG9zZVwiKSk6YmUobyk/VChuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW1cIikpOlFuKHRoaXMpfXJlbGVhc2VMb2NrKCl7aWYoIUllKHRoaXMpKXRocm93IGplKFwicmVsZWFzZUxvY2tcIik7dGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSE9PXZvaWQgMCYmWW4odGhpcyl9d3JpdGUobz12b2lkIDApe3JldHVybiBJZSh0aGlzKT90aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtPT09dm9pZCAwP1QoY3QoXCJ3cml0ZSB0b1wiKSk6Wm4odGhpcyxvKTpUKGplKFwid3JpdGVcIikpfX07dShRcixcIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclwiKTtsZXQgc2U9UXI7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2UucHJvdG90eXBlLHthYm9ydDp7ZW51bWVyYWJsZTohMH0sY2xvc2U6e2VudW1lcmFibGU6ITB9LHJlbGVhc2VMb2NrOntlbnVtZXJhYmxlOiEwfSx3cml0ZTp7ZW51bWVyYWJsZTohMH0sY2xvc2VkOntlbnVtZXJhYmxlOiEwfSxkZXNpcmVkU2l6ZTp7ZW51bWVyYWJsZTohMH0scmVhZHk6e2VudW1lcmFibGU6ITB9fSksdyhzZS5wcm90b3R5cGUuYWJvcnQsXCJhYm9ydFwiKSx3KHNlLnByb3RvdHlwZS5jbG9zZSxcImNsb3NlXCIpLHcoc2UucHJvdG90eXBlLnJlbGVhc2VMb2NrLFwicmVsZWFzZUxvY2tcIiksdyhzZS5wcm90b3R5cGUud3JpdGUsXCJ3cml0ZVwiKSx0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT1cInN5bWJvbFwiJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoc2UucHJvdG90eXBlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJcIixjb25maWd1cmFibGU6ITB9KTtmdW5jdGlvbiBJZShuKXtyZXR1cm4hYihuKXx8IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLFwiX293bmVyV3JpdGFibGVTdHJlYW1cIik/ITE6biBpbnN0YW5jZW9mIHNlfXUoSWUsXCJJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclwiKTtmdW5jdGlvbiBfaShuLG8pe2NvbnN0IGE9bi5fb3duZXJXcml0YWJsZVN0cmVhbTtyZXR1cm4gRnQoYSxvKX11KF9pLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnRcIik7ZnVuY3Rpb24gUW4obil7Y29uc3Qgbz1uLl9vd25lcldyaXRhYmxlU3RyZWFtO3JldHVybiBWbihvKX11KFFuLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VcIik7ZnVuY3Rpb24gU2kobil7Y29uc3Qgbz1uLl9vd25lcldyaXRhYmxlU3RyZWFtLGE9by5fc3RhdGU7cmV0dXJuIGJlKG8pfHxhPT09XCJjbG9zZWRcIj9rKHZvaWQgMCk6YT09PVwiZXJyb3JlZFwiP1Qoby5fc3RvcmVkRXJyb3IpOlFuKG4pfXUoU2ksXCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uXCIpO2Z1bmN0aW9uIHdpKG4sbyl7bi5fY2xvc2VkUHJvbWlzZVN0YXRlPT09XCJwZW5kaW5nXCI/a3IobixvKTpxaShuLG8pfXUod2ksXCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWRcIik7ZnVuY3Rpb24gR24obixvKXtuLl9yZWFkeVByb21pc2VTdGF0ZT09PVwicGVuZGluZ1wiP29vKG4sbyk6V2kobixvKX11KEduLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWRcIik7ZnVuY3Rpb24gUmkobil7Y29uc3Qgbz1uLl9vd25lcldyaXRhYmxlU3RyZWFtLGE9by5fc3RhdGU7cmV0dXJuIGE9PT1cImVycm9yZWRcInx8YT09PVwiZXJyb3JpbmdcIj9udWxsOmE9PT1cImNsb3NlZFwiPzA6WG4oby5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKX11KFJpLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemVcIik7ZnVuY3Rpb24gWW4obil7Y29uc3Qgbz1uLl9vd25lcldyaXRhYmxlU3RyZWFtLGE9bmV3IFR5cGVFcnJvcihcIldyaXRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzXCIpO0duKG4sYSksd2kobixhKSxvLl93cml0ZXI9dm9pZCAwLG4uX293bmVyV3JpdGFibGVTdHJlYW09dm9pZCAwfXUoWW4sXCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlXCIpO2Z1bmN0aW9uIFpuKG4sbyl7Y29uc3QgYT1uLl9vd25lcldyaXRhYmxlU3RyZWFtLHA9YS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLGc9UGkocCxvKTtpZihhIT09bi5fb3duZXJXcml0YWJsZVN0cmVhbSlyZXR1cm4gVChjdChcIndyaXRlIHRvXCIpKTtjb25zdCBfPWEuX3N0YXRlO2lmKF89PT1cImVycm9yZWRcIilyZXR1cm4gVChhLl9zdG9yZWRFcnJvcik7aWYoYmUoYSl8fF89PT1cImNsb3NlZFwiKXJldHVybiBUKG5ldyBUeXBlRXJyb3IoXCJUaGUgc3RyZWFtIGlzIGNsb3Npbmcgb3IgY2xvc2VkIGFuZCBjYW5ub3QgYmUgd3JpdHRlbiB0b1wiKSk7aWYoXz09PVwiZXJyb3JpbmdcIilyZXR1cm4gVChhLl9zdG9yZWRFcnJvcik7Y29uc3QgUz1jaShhKTtyZXR1cm4gdmkocCxvLGcpLFN9dShabixcIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlXCIpO2NvbnN0IEtuPXt9LEdyPWNsYXNzIEdye2NvbnN0cnVjdG9yKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgY29uc3RydWN0b3JcIil9Z2V0IGFib3J0UmVhc29uKCl7aWYoIUFyKHRoaXMpKXRocm93IHFyKFwiYWJvcnRSZWFzb25cIik7cmV0dXJuIHRoaXMuX2Fib3J0UmVhc29ufWdldCBzaWduYWwoKXtpZighQXIodGhpcykpdGhyb3cgcXIoXCJzaWduYWxcIik7aWYodGhpcy5fYWJvcnRDb250cm9sbGVyPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoXCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5zaWduYWwgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gdGhpcy5fYWJvcnRDb250cm9sbGVyLnNpZ25hbH1lcnJvcihvPXZvaWQgMCl7aWYoIUFyKHRoaXMpKXRocm93IHFyKFwiZXJyb3JcIik7dGhpcy5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZT09PVwid3JpdGFibGVcIiYmZW8odGhpcyxvKX1bd3RdKG8pe2NvbnN0IGE9dGhpcy5fYWJvcnRBbGdvcml0aG0obyk7cmV0dXJuIGp0KHRoaXMpLGF9W3VuXSgpe0FlKHRoaXMpfX07dShHcixcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcIik7bGV0IEJlPUdyO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJlLnByb3RvdHlwZSx7YWJvcnRSZWFzb246e2VudW1lcmFibGU6ITB9LHNpZ25hbDp7ZW51bWVyYWJsZTohMH0sZXJyb3I6e2VudW1lcmFibGU6ITB9fSksdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09XCJzeW1ib2xcIiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KEJlLnByb3RvdHlwZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiLGNvbmZpZ3VyYWJsZTohMH0pO2Z1bmN0aW9uIEFyKG4pe3JldHVybiFiKG4pfHwhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtXCIpPyExOm4gaW5zdGFuY2VvZiBCZX11KEFyLFwiSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyXCIpO2Z1bmN0aW9uIEpuKG4sbyxhLHAsZyxfLFMsQyl7by5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtPW4sbi5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyPW8sby5fcXVldWU9dm9pZCAwLG8uX3F1ZXVlVG90YWxTaXplPXZvaWQgMCxBZShvKSxvLl9hYm9ydFJlYXNvbj12b2lkIDAsby5fYWJvcnRDb250cm9sbGVyPWxpKCksby5fc3RhcnRlZD0hMSxvLl9zdHJhdGVneVNpemVBbGdvcml0aG09QyxvLl9zdHJhdGVneUhXTT1TLG8uX3dyaXRlQWxnb3JpdGhtPXAsby5fY2xvc2VBbGdvcml0aG09ZyxvLl9hYm9ydEFsZ29yaXRobT1fO2NvbnN0IHE9QnIobyk7RXIobixxKTtjb25zdCBQPWEoKSxXPWsoUCk7RShXLCgpPT4oby5fc3RhcnRlZD0hMCxMdChvKSxudWxsKSxPPT4oby5fc3RhcnRlZD0hMCxDcihuLE8pLG51bGwpKX11KEpuLFwiU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyXCIpO2Z1bmN0aW9uIFRpKG4sbyxhLHApe2NvbnN0IGc9T2JqZWN0LmNyZWF0ZShCZS5wcm90b3R5cGUpO2xldCBfLFMsQyxxO28uc3RhcnQhPT12b2lkIDA/Xz11KCgpPT5vLnN0YXJ0KGcpLFwic3RhcnRBbGdvcml0aG1cIik6Xz11KCgpPT57fSxcInN0YXJ0QWxnb3JpdGhtXCIpLG8ud3JpdGUhPT12b2lkIDA/Uz11KFA9Pm8ud3JpdGUoUCxnKSxcIndyaXRlQWxnb3JpdGhtXCIpOlM9dSgoKT0+ayh2b2lkIDApLFwid3JpdGVBbGdvcml0aG1cIiksby5jbG9zZSE9PXZvaWQgMD9DPXUoKCk9Pm8uY2xvc2UoKSxcImNsb3NlQWxnb3JpdGhtXCIpOkM9dSgoKT0+ayh2b2lkIDApLFwiY2xvc2VBbGdvcml0aG1cIiksby5hYm9ydCE9PXZvaWQgMD9xPXUoUD0+by5hYm9ydChQKSxcImFib3J0QWxnb3JpdGhtXCIpOnE9dSgoKT0+ayh2b2lkIDApLFwiYWJvcnRBbGdvcml0aG1cIiksSm4obixnLF8sUyxDLHEsYSxwKX11KFRpLFwiU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rXCIpO2Z1bmN0aW9uIGp0KG4pe24uX3dyaXRlQWxnb3JpdGhtPXZvaWQgMCxuLl9jbG9zZUFsZ29yaXRobT12b2lkIDAsbi5fYWJvcnRBbGdvcml0aG09dm9pZCAwLG4uX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobT12b2lkIDB9dShqdCxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXNcIik7ZnVuY3Rpb24gQ2kobil7bXIobixLbiwwKSxMdChuKX11KENpLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlXCIpO2Z1bmN0aW9uIFBpKG4sbyl7dHJ5e3JldHVybiBuLl9zdHJhdGVneVNpemVBbGdvcml0aG0obyl9Y2F0Y2goYSl7cmV0dXJuIGZ0KG4sYSksMX19dShQaSxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemVcIik7ZnVuY3Rpb24gWG4obil7cmV0dXJuIG4uX3N0cmF0ZWd5SFdNLW4uX3F1ZXVlVG90YWxTaXplfXUoWG4sXCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemVcIik7ZnVuY3Rpb24gdmkobixvLGEpe3RyeXttcihuLG8sYSl9Y2F0Y2goZyl7ZnQobixnKTtyZXR1cm59Y29uc3QgcD1uLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07aWYoIWJlKHApJiZwLl9zdGF0ZT09PVwid3JpdGFibGVcIil7Y29uc3QgZz1CcihuKTtFcihwLGcpfUx0KG4pfXUodmksXCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyV3JpdGVcIik7ZnVuY3Rpb24gTHQobil7Y29uc3Qgbz1uLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07aWYoIW4uX3N0YXJ0ZWR8fG8uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0IT09dm9pZCAwKXJldHVybjtpZihvLl9zdGF0ZT09PVwiZXJyb3JpbmdcIil7dnIobyk7cmV0dXJufWlmKG4uX3F1ZXVlLmxlbmd0aD09PTApcmV0dXJuO2NvbnN0IHA9RG8obik7cD09PUtuP0VpKG4pOkFpKG4scCl9dShMdCxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZFwiKTtmdW5jdGlvbiBmdChuLG8pe24uX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbS5fc3RhdGU9PT1cIndyaXRhYmxlXCImJmVvKG4sbyl9dShmdCxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkXCIpO2Z1bmN0aW9uIEVpKG4pe2NvbnN0IG89bi5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO3lpKG8pLGJyKG4pO2NvbnN0IGE9bi5fY2xvc2VBbGdvcml0aG0oKTtqdChuKSxFKGEsKCk9PihwaShvKSxudWxsKSxwPT4oYmkobyxwKSxudWxsKSl9dShFaSxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2VcIik7ZnVuY3Rpb24gQWkobixvKXtjb25zdCBhPW4uX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtnaShhKTtjb25zdCBwPW4uX3dyaXRlQWxnb3JpdGhtKG8pO0UocCwoKT0+e2RpKGEpO2NvbnN0IGc9YS5fc3RhdGU7aWYoYnIobiksIWJlKGEpJiZnPT09XCJ3cml0YWJsZVwiKXtjb25zdCBfPUJyKG4pO0VyKGEsXyl9cmV0dXJuIEx0KG4pLG51bGx9LGc9PihhLl9zdGF0ZT09PVwid3JpdGFibGVcIiYmanQobiksaGkoYSxnKSxudWxsKSl9dShBaSxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzV3JpdGVcIik7ZnVuY3Rpb24gQnIobil7cmV0dXJuIFhuKG4pPD0wfXUoQnIsXCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlXCIpO2Z1bmN0aW9uIGVvKG4sbyl7Y29uc3QgYT1uLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07anQobiksUHIoYSxvKX11KGVvLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yXCIpO2Z1bmN0aW9uICR0KG4pe3JldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuJHtufSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1gKX11KCR0LFwic3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyXCIpO2Z1bmN0aW9uIHFyKG4pe3JldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke259IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCl9dShxcixcImRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyXCIpO2Z1bmN0aW9uIGplKG4pe3JldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLiR7bn0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcmApfXUoamUsXCJkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvblwiKTtmdW5jdGlvbiBjdChuKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBcIituK1wiIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgd3JpdGVyXCIpfXUoY3QsXCJkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvblwiKTtmdW5jdGlvbiBEdChuKXtuLl9jbG9zZWRQcm9taXNlPUYoKG8sYSk9PntuLl9jbG9zZWRQcm9taXNlX3Jlc29sdmU9byxuLl9jbG9zZWRQcm9taXNlX3JlamVjdD1hLG4uX2Nsb3NlZFByb21pc2VTdGF0ZT1cInBlbmRpbmdcIn0pfXUoRHQsXCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVcIik7ZnVuY3Rpb24gdG8obixvKXtEdChuKSxrcihuLG8pfXUodG8sXCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkXCIpO2Z1bmN0aW9uIEJpKG4pe0R0KG4pLHJvKG4pfXUoQmksXCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkXCIpO2Z1bmN0aW9uIGtyKG4sbyl7bi5fY2xvc2VkUHJvbWlzZV9yZWplY3QhPT12b2lkIDAmJihKKG4uX2Nsb3NlZFByb21pc2UpLG4uX2Nsb3NlZFByb21pc2VfcmVqZWN0KG8pLG4uX2Nsb3NlZFByb21pc2VfcmVzb2x2ZT12b2lkIDAsbi5fY2xvc2VkUHJvbWlzZV9yZWplY3Q9dm9pZCAwLG4uX2Nsb3NlZFByb21pc2VTdGF0ZT1cInJlamVjdGVkXCIpfXUoa3IsXCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdFwiKTtmdW5jdGlvbiBxaShuLG8pe3RvKG4sbyl9dShxaSxcImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkXCIpO2Z1bmN0aW9uIHJvKG4pe24uX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSE9PXZvaWQgMCYmKG4uX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSh2b2lkIDApLG4uX2Nsb3NlZFByb21pc2VfcmVzb2x2ZT12b2lkIDAsbi5fY2xvc2VkUHJvbWlzZV9yZWplY3Q9dm9pZCAwLG4uX2Nsb3NlZFByb21pc2VTdGF0ZT1cInJlc29sdmVkXCIpfXUocm8sXCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmVcIik7ZnVuY3Rpb24gTXQobil7bi5fcmVhZHlQcm9taXNlPUYoKG8sYSk9PntuLl9yZWFkeVByb21pc2VfcmVzb2x2ZT1vLG4uX3JlYWR5UHJvbWlzZV9yZWplY3Q9YX0pLG4uX3JlYWR5UHJvbWlzZVN0YXRlPVwicGVuZGluZ1wifXUoTXQsXCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZVwiKTtmdW5jdGlvbiBXcihuLG8pe010KG4pLG9vKG4sbyl9dShXcixcImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZFwiKTtmdW5jdGlvbiBubyhuKXtNdChuKSxPcihuKX11KG5vLFwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkXCIpO2Z1bmN0aW9uIG9vKG4sbyl7bi5fcmVhZHlQcm9taXNlX3JlamVjdCE9PXZvaWQgMCYmKEoobi5fcmVhZHlQcm9taXNlKSxuLl9yZWFkeVByb21pc2VfcmVqZWN0KG8pLG4uX3JlYWR5UHJvbWlzZV9yZXNvbHZlPXZvaWQgMCxuLl9yZWFkeVByb21pc2VfcmVqZWN0PXZvaWQgMCxuLl9yZWFkeVByb21pc2VTdGF0ZT1cInJlamVjdGVkXCIpfXUob28sXCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0XCIpO2Z1bmN0aW9uIGtpKG4pe010KG4pfXUoa2ksXCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRcIik7ZnVuY3Rpb24gV2kobixvKXtXcihuLG8pfXUoV2ksXCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkXCIpO2Z1bmN0aW9uIE9yKG4pe24uX3JlYWR5UHJvbWlzZV9yZXNvbHZlIT09dm9pZCAwJiYobi5fcmVhZHlQcm9taXNlX3Jlc29sdmUodm9pZCAwKSxuLl9yZWFkeVByb21pc2VfcmVzb2x2ZT12b2lkIDAsbi5fcmVhZHlQcm9taXNlX3JlamVjdD12b2lkIDAsbi5fcmVhZHlQcm9taXNlU3RhdGU9XCJmdWxmaWxsZWRcIil9dShPcixcImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlXCIpO2Z1bmN0aW9uIE9pKCl7aWYodHlwZW9mIGdsb2JhbFRoaXM8XCJ1XCIpcmV0dXJuIGdsb2JhbFRoaXM7aWYodHlwZW9mIHNlbGY8XCJ1XCIpcmV0dXJuIHNlbGY7aWYodHlwZW9mIF9jb21tb25qc0hlbHBlcnMuY29tbW9uanNHbG9iYWw8XCJ1XCIpcmV0dXJuIF9jb21tb25qc0hlbHBlcnMuY29tbW9uanNHbG9iYWx9dShPaSxcImdldEdsb2JhbHNcIik7Y29uc3QgenI9T2koKTtmdW5jdGlvbiB6aShuKXtpZighKHR5cGVvZiBuPT1cImZ1bmN0aW9uXCJ8fHR5cGVvZiBuPT1cIm9iamVjdFwiKXx8bi5uYW1lIT09XCJET01FeGNlcHRpb25cIilyZXR1cm4hMTt0cnl7cmV0dXJuIG5ldyBuLCEwfWNhdGNoe3JldHVybiExfX11KHppLFwiaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvclwiKTtmdW5jdGlvbiBGaSgpe2NvbnN0IG49enI/LkRPTUV4Y2VwdGlvbjtyZXR1cm4gemkobik/bjp2b2lkIDB9dShGaSxcImdldEZyb21HbG9iYWxcIik7ZnVuY3Rpb24gSWkoKXtjb25zdCBuPXUoZnVuY3Rpb24oYSxwKXt0aGlzLm1lc3NhZ2U9YXx8XCJcIix0aGlzLm5hbWU9cHx8XCJFcnJvclwiLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHRoaXMuY29uc3RydWN0b3IpfSxcIkRPTUV4Y2VwdGlvblwiKTtyZXR1cm4gdyhuLFwiRE9NRXhjZXB0aW9uXCIpLG4ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobi5wcm90b3R5cGUsXCJjb25zdHJ1Y3RvclwiLHt2YWx1ZTpuLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLG59dShJaSxcImNyZWF0ZVBvbHlmaWxsXCIpO2NvbnN0IGppPUZpKCl8fElpKCk7ZnVuY3Rpb24gaW8obixvLGEscCxnLF8pe2NvbnN0IFM9TmUobiksQz1ObihvKTtuLl9kaXN0dXJiZWQ9ITA7bGV0IHE9ITEsUD1rKHZvaWQgMCk7cmV0dXJuIEYoKFcsTyk9PntsZXQgajtpZihfIT09dm9pZCAwKXtpZihqPXUoKCk9Pntjb25zdCBBPV8ucmVhc29uIT09dm9pZCAwP18ucmVhc29uOm5ldyBqaShcIkFib3J0ZWRcIixcIkFib3J0RXJyb3JcIiksej1bXTtwfHx6LnB1c2goKCk9Pm8uX3N0YXRlPT09XCJ3cml0YWJsZVwiP0Z0KG8sQSk6ayh2b2lkIDApKSxnfHx6LnB1c2goKCk9Pm4uX3N0YXRlPT09XCJyZWFkYWJsZVwiP2xlKG4sQSk6ayh2b2lkIDApKSxaKCgpPT5Qcm9taXNlLmFsbCh6Lm1hcChMPT5MKCkpKSwhMCxBKX0sXCJhYm9ydEFsZ29yaXRobVwiKSxfLmFib3J0ZWQpe2ooKTtyZXR1cm59Xy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIixqKX1mdW5jdGlvbiBmZSgpe3JldHVybiBGKChBLHopPT57ZnVuY3Rpb24gTChYKXtYP0EoKTokKGV0KCksTCx6KX11KEwsXCJuZXh0XCIpLEwoITEpfSl9dShmZSxcInBpcGVMb29wXCIpO2Z1bmN0aW9uIGV0KCl7cmV0dXJuIHE/ayghMCk6JChDLl9yZWFkeVByb21pc2UsKCk9PkYoKEEseik9PntpdChTLHtfY2h1bmtTdGVwczpMPT57UD0kKFpuKEMsTCksdm9pZCAwLHkpLEEoITEpfSxfY2xvc2VTdGVwczooKT0+QSghMCksX2Vycm9yU3RlcHM6en0pfSkpfWlmKHUoZXQsXCJwaXBlU3RlcFwiKSxUZShuLFMuX2Nsb3NlZFByb21pc2UsQT0+KHA/cmUoITAsQSk6WigoKT0+RnQobyxBKSwhMCxBKSxudWxsKSksVGUobyxDLl9jbG9zZWRQcm9taXNlLEE9PihnP3JlKCEwLEEpOlooKCk9PmxlKG4sQSksITAsQSksbnVsbCkpLFkobixTLl9jbG9zZWRQcm9taXNlLCgpPT4oYT9yZSgpOlooKCk9PlNpKEMpKSxudWxsKSksYmUobyl8fG8uX3N0YXRlPT09XCJjbG9zZWRcIil7Y29uc3QgQT1uZXcgVHlwZUVycm9yKFwidGhlIGRlc3RpbmF0aW9uIHdyaXRhYmxlIHN0cmVhbSBjbG9zZWQgYmVmb3JlIGFsbCBkYXRhIGNvdWxkIGJlIHBpcGVkIHRvIGl0XCIpO2c/cmUoITAsQSk6WigoKT0+bGUobixBKSwhMCxBKX1KKGZlKCkpO2Z1bmN0aW9uIFdlKCl7Y29uc3QgQT1QO3JldHVybiAkKFAsKCk9PkEhPT1QP1dlKCk6dm9pZCAwKX11KFdlLFwid2FpdEZvcldyaXRlc1RvRmluaXNoXCIpO2Z1bmN0aW9uIFRlKEEseixMKXtBLl9zdGF0ZT09PVwiZXJyb3JlZFwiP0woQS5fc3RvcmVkRXJyb3IpOlUoeixMKX11KFRlLFwiaXNPckJlY29tZXNFcnJvcmVkXCIpO2Z1bmN0aW9uIFkoQSx6LEwpe0EuX3N0YXRlPT09XCJjbG9zZWRcIj9MKCk6Syh6LEwpfXUoWSxcImlzT3JCZWNvbWVzQ2xvc2VkXCIpO2Z1bmN0aW9uIFooQSx6LEwpe2lmKHEpcmV0dXJuO3E9ITAsby5fc3RhdGU9PT1cIndyaXRhYmxlXCImJiFiZShvKT9LKFdlKCksWCk6WCgpO2Z1bmN0aW9uIFgoKXtyZXR1cm4gRShBKCksKCk9PkNlKHosTCksdHQ9PkNlKCEwLHR0KSksbnVsbH11KFgsXCJkb1RoZVJlc3RcIil9dShaLFwic2h1dGRvd25XaXRoQWN0aW9uXCIpO2Z1bmN0aW9uIHJlKEEseil7cXx8KHE9ITAsby5fc3RhdGU9PT1cIndyaXRhYmxlXCImJiFiZShvKT9LKFdlKCksKCk9PkNlKEEseikpOkNlKEEseikpfXUocmUsXCJzaHV0ZG93blwiKTtmdW5jdGlvbiBDZShBLHope3JldHVybiBZbihDKSxfZShTKSxfIT09dm9pZCAwJiZfLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLGopLEE/Tyh6KTpXKHZvaWQgMCksbnVsbH11KENlLFwiZmluYWxpemVcIil9KX11KGlvLFwiUmVhZGFibGVTdHJlYW1QaXBlVG9cIik7Y29uc3QgWXI9Y2xhc3MgWXJ7Y29uc3RydWN0b3IoKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBjb25zdHJ1Y3RvclwiKX1nZXQgZGVzaXJlZFNpemUoKXtpZigheHQodGhpcykpdGhyb3cgTnQoXCJkZXNpcmVkU2l6ZVwiKTtyZXR1cm4gRnIodGhpcyl9Y2xvc2UoKXtpZigheHQodGhpcykpdGhyb3cgTnQoXCJjbG9zZVwiKTtpZighWWUodGhpcykpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGNsb3NlXCIpO0xlKHRoaXMpfWVucXVldWUobz12b2lkIDApe2lmKCF4dCh0aGlzKSl0aHJvdyBOdChcImVucXVldWVcIik7aWYoIVllKHRoaXMpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBlbnF1ZXVlXCIpO3JldHVybiBHZSh0aGlzLG8pfWVycm9yKG89dm9pZCAwKXtpZigheHQodGhpcykpdGhyb3cgTnQoXCJlcnJvclwiKTt1ZSh0aGlzLG8pfVtlcl0obyl7QWUodGhpcyk7Y29uc3QgYT10aGlzLl9jYW5jZWxBbGdvcml0aG0obyk7cmV0dXJuIFV0KHRoaXMpLGF9W3RyXShvKXtjb25zdCBhPXRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtpZih0aGlzLl9xdWV1ZS5sZW5ndGg+MCl7Y29uc3QgcD1icih0aGlzKTt0aGlzLl9jbG9zZVJlcXVlc3RlZCYmdGhpcy5fcXVldWUubGVuZ3RoPT09MD8oVXQodGhpcykscHQoYSkpOmR0KHRoaXMpLG8uX2NodW5rU3RlcHMocCl9ZWxzZSBibihhLG8pLGR0KHRoaXMpfVtycl0oKXt9fTt1KFlyLFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiKTtsZXQgYWU9WXI7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYWUucHJvdG90eXBlLHtjbG9zZTp7ZW51bWVyYWJsZTohMH0sZW5xdWV1ZTp7ZW51bWVyYWJsZTohMH0sZXJyb3I6e2VudW1lcmFibGU6ITB9LGRlc2lyZWRTaXplOntlbnVtZXJhYmxlOiEwfX0pLHcoYWUucHJvdG90eXBlLmNsb3NlLFwiY2xvc2VcIiksdyhhZS5wcm90b3R5cGUuZW5xdWV1ZSxcImVucXVldWVcIiksdyhhZS5wcm90b3R5cGUuZXJyb3IsXCJlcnJvclwiKSx0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT1cInN5bWJvbFwiJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoYWUucHJvdG90eXBlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyXCIsY29uZmlndXJhYmxlOiEwfSk7ZnVuY3Rpb24geHQobil7cmV0dXJuIWIobil8fCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixcIl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW1cIik/ITE6biBpbnN0YW5jZW9mIGFlfXUoeHQsXCJJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcIik7ZnVuY3Rpb24gZHQobil7aWYoIXNvKG4pKXJldHVybjtpZihuLl9wdWxsaW5nKXtuLl9wdWxsQWdhaW49ITA7cmV0dXJufW4uX3B1bGxpbmc9ITA7Y29uc3QgYT1uLl9wdWxsQWxnb3JpdGhtKCk7RShhLCgpPT4obi5fcHVsbGluZz0hMSxuLl9wdWxsQWdhaW4mJihuLl9wdWxsQWdhaW49ITEsZHQobikpLG51bGwpLHA9Pih1ZShuLHApLG51bGwpKX11KGR0LFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWRcIik7ZnVuY3Rpb24gc28obil7Y29uc3Qgbz1uLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07cmV0dXJuIVllKG4pfHwhbi5fc3RhcnRlZD8hMTohIShrZShvKSYmVHQobyk+MHx8RnIobik+MCl9dShzbyxcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbFwiKTtmdW5jdGlvbiBVdChuKXtuLl9wdWxsQWxnb3JpdGhtPXZvaWQgMCxuLl9jYW5jZWxBbGdvcml0aG09dm9pZCAwLG4uX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobT12b2lkIDB9dShVdCxcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXNcIik7ZnVuY3Rpb24gTGUobil7aWYoIVllKG4pKXJldHVybjtjb25zdCBvPW4uX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtuLl9jbG9zZVJlcXVlc3RlZD0hMCxuLl9xdWV1ZS5sZW5ndGg9PT0wJiYoVXQobikscHQobykpfXUoTGUsXCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2VcIik7ZnVuY3Rpb24gR2UobixvKXtpZighWWUobikpcmV0dXJuO2NvbnN0IGE9bi5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO2lmKGtlKGEpJiZUdChhKT4wKWZyKGEsbywhMSk7ZWxzZXtsZXQgcDt0cnl7cD1uLl9zdHJhdGVneVNpemVBbGdvcml0aG0obyl9Y2F0Y2goZyl7dGhyb3cgdWUobixnKSxnfXRyeXttcihuLG8scCl9Y2F0Y2goZyl7dGhyb3cgdWUobixnKSxnfX1kdChuKX11KEdlLFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWVcIik7ZnVuY3Rpb24gdWUobixvKXtjb25zdCBhPW4uX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTthLl9zdGF0ZT09PVwicmVhZGFibGVcIiYmKEFlKG4pLFV0KG4pLGZvKGEsbykpfXUodWUsXCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JcIik7ZnVuY3Rpb24gRnIobil7Y29uc3Qgbz1uLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO3JldHVybiBvPT09XCJlcnJvcmVkXCI/bnVsbDpvPT09XCJjbG9zZWRcIj8wOm4uX3N0cmF0ZWd5SFdNLW4uX3F1ZXVlVG90YWxTaXplfXUoRnIsXCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemVcIik7ZnVuY3Rpb24gTGkobil7cmV0dXJuIXNvKG4pfXUoTGksXCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlXCIpO2Z1bmN0aW9uIFllKG4pe2NvbnN0IG89bi5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtLl9zdGF0ZTtyZXR1cm4hbi5fY2xvc2VSZXF1ZXN0ZWQmJm89PT1cInJlYWRhYmxlXCJ9dShZZSxcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZVwiKTtmdW5jdGlvbiBhbyhuLG8sYSxwLGcsXyxTKXtvLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW09bixvLl9xdWV1ZT12b2lkIDAsby5fcXVldWVUb3RhbFNpemU9dm9pZCAwLEFlKG8pLG8uX3N0YXJ0ZWQ9ITEsby5fY2xvc2VSZXF1ZXN0ZWQ9ITEsby5fcHVsbEFnYWluPSExLG8uX3B1bGxpbmc9ITEsby5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtPVMsby5fc3RyYXRlZ3lIV009XyxvLl9wdWxsQWxnb3JpdGhtPXAsby5fY2FuY2VsQWxnb3JpdGhtPWcsbi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyPW87Y29uc3QgQz1hKCk7RShrKEMpLCgpPT4oby5fc3RhcnRlZD0hMCxkdChvKSxudWxsKSxxPT4odWUobyxxKSxudWxsKSl9dShhbyxcIlNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiKTtmdW5jdGlvbiAkaShuLG8sYSxwKXtjb25zdCBnPU9iamVjdC5jcmVhdGUoYWUucHJvdG90eXBlKTtsZXQgXyxTLEM7by5zdGFydCE9PXZvaWQgMD9fPXUoKCk9Pm8uc3RhcnQoZyksXCJzdGFydEFsZ29yaXRobVwiKTpfPXUoKCk9Pnt9LFwic3RhcnRBbGdvcml0aG1cIiksby5wdWxsIT09dm9pZCAwP1M9dSgoKT0+by5wdWxsKGcpLFwicHVsbEFsZ29yaXRobVwiKTpTPXUoKCk9Pmsodm9pZCAwKSxcInB1bGxBbGdvcml0aG1cIiksby5jYW5jZWwhPT12b2lkIDA/Qz11KHE9Pm8uY2FuY2VsKHEpLFwiY2FuY2VsQWxnb3JpdGhtXCIpOkM9dSgoKT0+ayh2b2lkIDApLFwiY2FuY2VsQWxnb3JpdGhtXCIpLGFvKG4sZyxfLFMsQyxhLHApfXUoJGksXCJTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZVwiKTtmdW5jdGlvbiBOdChuKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtufSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcmApfXUoTnQsXCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMVwiKTtmdW5jdGlvbiBEaShuLG8pe3JldHVybiBPZShuLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpP3hpKG4pOk1pKG4pfXUoRGksXCJSZWFkYWJsZVN0cmVhbVRlZVwiKTtmdW5jdGlvbiBNaShuLG8pe2NvbnN0IGE9TmUobik7bGV0IHA9ITEsZz0hMSxfPSExLFM9ITEsQyxxLFAsVyxPO2NvbnN0IGo9RihZPT57Tz1ZfSk7ZnVuY3Rpb24gZmUoKXtyZXR1cm4gcD8oZz0hMCxrKHZvaWQgMCkpOihwPSEwLGl0KGEse19jaHVua1N0ZXBzOlo9PntnZSgoKT0+e2c9ITE7Y29uc3QgcmU9WixDZT1aO198fEdlKFAuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixyZSksU3x8R2UoVy5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLENlKSxwPSExLGcmJmZlKCl9KX0sX2Nsb3NlU3RlcHM6KCk9PntwPSExLF98fExlKFAuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciksU3x8TGUoVy5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSwoIV98fCFTKSYmTyh2b2lkIDApfSxfZXJyb3JTdGVwczooKT0+e3A9ITF9fSksayh2b2lkIDApKX11KGZlLFwicHVsbEFsZ29yaXRobVwiKTtmdW5jdGlvbiBldChZKXtpZihfPSEwLEM9WSxTKXtjb25zdCBaPXN0KFtDLHFdKSxyZT1sZShuLFopO08ocmUpfXJldHVybiBqfXUoZXQsXCJjYW5jZWwxQWxnb3JpdGhtXCIpO2Z1bmN0aW9uIFdlKFkpe2lmKFM9ITAscT1ZLF8pe2NvbnN0IFo9c3QoW0MscV0pLHJlPWxlKG4sWik7TyhyZSl9cmV0dXJuIGp9dShXZSxcImNhbmNlbDJBbGdvcml0aG1cIik7ZnVuY3Rpb24gVGUoKXt9cmV0dXJuIHUoVGUsXCJzdGFydEFsZ29yaXRobVwiKSxQPWh0KFRlLGZlLGV0KSxXPWh0KFRlLGZlLFdlKSxVKGEuX2Nsb3NlZFByb21pc2UsWT0+KHVlKFAuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixZKSx1ZShXLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsWSksKCFffHwhUykmJk8odm9pZCAwKSxudWxsKSksW1AsV119dShNaSxcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZVwiKTtmdW5jdGlvbiB4aShuKXtsZXQgbz1OZShuKSxhPSExLHA9ITEsZz0hMSxfPSExLFM9ITEsQyxxLFAsVyxPO2NvbnN0IGo9RihBPT57Tz1BfSk7ZnVuY3Rpb24gZmUoQSl7VShBLl9jbG9zZWRQcm9taXNlLHo9PihBIT09b3x8KHRlKFAuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcix6KSx0ZShXLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIseiksKCFffHwhUykmJk8odm9pZCAwKSksbnVsbCkpfXUoZmUsXCJmb3J3YXJkUmVhZGVyRXJyb3JcIik7ZnVuY3Rpb24gZXQoKXtGZShvKSYmKF9lKG8pLG89TmUobiksZmUobykpLGl0KG8se19jaHVua1N0ZXBzOno9PntnZSgoKT0+e3A9ITEsZz0hMTtjb25zdCBMPXo7bGV0IFg9ejtpZighXyYmIVMpdHJ5e1g9UG4oeil9Y2F0Y2godHQpe3RlKFAuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcix0dCksdGUoVy5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLHR0KSxPKGxlKG4sdHQpKTtyZXR1cm59X3x8QnQoUC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLEwpLFN8fEJ0KFcuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixYKSxhPSExLHA/VGUoKTpnJiZZKCl9KX0sX2Nsb3NlU3RlcHM6KCk9PnthPSExLF98fGF0KFAuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciksU3x8YXQoVy5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSxQLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoPjAmJnF0KFAuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwwKSxXLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoPjAmJnF0KFcuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwwKSwoIV98fCFTKSYmTyh2b2lkIDApfSxfZXJyb3JTdGVwczooKT0+e2E9ITF9fSl9dShldCxcInB1bGxXaXRoRGVmYXVsdFJlYWRlclwiKTtmdW5jdGlvbiBXZShBLHope3ZlKG8pJiYoX2Uobyksbz1MbihuKSxmZShvKSk7Y29uc3QgTD16P1c6UCxYPXo/UDpXO01uKG8sQSwxLHtfY2h1bmtTdGVwczpydD0+e2dlKCgpPT57cD0hMSxnPSExO2NvbnN0IG50PXo/UzpfO2lmKHo/XzpTKW50fHxrdChMLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIscnQpO2Vsc2V7bGV0IENvO3RyeXtDbz1QbihydCl9Y2F0Y2godG4pe3RlKEwuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcix0biksdGUoWC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLHRuKSxPKGxlKG4sdG4pKTtyZXR1cm59bnR8fGt0KEwuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixydCksQnQoWC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLENvKX1hPSExLHA/VGUoKTpnJiZZKCl9KX0sX2Nsb3NlU3RlcHM6cnQ9PnthPSExO2NvbnN0IG50PXo/UzpfLFl0PXo/XzpTO250fHxhdChMLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpLFl0fHxhdChYLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpLHJ0IT09dm9pZCAwJiYobnR8fGt0KEwuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixydCksIVl0JiZYLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoPjAmJnF0KFguX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwwKSksKCFudHx8IVl0KSYmTyh2b2lkIDApfSxfZXJyb3JTdGVwczooKT0+e2E9ITF9fSl9dShXZSxcInB1bGxXaXRoQllPQlJlYWRlclwiKTtmdW5jdGlvbiBUZSgpe2lmKGEpcmV0dXJuIHA9ITAsayh2b2lkIDApO2E9ITA7Y29uc3QgQT13cihQLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO3JldHVybiBBPT09bnVsbD9ldCgpOldlKEEuX3ZpZXcsITEpLGsodm9pZCAwKX11KFRlLFwicHVsbDFBbGdvcml0aG1cIik7ZnVuY3Rpb24gWSgpe2lmKGEpcmV0dXJuIGc9ITAsayh2b2lkIDApO2E9ITA7Y29uc3QgQT13cihXLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO3JldHVybiBBPT09bnVsbD9ldCgpOldlKEEuX3ZpZXcsITApLGsodm9pZCAwKX11KFksXCJwdWxsMkFsZ29yaXRobVwiKTtmdW5jdGlvbiBaKEEpe2lmKF89ITAsQz1BLFMpe2NvbnN0IHo9c3QoW0MscV0pLEw9bGUobix6KTtPKEwpfXJldHVybiBqfXUoWixcImNhbmNlbDFBbGdvcml0aG1cIik7ZnVuY3Rpb24gcmUoQSl7aWYoUz0hMCxxPUEsXyl7Y29uc3Qgej1zdChbQyxxXSksTD1sZShuLHopO08oTCl9cmV0dXJuIGp9dShyZSxcImNhbmNlbDJBbGdvcml0aG1cIik7ZnVuY3Rpb24gQ2UoKXt9cmV0dXJuIHUoQ2UsXCJzdGFydEFsZ29yaXRobVwiKSxQPWxvKENlLFRlLFopLFc9bG8oQ2UsWSxyZSksZmUobyksW1AsV119dSh4aSxcIlJlYWRhYmxlQnl0ZVN0cmVhbVRlZVwiKTtmdW5jdGlvbiBVaShuKXtyZXR1cm4gYihuKSYmdHlwZW9mIG4uZ2V0UmVhZGVyPFwidVwifXUoVWksXCJpc1JlYWRhYmxlU3RyZWFtTGlrZVwiKTtmdW5jdGlvbiBOaShuKXtyZXR1cm4gVWkobik/Vmkobi5nZXRSZWFkZXIoKSk6SGkobil9dShOaSxcIlJlYWRhYmxlU3RyZWFtRnJvbVwiKTtmdW5jdGlvbiBIaShuKXtsZXQgbztjb25zdCBhPUNuKG4sXCJhc3luY1wiKSxwPXk7ZnVuY3Rpb24gZygpe2xldCBTO3RyeXtTPUlvKGEpfWNhdGNoKHEpe3JldHVybiBUKHEpfWNvbnN0IEM9ayhTKTtyZXR1cm4gTihDLHE9PntpZighYihxKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGl0ZXJhdG9yLm5leHQoKSBtZXRob2QgbXVzdCBmdWxmaWxsIHdpdGggYW4gb2JqZWN0XCIpO2lmKGpvKHEpKUxlKG8uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7ZWxzZXtjb25zdCBXPUxvKHEpO0dlKG8uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixXKX19KX11KGcsXCJwdWxsQWxnb3JpdGhtXCIpO2Z1bmN0aW9uIF8oUyl7Y29uc3QgQz1hLml0ZXJhdG9yO2xldCBxO3RyeXtxPXZ0KEMsXCJyZXR1cm5cIil9Y2F0Y2goTyl7cmV0dXJuIFQoTyl9aWYocT09PXZvaWQgMClyZXR1cm4gayh2b2lkIDApO2xldCBQO3RyeXtQPU0ocSxDLFtTXSl9Y2F0Y2goTyl7cmV0dXJuIFQoTyl9Y29uc3QgVz1rKFApO3JldHVybiBOKFcsTz0+e2lmKCFiKE8pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgaXRlcmF0b3IucmV0dXJuKCkgbWV0aG9kIG11c3QgZnVsZmlsbCB3aXRoIGFuIG9iamVjdFwiKX0pfXJldHVybiB1KF8sXCJjYW5jZWxBbGdvcml0aG1cIiksbz1odChwLGcsXywwKSxvfXUoSGksXCJSZWFkYWJsZVN0cmVhbUZyb21JdGVyYWJsZVwiKTtmdW5jdGlvbiBWaShuKXtsZXQgbztjb25zdCBhPXk7ZnVuY3Rpb24gcCgpe2xldCBfO3RyeXtfPW4ucmVhZCgpfWNhdGNoKFMpe3JldHVybiBUKFMpfXJldHVybiBOKF8sUz0+e2lmKCFiKFMpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgcmVhZGVyLnJlYWQoKSBtZXRob2QgbXVzdCBmdWxmaWxsIHdpdGggYW4gb2JqZWN0XCIpO2lmKFMuZG9uZSlMZShvLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO2Vsc2V7Y29uc3QgQz1TLnZhbHVlO0dlKG8uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixDKX19KX11KHAsXCJwdWxsQWxnb3JpdGhtXCIpO2Z1bmN0aW9uIGcoXyl7dHJ5e3JldHVybiBrKG4uY2FuY2VsKF8pKX1jYXRjaChTKXtyZXR1cm4gVChTKX19cmV0dXJuIHUoZyxcImNhbmNlbEFsZ29yaXRobVwiKSxvPWh0KGEscCxnLDApLG99dShWaSxcIlJlYWRhYmxlU3RyZWFtRnJvbURlZmF1bHRSZWFkZXJcIik7ZnVuY3Rpb24gUWkobixvKXtjZShuLG8pO2NvbnN0IGE9bixwPWE/LmF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxnPWE/LmNhbmNlbCxfPWE/LnB1bGwsUz1hPy5zdGFydCxDPWE/LnR5cGU7cmV0dXJue2F1dG9BbGxvY2F0ZUNodW5rU2l6ZTpwPT09dm9pZCAwP3ZvaWQgMDp1cihwLGAke299IGhhcyBtZW1iZXIgJ2F1dG9BbGxvY2F0ZUNodW5rU2l6ZScgdGhhdGApLGNhbmNlbDpnPT09dm9pZCAwP3ZvaWQgMDpHaShnLGEsYCR7b30gaGFzIG1lbWJlciAnY2FuY2VsJyB0aGF0YCkscHVsbDpfPT09dm9pZCAwP3ZvaWQgMDpZaShfLGEsYCR7b30gaGFzIG1lbWJlciAncHVsbCcgdGhhdGApLHN0YXJ0OlM9PT12b2lkIDA/dm9pZCAwOlppKFMsYSxgJHtvfSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLHR5cGU6Qz09PXZvaWQgMD92b2lkIDA6S2koQyxgJHtvfSBoYXMgbWVtYmVyICd0eXBlJyB0aGF0YCl9fXUoUWksXCJjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2VcIik7ZnVuY3Rpb24gR2kobixvLGEpe3JldHVybiBlZShuLGEpLHA9PkgobixvLFtwXSl9dShHaSxcImNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2tcIik7ZnVuY3Rpb24gWWkobixvLGEpe3JldHVybiBlZShuLGEpLHA9PkgobixvLFtwXSl9dShZaSxcImNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrXCIpO2Z1bmN0aW9uIFppKG4sbyxhKXtyZXR1cm4gZWUobixhKSxwPT5NKG4sbyxbcF0pfXUoWmksXCJjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVN0YXJ0Q2FsbGJhY2tcIik7ZnVuY3Rpb24gS2kobixvKXtpZihuPWAke259YCxuIT09XCJieXRlc1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7b30gJyR7bn0nIGlzIG5vdCBhIHZhbGlkIGVudW1lcmF0aW9uIHZhbHVlIGZvciBSZWFkYWJsZVN0cmVhbVR5cGVgKTtyZXR1cm4gbn11KEtpLFwiY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZVwiKTtmdW5jdGlvbiBKaShuLG8pe3JldHVybiBjZShuLG8pLHtwcmV2ZW50Q2FuY2VsOiEhbj8ucHJldmVudENhbmNlbH19dShKaSxcImNvbnZlcnRJdGVyYXRvck9wdGlvbnNcIik7ZnVuY3Rpb24gdW8obixvKXtjZShuLG8pO2NvbnN0IGE9bj8ucHJldmVudEFib3J0LHA9bj8ucHJldmVudENhbmNlbCxnPW4/LnByZXZlbnRDbG9zZSxfPW4/LnNpZ25hbDtyZXR1cm4gXyE9PXZvaWQgMCYmWGkoXyxgJHtvfSBoYXMgbWVtYmVyICdzaWduYWwnIHRoYXRgKSx7cHJldmVudEFib3J0OiEhYSxwcmV2ZW50Q2FuY2VsOiEhcCxwcmV2ZW50Q2xvc2U6ISFnLHNpZ25hbDpffX11KHVvLFwiY29udmVydFBpcGVPcHRpb25zXCIpO2Z1bmN0aW9uIFhpKG4sbyl7aWYoIWFpKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7b30gaXMgbm90IGFuIEFib3J0U2lnbmFsLmApfXUoWGksXCJhc3NlcnRBYm9ydFNpZ25hbFwiKTtmdW5jdGlvbiBlcyhuLG8pe2NlKG4sbyk7Y29uc3QgYT1uPy5yZWFkYWJsZTtzcihhLFwicmVhZGFibGVcIixcIlJlYWRhYmxlV3JpdGFibGVQYWlyXCIpLGxyKGEsYCR7b30gaGFzIG1lbWJlciAncmVhZGFibGUnIHRoYXRgKTtjb25zdCBwPW4/LndyaXRhYmxlO3JldHVybiBzcihwLFwid3JpdGFibGVcIixcIlJlYWRhYmxlV3JpdGFibGVQYWlyXCIpLFVuKHAsYCR7b30gaGFzIG1lbWJlciAnd3JpdGFibGUnIHRoYXRgKSx7cmVhZGFibGU6YSx3cml0YWJsZTpwfX11KGVzLFwiY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyXCIpO2NvbnN0IFpyPWNsYXNzIFpye2NvbnN0cnVjdG9yKG89e30sYT17fSl7bz09PXZvaWQgMD9vPW51bGw6aG4obyxcIkZpcnN0IHBhcmFtZXRlclwiKTtjb25zdCBwPXp0KGEsXCJTZWNvbmQgcGFyYW1ldGVyXCIpLGc9UWkobyxcIkZpcnN0IHBhcmFtZXRlclwiKTtpZihJcih0aGlzKSxnLnR5cGU9PT1cImJ5dGVzXCIpe2lmKHAuc2l6ZSE9PXZvaWQgMCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBzdHJhdGVneSBmb3IgYSBieXRlIHN0cmVhbSBjYW5ub3QgaGF2ZSBhIHNpemUgZnVuY3Rpb25cIik7Y29uc3QgXz1sdChwLDApO0dvKHRoaXMsZyxfKX1lbHNle2NvbnN0IF89T3QocCksUz1sdChwLDEpOyRpKHRoaXMsZyxTLF8pfX1nZXQgbG9ja2VkKCl7aWYoIXFlKHRoaXMpKXRocm93ICRlKFwibG9ja2VkXCIpO3JldHVybiBrZSh0aGlzKX1jYW5jZWwobz12b2lkIDApe3JldHVybiBxZSh0aGlzKT9rZSh0aGlzKT9UKG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FuY2VsIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSByZWFkZXJcIikpOmxlKHRoaXMsbyk6VCgkZShcImNhbmNlbFwiKSl9Z2V0UmVhZGVyKG89dm9pZCAwKXtpZighcWUodGhpcykpdGhyb3cgJGUoXCJnZXRSZWFkZXJcIik7cmV0dXJuIFpvKG8sXCJGaXJzdCBwYXJhbWV0ZXJcIikubW9kZT09PXZvaWQgMD9OZSh0aGlzKTpMbih0aGlzKX1waXBlVGhyb3VnaChvLGE9e30pe2lmKCFxZSh0aGlzKSl0aHJvdyAkZShcInBpcGVUaHJvdWdoXCIpO1NlKG8sMSxcInBpcGVUaHJvdWdoXCIpO2NvbnN0IHA9ZXMobyxcIkZpcnN0IHBhcmFtZXRlclwiKSxnPXVvKGEsXCJTZWNvbmQgcGFyYW1ldGVyXCIpO2lmKGtlKHRoaXMpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW1cIik7aWYoUWUocC53cml0YWJsZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVGhyb3VnaCBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbVwiKTtjb25zdCBfPWlvKHRoaXMscC53cml0YWJsZSxnLnByZXZlbnRDbG9zZSxnLnByZXZlbnRBYm9ydCxnLnByZXZlbnRDYW5jZWwsZy5zaWduYWwpO3JldHVybiBKKF8pLHAucmVhZGFibGV9cGlwZVRvKG8sYT17fSl7aWYoIXFlKHRoaXMpKXJldHVybiBUKCRlKFwicGlwZVRvXCIpKTtpZihvPT09dm9pZCAwKXJldHVybiBUKFwiUGFyYW1ldGVyIDEgaXMgcmVxdWlyZWQgaW4gJ3BpcGVUbycuXCIpO2lmKCFWZShvKSlyZXR1cm4gVChuZXcgVHlwZUVycm9yKFwiUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbydzIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBXcml0YWJsZVN0cmVhbVwiKSk7bGV0IHA7dHJ5e3A9dW8oYSxcIlNlY29uZCBwYXJhbWV0ZXJcIil9Y2F0Y2goZyl7cmV0dXJuIFQoZyl9cmV0dXJuIGtlKHRoaXMpP1QobmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW1cIikpOlFlKG8pP1QobmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW1cIikpOmlvKHRoaXMsbyxwLnByZXZlbnRDbG9zZSxwLnByZXZlbnRBYm9ydCxwLnByZXZlbnRDYW5jZWwscC5zaWduYWwpfXRlZSgpe2lmKCFxZSh0aGlzKSl0aHJvdyAkZShcInRlZVwiKTtjb25zdCBvPURpKHRoaXMpO3JldHVybiBzdChvKX12YWx1ZXMobz12b2lkIDApe2lmKCFxZSh0aGlzKSl0aHJvdyAkZShcInZhbHVlc1wiKTtjb25zdCBhPUppKG8sXCJGaXJzdCBwYXJhbWV0ZXJcIik7cmV0dXJuIHpvKHRoaXMsYS5wcmV2ZW50Q2FuY2VsKX1bcHJdKG8pe3JldHVybiB0aGlzLnZhbHVlcyhvKX1zdGF0aWMgZnJvbShvKXtyZXR1cm4gTmkobyl9fTt1KFpyLFwiUmVhZGFibGVTdHJlYW1cIik7bGV0IFY9WnI7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVix7ZnJvbTp7ZW51bWVyYWJsZTohMH19KSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhWLnByb3RvdHlwZSx7Y2FuY2VsOntlbnVtZXJhYmxlOiEwfSxnZXRSZWFkZXI6e2VudW1lcmFibGU6ITB9LHBpcGVUaHJvdWdoOntlbnVtZXJhYmxlOiEwfSxwaXBlVG86e2VudW1lcmFibGU6ITB9LHRlZTp7ZW51bWVyYWJsZTohMH0sdmFsdWVzOntlbnVtZXJhYmxlOiEwfSxsb2NrZWQ6e2VudW1lcmFibGU6ITB9fSksdyhWLmZyb20sXCJmcm9tXCIpLHcoVi5wcm90b3R5cGUuY2FuY2VsLFwiY2FuY2VsXCIpLHcoVi5wcm90b3R5cGUuZ2V0UmVhZGVyLFwiZ2V0UmVhZGVyXCIpLHcoVi5wcm90b3R5cGUucGlwZVRocm91Z2gsXCJwaXBlVGhyb3VnaFwiKSx3KFYucHJvdG90eXBlLnBpcGVUbyxcInBpcGVUb1wiKSx3KFYucHJvdG90eXBlLnRlZSxcInRlZVwiKSx3KFYucHJvdG90eXBlLnZhbHVlcyxcInZhbHVlc1wiKSx0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT1cInN5bWJvbFwiJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoVi5wcm90b3R5cGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIlJlYWRhYmxlU3RyZWFtXCIsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFYucHJvdG90eXBlLHByLHt2YWx1ZTpWLnByb3RvdHlwZS52YWx1ZXMsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSk7ZnVuY3Rpb24gaHQobixvLGEscD0xLGc9KCk9PjEpe2NvbnN0IF89T2JqZWN0LmNyZWF0ZShWLnByb3RvdHlwZSk7SXIoXyk7Y29uc3QgUz1PYmplY3QuY3JlYXRlKGFlLnByb3RvdHlwZSk7cmV0dXJuIGFvKF8sUyxuLG8sYSxwLGcpLF99dShodCxcIkNyZWF0ZVJlYWRhYmxlU3RyZWFtXCIpO2Z1bmN0aW9uIGxvKG4sbyxhKXtjb25zdCBwPU9iamVjdC5jcmVhdGUoVi5wcm90b3R5cGUpO0lyKHApO2NvbnN0IGc9T2JqZWN0LmNyZWF0ZShpZS5wcm90b3R5cGUpO3JldHVybiBqbihwLGcsbixvLGEsMCx2b2lkIDApLHB9dShsbyxcIkNyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbVwiKTtmdW5jdGlvbiBJcihuKXtuLl9zdGF0ZT1cInJlYWRhYmxlXCIsbi5fcmVhZGVyPXZvaWQgMCxuLl9zdG9yZWRFcnJvcj12b2lkIDAsbi5fZGlzdHVyYmVkPSExfXUoSXIsXCJJbml0aWFsaXplUmVhZGFibGVTdHJlYW1cIik7ZnVuY3Rpb24gcWUobil7cmV0dXJuIWIobil8fCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixcIl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJcIik/ITE6biBpbnN0YW5jZW9mIFZ9dShxZSxcIklzUmVhZGFibGVTdHJlYW1cIik7ZnVuY3Rpb24ga2Uobil7cmV0dXJuIG4uX3JlYWRlciE9PXZvaWQgMH11KGtlLFwiSXNSZWFkYWJsZVN0cmVhbUxvY2tlZFwiKTtmdW5jdGlvbiBsZShuLG8pe2lmKG4uX2Rpc3R1cmJlZD0hMCxuLl9zdGF0ZT09PVwiY2xvc2VkXCIpcmV0dXJuIGsodm9pZCAwKTtpZihuLl9zdGF0ZT09PVwiZXJyb3JlZFwiKXJldHVybiBUKG4uX3N0b3JlZEVycm9yKTtwdChuKTtjb25zdCBhPW4uX3JlYWRlcjtpZihhIT09dm9pZCAwJiZGZShhKSl7Y29uc3QgZz1hLl9yZWFkSW50b1JlcXVlc3RzO2EuX3JlYWRJbnRvUmVxdWVzdHM9bmV3IFEsZy5mb3JFYWNoKF89PntfLl9jbG9zZVN0ZXBzKHZvaWQgMCl9KX1jb25zdCBwPW4uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltlcl0obyk7cmV0dXJuIE4ocCx5KX11KGxlLFwiUmVhZGFibGVTdHJlYW1DYW5jZWxcIik7ZnVuY3Rpb24gcHQobil7bi5fc3RhdGU9XCJjbG9zZWRcIjtjb25zdCBvPW4uX3JlYWRlcjtpZihvIT09dm9pZCAwJiYoY24obyksdmUobykpKXtjb25zdCBhPW8uX3JlYWRSZXF1ZXN0cztvLl9yZWFkUmVxdWVzdHM9bmV3IFEsYS5mb3JFYWNoKHA9PntwLl9jbG9zZVN0ZXBzKCl9KX19dShwdCxcIlJlYWRhYmxlU3RyZWFtQ2xvc2VcIik7ZnVuY3Rpb24gZm8obixvKXtuLl9zdGF0ZT1cImVycm9yZWRcIixuLl9zdG9yZWRFcnJvcj1vO2NvbnN0IGE9bi5fcmVhZGVyO2EhPT12b2lkIDAmJihpcihhLG8pLHZlKGEpP3luKGEsbyk6eG4oYSxvKSl9dShmbyxcIlJlYWRhYmxlU3RyZWFtRXJyb3JcIik7ZnVuY3Rpb24gJGUobil7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS4ke259IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbWApfXUoJGUsXCJzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDFcIik7ZnVuY3Rpb24gY28obixvKXtjZShuLG8pO2NvbnN0IGE9bj8uaGlnaFdhdGVyTWFyaztyZXR1cm4gc3IoYSxcImhpZ2hXYXRlck1hcmtcIixcIlF1ZXVpbmdTdHJhdGVneUluaXRcIikse2hpZ2hXYXRlck1hcms6YXIoYSl9fXUoY28sXCJjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdFwiKTtjb25zdCBobz11KG49Pm4uYnl0ZUxlbmd0aCxcImJ5dGVMZW5ndGhTaXplRnVuY3Rpb25cIik7dyhobyxcInNpemVcIik7Y29uc3QgS3I9Y2xhc3MgS3J7Y29uc3RydWN0b3Iobyl7U2UobywxLFwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneVwiKSxvPWNvKG8sXCJGaXJzdCBwYXJhbWV0ZXJcIiksdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms9by5oaWdoV2F0ZXJNYXJrfWdldCBoaWdoV2F0ZXJNYXJrKCl7aWYoIWJvKHRoaXMpKXRocm93IHBvKFwiaGlnaFdhdGVyTWFya1wiKTtyZXR1cm4gdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmt9Z2V0IHNpemUoKXtpZighYm8odGhpcykpdGhyb3cgcG8oXCJzaXplXCIpO3JldHVybiBob319O3UoS3IsXCJCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5XCIpO2xldCBaZT1LcjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhaZS5wcm90b3R5cGUse2hpZ2hXYXRlck1hcms6e2VudW1lcmFibGU6ITB9LHNpemU6e2VudW1lcmFibGU6ITB9fSksdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09XCJzeW1ib2xcIiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KFplLnByb3RvdHlwZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneVwiLGNvbmZpZ3VyYWJsZTohMH0pO2Z1bmN0aW9uIHBvKG4pe3JldHVybiBuZXcgVHlwZUVycm9yKGBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS4ke259IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5YCl9dShwbyxcImJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uXCIpO2Z1bmN0aW9uIGJvKG4pe3JldHVybiFiKG4pfHwhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmtcIik/ITE6biBpbnN0YW5jZW9mIFplfXUoYm8sXCJJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lcIik7Y29uc3QgbW89dSgoKT0+MSxcImNvdW50U2l6ZUZ1bmN0aW9uXCIpO3cobW8sXCJzaXplXCIpO2NvbnN0IEpyPWNsYXNzIEpye2NvbnN0cnVjdG9yKG8pe1NlKG8sMSxcIkNvdW50UXVldWluZ1N0cmF0ZWd5XCIpLG89Y28obyxcIkZpcnN0IHBhcmFtZXRlclwiKSx0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms9by5oaWdoV2F0ZXJNYXJrfWdldCBoaWdoV2F0ZXJNYXJrKCl7aWYoIWdvKHRoaXMpKXRocm93IHlvKFwiaGlnaFdhdGVyTWFya1wiKTtyZXR1cm4gdGhpcy5fY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrfWdldCBzaXplKCl7aWYoIWdvKHRoaXMpKXRocm93IHlvKFwic2l6ZVwiKTtyZXR1cm4gbW99fTt1KEpyLFwiQ291bnRRdWV1aW5nU3RyYXRlZ3lcIik7bGV0IEtlPUpyO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEtlLnByb3RvdHlwZSx7aGlnaFdhdGVyTWFyazp7ZW51bWVyYWJsZTohMH0sc2l6ZTp7ZW51bWVyYWJsZTohMH19KSx0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT1cInN5bWJvbFwiJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoS2UucHJvdG90eXBlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJDb3VudFF1ZXVpbmdTdHJhdGVneVwiLGNvbmZpZ3VyYWJsZTohMH0pO2Z1bmN0aW9uIHlvKG4pe3JldHVybiBuZXcgVHlwZUVycm9yKGBDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtufSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQ291bnRRdWV1aW5nU3RyYXRlZ3lgKX11KHlvLFwiY291bnRCcmFuZENoZWNrRXhjZXB0aW9uXCIpO2Z1bmN0aW9uIGdvKG4pe3JldHVybiFiKG4pfHwhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrXCIpPyExOm4gaW5zdGFuY2VvZiBLZX11KGdvLFwiSXNDb3VudFF1ZXVpbmdTdHJhdGVneVwiKTtmdW5jdGlvbiB0cyhuLG8pe2NlKG4sbyk7Y29uc3QgYT1uPy5jYW5jZWwscD1uPy5mbHVzaCxnPW4/LnJlYWRhYmxlVHlwZSxfPW4/LnN0YXJ0LFM9bj8udHJhbnNmb3JtLEM9bj8ud3JpdGFibGVUeXBlO3JldHVybntjYW5jZWw6YT09PXZvaWQgMD92b2lkIDA6aXMoYSxuLGAke299IGhhcyBtZW1iZXIgJ2NhbmNlbCcgdGhhdGApLGZsdXNoOnA9PT12b2lkIDA/dm9pZCAwOnJzKHAsbixgJHtvfSBoYXMgbWVtYmVyICdmbHVzaCcgdGhhdGApLHJlYWRhYmxlVHlwZTpnLHN0YXJ0Ol89PT12b2lkIDA/dm9pZCAwOm5zKF8sbixgJHtvfSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLHRyYW5zZm9ybTpTPT09dm9pZCAwP3ZvaWQgMDpvcyhTLG4sYCR7b30gaGFzIG1lbWJlciAndHJhbnNmb3JtJyB0aGF0YCksd3JpdGFibGVUeXBlOkN9fXUodHMsXCJjb252ZXJ0VHJhbnNmb3JtZXJcIik7ZnVuY3Rpb24gcnMobixvLGEpe3JldHVybiBlZShuLGEpLHA9PkgobixvLFtwXSl9dShycyxcImNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2tcIik7ZnVuY3Rpb24gbnMobixvLGEpe3JldHVybiBlZShuLGEpLHA9Pk0obixvLFtwXSl9dShucyxcImNvbnZlcnRUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2tcIik7ZnVuY3Rpb24gb3MobixvLGEpe3JldHVybiBlZShuLGEpLChwLGcpPT5IKG4sbyxbcCxnXSl9dShvcyxcImNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrXCIpO2Z1bmN0aW9uIGlzKG4sbyxhKXtyZXR1cm4gZWUobixhKSxwPT5IKG4sbyxbcF0pfXUoaXMsXCJjb252ZXJ0VHJhbnNmb3JtZXJDYW5jZWxDYWxsYmFja1wiKTtjb25zdCBYcj1jbGFzcyBYcntjb25zdHJ1Y3RvcihvPXt9LGE9e30scD17fSl7bz09PXZvaWQgMCYmKG89bnVsbCk7Y29uc3QgZz16dChhLFwiU2Vjb25kIHBhcmFtZXRlclwiKSxfPXp0KHAsXCJUaGlyZCBwYXJhbWV0ZXJcIiksUz10cyhvLFwiRmlyc3QgcGFyYW1ldGVyXCIpO2lmKFMucmVhZGFibGVUeXBlIT09dm9pZCAwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByZWFkYWJsZVR5cGUgc3BlY2lmaWVkXCIpO2lmKFMud3JpdGFibGVUeXBlIT09dm9pZCAwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB3cml0YWJsZVR5cGUgc3BlY2lmaWVkXCIpO2NvbnN0IEM9bHQoXywwKSxxPU90KF8pLFA9bHQoZywxKSxXPU90KGcpO2xldCBPO2NvbnN0IGo9RihmZT0+e089ZmV9KTtzcyh0aGlzLGosUCxXLEMscSksdXModGhpcyxTKSxTLnN0YXJ0IT09dm9pZCAwP08oUy5zdGFydCh0aGlzLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyKSk6Tyh2b2lkIDApfWdldCByZWFkYWJsZSgpe2lmKCFfbyh0aGlzKSl0aHJvdyBUbyhcInJlYWRhYmxlXCIpO3JldHVybiB0aGlzLl9yZWFkYWJsZX1nZXQgd3JpdGFibGUoKXtpZighX28odGhpcykpdGhyb3cgVG8oXCJ3cml0YWJsZVwiKTtyZXR1cm4gdGhpcy5fd3JpdGFibGV9fTt1KFhyLFwiVHJhbnNmb3JtU3RyZWFtXCIpO2xldCBKZT1YcjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhKZS5wcm90b3R5cGUse3JlYWRhYmxlOntlbnVtZXJhYmxlOiEwfSx3cml0YWJsZTp7ZW51bWVyYWJsZTohMH19KSx0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT1cInN5bWJvbFwiJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoSmUucHJvdG90eXBlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJUcmFuc2Zvcm1TdHJlYW1cIixjb25maWd1cmFibGU6ITB9KTtmdW5jdGlvbiBzcyhuLG8sYSxwLGcsXyl7ZnVuY3Rpb24gUygpe3JldHVybiBvfXUoUyxcInN0YXJ0QWxnb3JpdGhtXCIpO2Z1bmN0aW9uIEMoail7cmV0dXJuIGNzKG4sail9dShDLFwid3JpdGVBbGdvcml0aG1cIik7ZnVuY3Rpb24gcShqKXtyZXR1cm4gZHMobixqKX11KHEsXCJhYm9ydEFsZ29yaXRobVwiKTtmdW5jdGlvbiBQKCl7cmV0dXJuIGhzKG4pfXUoUCxcImNsb3NlQWxnb3JpdGhtXCIpLG4uX3dyaXRhYmxlPWZpKFMsQyxQLHEsYSxwKTtmdW5jdGlvbiBXKCl7cmV0dXJuIHBzKG4pfXUoVyxcInB1bGxBbGdvcml0aG1cIik7ZnVuY3Rpb24gTyhqKXtyZXR1cm4gYnMobixqKX11KE8sXCJjYW5jZWxBbGdvcml0aG1cIiksbi5fcmVhZGFibGU9aHQoUyxXLE8sZyxfKSxuLl9iYWNrcHJlc3N1cmU9dm9pZCAwLG4uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2U9dm9pZCAwLG4uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZT12b2lkIDAsSHQobiwhMCksbi5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcj12b2lkIDB9dShzcyxcIkluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW1cIik7ZnVuY3Rpb24gX28obil7cmV0dXJuIWIobil8fCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixcIl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyXCIpPyExOm4gaW5zdGFuY2VvZiBKZX11KF9vLFwiSXNUcmFuc2Zvcm1TdHJlYW1cIik7ZnVuY3Rpb24gU28obixvKXt1ZShuLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLG8pLGpyKG4sbyl9dShTbyxcIlRyYW5zZm9ybVN0cmVhbUVycm9yXCIpO2Z1bmN0aW9uIGpyKG4sbyl7UXQobi5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciksZnQobi5fd3JpdGFibGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcixvKSxMcihuKX11KGpyLFwiVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZVwiKTtmdW5jdGlvbiBMcihuKXtuLl9iYWNrcHJlc3N1cmUmJkh0KG4sITEpfXUoTHIsXCJUcmFuc2Zvcm1TdHJlYW1VbmJsb2NrV3JpdGVcIik7ZnVuY3Rpb24gSHQobixvKXtuLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlIT09dm9pZCAwJiZuLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUoKSxuLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlPUYoYT0+e24uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZT1hfSksbi5fYmFja3ByZXNzdXJlPW99dShIdCxcIlRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZVwiKTtjb25zdCBlbj1jbGFzcyBlbntjb25zdHJ1Y3Rvcigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNvbnN0cnVjdG9yXCIpfWdldCBkZXNpcmVkU2l6ZSgpe2lmKCFWdCh0aGlzKSl0aHJvdyBHdChcImRlc2lyZWRTaXplXCIpO2NvbnN0IG89dGhpcy5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtyZXR1cm4gRnIobyl9ZW5xdWV1ZShvPXZvaWQgMCl7aWYoIVZ0KHRoaXMpKXRocm93IEd0KFwiZW5xdWV1ZVwiKTt3byh0aGlzLG8pfWVycm9yKG89dm9pZCAwKXtpZighVnQodGhpcykpdGhyb3cgR3QoXCJlcnJvclwiKTtscyh0aGlzLG8pfXRlcm1pbmF0ZSgpe2lmKCFWdCh0aGlzKSl0aHJvdyBHdChcInRlcm1pbmF0ZVwiKTtmcyh0aGlzKX19O3UoZW4sXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiKTtsZXQgbWU9ZW47T2JqZWN0LmRlZmluZVByb3BlcnRpZXMobWUucHJvdG90eXBlLHtlbnF1ZXVlOntlbnVtZXJhYmxlOiEwfSxlcnJvcjp7ZW51bWVyYWJsZTohMH0sdGVybWluYXRlOntlbnVtZXJhYmxlOiEwfSxkZXNpcmVkU2l6ZTp7ZW51bWVyYWJsZTohMH19KSx3KG1lLnByb3RvdHlwZS5lbnF1ZXVlLFwiZW5xdWV1ZVwiKSx3KG1lLnByb3RvdHlwZS5lcnJvcixcImVycm9yXCIpLHcobWUucHJvdG90eXBlLnRlcm1pbmF0ZSxcInRlcm1pbmF0ZVwiKSx0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT1cInN5bWJvbFwiJiZPYmplY3QuZGVmaW5lUHJvcGVydHkobWUucHJvdG90eXBlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiLGNvbmZpZ3VyYWJsZTohMH0pO2Z1bmN0aW9uIFZ0KG4pe3JldHVybiFiKG4pfHwhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sXCJfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbVwiKT8hMTpuIGluc3RhbmNlb2YgbWV9dShWdCxcIklzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcIik7ZnVuY3Rpb24gYXMobixvLGEscCxnKXtvLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtPW4sbi5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcj1vLG8uX3RyYW5zZm9ybUFsZ29yaXRobT1hLG8uX2ZsdXNoQWxnb3JpdGhtPXAsby5fY2FuY2VsQWxnb3JpdGhtPWcsby5fZmluaXNoUHJvbWlzZT12b2lkIDAsby5fZmluaXNoUHJvbWlzZV9yZXNvbHZlPXZvaWQgMCxvLl9maW5pc2hQcm9taXNlX3JlamVjdD12b2lkIDB9dShhcyxcIlNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcIik7ZnVuY3Rpb24gdXMobixvKXtjb25zdCBhPU9iamVjdC5jcmVhdGUobWUucHJvdG90eXBlKTtsZXQgcCxnLF87by50cmFuc2Zvcm0hPT12b2lkIDA/cD11KFM9Pm8udHJhbnNmb3JtKFMsYSksXCJ0cmFuc2Zvcm1BbGdvcml0aG1cIik6cD11KFM9Pnt0cnl7cmV0dXJuIHdvKGEsUyksayh2b2lkIDApfWNhdGNoKEMpe3JldHVybiBUKEMpfX0sXCJ0cmFuc2Zvcm1BbGdvcml0aG1cIiksby5mbHVzaCE9PXZvaWQgMD9nPXUoKCk9Pm8uZmx1c2goYSksXCJmbHVzaEFsZ29yaXRobVwiKTpnPXUoKCk9Pmsodm9pZCAwKSxcImZsdXNoQWxnb3JpdGhtXCIpLG8uY2FuY2VsIT09dm9pZCAwP189dShTPT5vLmNhbmNlbChTKSxcImNhbmNlbEFsZ29yaXRobVwiKTpfPXUoKCk9Pmsodm9pZCAwKSxcImNhbmNlbEFsZ29yaXRobVwiKSxhcyhuLGEscCxnLF8pfXUodXMsXCJTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVRyYW5zZm9ybWVyXCIpO2Z1bmN0aW9uIFF0KG4pe24uX3RyYW5zZm9ybUFsZ29yaXRobT12b2lkIDAsbi5fZmx1c2hBbGdvcml0aG09dm9pZCAwLG4uX2NhbmNlbEFsZ29yaXRobT12b2lkIDB9dShRdCxcIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zXCIpO2Z1bmN0aW9uIHdvKG4sbyl7Y29uc3QgYT1uLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLHA9YS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtpZighWWUocCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlIHNpZGUgaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWVcIik7dHJ5e0dlKHAsbyl9Y2F0Y2goXyl7dGhyb3cganIoYSxfKSxhLl9yZWFkYWJsZS5fc3RvcmVkRXJyb3J9TGkocCkhPT1hLl9iYWNrcHJlc3N1cmUmJkh0KGEsITApfXUod28sXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWVcIik7ZnVuY3Rpb24gbHMobixvKXtTbyhuLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLG8pfXUobHMsXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yXCIpO2Z1bmN0aW9uIFJvKG4sbyl7Y29uc3QgYT1uLl90cmFuc2Zvcm1BbGdvcml0aG0obyk7cmV0dXJuIE4oYSx2b2lkIDAscD0+e3Rocm93IFNvKG4uX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0scCkscH0pfXUoUm8sXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm1cIik7ZnVuY3Rpb24gZnMobil7Y29uc3Qgbz1uLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLGE9by5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtMZShhKTtjb25zdCBwPW5ldyBUeXBlRXJyb3IoXCJUcmFuc2Zvcm1TdHJlYW0gdGVybWluYXRlZFwiKTtqcihvLHApfXUoZnMsXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclRlcm1pbmF0ZVwiKTtmdW5jdGlvbiBjcyhuLG8pe2NvbnN0IGE9bi5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtpZihuLl9iYWNrcHJlc3N1cmUpe2NvbnN0IHA9bi5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtyZXR1cm4gTihwLCgpPT57Y29uc3QgZz1uLl93cml0YWJsZTtpZihnLl9zdGF0ZT09PVwiZXJyb3JpbmdcIil0aHJvdyBnLl9zdG9yZWRFcnJvcjtyZXR1cm4gUm8oYSxvKX0pfXJldHVybiBSbyhhLG8pfXUoY3MsXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtXCIpO2Z1bmN0aW9uIGRzKG4sbyl7Y29uc3QgYT1uLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO2lmKGEuX2ZpbmlzaFByb21pc2UhPT12b2lkIDApcmV0dXJuIGEuX2ZpbmlzaFByb21pc2U7Y29uc3QgcD1uLl9yZWFkYWJsZTthLl9maW5pc2hQcm9taXNlPUYoKF8sUyk9PnthLl9maW5pc2hQcm9taXNlX3Jlc29sdmU9XyxhLl9maW5pc2hQcm9taXNlX3JlamVjdD1TfSk7Y29uc3QgZz1hLl9jYW5jZWxBbGdvcml0aG0obyk7cmV0dXJuIFF0KGEpLEUoZywoKT0+KHAuX3N0YXRlPT09XCJlcnJvcmVkXCI/WGUoYSxwLl9zdG9yZWRFcnJvcik6KHVlKHAuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixvKSwkcihhKSksbnVsbCksXz0+KHVlKHAuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixfKSxYZShhLF8pLG51bGwpKSxhLl9maW5pc2hQcm9taXNlfXUoZHMsXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Fib3J0QWxnb3JpdGhtXCIpO2Z1bmN0aW9uIGhzKG4pe2NvbnN0IG89bi5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtpZihvLl9maW5pc2hQcm9taXNlIT09dm9pZCAwKXJldHVybiBvLl9maW5pc2hQcm9taXNlO2NvbnN0IGE9bi5fcmVhZGFibGU7by5fZmluaXNoUHJvbWlzZT1GKChnLF8pPT57by5fZmluaXNoUHJvbWlzZV9yZXNvbHZlPWcsby5fZmluaXNoUHJvbWlzZV9yZWplY3Q9X30pO2NvbnN0IHA9by5fZmx1c2hBbGdvcml0aG0oKTtyZXR1cm4gUXQobyksRShwLCgpPT4oYS5fc3RhdGU9PT1cImVycm9yZWRcIj9YZShvLGEuX3N0b3JlZEVycm9yKTooTGUoYS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSwkcihvKSksbnVsbCksZz0+KHVlKGEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixnKSxYZShvLGcpLG51bGwpKSxvLl9maW5pc2hQcm9taXNlfXUoaHMsXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtXCIpO2Z1bmN0aW9uIHBzKG4pe3JldHVybiBIdChuLCExKSxuLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlfXUocHMsXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobVwiKTtmdW5jdGlvbiBicyhuLG8pe2NvbnN0IGE9bi5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtpZihhLl9maW5pc2hQcm9taXNlIT09dm9pZCAwKXJldHVybiBhLl9maW5pc2hQcm9taXNlO2NvbnN0IHA9bi5fd3JpdGFibGU7YS5fZmluaXNoUHJvbWlzZT1GKChfLFMpPT57YS5fZmluaXNoUHJvbWlzZV9yZXNvbHZlPV8sYS5fZmluaXNoUHJvbWlzZV9yZWplY3Q9U30pO2NvbnN0IGc9YS5fY2FuY2VsQWxnb3JpdGhtKG8pO3JldHVybiBRdChhKSxFKGcsKCk9PihwLl9zdGF0ZT09PVwiZXJyb3JlZFwiP1hlKGEscC5fc3RvcmVkRXJyb3IpOihmdChwLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsbyksTHIobiksJHIoYSkpLG51bGwpLF89PihmdChwLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsXyksTHIobiksWGUoYSxfKSxudWxsKSksYS5fZmluaXNoUHJvbWlzZX11KGJzLFwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZUNhbmNlbEFsZ29yaXRobVwiKTtmdW5jdGlvbiBHdChuKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bn0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCl9dShHdCxcImRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvblwiKTtmdW5jdGlvbiAkcihuKXtuLl9maW5pc2hQcm9taXNlX3Jlc29sdmUhPT12b2lkIDAmJihuLl9maW5pc2hQcm9taXNlX3Jlc29sdmUoKSxuLl9maW5pc2hQcm9taXNlX3Jlc29sdmU9dm9pZCAwLG4uX2ZpbmlzaFByb21pc2VfcmVqZWN0PXZvaWQgMCl9dSgkcixcImRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlc29sdmVcIik7ZnVuY3Rpb24gWGUobixvKXtuLl9maW5pc2hQcm9taXNlX3JlamVjdCE9PXZvaWQgMCYmKEoobi5fZmluaXNoUHJvbWlzZSksbi5fZmluaXNoUHJvbWlzZV9yZWplY3Qobyksbi5fZmluaXNoUHJvbWlzZV9yZXNvbHZlPXZvaWQgMCxuLl9maW5pc2hQcm9taXNlX3JlamVjdD12b2lkIDApfXUoWGUsXCJkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZWplY3RcIik7ZnVuY3Rpb24gVG8obil7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUuJHtufSBjYW4gb25seSBiZSB1c2VkIG9uIGEgVHJhbnNmb3JtU3RyZWFtYCl9dShUbyxcInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb25cIiksZC5CeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5PVplLGQuQ291bnRRdWV1aW5nU3RyYXRlZ3k9S2UsZC5SZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyPWllLGQuUmVhZGFibGVTdHJlYW09VixkLlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcj1oZSxkLlJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3Q9UmUsZC5SZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPWFlLGQuUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPWRlLGQuVHJhbnNmb3JtU3RyZWFtPUplLGQuVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI9bWUsZC5Xcml0YWJsZVN0cmVhbT1wZSxkLldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI9QmUsZC5Xcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI9c2V9KX0ocG9ueWZpbGxfZXMyMDE4LHBvbnlmaWxsX2VzMjAxOC5leHBvcnRzKSkscG9ueWZpbGxfZXMyMDE4LmV4cG9ydHN9dShyZXF1aXJlUG9ueWZpbGxfZXMyMDE4LFwicmVxdWlyZVBvbnlmaWxsX2VzMjAxOFwiKTtjb25zdCBQT09MX1NJWkUkMT02NTUzNjtpZighZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSl0cnl7Y29uc3QgYz1yZXF1aXJlKFwibm9kZTpwcm9jZXNzXCIpLHtlbWl0V2FybmluZzpsfT1jO3RyeXtjLmVtaXRXYXJuaW5nPSgpPT57fSxPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMscmVxdWlyZShcIm5vZGU6c3RyZWFtL3dlYlwiKSksYy5lbWl0V2FybmluZz1sfWNhdGNoKGQpe3Rocm93IGMuZW1pdFdhcm5pbmc9bCxkfX1jYXRjaHtPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMscmVxdWlyZVBvbnlmaWxsX2VzMjAxOCgpKX10cnl7Y29uc3R7QmxvYjpjfT1yZXF1aXJlKFwiYnVmZmVyXCIpO2MmJiFjLnByb3RvdHlwZS5zdHJlYW0mJihjLnByb3RvdHlwZS5zdHJlYW09dShmdW5jdGlvbihkKXtsZXQgeT0wO2NvbnN0IGI9dGhpcztyZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHt0eXBlOlwiYnl0ZXNcIixhc3luYyBwdWxsKFIpe2NvbnN0IHY9YXdhaXQgYi5zbGljZSh5LE1hdGgubWluKGIuc2l6ZSx5K1BPT0xfU0laRSQxKSkuYXJyYXlCdWZmZXIoKTt5Kz12LmJ5dGVMZW5ndGgsUi5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHYpKSx5PT09Yi5zaXplJiZSLmNsb3NlKCl9fSl9LFwibmFtZVwiKSl9Y2F0Y2h7fS8qISBmZXRjaC1ibG9iLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL2NvbnN0IFBPT0xfU0laRT02NTUzNjthc3luYyBmdW5jdGlvbip0b0l0ZXJhdG9yKGMsbD0hMCl7Zm9yKGNvbnN0IGQgb2YgYylpZihcInN0cmVhbVwiaW4gZCl5aWVsZCpkLnN0cmVhbSgpO2Vsc2UgaWYoQXJyYXlCdWZmZXIuaXNWaWV3KGQpKWlmKGwpe2xldCB5PWQuYnl0ZU9mZnNldDtjb25zdCBiPWQuYnl0ZU9mZnNldCtkLmJ5dGVMZW5ndGg7Zm9yKDt5IT09Yjspe2NvbnN0IFI9TWF0aC5taW4oYi15LFBPT0xfU0laRSksdz1kLmJ1ZmZlci5zbGljZSh5LHkrUik7eSs9dy5ieXRlTGVuZ3RoLHlpZWxkIG5ldyBVaW50OEFycmF5KHcpfX1lbHNlIHlpZWxkIGQ7ZWxzZXtsZXQgeT0wLGI9ZDtmb3IoO3khPT1iLnNpemU7KXtjb25zdCB3PWF3YWl0IGIuc2xpY2UoeSxNYXRoLm1pbihiLnNpemUseStQT09MX1NJWkUpKS5hcnJheUJ1ZmZlcigpO3krPXcuYnl0ZUxlbmd0aCx5aWVsZCBuZXcgVWludDhBcnJheSh3KX19fXUodG9JdGVyYXRvcixcInRvSXRlcmF0b3JcIik7Y29uc3QgX0Jsb2I9KFVlPWNsYXNze2NvbnN0cnVjdG9yKGw9W10sZD17fSl7eWUodGhpcyxQZSxbXSk7eWUodGhpcyxidCxcIlwiKTt5ZSh0aGlzLG90LDApO3llKHRoaXMsWnQsXCJ0cmFuc3BhcmVudFwiKTtpZih0eXBlb2YgbCE9XCJvYmplY3RcInx8bD09PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ0Jsb2InOiBUaGUgcHJvdmlkZWQgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIHNlcXVlbmNlLlwiKTtpZih0eXBlb2YgbFtTeW1ib2wuaXRlcmF0b3JdIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ0Jsb2InOiBUaGUgb2JqZWN0IG11c3QgaGF2ZSBhIGNhbGxhYmxlIEBAaXRlcmF0b3IgcHJvcGVydHkuXCIpO2lmKHR5cGVvZiBkIT1cIm9iamVjdFwiJiZ0eXBlb2YgZCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdCbG9iJzogcGFyYW1ldGVyIDIgY2Fubm90IGNvbnZlcnQgdG8gZGljdGlvbmFyeS5cIik7ZD09PW51bGwmJihkPXt9KTtjb25zdCB5PW5ldyBUZXh0RW5jb2Rlcjtmb3IoY29uc3QgUiBvZiBsKXtsZXQgdztBcnJheUJ1ZmZlci5pc1ZpZXcoUik/dz1uZXcgVWludDhBcnJheShSLmJ1ZmZlci5zbGljZShSLmJ5dGVPZmZzZXQsUi5ieXRlT2Zmc2V0K1IuYnl0ZUxlbmd0aCkpOlIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj93PW5ldyBVaW50OEFycmF5KFIuc2xpY2UoMCkpOlIgaW5zdGFuY2VvZiBVZT93PVI6dz15LmVuY29kZShgJHtSfWApLG5lKHRoaXMsb3QsRCh0aGlzLG90KSsoQXJyYXlCdWZmZXIuaXNWaWV3KHcpP3cuYnl0ZUxlbmd0aDp3LnNpemUpKSxEKHRoaXMsUGUpLnB1c2godyl9bmUodGhpcyxadCxgJHtkLmVuZGluZ3M9PT12b2lkIDA/XCJ0cmFuc3BhcmVudFwiOmQuZW5kaW5nc31gKTtjb25zdCBiPWQudHlwZT09PXZvaWQgMD9cIlwiOlN0cmluZyhkLnR5cGUpO25lKHRoaXMsYnQsL15bXFx4MjAtXFx4N0VdKiQvLnRlc3QoYik/YjpcIlwiKX1nZXQgc2l6ZSgpe3JldHVybiBEKHRoaXMsb3QpfWdldCB0eXBlKCl7cmV0dXJuIEQodGhpcyxidCl9YXN5bmMgdGV4dCgpe2NvbnN0IGw9bmV3IFRleHREZWNvZGVyO2xldCBkPVwiXCI7Zm9yIGF3YWl0KGNvbnN0IHkgb2YgdG9JdGVyYXRvcihEKHRoaXMsUGUpLCExKSlkKz1sLmRlY29kZSh5LHtzdHJlYW06ITB9KTtyZXR1cm4gZCs9bC5kZWNvZGUoKSxkfWFzeW5jIGFycmF5QnVmZmVyKCl7Y29uc3QgbD1uZXcgVWludDhBcnJheSh0aGlzLnNpemUpO2xldCBkPTA7Zm9yIGF3YWl0KGNvbnN0IHkgb2YgdG9JdGVyYXRvcihEKHRoaXMsUGUpLCExKSlsLnNldCh5LGQpLGQrPXkubGVuZ3RoO3JldHVybiBsLmJ1ZmZlcn1zdHJlYW0oKXtjb25zdCBsPXRvSXRlcmF0b3IoRCh0aGlzLFBlKSwhMCk7cmV0dXJuIG5ldyBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKHt0eXBlOlwiYnl0ZXNcIixhc3luYyBwdWxsKGQpe2NvbnN0IHk9YXdhaXQgbC5uZXh0KCk7eS5kb25lP2QuY2xvc2UoKTpkLmVucXVldWUoeS52YWx1ZSl9LGFzeW5jIGNhbmNlbCgpe2F3YWl0IGwucmV0dXJuKCl9fSl9c2xpY2UobD0wLGQ9dGhpcy5zaXplLHk9XCJcIil7Y29uc3R7c2l6ZTpifT10aGlzO2xldCBSPWw8MD9NYXRoLm1heChiK2wsMCk6TWF0aC5taW4obCxiKSx3PWQ8MD9NYXRoLm1heChiK2QsMCk6TWF0aC5taW4oZCxiKTtjb25zdCB2PU1hdGgubWF4KHctUiwwKSxJPUQodGhpcyxQZSksQj1bXTtsZXQgRj0wO2Zvcihjb25zdCBUIG9mIEkpe2lmKEY+PXYpYnJlYWs7Y29uc3QgJD1BcnJheUJ1ZmZlci5pc1ZpZXcoVCk/VC5ieXRlTGVuZ3RoOlQuc2l6ZTtpZihSJiYkPD1SKVItPSQsdy09JDtlbHNle2xldCBFO0FycmF5QnVmZmVyLmlzVmlldyhUKT8oRT1ULnN1YmFycmF5KFIsTWF0aC5taW4oJCx3KSksRis9RS5ieXRlTGVuZ3RoKTooRT1ULnNsaWNlKFIsTWF0aC5taW4oJCx3KSksRis9RS5zaXplKSx3LT0kLEIucHVzaChFKSxSPTB9fWNvbnN0IGs9bmV3IFVlKFtdLHt0eXBlOlN0cmluZyh5KS50b0xvd2VyQ2FzZSgpfSk7cmV0dXJuIG5lKGssb3QsdiksbmUoayxQZSxCKSxrfWdldFtTeW1ib2wudG9TdHJpbmdUYWddKCl7cmV0dXJuXCJCbG9iXCJ9c3RhdGljW1N5bWJvbC5oYXNJbnN0YW5jZV0obCl7cmV0dXJuIGwmJnR5cGVvZiBsPT1cIm9iamVjdFwiJiZ0eXBlb2YgbC5jb25zdHJ1Y3Rvcj09XCJmdW5jdGlvblwiJiYodHlwZW9mIGwuc3RyZWFtPT1cImZ1bmN0aW9uXCJ8fHR5cGVvZiBsLmFycmF5QnVmZmVyPT1cImZ1bmN0aW9uXCIpJiYvXihCbG9ifEZpbGUpJC8udGVzdChsW1N5bWJvbC50b1N0cmluZ1RhZ10pfX0sUGU9bmV3IFdlYWtNYXAsYnQ9bmV3IFdlYWtNYXAsb3Q9bmV3IFdlYWtNYXAsWnQ9bmV3IFdlYWtNYXAsdShVZSxcIkJsb2JcIiksVWUpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF9CbG9iLnByb3RvdHlwZSx7c2l6ZTp7ZW51bWVyYWJsZTohMH0sdHlwZTp7ZW51bWVyYWJsZTohMH0sc2xpY2U6e2VudW1lcmFibGU6ITB9fSk7Y29uc3QgQmxvYj1fQmxvYixyJDE9QmxvYixfRmlsZT0oZ3Q9Y2xhc3MgZXh0ZW5kcyByJDF7Y29uc3RydWN0b3IoZCx5LGI9e30pe2lmKGFyZ3VtZW50cy5sZW5ndGg8Mil0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gY29uc3RydWN0ICdGaWxlJzogMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gKTtzdXBlcihkLGIpO3llKHRoaXMsbXQsMCk7eWUodGhpcyx5dCxcIlwiKTtiPT09bnVsbCYmKGI9e30pO2NvbnN0IFI9Yi5sYXN0TW9kaWZpZWQ9PT12b2lkIDA/RGF0ZS5ub3coKTpOdW1iZXIoYi5sYXN0TW9kaWZpZWQpO051bWJlci5pc05hTihSKXx8bmUodGhpcyxtdCxSKSxuZSh0aGlzLHl0LFN0cmluZyh5KSl9Z2V0IG5hbWUoKXtyZXR1cm4gRCh0aGlzLHl0KX1nZXQgbGFzdE1vZGlmaWVkKCl7cmV0dXJuIEQodGhpcyxtdCl9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm5cIkZpbGVcIn1zdGF0aWNbU3ltYm9sLmhhc0luc3RhbmNlXShkKXtyZXR1cm4hIWQmJmQgaW5zdGFuY2VvZiByJDEmJi9eKEZpbGUpJC8udGVzdChkW1N5bWJvbC50b1N0cmluZ1RhZ10pfX0sbXQ9bmV3IFdlYWtNYXAseXQ9bmV3IFdlYWtNYXAsdShndCxcIkZpbGVcIiksZ3QpLEZpbGU9X0ZpbGUsRmlsZSQxPUZpbGU7LyohIGZvcm1kYXRhLXBvbHlmaWxsLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL3Zhcnt0b1N0cmluZ1RhZzp0JDEsaXRlcmF0b3I6aSxoYXNJbnN0YW5jZTpofT1TeW1ib2wscj1NYXRoLnJhbmRvbSxtPVwiYXBwZW5kLHNldCxnZXQsZ2V0QWxsLGRlbGV0ZSxrZXlzLHZhbHVlcyxlbnRyaWVzLGZvckVhY2gsY29uc3RydWN0b3JcIi5zcGxpdChcIixcIiksZj11KChjLGwsZCk9PihjKz1cIlwiLC9eKEJsb2J8RmlsZSkkLy50ZXN0KGwmJmxbdCQxXSk/WyhkPWQhPT12b2lkIDA/ZCtcIlwiOmxbdCQxXT09XCJGaWxlXCI/bC5uYW1lOlwiYmxvYlwiLGMpLGwubmFtZSE9PWR8fGxbdCQxXT09XCJibG9iXCI/bmV3IEZpbGUkMShbbF0sZCxsKTpsXTpbYyxsK1wiXCJdKSxcImZcIiksZSQxPXUoKGMsbCk9PihsP2M6Yy5yZXBsYWNlKC9cXHI/XFxufFxcci9nLGBcXHJcbmApKS5yZXBsYWNlKC9cXG4vZyxcIiUwQVwiKS5yZXBsYWNlKC9cXHIvZyxcIiUwRFwiKS5yZXBsYWNlKC9cIi9nLFwiJTIyXCIpLFwiZSQxXCIpLHg9dSgoYyxsLGQpPT57aWYobC5sZW5ndGg8ZCl0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnJHtjfScgb24gJ0Zvcm1EYXRhJzogJHtkfSBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7bC5sZW5ndGh9IHByZXNlbnQuYCl9LFwieFwiKTtjb25zdCBGb3JtRGF0YT0oX3Q9Y2xhc3N7Y29uc3RydWN0b3IoLi4ubCl7eWUodGhpcyxvZSxbXSk7aWYobC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ0Zvcm1EYXRhJzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0hUTUxGb3JtRWxlbWVudCcuXCIpfWdldFt0JDFdKCl7cmV0dXJuXCJGb3JtRGF0YVwifVtpXSgpe3JldHVybiB0aGlzLmVudHJpZXMoKX1zdGF0aWNbaF0obCl7cmV0dXJuIGwmJnR5cGVvZiBsPT1cIm9iamVjdFwiJiZsW3QkMV09PT1cIkZvcm1EYXRhXCImJiFtLnNvbWUoZD0+dHlwZW9mIGxbZF0hPVwiZnVuY3Rpb25cIil9YXBwZW5kKC4uLmwpe3goXCJhcHBlbmRcIixhcmd1bWVudHMsMiksRCh0aGlzLG9lKS5wdXNoKGYoLi4ubCkpfWRlbGV0ZShsKXt4KFwiZGVsZXRlXCIsYXJndW1lbnRzLDEpLGwrPVwiXCIsbmUodGhpcyxvZSxEKHRoaXMsb2UpLmZpbHRlcigoW2RdKT0+ZCE9PWwpKX1nZXQobCl7eChcImdldFwiLGFyZ3VtZW50cywxKSxsKz1cIlwiO2Zvcih2YXIgZD1EKHRoaXMsb2UpLHk9ZC5sZW5ndGgsYj0wO2I8eTtiKyspaWYoZFtiXVswXT09PWwpcmV0dXJuIGRbYl1bMV07cmV0dXJuIG51bGx9Z2V0QWxsKGwsZCl7cmV0dXJuIHgoXCJnZXRBbGxcIixhcmd1bWVudHMsMSksZD1bXSxsKz1cIlwiLEQodGhpcyxvZSkuZm9yRWFjaCh5PT55WzBdPT09bCYmZC5wdXNoKHlbMV0pKSxkfWhhcyhsKXtyZXR1cm4geChcImhhc1wiLGFyZ3VtZW50cywxKSxsKz1cIlwiLEQodGhpcyxvZSkuc29tZShkPT5kWzBdPT09bCl9Zm9yRWFjaChsLGQpe3goXCJmb3JFYWNoXCIsYXJndW1lbnRzLDEpO2Zvcih2YXJbeSxiXW9mIHRoaXMpbC5jYWxsKGQsYix5LHRoaXMpfXNldCguLi5sKXt4KFwic2V0XCIsYXJndW1lbnRzLDIpO3ZhciBkPVtdLHk9ITA7bD1mKC4uLmwpLEQodGhpcyxvZSkuZm9yRWFjaChiPT57YlswXT09PWxbMF0/eSYmKHk9IWQucHVzaChsKSk6ZC5wdXNoKGIpfSkseSYmZC5wdXNoKGwpLG5lKHRoaXMsb2UsZCl9KmVudHJpZXMoKXt5aWVsZCpEKHRoaXMsb2UpfSprZXlzKCl7Zm9yKHZhcltsXW9mIHRoaXMpeWllbGQgbH0qdmFsdWVzKCl7Zm9yKHZhclssbF1vZiB0aGlzKXlpZWxkIGx9fSxvZT1uZXcgV2Vha01hcCx1KF90LFwiRm9ybURhdGFcIiksX3QpO2Z1bmN0aW9uIGZvcm1EYXRhVG9CbG9iKGMsbD1yJDEpe3ZhciBkPWAke3IoKX0ke3IoKX1gLnJlcGxhY2UoL1xcLi9nLFwiXCIpLnNsaWNlKC0yOCkucGFkU3RhcnQoMzIsXCItXCIpLHk9W10sYj1gLS0ke2R9XFxyXG5Db250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCJgO3JldHVybiBjLmZvckVhY2goKFIsdyk9PnR5cGVvZiBSPT1cInN0cmluZ1wiP3kucHVzaChiK2UkMSh3KStgXCJcXHJcblxcclxuJHtSLnJlcGxhY2UoL1xccig/IVxcbil8KD88IVxccilcXG4vZyxgXFxyXG5gKX1cXHJcbmApOnkucHVzaChiK2UkMSh3KStgXCI7IGZpbGVuYW1lPVwiJHtlJDEoUi5uYW1lLDEpfVwiXFxyXG5Db250ZW50LVR5cGU6ICR7Ui50eXBlfHxcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifVxcclxuXFxyXG5gLFIsYFxcclxuYCkpLHkucHVzaChgLS0ke2R9LS1gKSxuZXcgbCh5LHt0eXBlOlwibXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9XCIrZH0pfXUoZm9ybURhdGFUb0Jsb2IsXCJmb3JtRGF0YVRvQmxvYlwiKTtjb25zdCBybj1jbGFzcyBybiBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKGwsZCl7c3VwZXIobCksRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyx0aGlzLmNvbnN0cnVjdG9yKSx0aGlzLnR5cGU9ZH1nZXQgbmFtZSgpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWV9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lfX07dShybixcIkZldGNoQmFzZUVycm9yXCIpO2xldCBGZXRjaEJhc2VFcnJvcj1ybjtjb25zdCBubj1jbGFzcyBubiBleHRlbmRzIEZldGNoQmFzZUVycm9ye2NvbnN0cnVjdG9yKGwsZCx5KXtzdXBlcihsLGQpLHkmJih0aGlzLmNvZGU9dGhpcy5lcnJubz15LmNvZGUsdGhpcy5lcnJvcmVkU3lzQ2FsbD15LnN5c2NhbGwpfX07dShubixcIkZldGNoRXJyb3JcIik7bGV0IEZldGNoRXJyb3I9bm47Y29uc3QgTkFNRT1TeW1ib2wudG9TdHJpbmdUYWcsaXNVUkxTZWFyY2hQYXJhbWV0ZXJzPXUoYz0+dHlwZW9mIGM9PVwib2JqZWN0XCImJnR5cGVvZiBjLmFwcGVuZD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgYy5kZWxldGU9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGMuZ2V0PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBjLmdldEFsbD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgYy5oYXM9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGMuc2V0PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBjLnNvcnQ9PVwiZnVuY3Rpb25cIiYmY1tOQU1FXT09PVwiVVJMU2VhcmNoUGFyYW1zXCIsXCJpc1VSTFNlYXJjaFBhcmFtZXRlcnNcIiksaXNCbG9iPXUoYz0+YyYmdHlwZW9mIGM9PVwib2JqZWN0XCImJnR5cGVvZiBjLmFycmF5QnVmZmVyPT1cImZ1bmN0aW9uXCImJnR5cGVvZiBjLnR5cGU9PVwic3RyaW5nXCImJnR5cGVvZiBjLnN0cmVhbT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgYy5jb25zdHJ1Y3Rvcj09XCJmdW5jdGlvblwiJiYvXihCbG9ifEZpbGUpJC8udGVzdChjW05BTUVdKSxcImlzQmxvYlwiKSxpc0Fib3J0U2lnbmFsPXUoYz0+dHlwZW9mIGM9PVwib2JqZWN0XCImJihjW05BTUVdPT09XCJBYm9ydFNpZ25hbFwifHxjW05BTUVdPT09XCJFdmVudFRhcmdldFwiKSxcImlzQWJvcnRTaWduYWxcIiksaXNEb21haW5PclN1YmRvbWFpbj11KChjLGwpPT57Y29uc3QgZD1uZXcgVVJMKGwpLmhvc3RuYW1lLHk9bmV3IFVSTChjKS5ob3N0bmFtZTtyZXR1cm4gZD09PXl8fGQuZW5kc1dpdGgoYC4ke3l9YCl9LFwiaXNEb21haW5PclN1YmRvbWFpblwiKSxpc1NhbWVQcm90b2NvbD11KChjLGwpPT57Y29uc3QgZD1uZXcgVVJMKGwpLnByb3RvY29sLHk9bmV3IFVSTChjKS5wcm90b2NvbDtyZXR1cm4gZD09PXl9LFwiaXNTYW1lUHJvdG9jb2xcIikscGlwZWxpbmU9cmVxdWlyZSQkMC5wcm9taXNpZnkoU3RyZWFtX19kZWZhdWx0LnBpcGVsaW5lKSxJTlRFUk5BTFMkMj1TeW1ib2woXCJCb2R5IGludGVybmFsc1wiKSxvbj1jbGFzcyBvbntjb25zdHJ1Y3RvcihsLHtzaXplOmQ9MH09e30pe2xldCB5PW51bGw7bD09PW51bGw/bD1udWxsOmlzVVJMU2VhcmNoUGFyYW1ldGVycyhsKT9sPXJlcXVpcmUkJDYuQnVmZmVyLmZyb20obC50b1N0cmluZygpKTppc0Jsb2IobCl8fHJlcXVpcmUkJDYuQnVmZmVyLmlzQnVmZmVyKGwpfHwocmVxdWlyZSQkMC50eXBlcy5pc0FueUFycmF5QnVmZmVyKGwpP2w9cmVxdWlyZSQkNi5CdWZmZXIuZnJvbShsKTpBcnJheUJ1ZmZlci5pc1ZpZXcobCk/bD1yZXF1aXJlJCQ2LkJ1ZmZlci5mcm9tKGwuYnVmZmVyLGwuYnl0ZU9mZnNldCxsLmJ5dGVMZW5ndGgpOmwgaW5zdGFuY2VvZiBTdHJlYW1fX2RlZmF1bHR8fChsIGluc3RhbmNlb2YgRm9ybURhdGE/KGw9Zm9ybURhdGFUb0Jsb2IobCkseT1sLnR5cGUuc3BsaXQoXCI9XCIpWzFdKTpsPXJlcXVpcmUkJDYuQnVmZmVyLmZyb20oU3RyaW5nKGwpKSkpO2xldCBiPWw7cmVxdWlyZSQkNi5CdWZmZXIuaXNCdWZmZXIobCk/Yj1TdHJlYW1fX2RlZmF1bHQuUmVhZGFibGUuZnJvbShsKTppc0Jsb2IobCkmJihiPVN0cmVhbV9fZGVmYXVsdC5SZWFkYWJsZS5mcm9tKGwuc3RyZWFtKCkpKSx0aGlzW0lOVEVSTkFMUyQyXT17Ym9keTpsLHN0cmVhbTpiLGJvdW5kYXJ5OnksZGlzdHVyYmVkOiExLGVycm9yOm51bGx9LHRoaXMuc2l6ZT1kLGwgaW5zdGFuY2VvZiBTdHJlYW1fX2RlZmF1bHQmJmwub24oXCJlcnJvclwiLFI9Pntjb25zdCB3PVIgaW5zdGFuY2VvZiBGZXRjaEJhc2VFcnJvcj9SOm5ldyBGZXRjaEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGJvZHkgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7dGhpcy51cmx9OiAke1IubWVzc2FnZX1gLFwic3lzdGVtXCIsUik7dGhpc1tJTlRFUk5BTFMkMl0uZXJyb3I9d30pfWdldCBib2R5KCl7cmV0dXJuIHRoaXNbSU5URVJOQUxTJDJdLnN0cmVhbX1nZXQgYm9keVVzZWQoKXtyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMl0uZGlzdHVyYmVkfWFzeW5jIGFycmF5QnVmZmVyKCl7Y29uc3R7YnVmZmVyOmwsYnl0ZU9mZnNldDpkLGJ5dGVMZW5ndGg6eX09YXdhaXQgY29uc3VtZUJvZHkodGhpcyk7cmV0dXJuIGwuc2xpY2UoZCxkK3kpfWFzeW5jIGZvcm1EYXRhKCl7Y29uc3QgbD10aGlzLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO2lmKGwuc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSl7Y29uc3QgeT1uZXcgRm9ybURhdGEsYj1uZXcgVVJMU2VhcmNoUGFyYW1zKGF3YWl0IHRoaXMudGV4dCgpKTtmb3IoY29uc3RbUix3XW9mIGIpeS5hcHBlbmQoUix3KTtyZXR1cm4geX1jb25zdHt0b0Zvcm1EYXRhOmR9PWF3YWl0IGltcG9ydChcIi4vY2h1bmtzL211bHRpcGFydC1wYXJzZXIuY2pzXCIpO3JldHVybiBkKHRoaXMuYm9keSxsKX1hc3luYyBibG9iKCl7Y29uc3QgbD10aGlzLmhlYWRlcnMmJnRoaXMuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIil8fHRoaXNbSU5URVJOQUxTJDJdLmJvZHkmJnRoaXNbSU5URVJOQUxTJDJdLmJvZHkudHlwZXx8XCJcIixkPWF3YWl0IHRoaXMuYXJyYXlCdWZmZXIoKTtyZXR1cm4gbmV3IHIkMShbZF0se3R5cGU6bH0pfWFzeW5jIGpzb24oKXtjb25zdCBsPWF3YWl0IHRoaXMudGV4dCgpO3JldHVybiBKU09OLnBhcnNlKGwpfWFzeW5jIHRleHQoKXtjb25zdCBsPWF3YWl0IGNvbnN1bWVCb2R5KHRoaXMpO3JldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobCl9YnVmZmVyKCl7cmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMpfX07dShvbixcIkJvZHlcIik7bGV0IEJvZHk9b247Qm9keS5wcm90b3R5cGUuYnVmZmVyPXJlcXVpcmUkJDAuZGVwcmVjYXRlKEJvZHkucHJvdG90eXBlLmJ1ZmZlcixcIlBsZWFzZSB1c2UgJ3Jlc3BvbnNlLmFycmF5QnVmZmVyKCknIGluc3RlYWQgb2YgJ3Jlc3BvbnNlLmJ1ZmZlcigpJ1wiLFwibm9kZS1mZXRjaCNidWZmZXJcIiksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQm9keS5wcm90b3R5cGUse2JvZHk6e2VudW1lcmFibGU6ITB9LGJvZHlVc2VkOntlbnVtZXJhYmxlOiEwfSxhcnJheUJ1ZmZlcjp7ZW51bWVyYWJsZTohMH0sYmxvYjp7ZW51bWVyYWJsZTohMH0sanNvbjp7ZW51bWVyYWJsZTohMH0sdGV4dDp7ZW51bWVyYWJsZTohMH0sZGF0YTp7Z2V0OnJlcXVpcmUkJDAuZGVwcmVjYXRlKCgpPT57fSxcImRhdGEgZG9lc24ndCBleGlzdCwgdXNlIGpzb24oKSwgdGV4dCgpLCBhcnJheUJ1ZmZlcigpLCBvciBib2R5IGluc3RlYWRcIixcImh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzEwMDAgKHJlc3BvbnNlKVwiKX19KTthc3luYyBmdW5jdGlvbiBjb25zdW1lQm9keShjKXtpZihjW0lOVEVSTkFMUyQyXS5kaXN0dXJiZWQpdGhyb3cgbmV3IFR5cGVFcnJvcihgYm9keSB1c2VkIGFscmVhZHkgZm9yOiAke2MudXJsfWApO2lmKGNbSU5URVJOQUxTJDJdLmRpc3R1cmJlZD0hMCxjW0lOVEVSTkFMUyQyXS5lcnJvcil0aHJvdyBjW0lOVEVSTkFMUyQyXS5lcnJvcjtjb25zdHtib2R5Omx9PWM7aWYobD09PW51bGx8fCEobCBpbnN0YW5jZW9mIFN0cmVhbV9fZGVmYXVsdCkpcmV0dXJuIHJlcXVpcmUkJDYuQnVmZmVyLmFsbG9jKDApO2NvbnN0IGQ9W107bGV0IHk9MDt0cnl7Zm9yIGF3YWl0KGNvbnN0IGIgb2YgbCl7aWYoYy5zaXplPjAmJnkrYi5sZW5ndGg+Yy5zaXplKXtjb25zdCBSPW5ldyBGZXRjaEVycm9yKGBjb250ZW50IHNpemUgYXQgJHtjLnVybH0gb3ZlciBsaW1pdDogJHtjLnNpemV9YCxcIm1heC1zaXplXCIpO3Rocm93IGwuZGVzdHJveShSKSxSfXkrPWIubGVuZ3RoLGQucHVzaChiKX19Y2F0Y2goYil7dGhyb3cgYiBpbnN0YW5jZW9mIEZldGNoQmFzZUVycm9yP2I6bmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtjLnVybH06ICR7Yi5tZXNzYWdlfWAsXCJzeXN0ZW1cIixiKX1pZihsLnJlYWRhYmxlRW5kZWQ9PT0hMHx8bC5fcmVhZGFibGVTdGF0ZS5lbmRlZD09PSEwKXRyeXtyZXR1cm4gZC5ldmVyeShiPT50eXBlb2YgYj09XCJzdHJpbmdcIik/cmVxdWlyZSQkNi5CdWZmZXIuZnJvbShkLmpvaW4oXCJcIikpOnJlcXVpcmUkJDYuQnVmZmVyLmNvbmNhdChkLHkpfWNhdGNoKGIpe3Rocm93IG5ldyBGZXRjaEVycm9yKGBDb3VsZCBub3QgY3JlYXRlIEJ1ZmZlciBmcm9tIHJlc3BvbnNlIGJvZHkgZm9yICR7Yy51cmx9OiAke2IubWVzc2FnZX1gLFwic3lzdGVtXCIsYil9ZWxzZSB0aHJvdyBuZXcgRmV0Y2hFcnJvcihgUHJlbWF0dXJlIGNsb3NlIG9mIHNlcnZlciByZXNwb25zZSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtjLnVybH1gKX11KGNvbnN1bWVCb2R5LFwiY29uc3VtZUJvZHlcIik7Y29uc3QgY2xvbmU9dSgoYyxsKT0+e2xldCBkLHkse2JvZHk6Yn09Y1tJTlRFUk5BTFMkMl07aWYoYy5ib2R5VXNlZCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY2xvbmUgYm9keSBhZnRlciBpdCBpcyB1c2VkXCIpO3JldHVybiBiIGluc3RhbmNlb2YgU3RyZWFtX19kZWZhdWx0JiZ0eXBlb2YgYi5nZXRCb3VuZGFyeSE9XCJmdW5jdGlvblwiJiYoZD1uZXcgU3RyZWFtLlBhc3NUaHJvdWdoKHtoaWdoV2F0ZXJNYXJrOmx9KSx5PW5ldyBTdHJlYW0uUGFzc1Rocm91Z2goe2hpZ2hXYXRlck1hcms6bH0pLGIucGlwZShkKSxiLnBpcGUoeSksY1tJTlRFUk5BTFMkMl0uc3RyZWFtPWQsYj15KSxifSxcImNsb25lXCIpLGdldE5vblNwZWNGb3JtRGF0YUJvdW5kYXJ5PXJlcXVpcmUkJDAuZGVwcmVjYXRlKGM9PmMuZ2V0Qm91bmRhcnkoKSxcImZvcm0tZGF0YSBkb2Vzbid0IGZvbGxvdyB0aGUgc3BlYyBhbmQgcmVxdWlyZXMgc3BlY2lhbCB0cmVhdG1lbnQuIFVzZSBhbHRlcm5hdGl2ZSBwYWNrYWdlXCIsXCJodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMTY3XCIpLGV4dHJhY3RDb250ZW50VHlwZT11KChjLGwpPT5jPT09bnVsbD9udWxsOnR5cGVvZiBjPT1cInN0cmluZ1wiP1widGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCI6aXNVUkxTZWFyY2hQYXJhbWV0ZXJzKGMpP1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLThcIjppc0Jsb2IoYyk/Yy50eXBlfHxudWxsOnJlcXVpcmUkJDYuQnVmZmVyLmlzQnVmZmVyKGMpfHxyZXF1aXJlJCQwLnR5cGVzLmlzQW55QXJyYXlCdWZmZXIoYyl8fEFycmF5QnVmZmVyLmlzVmlldyhjKT9udWxsOmMgaW5zdGFuY2VvZiBGb3JtRGF0YT9gbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JHtsW0lOVEVSTkFMUyQyXS5ib3VuZGFyeX1gOmMmJnR5cGVvZiBjLmdldEJvdW5kYXJ5PT1cImZ1bmN0aW9uXCI/YG11bHRpcGFydC9mb3JtLWRhdGE7Ym91bmRhcnk9JHtnZXROb25TcGVjRm9ybURhdGFCb3VuZGFyeShjKX1gOmMgaW5zdGFuY2VvZiBTdHJlYW1fX2RlZmF1bHQ/bnVsbDpcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiLFwiZXh0cmFjdENvbnRlbnRUeXBlXCIpLGdldFRvdGFsQnl0ZXM9dShjPT57Y29uc3R7Ym9keTpsfT1jW0lOVEVSTkFMUyQyXTtyZXR1cm4gbD09PW51bGw/MDppc0Jsb2IobCk/bC5zaXplOnJlcXVpcmUkJDYuQnVmZmVyLmlzQnVmZmVyKGwpP2wubGVuZ3RoOmwmJnR5cGVvZiBsLmdldExlbmd0aFN5bmM9PVwiZnVuY3Rpb25cIiYmbC5oYXNLbm93bkxlbmd0aCYmbC5oYXNLbm93bkxlbmd0aCgpP2wuZ2V0TGVuZ3RoU3luYygpOm51bGx9LFwiZ2V0VG90YWxCeXRlc1wiKSx3cml0ZVRvU3RyZWFtPXUoYXN5bmMoYyx7Ym9keTpsfSk9PntsPT09bnVsbD9jLmVuZCgpOmF3YWl0IHBpcGVsaW5lKGwsYyl9LFwid3JpdGVUb1N0cmVhbVwiKSx2YWxpZGF0ZUhlYWRlck5hbWU9dHlwZW9mIGh0dHBfX2RlZmF1bHQudmFsaWRhdGVIZWFkZXJOYW1lPT1cImZ1bmN0aW9uXCI/aHR0cF9fZGVmYXVsdC52YWxpZGF0ZUhlYWRlck5hbWU6Yz0+e2lmKCEvXltcXF5gXFwtXFx3ISMkJSYnKisufH5dKyQvLnRlc3QoYykpe2NvbnN0IGw9bmV3IFR5cGVFcnJvcihgSGVhZGVyIG5hbWUgbXVzdCBiZSBhIHZhbGlkIEhUVFAgdG9rZW4gWyR7Y31dYCk7dGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KGwsXCJjb2RlXCIse3ZhbHVlOlwiRVJSX0lOVkFMSURfSFRUUF9UT0tFTlwifSksbH19LHZhbGlkYXRlSGVhZGVyVmFsdWU9dHlwZW9mIGh0dHBfX2RlZmF1bHQudmFsaWRhdGVIZWFkZXJWYWx1ZT09XCJmdW5jdGlvblwiP2h0dHBfX2RlZmF1bHQudmFsaWRhdGVIZWFkZXJWYWx1ZTooYyxsKT0+e2lmKC9bXlxcdFxcdTAwMjAtXFx1MDA3RVxcdTAwODAtXFx1MDBGRl0vLnRlc3QobCkpe2NvbnN0IGQ9bmV3IFR5cGVFcnJvcihgSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGNvbnRlbnQgW1wiJHtjfVwiXWApO3Rocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkLFwiY29kZVwiLHt2YWx1ZTpcIkVSUl9JTlZBTElEX0NIQVJcIn0pLGR9fSxLdD1jbGFzcyBLdCBleHRlbmRzIFVSTFNlYXJjaFBhcmFtc3tjb25zdHJ1Y3RvcihsKXtsZXQgZD1bXTtpZihsIGluc3RhbmNlb2YgS3Qpe2NvbnN0IHk9bC5yYXcoKTtmb3IoY29uc3RbYixSXW9mIE9iamVjdC5lbnRyaWVzKHkpKWQucHVzaCguLi5SLm1hcCh3PT5bYix3XSkpfWVsc2UgaWYobCE9bnVsbClpZih0eXBlb2YgbD09XCJvYmplY3RcIiYmIXJlcXVpcmUkJDAudHlwZXMuaXNCb3hlZFByaW1pdGl2ZShsKSl7Y29uc3QgeT1sW1N5bWJvbC5pdGVyYXRvcl07aWYoeT09bnVsbClkLnB1c2goLi4uT2JqZWN0LmVudHJpZXMobCkpO2Vsc2V7aWYodHlwZW9mIHkhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiSGVhZGVyIHBhaXJzIG11c3QgYmUgaXRlcmFibGVcIik7ZD1bLi4ubF0ubWFwKGI9PntpZih0eXBlb2YgYiE9XCJvYmplY3RcInx8cmVxdWlyZSQkMC50eXBlcy5pc0JveGVkUHJpbWl0aXZlKGIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYW4gaXRlcmFibGUgb2JqZWN0XCIpO3JldHVyblsuLi5iXX0pLm1hcChiPT57aWYoYi5sZW5ndGghPT0yKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYSBuYW1lL3ZhbHVlIHR1cGxlXCIpO3JldHVyblsuLi5iXX0pfX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdIZWFkZXJzJzogVGhlIHByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvZiB0eXBlICcoc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+IG9yIHJlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPilcIik7cmV0dXJuIGQ9ZC5sZW5ndGg+MD9kLm1hcCgoW3ksYl0pPT4odmFsaWRhdGVIZWFkZXJOYW1lKHkpLHZhbGlkYXRlSGVhZGVyVmFsdWUoeSxTdHJpbmcoYikpLFtTdHJpbmcoeSkudG9Mb3dlckNhc2UoKSxTdHJpbmcoYildKSk6dm9pZCAwLHN1cGVyKGQpLG5ldyBQcm94eSh0aGlzLHtnZXQoeSxiLFIpe3N3aXRjaChiKXtjYXNlXCJhcHBlbmRcIjpjYXNlXCJzZXRcIjpyZXR1cm4odyx2KT0+KHZhbGlkYXRlSGVhZGVyTmFtZSh3KSx2YWxpZGF0ZUhlYWRlclZhbHVlKHcsU3RyaW5nKHYpKSxVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlW2JdLmNhbGwoeSxTdHJpbmcodykudG9Mb3dlckNhc2UoKSxTdHJpbmcodikpKTtjYXNlXCJkZWxldGVcIjpjYXNlXCJoYXNcIjpjYXNlXCJnZXRBbGxcIjpyZXR1cm4gdz0+KHZhbGlkYXRlSGVhZGVyTmFtZSh3KSxVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlW2JdLmNhbGwoeSxTdHJpbmcodykudG9Mb3dlckNhc2UoKSkpO2Nhc2VcImtleXNcIjpyZXR1cm4oKT0+KHkuc29ydCgpLG5ldyBTZXQoVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5rZXlzLmNhbGwoeSkpLmtleXMoKSk7ZGVmYXVsdDpyZXR1cm4gUmVmbGVjdC5nZXQoeSxiLFIpfX19KX1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWV9dG9TdHJpbmcoKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpfWdldChsKXtjb25zdCBkPXRoaXMuZ2V0QWxsKGwpO2lmKGQubGVuZ3RoPT09MClyZXR1cm4gbnVsbDtsZXQgeT1kLmpvaW4oXCIsIFwiKTtyZXR1cm4vXmNvbnRlbnQtZW5jb2RpbmckL2kudGVzdChsKSYmKHk9eS50b0xvd2VyQ2FzZSgpKSx5fWZvckVhY2gobCxkPXZvaWQgMCl7Zm9yKGNvbnN0IHkgb2YgdGhpcy5rZXlzKCkpUmVmbGVjdC5hcHBseShsLGQsW3RoaXMuZ2V0KHkpLHksdGhpc10pfSp2YWx1ZXMoKXtmb3IoY29uc3QgbCBvZiB0aGlzLmtleXMoKSl5aWVsZCB0aGlzLmdldChsKX0qZW50cmllcygpe2Zvcihjb25zdCBsIG9mIHRoaXMua2V5cygpKXlpZWxkW2wsdGhpcy5nZXQobCldfVtTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIHRoaXMuZW50cmllcygpfXJhdygpe3JldHVyblsuLi50aGlzLmtleXMoKV0ucmVkdWNlKChsLGQpPT4obFtkXT10aGlzLmdldEFsbChkKSxsKSx7fSl9W1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oKXtyZXR1cm5bLi4udGhpcy5rZXlzKCldLnJlZHVjZSgobCxkKT0+e2NvbnN0IHk9dGhpcy5nZXRBbGwoZCk7cmV0dXJuIGQ9PT1cImhvc3RcIj9sW2RdPXlbMF06bFtkXT15Lmxlbmd0aD4xP3k6eVswXSxsfSx7fSl9fTt1KEt0LFwiSGVhZGVyc1wiKTtsZXQgSGVhZGVycz1LdDtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhIZWFkZXJzLnByb3RvdHlwZSxbXCJnZXRcIixcImVudHJpZXNcIixcImZvckVhY2hcIixcInZhbHVlc1wiXS5yZWR1Y2UoKGMsbCk9PihjW2xdPXtlbnVtZXJhYmxlOiEwfSxjKSx7fSkpO2Z1bmN0aW9uIGZyb21SYXdIZWFkZXJzKGM9W10pe3JldHVybiBuZXcgSGVhZGVycyhjLnJlZHVjZSgobCxkLHksYik9Pih5JTI9PT0wJiZsLnB1c2goYi5zbGljZSh5LHkrMikpLGwpLFtdKS5maWx0ZXIoKFtsLGRdKT0+e3RyeXtyZXR1cm4gdmFsaWRhdGVIZWFkZXJOYW1lKGwpLHZhbGlkYXRlSGVhZGVyVmFsdWUobCxTdHJpbmcoZCkpLCEwfWNhdGNoe3JldHVybiExfX0pKX11KGZyb21SYXdIZWFkZXJzLFwiZnJvbVJhd0hlYWRlcnNcIik7Y29uc3QgcmVkaXJlY3RTdGF0dXM9bmV3IFNldChbMzAxLDMwMiwzMDMsMzA3LDMwOF0pLGlzUmVkaXJlY3Q9dShjPT5yZWRpcmVjdFN0YXR1cy5oYXMoYyksXCJpc1JlZGlyZWN0XCIpLElOVEVSTkFMUyQxPVN5bWJvbChcIlJlc3BvbnNlIGludGVybmFsc1wiKSxEZT1jbGFzcyBEZSBleHRlbmRzIEJvZHl7Y29uc3RydWN0b3IobD1udWxsLGQ9e30pe3N1cGVyKGwsZCk7Y29uc3QgeT1kLnN0YXR1cyE9bnVsbD9kLnN0YXR1czoyMDAsYj1uZXcgSGVhZGVycyhkLmhlYWRlcnMpO2lmKGwhPT1udWxsJiYhYi5oYXMoXCJDb250ZW50LVR5cGVcIikpe2NvbnN0IFI9ZXh0cmFjdENvbnRlbnRUeXBlKGwsdGhpcyk7UiYmYi5hcHBlbmQoXCJDb250ZW50LVR5cGVcIixSKX10aGlzW0lOVEVSTkFMUyQxXT17dHlwZTpcImRlZmF1bHRcIix1cmw6ZC51cmwsc3RhdHVzOnksc3RhdHVzVGV4dDpkLnN0YXR1c1RleHR8fFwiXCIsaGVhZGVyczpiLGNvdW50ZXI6ZC5jb3VudGVyLGhpZ2hXYXRlck1hcms6ZC5oaWdoV2F0ZXJNYXJrfX1nZXQgdHlwZSgpe3JldHVybiB0aGlzW0lOVEVSTkFMUyQxXS50eXBlfWdldCB1cmwoKXtyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0udXJsfHxcIlwifWdldCBzdGF0dXMoKXtyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzfWdldCBvaygpe3JldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5zdGF0dXM+PTIwMCYmdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzPDMwMH1nZXQgcmVkaXJlY3RlZCgpe3JldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5jb3VudGVyPjB9Z2V0IHN0YXR1c1RleHQoKXtyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzVGV4dH1nZXQgaGVhZGVycygpe3JldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5oZWFkZXJzfWdldCBoaWdoV2F0ZXJNYXJrKCl7cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLmhpZ2hXYXRlck1hcmt9Y2xvbmUoKXtyZXR1cm4gbmV3IERlKGNsb25lKHRoaXMsdGhpcy5oaWdoV2F0ZXJNYXJrKSx7dHlwZTp0aGlzLnR5cGUsdXJsOnRoaXMudXJsLHN0YXR1czp0aGlzLnN0YXR1cyxzdGF0dXNUZXh0OnRoaXMuc3RhdHVzVGV4dCxoZWFkZXJzOnRoaXMuaGVhZGVycyxvazp0aGlzLm9rLHJlZGlyZWN0ZWQ6dGhpcy5yZWRpcmVjdGVkLHNpemU6dGhpcy5zaXplLGhpZ2hXYXRlck1hcms6dGhpcy5oaWdoV2F0ZXJNYXJrfSl9c3RhdGljIHJlZGlyZWN0KGwsZD0zMDIpe2lmKCFpc1JlZGlyZWN0KGQpKXRocm93IG5ldyBSYW5nZUVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSBcInJlZGlyZWN0XCIgb24gXCJyZXNwb25zZVwiOiBJbnZhbGlkIHN0YXR1cyBjb2RlJyk7cmV0dXJuIG5ldyBEZShudWxsLHtoZWFkZXJzOntsb2NhdGlvbjpuZXcgVVJMKGwpLnRvU3RyaW5nKCl9LHN0YXR1czpkfSl9c3RhdGljIGVycm9yKCl7Y29uc3QgbD1uZXcgRGUobnVsbCx7c3RhdHVzOjAsc3RhdHVzVGV4dDpcIlwifSk7cmV0dXJuIGxbSU5URVJOQUxTJDFdLnR5cGU9XCJlcnJvclwiLGx9c3RhdGljIGpzb24obD12b2lkIDAsZD17fSl7Y29uc3QgeT1KU09OLnN0cmluZ2lmeShsKTtpZih5PT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoXCJkYXRhIGlzIG5vdCBKU09OIHNlcmlhbGl6YWJsZVwiKTtjb25zdCBiPW5ldyBIZWFkZXJzKGQmJmQuaGVhZGVycyk7cmV0dXJuIGIuaGFzKFwiY29udGVudC10eXBlXCIpfHxiLnNldChcImNvbnRlbnQtdHlwZVwiLFwiYXBwbGljYXRpb24vanNvblwiKSxuZXcgRGUoeSx7Li4uZCxoZWFkZXJzOmJ9KX1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVyblwiUmVzcG9uc2VcIn19O3UoRGUsXCJSZXNwb25zZVwiKTtsZXQgUmVzcG9uc2U9RGU7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UucHJvdG90eXBlLHt0eXBlOntlbnVtZXJhYmxlOiEwfSx1cmw6e2VudW1lcmFibGU6ITB9LHN0YXR1czp7ZW51bWVyYWJsZTohMH0sb2s6e2VudW1lcmFibGU6ITB9LHJlZGlyZWN0ZWQ6e2VudW1lcmFibGU6ITB9LHN0YXR1c1RleHQ6e2VudW1lcmFibGU6ITB9LGhlYWRlcnM6e2VudW1lcmFibGU6ITB9LGNsb25lOntlbnVtZXJhYmxlOiEwfX0pO2NvbnN0IGdldFNlYXJjaD11KGM9PntpZihjLnNlYXJjaClyZXR1cm4gYy5zZWFyY2g7Y29uc3QgbD1jLmhyZWYubGVuZ3RoLTEsZD1jLmhhc2h8fChjLmhyZWZbbF09PT1cIiNcIj9cIiNcIjpcIlwiKTtyZXR1cm4gYy5ocmVmW2wtZC5sZW5ndGhdPT09XCI/XCI/XCI/XCI6XCJcIn0sXCJnZXRTZWFyY2hcIik7ZnVuY3Rpb24gc3RyaXBVUkxGb3JVc2VBc0FSZWZlcnJlcihjLGw9ITEpe3JldHVybiBjPT1udWxsfHwoYz1uZXcgVVJMKGMpLC9eKGFib3V0fGJsb2J8ZGF0YSk6JC8udGVzdChjLnByb3RvY29sKSk/XCJuby1yZWZlcnJlclwiOihjLnVzZXJuYW1lPVwiXCIsYy5wYXNzd29yZD1cIlwiLGMuaGFzaD1cIlwiLGwmJihjLnBhdGhuYW1lPVwiXCIsYy5zZWFyY2g9XCJcIiksYyl9dShzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyLFwic3RyaXBVUkxGb3JVc2VBc0FSZWZlcnJlclwiKTtjb25zdCBSZWZlcnJlclBvbGljeT1uZXcgU2V0KFtcIlwiLFwibm8tcmVmZXJyZXJcIixcIm5vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlXCIsXCJzYW1lLW9yaWdpblwiLFwib3JpZ2luXCIsXCJzdHJpY3Qtb3JpZ2luXCIsXCJvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIixcInN0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIixcInVuc2FmZS11cmxcIl0pLERFRkFVTFRfUkVGRVJSRVJfUE9MSUNZPVwic3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiO2Z1bmN0aW9uIHZhbGlkYXRlUmVmZXJyZXJQb2xpY3koYyl7aWYoIVJlZmVycmVyUG9saWN5LmhhcyhjKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHJlZmVycmVyUG9saWN5OiAke2N9YCk7cmV0dXJuIGN9dSh2YWxpZGF0ZVJlZmVycmVyUG9saWN5LFwidmFsaWRhdGVSZWZlcnJlclBvbGljeVwiKTtmdW5jdGlvbiBpc09yaWdpblBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoYyl7aWYoL14oaHR0cHx3cylzOiQvLnRlc3QoYy5wcm90b2NvbCkpcmV0dXJuITA7Y29uc3QgbD1jLmhvc3QucmVwbGFjZSgvKF5cXFspfChdJCkvZyxcIlwiKSxkPXJlcXVpcmUkJDQuaXNJUChsKTtyZXR1cm4gZD09PTQmJi9eMTI3XFwuLy50ZXN0KGwpfHxkPT09NiYmL14oKCgwKzopezd9KXwoOjooMCs6KXswLDZ9KSkwKjEkLy50ZXN0KGwpPyEwOmMuaG9zdD09PVwibG9jYWxob3N0XCJ8fGMuaG9zdC5lbmRzV2l0aChcIi5sb2NhbGhvc3RcIik/ITE6Yy5wcm90b2NvbD09PVwiZmlsZTpcIn11KGlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSxcImlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeVwiKTtmdW5jdGlvbiBpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoYyl7cmV0dXJuL15hYm91dDooYmxhbmt8c3JjZG9jKSQvLnRlc3QoYyl8fGMucHJvdG9jb2w9PT1cImRhdGE6XCJ8fC9eKGJsb2J8ZmlsZXN5c3RlbSk6JC8udGVzdChjLnByb3RvY29sKT8hMDppc09yaWdpblBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoYyl9dShpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHksXCJpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHlcIik7ZnVuY3Rpb24gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihjLHtyZWZlcnJlclVSTENhbGxiYWNrOmwscmVmZXJyZXJPcmlnaW5DYWxsYmFjazpkfT17fSl7aWYoYy5yZWZlcnJlcj09PVwibm8tcmVmZXJyZXJcInx8Yy5yZWZlcnJlclBvbGljeT09PVwiXCIpcmV0dXJuIG51bGw7Y29uc3QgeT1jLnJlZmVycmVyUG9saWN5O2lmKGMucmVmZXJyZXI9PT1cImFib3V0OmNsaWVudFwiKXJldHVyblwibm8tcmVmZXJyZXJcIjtjb25zdCBiPWMucmVmZXJyZXI7bGV0IFI9c3RyaXBVUkxGb3JVc2VBc0FSZWZlcnJlcihiKSx3PXN0cmlwVVJMRm9yVXNlQXNBUmVmZXJyZXIoYiwhMCk7Ui50b1N0cmluZygpLmxlbmd0aD40MDk2JiYoUj13KSxsJiYoUj1sKFIpKSxkJiYodz1kKHcpKTtjb25zdCB2PW5ldyBVUkwoYy51cmwpO3N3aXRjaCh5KXtjYXNlXCJuby1yZWZlcnJlclwiOnJldHVyblwibm8tcmVmZXJyZXJcIjtjYXNlXCJvcmlnaW5cIjpyZXR1cm4gdztjYXNlXCJ1bnNhZmUtdXJsXCI6cmV0dXJuIFI7Y2FzZVwic3RyaWN0LW9yaWdpblwiOnJldHVybiBpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoUikmJiFpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkodik/XCJuby1yZWZlcnJlclwiOncudG9TdHJpbmcoKTtjYXNlXCJzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCI6cmV0dXJuIFIub3JpZ2luPT09di5vcmlnaW4/Ujppc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoUikmJiFpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkodik/XCJuby1yZWZlcnJlclwiOnc7Y2FzZVwic2FtZS1vcmlnaW5cIjpyZXR1cm4gUi5vcmlnaW49PT12Lm9yaWdpbj9SOlwibm8tcmVmZXJyZXJcIjtjYXNlXCJvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIjpyZXR1cm4gUi5vcmlnaW49PT12Lm9yaWdpbj9SOnc7Y2FzZVwibm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGVcIjpyZXR1cm4gaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5KFIpJiYhaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5KHYpP1wibm8tcmVmZXJyZXJcIjpSO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCByZWZlcnJlclBvbGljeTogJHt5fWApfX11KGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIsXCJkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyXCIpO2Z1bmN0aW9uIHBhcnNlUmVmZXJyZXJQb2xpY3lGcm9tSGVhZGVyKGMpe2NvbnN0IGw9KGMuZ2V0KFwicmVmZXJyZXItcG9saWN5XCIpfHxcIlwiKS5zcGxpdCgvWyxcXHNdKy8pO2xldCBkPVwiXCI7Zm9yKGNvbnN0IHkgb2YgbCl5JiZSZWZlcnJlclBvbGljeS5oYXMoeSkmJihkPXkpO3JldHVybiBkfXUocGFyc2VSZWZlcnJlclBvbGljeUZyb21IZWFkZXIsXCJwYXJzZVJlZmVycmVyUG9saWN5RnJvbUhlYWRlclwiKTtjb25zdCBJTlRFUk5BTFM9U3ltYm9sKFwiUmVxdWVzdCBpbnRlcm5hbHNcIiksaXNSZXF1ZXN0PXUoYz0+dHlwZW9mIGM9PVwib2JqZWN0XCImJnR5cGVvZiBjW0lOVEVSTkFMU109PVwib2JqZWN0XCIsXCJpc1JlcXVlc3RcIiksZG9CYWREYXRhV2Fybj1yZXF1aXJlJCQwLmRlcHJlY2F0ZSgoKT0+e30sXCIuZGF0YSBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0SW5pdCBwcm9wZXJ0eSwgdXNlIC5ib2R5IGluc3RlYWRcIixcImh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzEwMDAgKHJlcXVlc3QpXCIpLEp0PWNsYXNzIEp0IGV4dGVuZHMgQm9keXtjb25zdHJ1Y3RvcihsLGQ9e30pe2xldCB5O2lmKGlzUmVxdWVzdChsKT95PW5ldyBVUkwobC51cmwpOih5PW5ldyBVUkwobCksbD17fSkseS51c2VybmFtZSE9PVwiXCJ8fHkucGFzc3dvcmQhPT1cIlwiKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7eX0gaXMgYW4gdXJsIHdpdGggZW1iZWRkZWQgY3JlZGVudGlhbHMuYCk7bGV0IGI9ZC5tZXRob2R8fGwubWV0aG9kfHxcIkdFVFwiO2lmKC9eKGRlbGV0ZXxnZXR8aGVhZHxvcHRpb25zfHBvc3R8cHV0KSQvaS50ZXN0KGIpJiYoYj1iLnRvVXBwZXJDYXNlKCkpLCFpc1JlcXVlc3QoZCkmJlwiZGF0YVwiaW4gZCYmZG9CYWREYXRhV2FybigpLChkLmJvZHkhPW51bGx8fGlzUmVxdWVzdChsKSYmbC5ib2R5IT09bnVsbCkmJihiPT09XCJHRVRcInx8Yj09PVwiSEVBRFwiKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmVxdWVzdCB3aXRoIEdFVC9IRUFEIG1ldGhvZCBjYW5ub3QgaGF2ZSBib2R5XCIpO2NvbnN0IFI9ZC5ib2R5P2QuYm9keTppc1JlcXVlc3QobCkmJmwuYm9keSE9PW51bGw/Y2xvbmUobCk6bnVsbDtzdXBlcihSLHtzaXplOmQuc2l6ZXx8bC5zaXplfHwwfSk7Y29uc3Qgdz1uZXcgSGVhZGVycyhkLmhlYWRlcnN8fGwuaGVhZGVyc3x8e30pO2lmKFIhPT1udWxsJiYhdy5oYXMoXCJDb250ZW50LVR5cGVcIikpe2NvbnN0IEI9ZXh0cmFjdENvbnRlbnRUeXBlKFIsdGhpcyk7QiYmdy5zZXQoXCJDb250ZW50LVR5cGVcIixCKX1sZXQgdj1pc1JlcXVlc3QobCk/bC5zaWduYWw6bnVsbDtpZihcInNpZ25hbFwiaW4gZCYmKHY9ZC5zaWduYWwpLHYhPW51bGwmJiFpc0Fib3J0U2lnbmFsKHYpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBzaWduYWwgdG8gYmUgYW4gaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCBvciBFdmVudFRhcmdldFwiKTtsZXQgST1kLnJlZmVycmVyPT1udWxsP2wucmVmZXJyZXI6ZC5yZWZlcnJlcjtpZihJPT09XCJcIilJPVwibm8tcmVmZXJyZXJcIjtlbHNlIGlmKEkpe2NvbnN0IEI9bmV3IFVSTChJKTtJPS9eYWJvdXQ6KFxcL1xcLyk/Y2xpZW50JC8udGVzdChCKT9cImNsaWVudFwiOkJ9ZWxzZSBJPXZvaWQgMDt0aGlzW0lOVEVSTkFMU109e21ldGhvZDpiLHJlZGlyZWN0OmQucmVkaXJlY3R8fGwucmVkaXJlY3R8fFwiZm9sbG93XCIsaGVhZGVyczp3LHBhcnNlZFVSTDp5LHNpZ25hbDp2LHJlZmVycmVyOkl9LHRoaXMuZm9sbG93PWQuZm9sbG93PT09dm9pZCAwP2wuZm9sbG93PT09dm9pZCAwPzIwOmwuZm9sbG93OmQuZm9sbG93LHRoaXMuY29tcHJlc3M9ZC5jb21wcmVzcz09PXZvaWQgMD9sLmNvbXByZXNzPT09dm9pZCAwPyEwOmwuY29tcHJlc3M6ZC5jb21wcmVzcyx0aGlzLmNvdW50ZXI9ZC5jb3VudGVyfHxsLmNvdW50ZXJ8fDAsdGhpcy5hZ2VudD1kLmFnZW50fHxsLmFnZW50LHRoaXMuaGlnaFdhdGVyTWFyaz1kLmhpZ2hXYXRlck1hcmt8fGwuaGlnaFdhdGVyTWFya3x8MTYzODQsdGhpcy5pbnNlY3VyZUhUVFBQYXJzZXI9ZC5pbnNlY3VyZUhUVFBQYXJzZXJ8fGwuaW5zZWN1cmVIVFRQUGFyc2VyfHwhMSx0aGlzLnJlZmVycmVyUG9saWN5PWQucmVmZXJyZXJQb2xpY3l8fGwucmVmZXJyZXJQb2xpY3l8fFwiXCJ9Z2V0IG1ldGhvZCgpe3JldHVybiB0aGlzW0lOVEVSTkFMU10ubWV0aG9kfWdldCB1cmwoKXtyZXR1cm4gcmVxdWlyZSQkMS5mb3JtYXQodGhpc1tJTlRFUk5BTFNdLnBhcnNlZFVSTCl9Z2V0IGhlYWRlcnMoKXtyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmhlYWRlcnN9Z2V0IHJlZGlyZWN0KCl7cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5yZWRpcmVjdH1nZXQgc2lnbmFsKCl7cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5zaWduYWx9Z2V0IHJlZmVycmVyKCl7aWYodGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyPT09XCJuby1yZWZlcnJlclwiKXJldHVyblwiXCI7aWYodGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyPT09XCJjbGllbnRcIilyZXR1cm5cImFib3V0OmNsaWVudFwiO2lmKHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlcilyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyLnRvU3RyaW5nKCl9Z2V0IHJlZmVycmVyUG9saWN5KCl7cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlclBvbGljeX1zZXQgcmVmZXJyZXJQb2xpY3kobCl7dGhpc1tJTlRFUk5BTFNdLnJlZmVycmVyUG9saWN5PXZhbGlkYXRlUmVmZXJyZXJQb2xpY3kobCl9Y2xvbmUoKXtyZXR1cm4gbmV3IEp0KHRoaXMpfWdldFtTeW1ib2wudG9TdHJpbmdUYWddKCl7cmV0dXJuXCJSZXF1ZXN0XCJ9fTt1KEp0LFwiUmVxdWVzdFwiKTtsZXQgUmVxdWVzdD1KdDtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXF1ZXN0LnByb3RvdHlwZSx7bWV0aG9kOntlbnVtZXJhYmxlOiEwfSx1cmw6e2VudW1lcmFibGU6ITB9LGhlYWRlcnM6e2VudW1lcmFibGU6ITB9LHJlZGlyZWN0OntlbnVtZXJhYmxlOiEwfSxjbG9uZTp7ZW51bWVyYWJsZTohMH0sc2lnbmFsOntlbnVtZXJhYmxlOiEwfSxyZWZlcnJlcjp7ZW51bWVyYWJsZTohMH0scmVmZXJyZXJQb2xpY3k6e2VudW1lcmFibGU6ITB9fSk7Y29uc3QgZ2V0Tm9kZVJlcXVlc3RPcHRpb25zPXUoYz0+e2NvbnN0e3BhcnNlZFVSTDpsfT1jW0lOVEVSTkFMU10sZD1uZXcgSGVhZGVycyhjW0lOVEVSTkFMU10uaGVhZGVycyk7ZC5oYXMoXCJBY2NlcHRcIil8fGQuc2V0KFwiQWNjZXB0XCIsXCIqLypcIik7bGV0IHk9bnVsbDtpZihjLmJvZHk9PT1udWxsJiYvXihwb3N0fHB1dCkkL2kudGVzdChjLm1ldGhvZCkmJih5PVwiMFwiKSxjLmJvZHkhPT1udWxsKXtjb25zdCB2PWdldFRvdGFsQnl0ZXMoYyk7dHlwZW9mIHY9PVwibnVtYmVyXCImJiFOdW1iZXIuaXNOYU4odikmJih5PVN0cmluZyh2KSl9eSYmZC5zZXQoXCJDb250ZW50LUxlbmd0aFwiLHkpLGMucmVmZXJyZXJQb2xpY3k9PT1cIlwiJiYoYy5yZWZlcnJlclBvbGljeT1ERUZBVUxUX1JFRkVSUkVSX1BPTElDWSksYy5yZWZlcnJlciYmYy5yZWZlcnJlciE9PVwibm8tcmVmZXJyZXJcIj9jW0lOVEVSTkFMU10ucmVmZXJyZXI9ZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihjKTpjW0lOVEVSTkFMU10ucmVmZXJyZXI9XCJuby1yZWZlcnJlclwiLGNbSU5URVJOQUxTXS5yZWZlcnJlciBpbnN0YW5jZW9mIFVSTCYmZC5zZXQoXCJSZWZlcmVyXCIsYy5yZWZlcnJlciksZC5oYXMoXCJVc2VyLUFnZW50XCIpfHxkLnNldChcIlVzZXItQWdlbnRcIixcIm5vZGUtZmV0Y2hcIiksYy5jb21wcmVzcyYmIWQuaGFzKFwiQWNjZXB0LUVuY29kaW5nXCIpJiZkLnNldChcIkFjY2VwdC1FbmNvZGluZ1wiLFwiZ3ppcCwgZGVmbGF0ZSwgYnJcIik7bGV0e2FnZW50OmJ9PWM7dHlwZW9mIGI9PVwiZnVuY3Rpb25cIiYmKGI9YihsKSk7Y29uc3QgUj1nZXRTZWFyY2gobCksdz17cGF0aDpsLnBhdGhuYW1lK1IsbWV0aG9kOmMubWV0aG9kLGhlYWRlcnM6ZFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCksaW5zZWN1cmVIVFRQUGFyc2VyOmMuaW5zZWN1cmVIVFRQUGFyc2VyLGFnZW50OmJ9O3JldHVybntwYXJzZWRVUkw6bCxvcHRpb25zOnd9fSxcImdldE5vZGVSZXF1ZXN0T3B0aW9uc1wiKSxzbj1jbGFzcyBzbiBleHRlbmRzIEZldGNoQmFzZUVycm9ye2NvbnN0cnVjdG9yKGwsZD1cImFib3J0ZWRcIil7c3VwZXIobCxkKX19O3Uoc24sXCJBYm9ydEVycm9yXCIpO2xldCBBYm9ydEVycm9yPXNuOy8qISBub2RlLWRvbWV4Y2VwdGlvbi4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9pZighZ2xvYmFsVGhpcy5ET01FeGNlcHRpb24pdHJ5e2NvbnN0e01lc3NhZ2VDaGFubmVsOmN9PXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKSxsPW5ldyBjKCkucG9ydDEsZD1uZXcgQXJyYXlCdWZmZXI7bC5wb3N0TWVzc2FnZShkLFtkLGRdKX1jYXRjaChjKXtjLmNvbnN0cnVjdG9yLm5hbWU9PT1cIkRPTUV4Y2VwdGlvblwiJiYoZ2xvYmFsVGhpcy5ET01FeGNlcHRpb249Yy5jb25zdHJ1Y3Rvcil9dmFyIG5vZGVEb21leGNlcHRpb249Z2xvYmFsVGhpcy5ET01FeGNlcHRpb247Y29uc3QgRE9NRXhjZXB0aW9uPV9jb21tb25qc0hlbHBlcnMuZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobm9kZURvbWV4Y2VwdGlvbikse3N0YXR9PW5vZGVfZnMucHJvbWlzZXMsYmxvYkZyb21TeW5jPXUoKGMsbCk9PmZyb21CbG9iKG5vZGVfZnMuc3RhdFN5bmMoYyksYyxsKSxcImJsb2JGcm9tU3luY1wiKSxibG9iRnJvbT11KChjLGwpPT5zdGF0KGMpLnRoZW4oZD0+ZnJvbUJsb2IoZCxjLGwpKSxcImJsb2JGcm9tXCIpLGZpbGVGcm9tPXUoKGMsbCk9PnN0YXQoYykudGhlbihkPT5mcm9tRmlsZShkLGMsbCkpLFwiZmlsZUZyb21cIiksZmlsZUZyb21TeW5jPXUoKGMsbCk9PmZyb21GaWxlKG5vZGVfZnMuc3RhdFN5bmMoYyksYyxsKSxcImZpbGVGcm9tU3luY1wiKSxmcm9tQmxvYj11KChjLGwsZD1cIlwiKT0+bmV3IHIkMShbbmV3IEJsb2JEYXRhSXRlbSh7cGF0aDpsLHNpemU6Yy5zaXplLGxhc3RNb2RpZmllZDpjLm10aW1lTXMsc3RhcnQ6MH0pXSx7dHlwZTpkfSksXCJmcm9tQmxvYlwiKSxmcm9tRmlsZT11KChjLGwsZD1cIlwiKT0+bmV3IEZpbGUkMShbbmV3IEJsb2JEYXRhSXRlbSh7cGF0aDpsLHNpemU6Yy5zaXplLGxhc3RNb2RpZmllZDpjLm10aW1lTXMsc3RhcnQ6MH0pXSxub2RlX3BhdGguYmFzZW5hbWUobCkse3R5cGU6ZCxsYXN0TW9kaWZpZWQ6Yy5tdGltZU1zfSksXCJmcm9tRmlsZVwiKSxYdD1jbGFzcyBYdHtjb25zdHJ1Y3RvcihsKXt5ZSh0aGlzLE1lLHZvaWQgMCk7eWUodGhpcyx4ZSx2b2lkIDApO25lKHRoaXMsTWUsbC5wYXRoKSxuZSh0aGlzLHhlLGwuc3RhcnQpLHRoaXMuc2l6ZT1sLnNpemUsdGhpcy5sYXN0TW9kaWZpZWQ9bC5sYXN0TW9kaWZpZWR9c2xpY2UobCxkKXtyZXR1cm4gbmV3IFh0KHtwYXRoOkQodGhpcyxNZSksbGFzdE1vZGlmaWVkOnRoaXMubGFzdE1vZGlmaWVkLHNpemU6ZC1sLHN0YXJ0OkQodGhpcyx4ZSkrbH0pfWFzeW5jKnN0cmVhbSgpe2NvbnN0e210aW1lTXM6bH09YXdhaXQgc3RhdChEKHRoaXMsTWUpKTtpZihsPnRoaXMubGFzdE1vZGlmaWVkKXRocm93IG5ldyBET01FeGNlcHRpb24oXCJUaGUgcmVxdWVzdGVkIGZpbGUgY291bGQgbm90IGJlIHJlYWQsIHR5cGljYWxseSBkdWUgdG8gcGVybWlzc2lvbiBwcm9ibGVtcyB0aGF0IGhhdmUgb2NjdXJyZWQgYWZ0ZXIgYSByZWZlcmVuY2UgdG8gYSBmaWxlIHdhcyBhY3F1aXJlZC5cIixcIk5vdFJlYWRhYmxlRXJyb3JcIik7eWllbGQqbm9kZV9mcy5jcmVhdGVSZWFkU3RyZWFtKEQodGhpcyxNZSkse3N0YXJ0OkQodGhpcyx4ZSksZW5kOkQodGhpcyx4ZSkrdGhpcy5zaXplLTF9KX1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVyblwiQmxvYlwifX07TWU9bmV3IFdlYWtNYXAseGU9bmV3IFdlYWtNYXAsdShYdCxcIkJsb2JEYXRhSXRlbVwiKTtsZXQgQmxvYkRhdGFJdGVtPVh0O2NvbnN0IHN1cHBvcnRlZFNjaGVtYXM9bmV3IFNldChbXCJkYXRhOlwiLFwiaHR0cDpcIixcImh0dHBzOlwiXSk7YXN5bmMgZnVuY3Rpb24gZmV0Y2gkMShjLGwpe3JldHVybiBuZXcgUHJvbWlzZSgoZCx5KT0+e2NvbnN0IGI9bmV3IFJlcXVlc3QoYyxsKSx7cGFyc2VkVVJMOlIsb3B0aW9uczp3fT1nZXROb2RlUmVxdWVzdE9wdGlvbnMoYik7aWYoIXN1cHBvcnRlZFNjaGVtYXMuaGFzKFIucHJvdG9jb2wpKXRocm93IG5ldyBUeXBlRXJyb3IoYG5vZGUtZmV0Y2ggY2Fubm90IGxvYWQgJHtjfS4gVVJMIHNjaGVtZSBcIiR7Ui5wcm90b2NvbC5yZXBsYWNlKC86JC8sXCJcIil9XCIgaXMgbm90IHN1cHBvcnRlZC5gKTtpZihSLnByb3RvY29sPT09XCJkYXRhOlwiKXtjb25zdCBFPWRhdGFVcmlUb0J1ZmZlcihiLnVybCksSz1uZXcgUmVzcG9uc2UoRSx7aGVhZGVyczp7XCJDb250ZW50LVR5cGVcIjpFLnR5cGVGdWxsfX0pO2QoSyk7cmV0dXJufWNvbnN0IHY9KFIucHJvdG9jb2w9PT1cImh0dHBzOlwiP2h0dHBzX19kZWZhdWx0Omh0dHBfX2RlZmF1bHQpLnJlcXVlc3Qse3NpZ25hbDpJfT1iO2xldCBCPW51bGw7Y29uc3QgRj11KCgpPT57Y29uc3QgRT1uZXcgQWJvcnRFcnJvcihcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIpO3koRSksYi5ib2R5JiZiLmJvZHkgaW5zdGFuY2VvZiBTdHJlYW1fX2RlZmF1bHQuUmVhZGFibGUmJmIuYm9keS5kZXN0cm95KEUpLCEoIUJ8fCFCLmJvZHkpJiZCLmJvZHkuZW1pdChcImVycm9yXCIsRSl9LFwiYWJvcnRcIik7aWYoSSYmSS5hYm9ydGVkKXtGKCk7cmV0dXJufWNvbnN0IGs9dSgoKT0+e0YoKSwkKCl9LFwiYWJvcnRBbmRGaW5hbGl6ZVwiKSxUPXYoUi50b1N0cmluZygpLHcpO0kmJkkuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsayk7Y29uc3QgJD11KCgpPT57VC5hYm9ydCgpLEkmJkkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsayl9LFwiZmluYWxpemVcIik7VC5vbihcImVycm9yXCIsRT0+e3kobmV3IEZldGNoRXJyb3IoYHJlcXVlc3QgdG8gJHtiLnVybH0gZmFpbGVkLCByZWFzb246ICR7RS5tZXNzYWdlfWAsXCJzeXN0ZW1cIixFKSksJCgpfSksZml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcoVCxFPT57QiYmQi5ib2R5JiZCLmJvZHkuZGVzdHJveShFKX0pLHByb2Nlc3MudmVyc2lvbjxcInYxNFwiJiZULm9uKFwic29ja2V0XCIsRT0+e2xldCBLO0UucHJlcGVuZExpc3RlbmVyKFwiZW5kXCIsKCk9PntLPUUuX2V2ZW50c0NvdW50fSksRS5wcmVwZW5kTGlzdGVuZXIoXCJjbG9zZVwiLFU9PntpZihCJiZLPEUuX2V2ZW50c0NvdW50JiYhVSl7Y29uc3QgTj1uZXcgRXJyb3IoXCJQcmVtYXR1cmUgY2xvc2VcIik7Ti5jb2RlPVwiRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0VcIixCLmJvZHkuZW1pdChcImVycm9yXCIsTil9fSl9KSxULm9uKFwicmVzcG9uc2VcIixFPT57VC5zZXRUaW1lb3V0KDApO2NvbnN0IEs9ZnJvbVJhd0hlYWRlcnMoRS5yYXdIZWFkZXJzKTtpZihpc1JlZGlyZWN0KEUuc3RhdHVzQ29kZSkpe2NvbnN0IE09Sy5nZXQoXCJMb2NhdGlvblwiKTtsZXQgSD1udWxsO3RyeXtIPU09PT1udWxsP251bGw6bmV3IFVSTChNLGIudXJsKX1jYXRjaHtpZihiLnJlZGlyZWN0IT09XCJtYW51YWxcIil7eShuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGFuIGludmFsaWQgcmVkaXJlY3QgVVJMOiAke019YCxcImludmFsaWQtcmVkaXJlY3RcIikpLCQoKTtyZXR1cm59fXN3aXRjaChiLnJlZGlyZWN0KXtjYXNlXCJlcnJvclwiOnkobmV3IEZldGNoRXJyb3IoYHVyaSByZXF1ZXN0ZWQgcmVzcG9uZHMgd2l0aCBhIHJlZGlyZWN0LCByZWRpcmVjdCBtb2RlIGlzIHNldCB0byBlcnJvcjogJHtiLnVybH1gLFwibm8tcmVkaXJlY3RcIikpLCQoKTtyZXR1cm47Y2FzZVwibWFudWFsXCI6YnJlYWs7Y2FzZVwiZm9sbG93XCI6e2lmKEg9PT1udWxsKWJyZWFrO2lmKGIuY291bnRlcj49Yi5mb2xsb3cpe3kobmV3IEZldGNoRXJyb3IoYG1heGltdW0gcmVkaXJlY3QgcmVhY2hlZCBhdDogJHtiLnVybH1gLFwibWF4LXJlZGlyZWN0XCIpKSwkKCk7cmV0dXJufWNvbnN0IEc9e2hlYWRlcnM6bmV3IEhlYWRlcnMoYi5oZWFkZXJzKSxmb2xsb3c6Yi5mb2xsb3csY291bnRlcjpiLmNvdW50ZXIrMSxhZ2VudDpiLmFnZW50LGNvbXByZXNzOmIuY29tcHJlc3MsbWV0aG9kOmIubWV0aG9kLGJvZHk6Y2xvbmUoYiksc2lnbmFsOmIuc2lnbmFsLHNpemU6Yi5zaXplLHJlZmVycmVyOmIucmVmZXJyZXIscmVmZXJyZXJQb2xpY3k6Yi5yZWZlcnJlclBvbGljeX07aWYoIWlzRG9tYWluT3JTdWJkb21haW4oYi51cmwsSCl8fCFpc1NhbWVQcm90b2NvbChiLnVybCxIKSlmb3IoY29uc3Qgd3Qgb2ZbXCJhdXRob3JpemF0aW9uXCIsXCJ3d3ctYXV0aGVudGljYXRlXCIsXCJjb29raWVcIixcImNvb2tpZTJcIl0pRy5oZWFkZXJzLmRlbGV0ZSh3dCk7aWYoRS5zdGF0dXNDb2RlIT09MzAzJiZiLmJvZHkmJmwuYm9keSBpbnN0YW5jZW9mIFN0cmVhbV9fZGVmYXVsdC5SZWFkYWJsZSl7eShuZXcgRmV0Y2hFcnJvcihcIkNhbm5vdCBmb2xsb3cgcmVkaXJlY3Qgd2l0aCBib2R5IGJlaW5nIGEgcmVhZGFibGUgc3RyZWFtXCIsXCJ1bnN1cHBvcnRlZC1yZWRpcmVjdFwiKSksJCgpO3JldHVybn0oRS5zdGF0dXNDb2RlPT09MzAzfHwoRS5zdGF0dXNDb2RlPT09MzAxfHxFLnN0YXR1c0NvZGU9PT0zMDIpJiZiLm1ldGhvZD09PVwiUE9TVFwiKSYmKEcubWV0aG9kPVwiR0VUXCIsRy5ib2R5PXZvaWQgMCxHLmhlYWRlcnMuZGVsZXRlKFwiY29udGVudC1sZW5ndGhcIikpO2NvbnN0IFE9cGFyc2VSZWZlcnJlclBvbGljeUZyb21IZWFkZXIoSyk7USYmKEcucmVmZXJyZXJQb2xpY3k9USksZChmZXRjaCQxKG5ldyBSZXF1ZXN0KEgsRykpKSwkKCk7cmV0dXJufWRlZmF1bHQ6cmV0dXJuIHkobmV3IFR5cGVFcnJvcihgUmVkaXJlY3Qgb3B0aW9uICcke2IucmVkaXJlY3R9JyBpcyBub3QgYSB2YWxpZCB2YWx1ZSBvZiBSZXF1ZXN0UmVkaXJlY3RgKSl9fUkmJkUub25jZShcImVuZFwiLCgpPT57SS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIixrKX0pO2xldCBVPVN0cmVhbS5waXBlbGluZShFLG5ldyBTdHJlYW0uUGFzc1Rocm91Z2gsTT0+e00mJnkoTSl9KTtwcm9jZXNzLnZlcnNpb248XCJ2MTIuMTBcIiYmRS5vbihcImFib3J0ZWRcIixrKTtjb25zdCBOPXt1cmw6Yi51cmwsc3RhdHVzOkUuc3RhdHVzQ29kZSxzdGF0dXNUZXh0OkUuc3RhdHVzTWVzc2FnZSxoZWFkZXJzOkssc2l6ZTpiLnNpemUsY291bnRlcjpiLmNvdW50ZXIsaGlnaFdhdGVyTWFyazpiLmhpZ2hXYXRlck1hcmt9LEo9Sy5nZXQoXCJDb250ZW50LUVuY29kaW5nXCIpO2lmKCFiLmNvbXByZXNzfHxiLm1ldGhvZD09PVwiSEVBRFwifHxKPT09bnVsbHx8RS5zdGF0dXNDb2RlPT09MjA0fHxFLnN0YXR1c0NvZGU9PT0zMDQpe0I9bmV3IFJlc3BvbnNlKFUsTiksZChCKTtyZXR1cm59Y29uc3QgZ2U9e2ZsdXNoOnpsaWJfX2RlZmF1bHQuWl9TWU5DX0ZMVVNILGZpbmlzaEZsdXNoOnpsaWJfX2RlZmF1bHQuWl9TWU5DX0ZMVVNIfTtpZihKPT09XCJnemlwXCJ8fEo9PT1cIngtZ3ppcFwiKXtVPVN0cmVhbS5waXBlbGluZShVLHpsaWJfX2RlZmF1bHQuY3JlYXRlR3VuemlwKGdlKSxNPT57TSYmeShNKX0pLEI9bmV3IFJlc3BvbnNlKFUsTiksZChCKTtyZXR1cm59aWYoSj09PVwiZGVmbGF0ZVwifHxKPT09XCJ4LWRlZmxhdGVcIil7Y29uc3QgTT1TdHJlYW0ucGlwZWxpbmUoRSxuZXcgU3RyZWFtLlBhc3NUaHJvdWdoLEg9PntIJiZ5KEgpfSk7TS5vbmNlKFwiZGF0YVwiLEg9PnsoSFswXSYxNSk9PT04P1U9U3RyZWFtLnBpcGVsaW5lKFUsemxpYl9fZGVmYXVsdC5jcmVhdGVJbmZsYXRlKCksRz0+e0cmJnkoRyl9KTpVPVN0cmVhbS5waXBlbGluZShVLHpsaWJfX2RlZmF1bHQuY3JlYXRlSW5mbGF0ZVJhdygpLEc9PntHJiZ5KEcpfSksQj1uZXcgUmVzcG9uc2UoVSxOKSxkKEIpfSksTS5vbmNlKFwiZW5kXCIsKCk9PntCfHwoQj1uZXcgUmVzcG9uc2UoVSxOKSxkKEIpKX0pO3JldHVybn1pZihKPT09XCJiclwiKXtVPVN0cmVhbS5waXBlbGluZShVLHpsaWJfX2RlZmF1bHQuY3JlYXRlQnJvdGxpRGVjb21wcmVzcygpLE09PntNJiZ5KE0pfSksQj1uZXcgUmVzcG9uc2UoVSxOKSxkKEIpO3JldHVybn1CPW5ldyBSZXNwb25zZShVLE4pLGQoQil9KSx3cml0ZVRvU3RyZWFtKFQsYikuY2F0Y2goeSl9KX11KGZldGNoJDEsXCJmZXRjaCQxXCIpO2Z1bmN0aW9uIGZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nKGMsbCl7Y29uc3QgZD1yZXF1aXJlJCQ2LkJ1ZmZlci5mcm9tKGAwXFxyXG5cXHJcbmApO2xldCB5PSExLGI9ITEsUjtjLm9uKFwicmVzcG9uc2VcIix3PT57Y29uc3R7aGVhZGVyczp2fT13O3k9dltcInRyYW5zZmVyLWVuY29kaW5nXCJdPT09XCJjaHVua2VkXCImJiF2W1wiY29udGVudC1sZW5ndGhcIl19KSxjLm9uKFwic29ja2V0XCIsdz0+e2NvbnN0IHY9dSgoKT0+e2lmKHkmJiFiKXtjb25zdCBCPW5ldyBFcnJvcihcIlByZW1hdHVyZSBjbG9zZVwiKTtCLmNvZGU9XCJFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRVwiLGwoQil9fSxcIm9uU29ja2V0Q2xvc2VcIiksST11KEI9PntiPXJlcXVpcmUkJDYuQnVmZmVyLmNvbXBhcmUoQi5zbGljZSgtNSksZCk9PT0wLCFiJiZSJiYoYj1yZXF1aXJlJCQ2LkJ1ZmZlci5jb21wYXJlKFIuc2xpY2UoLTMpLGQuc2xpY2UoMCwzKSk9PT0wJiZyZXF1aXJlJCQ2LkJ1ZmZlci5jb21wYXJlKEIuc2xpY2UoLTIpLGQuc2xpY2UoMykpPT09MCksUj1CfSxcIm9uRGF0YVwiKTt3LnByZXBlbmRMaXN0ZW5lcihcImNsb3NlXCIsdiksdy5vbihcImRhdGFcIixJKSxjLm9uKFwiY2xvc2VcIiwoKT0+e3cucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLHYpLHcucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsSSl9KX0pfXUoZml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcsXCJmaXhSZXNwb25zZUNodW5rZWRUcmFuc2ZlckJhZEVuZGluZ1wiKTtjb25zdCBwcml2YXRlRGF0YT1uZXcgV2Vha01hcCx3cmFwcGVycz1uZXcgV2Vha01hcDtmdW5jdGlvbiBwZChjKXtjb25zdCBsPXByaXZhdGVEYXRhLmdldChjKTtyZXR1cm4gY29uc29sZS5hc3NlcnQobCE9bnVsbCxcIid0aGlzJyBpcyBleHBlY3RlZCBhbiBFdmVudCBvYmplY3QsIGJ1dCBnb3RcIixjKSxsfXUocGQsXCJwZFwiKTtmdW5jdGlvbiBzZXRDYW5jZWxGbGFnKGMpe2lmKGMucGFzc2l2ZUxpc3RlbmVyIT1udWxsKXt0eXBlb2YgY29uc29sZTxcInVcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PVwiZnVuY3Rpb25cIiYmY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBwcmV2ZW50RGVmYXVsdCBpbnNpZGUgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBpbnZvY2F0aW9uLlwiLGMucGFzc2l2ZUxpc3RlbmVyKTtyZXR1cm59Yy5ldmVudC5jYW5jZWxhYmxlJiYoYy5jYW5jZWxlZD0hMCx0eXBlb2YgYy5ldmVudC5wcmV2ZW50RGVmYXVsdD09XCJmdW5jdGlvblwiJiZjLmV2ZW50LnByZXZlbnREZWZhdWx0KCkpfXUoc2V0Q2FuY2VsRmxhZyxcInNldENhbmNlbEZsYWdcIik7ZnVuY3Rpb24gRXZlbnQoYyxsKXtwcml2YXRlRGF0YS5zZXQodGhpcyx7ZXZlbnRUYXJnZXQ6YyxldmVudDpsLGV2ZW50UGhhc2U6MixjdXJyZW50VGFyZ2V0OmMsY2FuY2VsZWQ6ITEsc3RvcHBlZDohMSxpbW1lZGlhdGVTdG9wcGVkOiExLHBhc3NpdmVMaXN0ZW5lcjpudWxsLHRpbWVTdGFtcDpsLnRpbWVTdGFtcHx8RGF0ZS5ub3coKX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwiaXNUcnVzdGVkXCIse3ZhbHVlOiExLGVudW1lcmFibGU6ITB9KTtjb25zdCBkPU9iamVjdC5rZXlzKGwpO2ZvcihsZXQgeT0wO3k8ZC5sZW5ndGg7Kyt5KXtjb25zdCBiPWRbeV07YiBpbiB0aGlzfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxiLGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihiKSl9fXUoRXZlbnQsXCJFdmVudFwiKSxFdmVudC5wcm90b3R5cGU9e2dldCB0eXBlKCl7cmV0dXJuIHBkKHRoaXMpLmV2ZW50LnR5cGV9LGdldCB0YXJnZXQoKXtyZXR1cm4gcGQodGhpcykuZXZlbnRUYXJnZXR9LGdldCBjdXJyZW50VGFyZ2V0KCl7cmV0dXJuIHBkKHRoaXMpLmN1cnJlbnRUYXJnZXR9LGNvbXBvc2VkUGF0aCgpe2NvbnN0IGM9cGQodGhpcykuY3VycmVudFRhcmdldDtyZXR1cm4gYz09bnVsbD9bXTpbY119LGdldCBOT05FKCl7cmV0dXJuIDB9LGdldCBDQVBUVVJJTkdfUEhBU0UoKXtyZXR1cm4gMX0sZ2V0IEFUX1RBUkdFVCgpe3JldHVybiAyfSxnZXQgQlVCQkxJTkdfUEhBU0UoKXtyZXR1cm4gM30sZ2V0IGV2ZW50UGhhc2UoKXtyZXR1cm4gcGQodGhpcykuZXZlbnRQaGFzZX0sc3RvcFByb3BhZ2F0aW9uKCl7Y29uc3QgYz1wZCh0aGlzKTtjLnN0b3BwZWQ9ITAsdHlwZW9mIGMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uPT1cImZ1bmN0aW9uXCImJmMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCl9LHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpe2NvbnN0IGM9cGQodGhpcyk7Yy5zdG9wcGVkPSEwLGMuaW1tZWRpYXRlU3RvcHBlZD0hMCx0eXBlb2YgYy5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb249PVwiZnVuY3Rpb25cIiYmYy5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKX0sZ2V0IGJ1YmJsZXMoKXtyZXR1cm4hIXBkKHRoaXMpLmV2ZW50LmJ1YmJsZXN9LGdldCBjYW5jZWxhYmxlKCl7cmV0dXJuISFwZCh0aGlzKS5ldmVudC5jYW5jZWxhYmxlfSxwcmV2ZW50RGVmYXVsdCgpe3NldENhbmNlbEZsYWcocGQodGhpcykpfSxnZXQgZGVmYXVsdFByZXZlbnRlZCgpe3JldHVybiBwZCh0aGlzKS5jYW5jZWxlZH0sZ2V0IGNvbXBvc2VkKCl7cmV0dXJuISFwZCh0aGlzKS5ldmVudC5jb21wb3NlZH0sZ2V0IHRpbWVTdGFtcCgpe3JldHVybiBwZCh0aGlzKS50aW1lU3RhbXB9LGdldCBzcmNFbGVtZW50KCl7cmV0dXJuIHBkKHRoaXMpLmV2ZW50VGFyZ2V0fSxnZXQgY2FuY2VsQnViYmxlKCl7cmV0dXJuIHBkKHRoaXMpLnN0b3BwZWR9LHNldCBjYW5jZWxCdWJibGUoYyl7aWYoIWMpcmV0dXJuO2NvbnN0IGw9cGQodGhpcyk7bC5zdG9wcGVkPSEwLHR5cGVvZiBsLmV2ZW50LmNhbmNlbEJ1YmJsZT09XCJib29sZWFuXCImJihsLmV2ZW50LmNhbmNlbEJ1YmJsZT0hMCl9LGdldCByZXR1cm5WYWx1ZSgpe3JldHVybiFwZCh0aGlzKS5jYW5jZWxlZH0sc2V0IHJldHVyblZhbHVlKGMpe2N8fHNldENhbmNlbEZsYWcocGQodGhpcykpfSxpbml0RXZlbnQoKXt9fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLFwiY29uc3RydWN0b3JcIix7dmFsdWU6RXZlbnQsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSksdHlwZW9mIHdpbmRvdzxcInVcIiYmdHlwZW9mIHdpbmRvdy5FdmVudDxcInVcIiYmKE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudC5wcm90b3R5cGUsd2luZG93LkV2ZW50LnByb3RvdHlwZSksd3JhcHBlcnMuc2V0KHdpbmRvdy5FdmVudC5wcm90b3R5cGUsRXZlbnQpKTtmdW5jdGlvbiBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3IoYyl7cmV0dXJue2dldCgpe3JldHVybiBwZCh0aGlzKS5ldmVudFtjXX0sc2V0KGwpe3BkKHRoaXMpLmV2ZW50W2NdPWx9LGNvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwfX11KGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcixcImRlZmluZVJlZGlyZWN0RGVzY3JpcHRvclwiKTtmdW5jdGlvbiBkZWZpbmVDYWxsRGVzY3JpcHRvcihjKXtyZXR1cm57dmFsdWUoKXtjb25zdCBsPXBkKHRoaXMpLmV2ZW50O3JldHVybiBsW2NdLmFwcGx5KGwsYXJndW1lbnRzKX0sY29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITB9fXUoZGVmaW5lQ2FsbERlc2NyaXB0b3IsXCJkZWZpbmVDYWxsRGVzY3JpcHRvclwiKTtmdW5jdGlvbiBkZWZpbmVXcmFwcGVyKGMsbCl7Y29uc3QgZD1PYmplY3Qua2V5cyhsKTtpZihkLmxlbmd0aD09PTApcmV0dXJuIGM7ZnVuY3Rpb24geShiLFIpe2MuY2FsbCh0aGlzLGIsUil9dSh5LFwiQ3VzdG9tRXZlbnRcIikseS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShjLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnksY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfX0pO2ZvcihsZXQgYj0wO2I8ZC5sZW5ndGg7KytiKXtjb25zdCBSPWRbYl07aWYoIShSIGluIGMucHJvdG90eXBlKSl7Y29uc3Qgdj10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihsLFIpLnZhbHVlPT1cImZ1bmN0aW9uXCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHkucHJvdG90eXBlLFIsdj9kZWZpbmVDYWxsRGVzY3JpcHRvcihSKTpkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3IoUikpfX1yZXR1cm4geX11KGRlZmluZVdyYXBwZXIsXCJkZWZpbmVXcmFwcGVyXCIpO2Z1bmN0aW9uIGdldFdyYXBwZXIoYyl7aWYoYz09bnVsbHx8Yz09PU9iamVjdC5wcm90b3R5cGUpcmV0dXJuIEV2ZW50O2xldCBsPXdyYXBwZXJzLmdldChjKTtyZXR1cm4gbD09bnVsbCYmKGw9ZGVmaW5lV3JhcHBlcihnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihjKSksYyksd3JhcHBlcnMuc2V0KGMsbCkpLGx9dShnZXRXcmFwcGVyLFwiZ2V0V3JhcHBlclwiKTtmdW5jdGlvbiB3cmFwRXZlbnQoYyxsKXtjb25zdCBkPWdldFdyYXBwZXIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGwpKTtyZXR1cm4gbmV3IGQoYyxsKX11KHdyYXBFdmVudCxcIndyYXBFdmVudFwiKTtmdW5jdGlvbiBpc1N0b3BwZWQoYyl7cmV0dXJuIHBkKGMpLmltbWVkaWF0ZVN0b3BwZWR9dShpc1N0b3BwZWQsXCJpc1N0b3BwZWRcIik7ZnVuY3Rpb24gc2V0RXZlbnRQaGFzZShjLGwpe3BkKGMpLmV2ZW50UGhhc2U9bH11KHNldEV2ZW50UGhhc2UsXCJzZXRFdmVudFBoYXNlXCIpO2Z1bmN0aW9uIHNldEN1cnJlbnRUYXJnZXQoYyxsKXtwZChjKS5jdXJyZW50VGFyZ2V0PWx9dShzZXRDdXJyZW50VGFyZ2V0LFwic2V0Q3VycmVudFRhcmdldFwiKTtmdW5jdGlvbiBzZXRQYXNzaXZlTGlzdGVuZXIoYyxsKXtwZChjKS5wYXNzaXZlTGlzdGVuZXI9bH11KHNldFBhc3NpdmVMaXN0ZW5lcixcInNldFBhc3NpdmVMaXN0ZW5lclwiKTtjb25zdCBsaXN0ZW5lcnNNYXA9bmV3IFdlYWtNYXAsQ0FQVFVSRT0xLEJVQkJMRT0yLEFUVFJJQlVURT0zO2Z1bmN0aW9uIGlzT2JqZWN0KGMpe3JldHVybiBjIT09bnVsbCYmdHlwZW9mIGM9PVwib2JqZWN0XCJ9dShpc09iamVjdCxcImlzT2JqZWN0XCIpO2Z1bmN0aW9uIGdldExpc3RlbmVycyhjKXtjb25zdCBsPWxpc3RlbmVyc01hcC5nZXQoYyk7aWYobD09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50VGFyZ2V0IG9iamVjdCwgYnV0IGdvdCBhbm90aGVyIHZhbHVlLlwiKTtyZXR1cm4gbH11KGdldExpc3RlbmVycyxcImdldExpc3RlbmVyc1wiKTtmdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IoYyl7cmV0dXJue2dldCgpe2xldCBkPWdldExpc3RlbmVycyh0aGlzKS5nZXQoYyk7Zm9yKDtkIT1udWxsOyl7aWYoZC5saXN0ZW5lclR5cGU9PT1BVFRSSUJVVEUpcmV0dXJuIGQubGlzdGVuZXI7ZD1kLm5leHR9cmV0dXJuIG51bGx9LHNldChsKXt0eXBlb2YgbCE9XCJmdW5jdGlvblwiJiYhaXNPYmplY3QobCkmJihsPW51bGwpO2NvbnN0IGQ9Z2V0TGlzdGVuZXJzKHRoaXMpO2xldCB5PW51bGwsYj1kLmdldChjKTtmb3IoO2IhPW51bGw7KWIubGlzdGVuZXJUeXBlPT09QVRUUklCVVRFP3khPT1udWxsP3kubmV4dD1iLm5leHQ6Yi5uZXh0IT09bnVsbD9kLnNldChjLGIubmV4dCk6ZC5kZWxldGUoYyk6eT1iLGI9Yi5uZXh0O2lmKGwhPT1udWxsKXtjb25zdCBSPXtsaXN0ZW5lcjpsLGxpc3RlbmVyVHlwZTpBVFRSSUJVVEUscGFzc2l2ZTohMSxvbmNlOiExLG5leHQ6bnVsbH07eT09PW51bGw/ZC5zZXQoYyxSKTp5Lm5leHQ9Un19LGNvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwfX11KGRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvcixcImRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvclwiKTtmdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZShjLGwpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShjLGBvbiR7bH1gLGRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvcihsKSl9dShkZWZpbmVFdmVudEF0dHJpYnV0ZSxcImRlZmluZUV2ZW50QXR0cmlidXRlXCIpO2Z1bmN0aW9uIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KGMpe2Z1bmN0aW9uIGwoKXtFdmVudFRhcmdldC5jYWxsKHRoaXMpfXUobCxcIkN1c3RvbUV2ZW50VGFyZ2V0XCIpLGwucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6bCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9fSk7Zm9yKGxldCBkPTA7ZDxjLmxlbmd0aDsrK2QpZGVmaW5lRXZlbnRBdHRyaWJ1dGUobC5wcm90b3R5cGUsY1tkXSk7cmV0dXJuIGx9dShkZWZpbmVDdXN0b21FdmVudFRhcmdldCxcImRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0XCIpO2Z1bmN0aW9uIEV2ZW50VGFyZ2V0KCl7aWYodGhpcyBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KXtsaXN0ZW5lcnNNYXAuc2V0KHRoaXMsbmV3IE1hcCk7cmV0dXJufWlmKGFyZ3VtZW50cy5sZW5ndGg9PT0xJiZBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpcmV0dXJuIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KGFyZ3VtZW50c1swXSk7aWYoYXJndW1lbnRzLmxlbmd0aD4wKXtjb25zdCBjPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtmb3IobGV0IGw9MDtsPGFyZ3VtZW50cy5sZW5ndGg7KytsKWNbbF09YXJndW1lbnRzW2xdO3JldHVybiBkZWZpbmVDdXN0b21FdmVudFRhcmdldChjKX10aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfXUoRXZlbnRUYXJnZXQsXCJFdmVudFRhcmdldFwiKSxFdmVudFRhcmdldC5wcm90b3R5cGU9e2FkZEV2ZW50TGlzdGVuZXIoYyxsLGQpe2lmKGw9PW51bGwpcmV0dXJuO2lmKHR5cGVvZiBsIT1cImZ1bmN0aW9uXCImJiFpc09iamVjdChsKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2xpc3RlbmVyJyBzaG91bGQgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QuXCIpO2NvbnN0IHk9Z2V0TGlzdGVuZXJzKHRoaXMpLGI9aXNPYmplY3QoZCksdz0oYj8hIWQuY2FwdHVyZTohIWQpP0NBUFRVUkU6QlVCQkxFLHY9e2xpc3RlbmVyOmwsbGlzdGVuZXJUeXBlOncscGFzc2l2ZTpiJiYhIWQucGFzc2l2ZSxvbmNlOmImJiEhZC5vbmNlLG5leHQ6bnVsbH07bGV0IEk9eS5nZXQoYyk7aWYoST09PXZvaWQgMCl7eS5zZXQoYyx2KTtyZXR1cm59bGV0IEI9bnVsbDtmb3IoO0khPW51bGw7KXtpZihJLmxpc3RlbmVyPT09bCYmSS5saXN0ZW5lclR5cGU9PT13KXJldHVybjtCPUksST1JLm5leHR9Qi5uZXh0PXZ9LHJlbW92ZUV2ZW50TGlzdGVuZXIoYyxsLGQpe2lmKGw9PW51bGwpcmV0dXJuO2NvbnN0IHk9Z2V0TGlzdGVuZXJzKHRoaXMpLFI9KGlzT2JqZWN0KGQpPyEhZC5jYXB0dXJlOiEhZCk/Q0FQVFVSRTpCVUJCTEU7bGV0IHc9bnVsbCx2PXkuZ2V0KGMpO2Zvcig7diE9bnVsbDspe2lmKHYubGlzdGVuZXI9PT1sJiZ2Lmxpc3RlbmVyVHlwZT09PVIpe3chPT1udWxsP3cubmV4dD12Lm5leHQ6di5uZXh0IT09bnVsbD95LnNldChjLHYubmV4dCk6eS5kZWxldGUoYyk7cmV0dXJufXc9dix2PXYubmV4dH19LGRpc3BhdGNoRXZlbnQoYyl7aWYoYz09bnVsbHx8dHlwZW9mIGMudHlwZSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV2ZW50LnR5cGVcIiBzaG91bGQgYmUgYSBzdHJpbmcuJyk7Y29uc3QgbD1nZXRMaXN0ZW5lcnModGhpcyksZD1jLnR5cGU7bGV0IHk9bC5nZXQoZCk7aWYoeT09bnVsbClyZXR1cm4hMDtjb25zdCBiPXdyYXBFdmVudCh0aGlzLGMpO2xldCBSPW51bGw7Zm9yKDt5IT1udWxsOyl7aWYoeS5vbmNlP1IhPT1udWxsP1IubmV4dD15Lm5leHQ6eS5uZXh0IT09bnVsbD9sLnNldChkLHkubmV4dCk6bC5kZWxldGUoZCk6Uj15LHNldFBhc3NpdmVMaXN0ZW5lcihiLHkucGFzc2l2ZT95Lmxpc3RlbmVyOm51bGwpLHR5cGVvZiB5Lmxpc3RlbmVyPT1cImZ1bmN0aW9uXCIpdHJ5e3kubGlzdGVuZXIuY2FsbCh0aGlzLGIpfWNhdGNoKHcpe3R5cGVvZiBjb25zb2xlPFwidVwiJiZ0eXBlb2YgY29uc29sZS5lcnJvcj09XCJmdW5jdGlvblwiJiZjb25zb2xlLmVycm9yKHcpfWVsc2UgeS5saXN0ZW5lclR5cGUhPT1BVFRSSUJVVEUmJnR5cGVvZiB5Lmxpc3RlbmVyLmhhbmRsZUV2ZW50PT1cImZ1bmN0aW9uXCImJnkubGlzdGVuZXIuaGFuZGxlRXZlbnQoYik7aWYoaXNTdG9wcGVkKGIpKWJyZWFrO3k9eS5uZXh0fXJldHVybiBzZXRQYXNzaXZlTGlzdGVuZXIoYixudWxsKSxzZXRFdmVudFBoYXNlKGIsMCksc2V0Q3VycmVudFRhcmdldChiLG51bGwpLCFiLmRlZmF1bHRQcmV2ZW50ZWR9fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRUYXJnZXQucHJvdG90eXBlLFwiY29uc3RydWN0b3JcIix7dmFsdWU6RXZlbnRUYXJnZXQsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSksdHlwZW9mIHdpbmRvdzxcInVcIiYmdHlwZW9mIHdpbmRvdy5FdmVudFRhcmdldDxcInVcIiYmT2JqZWN0LnNldFByb3RvdHlwZU9mKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSx3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlKTtjb25zdCBhbj1jbGFzcyBhbiBleHRlbmRzIEV2ZW50VGFyZ2V0e2NvbnN0cnVjdG9yKCl7dGhyb3cgc3VwZXIoKSxuZXcgVHlwZUVycm9yKFwiQWJvcnRTaWduYWwgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5XCIpfWdldCBhYm9ydGVkKCl7Y29uc3QgbD1hYm9ydGVkRmxhZ3MuZ2V0KHRoaXMpO2lmKHR5cGVvZiBsIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCAndGhpcycgdG8gYmUgYW4gJ0Fib3J0U2lnbmFsJyBvYmplY3QsIGJ1dCBnb3QgJHt0aGlzPT09bnVsbD9cIm51bGxcIjp0eXBlb2YgdGhpc31gKTtyZXR1cm4gbH19O3UoYW4sXCJBYm9ydFNpZ25hbFwiKTtsZXQgQWJvcnRTaWduYWw9YW47ZGVmaW5lRXZlbnRBdHRyaWJ1dGUoQWJvcnRTaWduYWwucHJvdG90eXBlLFwiYWJvcnRcIik7ZnVuY3Rpb24gY3JlYXRlQWJvcnRTaWduYWwoKXtjb25zdCBjPU9iamVjdC5jcmVhdGUoQWJvcnRTaWduYWwucHJvdG90eXBlKTtyZXR1cm4gRXZlbnRUYXJnZXQuY2FsbChjKSxhYm9ydGVkRmxhZ3Muc2V0KGMsITEpLGN9dShjcmVhdGVBYm9ydFNpZ25hbCxcImNyZWF0ZUFib3J0U2lnbmFsXCIpO2Z1bmN0aW9uIGFib3J0U2lnbmFsKGMpe2Fib3J0ZWRGbGFncy5nZXQoYyk9PT0hMSYmKGFib3J0ZWRGbGFncy5zZXQoYywhMCksYy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiYWJvcnRcIn0pKX11KGFib3J0U2lnbmFsLFwiYWJvcnRTaWduYWxcIik7Y29uc3QgYWJvcnRlZEZsYWdzPW5ldyBXZWFrTWFwO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFib3J0U2lnbmFsLnByb3RvdHlwZSx7YWJvcnRlZDp7ZW51bWVyYWJsZTohMH19KSx0eXBlb2YgU3ltYm9sPT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PVwic3ltYm9sXCImJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYm9ydFNpZ25hbC5wcm90b3R5cGUsU3ltYm9sLnRvU3RyaW5nVGFnLHtjb25maWd1cmFibGU6ITAsdmFsdWU6XCJBYm9ydFNpZ25hbFwifSk7bGV0IEFib3J0Q29udHJvbGxlciQxPShTdD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3NpZ25hbHMuc2V0KHRoaXMsY3JlYXRlQWJvcnRTaWduYWwoKSl9Z2V0IHNpZ25hbCgpe3JldHVybiBnZXRTaWduYWwodGhpcyl9YWJvcnQoKXthYm9ydFNpZ25hbChnZXRTaWduYWwodGhpcykpfX0sdShTdCxcIkFib3J0Q29udHJvbGxlclwiKSxTdCk7Y29uc3Qgc2lnbmFscz1uZXcgV2Vha01hcDtmdW5jdGlvbiBnZXRTaWduYWwoYyl7Y29uc3QgbD1zaWduYWxzLmdldChjKTtpZihsPT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkICd0aGlzJyB0byBiZSBhbiAnQWJvcnRDb250cm9sbGVyJyBvYmplY3QsIGJ1dCBnb3QgJHtjPT09bnVsbD9cIm51bGxcIjp0eXBlb2YgY31gKTtyZXR1cm4gbH11KGdldFNpZ25hbCxcImdldFNpZ25hbFwiKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhBYm9ydENvbnRyb2xsZXIkMS5wcm90b3R5cGUse3NpZ25hbDp7ZW51bWVyYWJsZTohMH0sYWJvcnQ6e2VudW1lcmFibGU6ITB9fSksdHlwZW9mIFN5bWJvbD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT1cInN5bWJvbFwiJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJvcnRDb250cm9sbGVyJDEucHJvdG90eXBlLFN5bWJvbC50b1N0cmluZ1RhZyx7Y29uZmlndXJhYmxlOiEwLHZhbHVlOlwiQWJvcnRDb250cm9sbGVyXCJ9KTt2YXIgdD1PYmplY3QuZGVmaW5lUHJvcGVydHksZT11KChjLGwpPT50KGMsXCJuYW1lXCIse3ZhbHVlOmwsY29uZmlndXJhYmxlOiEwfSksXCJlXCIpO2NvbnN0IGZldGNoPWZldGNoJDE7cygpO2Z1bmN0aW9uIHMoKXshZ2xvYmFsVGhpcy5wcm9jZXNzPy52ZXJzaW9ucz8ubm9kZSYmIWdsb2JhbFRoaXMucHJvY2Vzcz8uZW52LkRJU0FCTEVfTk9ERV9GRVRDSF9OQVRJVkVfV0FSTiYmY29uc29sZS53YXJuKFwiW25vZGUtZmV0Y2gtbmF0aXZlXSBOb2RlLmpzIGNvbXBhdGlibGUgYnVpbGQgb2YgYG5vZGUtZmV0Y2gtbmF0aXZlYCBpcyBiZWluZyB1c2VkIGluIGEgbm9uLU5vZGUuanMgZW52aXJvbm1lbnQuIFBsZWFzZSBtYWtlIHN1cmUgeW91IGFyZSB1c2luZyBwcm9wZXIgZXhwb3J0IGNvbmRpdGlvbnMgb3IgcmVwb3J0IHRoaXMgaXNzdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL3VuanMvbm9kZS1mZXRjaC1uYXRpdmUuIFlvdSBjYW4gc2V0IGBwcm9jZXNzLmVudi5ESVNBQkxFX05PREVfRkVUQ0hfTkFUSVZFX1dBUk5gIHRvIGRpc2FibGUgdGhpcyB3YXJuaW5nLlwiKX11KHMsXCJzXCIpLGUocyxcImNoZWNrTm9kZUVudmlyb25tZW50XCIpLGV4cG9ydHMuQWJvcnRDb250cm9sbGVyPUFib3J0Q29udHJvbGxlciQxLGV4cG9ydHMuQWJvcnRFcnJvcj1BYm9ydEVycm9yLGV4cG9ydHMuQmxvYj1yJDEsZXhwb3J0cy5GZXRjaEVycm9yPUZldGNoRXJyb3IsZXhwb3J0cy5GaWxlPUZpbGUkMSxleHBvcnRzLkZvcm1EYXRhPUZvcm1EYXRhLGV4cG9ydHMuSGVhZGVycz1IZWFkZXJzLGV4cG9ydHMuUmVxdWVzdD1SZXF1ZXN0LGV4cG9ydHMuUmVzcG9uc2U9UmVzcG9uc2UsZXhwb3J0cy5ibG9iRnJvbT1ibG9iRnJvbSxleHBvcnRzLmJsb2JGcm9tU3luYz1ibG9iRnJvbVN5bmMsZXhwb3J0cy5kZWZhdWx0PWZldGNoLGV4cG9ydHMuZmV0Y2g9ZmV0Y2gsZXhwb3J0cy5maWxlRnJvbT1maWxlRnJvbSxleHBvcnRzLmZpbGVGcm9tU3luYz1maWxlRnJvbVN5bmMsZXhwb3J0cy5pc1JlZGlyZWN0PWlzUmVkaXJlY3Q7XG4iXSwibmFtZXMiOlsibXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInUiLCJjIiwibCIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiUG8iLCJkIiwiaGFzIiwiVHlwZUVycm9yIiwiRCIsImNhbGwiLCJnZXQiLCJ5ZSIsIldlYWtTZXQiLCJhZGQiLCJzZXQiLCJuZSIsInkiLCJQZSIsImJ0Iiwib3QiLCJadCIsIlVlIiwibXQiLCJ5dCIsImd0Iiwib2UiLCJfdCIsIk1lIiwieGUiLCJTdCIsImV4cG9ydHMiLCJodHRwIiwicmVxdWlyZSIsImh0dHBzIiwiemxpYiIsIlN0cmVhbSIsInJlcXVpcmUkJDYiLCJyZXF1aXJlJCQwIiwiX2NvbW1vbmpzSGVscGVycyIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQ0Iiwibm9kZV9mcyIsIm5vZGVfcGF0aCIsIl9pbnRlcm9wRGVmYXVsdENvbXBhdCIsImRlZmF1bHQiLCJodHRwX19kZWZhdWx0IiwiaHR0cHNfX2RlZmF1bHQiLCJ6bGliX19kZWZhdWx0IiwiU3RyZWFtX19kZWZhdWx0IiwiZGF0YVVyaVRvQnVmZmVyIiwidGVzdCIsInJlcGxhY2UiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwic3BsaXQiLCJiIiwiUiIsInciLCJGIiwibGVuZ3RoIiwidiIsIkkiLCJ1bmVzY2FwZSIsIkIiLCJCdWZmZXIiLCJmcm9tIiwidHlwZSIsInR5cGVGdWxsIiwiY2hhcnNldCIsInBvbnlmaWxsX2VzMjAxOCIsImhhc1JlcXVpcmVkUG9ueWZpbGxfZXMyMDE4IiwicmVxdWlyZVBvbnlmaWxsX2VzMjAxOCIsImNvbW1vbmpzR2xvYmFsIiwibiIsIm8iLCJQcm9taXNlIiwicHJvdG90eXBlIiwidGhlbiIsInJlamVjdCIsImJpbmQiLCJrIiwiVCIsIiQiLCJhIiwiRSIsIksiLCJVIiwiTiIsIkoiLCJnZSIsInF1ZXVlTWljcm90YXNrIiwiTSIsIkZ1bmN0aW9uIiwiYXBwbHkiLCJIIiwicCIsIkciLCJEciIsImNvbnN0cnVjdG9yIiwiX2N1cnNvciIsIl9zaXplIiwiX2Zyb250IiwiX2VsZW1lbnRzIiwiX25leHQiLCJfYmFjayIsInB1c2giLCJzaGlmdCIsImciLCJfIiwiUyIsImZvckVhY2giLCJwZWVrIiwiUSIsInd0IiwiU3ltYm9sIiwidW4iLCJlciIsInRyIiwicnIiLCJsbiIsIl9vd25lclJlYWRhYmxlU3RyZWFtIiwiX3JlYWRlciIsIl9zdGF0ZSIsIm9yIiwidm8iLCJmbiIsIl9zdG9yZWRFcnJvciIsIm5yIiwibGUiLCJfZSIsImlyIiwiRW8iLCJfcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIiwiUnQiLCJfY2xvc2VkUHJvbWlzZSIsIl9jbG9zZWRQcm9taXNlX3Jlc29sdmUiLCJfY2xvc2VkUHJvbWlzZV9yZWplY3QiLCJjbiIsImRuIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJBbyIsIk1hdGgiLCJ0cnVuYyIsImNlaWwiLCJmbG9vciIsIkJvIiwiY2UiLCJlZSIsInFvIiwiaG4iLCJTZSIsInNyIiwiYXIiLCJwbiIsImtvIiwidXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwibHIiLCJxZSIsIk5lIiwiZGUiLCJibiIsIl9yZWFkUmVxdWVzdHMiLCJmciIsIl9jbG9zZVN0ZXBzIiwiX2NodW5rU3RlcHMiLCJUdCIsIm1uIiwidmUiLCJNciIsImtlIiwiY2xvc2VkIiwiQ3QiLCJjYW5jZWwiLCJyZWFkIiwiaXQiLCJkb25lIiwiX2Vycm9yU3RlcHMiLCJyZWxlYXNlTG9jayIsIldvIiwiZGVmaW5lUHJvcGVydGllcyIsImVudW1lcmFibGUiLCJ0b1N0cmluZ1RhZyIsImhhc093blByb3BlcnR5IiwiX2Rpc3R1cmJlZCIsInluIiwiT28iLCJnZXRQcm90b3R5cGVPZiIsInhyIiwiX29uZ29pbmdQcm9taXNlIiwiX2lzRmluaXNoZWQiLCJfcHJldmVudENhbmNlbCIsIm5leHQiLCJfbmV4dFN0ZXBzIiwicmV0dXJuIiwiX3JldHVyblN0ZXBzIiwicmVzb2x2ZSIsIkMiLCJQdCIsImduIiwiX24iLCJfYXN5bmNJdGVyYXRvckltcGwiLCJTbiIsInNldFByb3RvdHlwZU9mIiwiem8iLCJjcmVhdGUiLCJ3biIsImlzTmFOIiwiY3IiLCJkciIsImhyIiwic3QiLCJzbGljZSIsIlJuIiwiVWludDhBcnJheSIsIndlIiwidHJhbnNmZXIiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJFZSIsImRldGFjaGVkIiwiYnl0ZUxlbmd0aCIsIlRuIiwiQXJyYXlCdWZmZXIiLCJ2dCIsIlN0cmluZyIsIkZvIiwiaXRlcmF0b3IiLCJuZXh0TWV0aG9kIiwicHIiLCJhc3luY0l0ZXJhdG9yIiwiZm9yIiwiQ24iLCJJbyIsImpvIiwiTG8iLCIkbyIsIlBuIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJyIiwiX3F1ZXVlIiwiX3F1ZXVlVG90YWxTaXplIiwic2l6ZSIsIm1yIiwiUmFuZ2VFcnJvciIsIkRvIiwiQWUiLCJ2biIsIkRhdGFWaWV3IiwiTW8iLCJ4byIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiVXIiLCJ2aWV3IiwieXIiLCJSciIsIl92aWV3IiwicmVzcG9uZCIsIl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsInF0IiwicmVzcG9uZFdpdGhOZXdWaWV3IiwiaXNWaWV3Iiwia3QiLCJSZSIsIk5yIiwiYnlvYlJlcXVlc3QiLCJPZSIsInV0Iiwid3IiLCJkZXNpcmVkU2l6ZSIsIkluIiwiY2xvc2UiLCJfY2xvc2VSZXF1ZXN0ZWQiLCJfY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSIsImF0IiwiZW5xdWV1ZSIsIkJ0IiwiZXJyb3IiLCJ0ZSIsIkVuIiwiX2NhbmNlbEFsZ29yaXRobSIsIkF0IiwiRm4iLCJfYXV0b0FsbG9jYXRlQ2h1bmtTaXplIiwiYnVmZmVyQnl0ZUxlbmd0aCIsImJ5dGVzRmlsbGVkIiwibWluaW11bUZpbGwiLCJlbGVtZW50U2l6ZSIsInZpZXdDb25zdHJ1Y3RvciIsInJlYWRlclR5cGUiLCJfcGVuZGluZ1B1bGxJbnRvcyIsInplIiwiaWUiLCJRbyIsIl9wdWxsaW5nIiwiX3B1bGxBZ2FpbiIsIl9wdWxsQWxnb3JpdGhtIiwiX3IiLCJnciIsIkFuIiwiWG8iLCJFdCIsIkJuIiwicW4iLCJIZSIsImtuIiwibWluIiwicSIsIlAiLCJXIiwiTyIsIlduIiwiT24iLCJwdCIsIl9ieW9iUmVxdWVzdCIsIlNyIiwiVW8iLCJObyIsImoiLCIkbiIsIkhvIiwiVHIiLCJEbiIsIlZvIiwiem4iLCJfc3RhcnRlZCIsImZvIiwiWW8iLCJfc3RyYXRlZ3lIV00iLCJqbiIsIkdvIiwic3RhcnQiLCJwdWxsIiwiYXV0b0FsbG9jYXRlQ2h1bmtTaXplIiwiWm8iLCJtb2RlIiwiS28iLCJKbyIsIkxuIiwiaGUiLCJfcmVhZEludG9SZXF1ZXN0cyIsIkZlIiwiSHIiLCJXdCIsIk1uIiwiZWkiLCJ4biIsImx0IiwiaGlnaFdhdGVyTWFyayIsIk90IiwienQiLCJ0aSIsInJpIiwiYWJvcnQiLCJ3cml0ZSIsIm5pIiwib2kiLCJpaSIsInNpIiwiVW4iLCJWZSIsImFpIiwiYWJvcnRlZCIsInVpIiwiQWJvcnRDb250cm9sbGVyIiwibGkiLCJWciIsIkhuIiwiVGkiLCJsb2NrZWQiLCIkdCIsIlFlIiwiRnQiLCJiZSIsIlZuIiwiZ2V0V3JpdGVyIiwiTm4iLCJwZSIsInNlIiwiZmkiLCJCZSIsIkpuIiwiX3dyaXRlciIsIl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIiLCJfd3JpdGVSZXF1ZXN0cyIsIl9pbkZsaWdodFdyaXRlUmVxdWVzdCIsIl9jbG9zZVJlcXVlc3QiLCJfaW5GbGlnaHRDbG9zZVJlcXVlc3QiLCJfcGVuZGluZ0Fib3J0UmVxdWVzdCIsIl9iYWNrcHJlc3N1cmUiLCJfYWJvcnRSZWFzb24iLCJfYWJvcnRDb250cm9sbGVyIiwiX3Byb21pc2UiLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJfcmVhc29uIiwiX3dhc0FscmVhZHlFcnJvcmluZyIsIlByIiwiT3IiLCJDaSIsImNpIiwiQ3IiLCJ2ciIsIkduIiwibWkiLCJJdCIsImRpIiwiaGkiLCJwaSIsInJvIiwiYmkiLCJ5aSIsImdpIiwia3IiLCJFciIsImtpIiwiUXIiLCJfb3duZXJXcml0YWJsZVN0cmVhbSIsIk10Iiwibm8iLCJEdCIsIldyIiwiQmkiLCJ0byIsIkllIiwiamUiLCJjdCIsIlJpIiwicmVhZHkiLCJfcmVhZHlQcm9taXNlIiwiX2kiLCJRbiIsIlluIiwiWm4iLCJTaSIsIndpIiwiX2Nsb3NlZFByb21pc2VTdGF0ZSIsInFpIiwiX3JlYWR5UHJvbWlzZVN0YXRlIiwib28iLCJXaSIsIlhuIiwiUGkiLCJ2aSIsIktuIiwiR3IiLCJhYm9ydFJlYXNvbiIsIkFyIiwicXIiLCJzaWduYWwiLCJfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtIiwiZW8iLCJfYWJvcnRBbGdvcml0aG0iLCJqdCIsIl9zdHJhdGVneVNpemVBbGdvcml0aG0iLCJfd3JpdGVBbGdvcml0aG0iLCJfY2xvc2VBbGdvcml0aG0iLCJCciIsIkx0IiwiZnQiLCJFaSIsIkFpIiwiX3JlYWR5UHJvbWlzZV9yZXNvbHZlIiwiX3JlYWR5UHJvbWlzZV9yZWplY3QiLCJPaSIsImdsb2JhbFRoaXMiLCJzZWxmIiwienIiLCJ6aSIsIm5hbWUiLCJGaSIsIkRPTUV4Y2VwdGlvbiIsIklpIiwibWVzc2FnZSIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJ3cml0YWJsZSIsImppIiwiaW8iLCJBIiwicmVhc29uIiwieiIsIloiLCJhbGwiLCJtYXAiLCJMIiwiYWRkRXZlbnRMaXN0ZW5lciIsImZlIiwiWCIsImV0IiwiVGUiLCJyZSIsIlkiLCJXZSIsIkNlIiwidHQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiWXIiLCJ4dCIsIk50IiwiRnIiLCJZZSIsIkxlIiwiR2UiLCJ1ZSIsIlV0IiwiX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSIsImR0IiwiYWUiLCJzbyIsIkxpIiwiYW8iLCIkaSIsIkRpIiwieGkiLCJNaSIsImh0IiwicnQiLCJudCIsIkNvIiwidG4iLCJZdCIsImxvIiwiVWkiLCJnZXRSZWFkZXIiLCJOaSIsIlZpIiwiSGkiLCJRaSIsIkdpIiwiWWkiLCJaaSIsIktpIiwiSmkiLCJwcmV2ZW50Q2FuY2VsIiwidW8iLCJwcmV2ZW50QWJvcnQiLCJwcmV2ZW50Q2xvc2UiLCJYaSIsImVzIiwicmVhZGFibGUiLCJaciIsIklyIiwiJGUiLCJwaXBlVGhyb3VnaCIsInBpcGVUbyIsInRlZSIsInZhbHVlcyIsIlYiLCJjbyIsImhvIiwiS3IiLCJfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsiLCJibyIsInBvIiwiWmUiLCJtbyIsIkpyIiwiX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayIsImdvIiwieW8iLCJLZSIsInRzIiwiZmx1c2giLCJyZWFkYWJsZVR5cGUiLCJ0cmFuc2Zvcm0iLCJ3cml0YWJsZVR5cGUiLCJpcyIsInJzIiwibnMiLCJvcyIsIlhyIiwic3MiLCJ1cyIsIl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyIiwiX28iLCJUbyIsIl9yZWFkYWJsZSIsIl93cml0YWJsZSIsIkplIiwiY3MiLCJkcyIsImhzIiwicHMiLCJicyIsIl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlIiwiX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSIsIkh0IiwiU28iLCJqciIsIlF0IiwiTHIiLCJlbiIsIlZ0IiwiR3QiLCJfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSIsIndvIiwibHMiLCJ0ZXJtaW5hdGUiLCJmcyIsIm1lIiwiYXMiLCJfdHJhbnNmb3JtQWxnb3JpdGhtIiwiX2ZsdXNoQWxnb3JpdGhtIiwiX2ZpbmlzaFByb21pc2UiLCJfZmluaXNoUHJvbWlzZV9yZXNvbHZlIiwiX2ZpbmlzaFByb21pc2VfcmVqZWN0IiwiUm8iLCJYZSIsIiRyIiwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSIsIkNvdW50UXVldWluZ1N0cmF0ZWd5IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsIlJlYWRhYmxlU3RyZWFtIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIiLCJUcmFuc2Zvcm1TdHJlYW0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIldyaXRhYmxlU3RyZWFtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsIlBPT0xfU0laRSQxIiwiZW1pdFdhcm5pbmciLCJhc3NpZ24iLCJCbG9iIiwic3RyZWFtIiwiYXJyYXlCdWZmZXIiLCJQT09MX1NJWkUiLCJ0b0l0ZXJhdG9yIiwiX0Jsb2IiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImVuZGluZ3MiLCJ0ZXh0IiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJtYXgiLCJzdWJhcnJheSIsInRvTG93ZXJDYXNlIiwiaGFzSW5zdGFuY2UiLCJXZWFrTWFwIiwiciQxIiwiX0ZpbGUiLCJhcmd1bWVudHMiLCJsYXN0TW9kaWZpZWQiLCJEYXRlIiwibm93IiwiRmlsZSIsIkZpbGUkMSIsInQkMSIsImkiLCJoIiwiciIsInJhbmRvbSIsIm0iLCJmIiwiZSQxIiwieCIsIkZvcm1EYXRhIiwiZW50cmllcyIsInNvbWUiLCJhcHBlbmQiLCJkZWxldGUiLCJmaWx0ZXIiLCJnZXRBbGwiLCJrZXlzIiwiZm9ybURhdGFUb0Jsb2IiLCJwYWRTdGFydCIsInJuIiwiRmV0Y2hCYXNlRXJyb3IiLCJubiIsImNvZGUiLCJlcnJubyIsImVycm9yZWRTeXNDYWxsIiwic3lzY2FsbCIsIkZldGNoRXJyb3IiLCJOQU1FIiwiaXNVUkxTZWFyY2hQYXJhbWV0ZXJzIiwic29ydCIsImlzQmxvYiIsImlzQWJvcnRTaWduYWwiLCJpc0RvbWFpbk9yU3ViZG9tYWluIiwiVVJMIiwiaG9zdG5hbWUiLCJlbmRzV2l0aCIsImlzU2FtZVByb3RvY29sIiwicHJvdG9jb2wiLCJwaXBlbGluZSIsInByb21pc2lmeSIsIklOVEVSTkFMUyQyIiwib24iLCJ0b1N0cmluZyIsImlzQnVmZmVyIiwidHlwZXMiLCJpc0FueUFycmF5QnVmZmVyIiwiUmVhZGFibGUiLCJib2R5IiwiYm91bmRhcnkiLCJkaXN0dXJiZWQiLCJ1cmwiLCJib2R5VXNlZCIsImNvbnN1bWVCb2R5IiwiZm9ybURhdGEiLCJoZWFkZXJzIiwic3RhcnRzV2l0aCIsIlVSTFNlYXJjaFBhcmFtcyIsInRvRm9ybURhdGEiLCJibG9iIiwianNvbiIsIkpTT04iLCJwYXJzZSIsIkJvZHkiLCJkZXByZWNhdGUiLCJkYXRhIiwiYWxsb2MiLCJkZXN0cm95IiwicmVhZGFibGVFbmRlZCIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kZWQiLCJldmVyeSIsImpvaW4iLCJjb25jYXQiLCJjbG9uZSIsImdldEJvdW5kYXJ5IiwiUGFzc1Rocm91Z2giLCJwaXBlIiwiZ2V0Tm9uU3BlY0Zvcm1EYXRhQm91bmRhcnkiLCJleHRyYWN0Q29udGVudFR5cGUiLCJnZXRUb3RhbEJ5dGVzIiwiZ2V0TGVuZ3RoU3luYyIsImhhc0tub3duTGVuZ3RoIiwid3JpdGVUb1N0cmVhbSIsImVuZCIsInZhbGlkYXRlSGVhZGVyTmFtZSIsInZhbGlkYXRlSGVhZGVyVmFsdWUiLCJLdCIsInJhdyIsImlzQm94ZWRQcmltaXRpdmUiLCJQcm94eSIsIlNldCIsIlJlZmxlY3QiLCJyZWR1Y2UiLCJIZWFkZXJzIiwiZnJvbVJhd0hlYWRlcnMiLCJyZWRpcmVjdFN0YXR1cyIsImlzUmVkaXJlY3QiLCJJTlRFUk5BTFMkMSIsIkRlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImNvdW50ZXIiLCJvayIsInJlZGlyZWN0ZWQiLCJyZWRpcmVjdCIsImxvY2F0aW9uIiwic3RyaW5naWZ5IiwiUmVzcG9uc2UiLCJnZXRTZWFyY2giLCJzZWFyY2giLCJocmVmIiwiaGFzaCIsInN0cmlwVVJMRm9yVXNlQXNBUmVmZXJyZXIiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwicGF0aG5hbWUiLCJSZWZlcnJlclBvbGljeSIsIkRFRkFVTFRfUkVGRVJSRVJfUE9MSUNZIiwidmFsaWRhdGVSZWZlcnJlclBvbGljeSIsImlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSIsImhvc3QiLCJpc0lQIiwiaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5IiwiZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlciIsInJlZmVycmVyVVJMQ2FsbGJhY2siLCJyZWZlcnJlck9yaWdpbkNhbGxiYWNrIiwicmVmZXJyZXIiLCJyZWZlcnJlclBvbGljeSIsIm9yaWdpbiIsInBhcnNlUmVmZXJyZXJQb2xpY3lGcm9tSGVhZGVyIiwiSU5URVJOQUxTIiwiaXNSZXF1ZXN0IiwiZG9CYWREYXRhV2FybiIsIkp0IiwibWV0aG9kIiwidG9VcHBlckNhc2UiLCJwYXJzZWRVUkwiLCJmb2xsb3ciLCJjb21wcmVzcyIsImFnZW50IiwiaW5zZWN1cmVIVFRQUGFyc2VyIiwiZm9ybWF0IiwiUmVxdWVzdCIsImdldE5vZGVSZXF1ZXN0T3B0aW9ucyIsInBhdGgiLCJvcHRpb25zIiwic24iLCJBYm9ydEVycm9yIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvc3RNZXNzYWdlIiwibm9kZURvbWV4Y2VwdGlvbiIsImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIiwic3RhdCIsInByb21pc2VzIiwiYmxvYkZyb21TeW5jIiwiZnJvbUJsb2IiLCJzdGF0U3luYyIsImJsb2JGcm9tIiwiZmlsZUZyb20iLCJmcm9tRmlsZSIsImZpbGVGcm9tU3luYyIsIkJsb2JEYXRhSXRlbSIsIm10aW1lTXMiLCJiYXNlbmFtZSIsIlh0IiwiY3JlYXRlUmVhZFN0cmVhbSIsInN1cHBvcnRlZFNjaGVtYXMiLCJmZXRjaCQxIiwicmVxdWVzdCIsImVtaXQiLCJmaXhSZXNwb25zZUNodW5rZWRUcmFuc2ZlckJhZEVuZGluZyIsInByb2Nlc3MiLCJ2ZXJzaW9uIiwicHJlcGVuZExpc3RlbmVyIiwiX2V2ZW50c0NvdW50Iiwic2V0VGltZW91dCIsInJhd0hlYWRlcnMiLCJzdGF0dXNDb2RlIiwib25jZSIsInN0YXR1c01lc3NhZ2UiLCJaX1NZTkNfRkxVU0giLCJmaW5pc2hGbHVzaCIsImNyZWF0ZUd1bnppcCIsImNyZWF0ZUluZmxhdGUiLCJjcmVhdGVJbmZsYXRlUmF3IiwiY3JlYXRlQnJvdGxpRGVjb21wcmVzcyIsImNhdGNoIiwiY29tcGFyZSIsInJlbW92ZUxpc3RlbmVyIiwicHJpdmF0ZURhdGEiLCJ3cmFwcGVycyIsInBkIiwiY29uc29sZSIsImFzc2VydCIsInNldENhbmNlbEZsYWciLCJwYXNzaXZlTGlzdGVuZXIiLCJldmVudCIsImNhbmNlbGFibGUiLCJjYW5jZWxlZCIsInByZXZlbnREZWZhdWx0IiwiRXZlbnQiLCJldmVudFRhcmdldCIsImV2ZW50UGhhc2UiLCJjdXJyZW50VGFyZ2V0Iiwic3RvcHBlZCIsImltbWVkaWF0ZVN0b3BwZWQiLCJ0aW1lU3RhbXAiLCJkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3IiLCJ0YXJnZXQiLCJjb21wb3NlZFBhdGgiLCJOT05FIiwiQ0FQVFVSSU5HX1BIQVNFIiwiQVRfVEFSR0VUIiwiQlVCQkxJTkdfUEhBU0UiLCJzdG9wUHJvcGFnYXRpb24iLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJidWJibGVzIiwiZGVmYXVsdFByZXZlbnRlZCIsImNvbXBvc2VkIiwic3JjRWxlbWVudCIsImNhbmNlbEJ1YmJsZSIsInJldHVyblZhbHVlIiwiaW5pdEV2ZW50Iiwid2luZG93IiwiZGVmaW5lQ2FsbERlc2NyaXB0b3IiLCJkZWZpbmVXcmFwcGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0V3JhcHBlciIsIndyYXBFdmVudCIsImlzU3RvcHBlZCIsInNldEV2ZW50UGhhc2UiLCJzZXRDdXJyZW50VGFyZ2V0Iiwic2V0UGFzc2l2ZUxpc3RlbmVyIiwibGlzdGVuZXJzTWFwIiwiQ0FQVFVSRSIsIkJVQkJMRSIsIkFUVFJJQlVURSIsImlzT2JqZWN0IiwiZ2V0TGlzdGVuZXJzIiwiZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yIiwibGlzdGVuZXJUeXBlIiwibGlzdGVuZXIiLCJwYXNzaXZlIiwiZGVmaW5lRXZlbnRBdHRyaWJ1dGUiLCJkZWZpbmVDdXN0b21FdmVudFRhcmdldCIsIkV2ZW50VGFyZ2V0IiwiTWFwIiwiQXJyYXkiLCJpc0FycmF5IiwiY2FwdHVyZSIsImRpc3BhdGNoRXZlbnQiLCJoYW5kbGVFdmVudCIsImFuIiwiYWJvcnRlZEZsYWdzIiwiQWJvcnRTaWduYWwiLCJjcmVhdGVBYm9ydFNpZ25hbCIsImFib3J0U2lnbmFsIiwiQWJvcnRDb250cm9sbGVyJDEiLCJzaWduYWxzIiwiZ2V0U2lnbmFsIiwidCIsImUiLCJmZXRjaCIsInMiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJlbnYiLCJESVNBQkxFX05PREVfRkVUQ0hfTkFUSVZFX1dBUk4iLCJ3YXJuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native-with-agent/dist/node.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.61758d11.cjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.61758d11.cjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nvar l = Object.defineProperty;\nvar o = (e, t)=>l(e, \"name\", {\n        value: t,\n        configurable: !0\n    });\nvar commonjsGlobal = typeof globalThis < \"u\" ? globalThis :  false ? 0 : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction getDefaultExportFromCjs(e) {\n    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\no(getDefaultExportFromCjs, \"getDefaultExportFromCjs\"), exports.commonjsGlobal = commonjsGlobal, exports.getDefaultExportFromCjs = getDefaultExportFromCjs;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudC9kaXN0L3NoYXJlZC9ub2RlLWZldGNoLW5hdGl2ZS13aXRoLWFnZW50LjYxNzU4ZDExLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUFBLElBQUlBLElBQUVDLE9BQU9DLGNBQWM7QUFBQyxJQUFJQyxJQUFFLENBQUNDLEdBQUVDLElBQUlMLEVBQUVJLEdBQUUsUUFBTztRQUFDRSxPQUFNRDtRQUFFRSxjQUFhLENBQUM7SUFBQztBQUFHLElBQUlDLGlCQUFlLE9BQU9DLGFBQVcsTUFBSUEsYUFBVyxNQUFpQixHQUFDQyxDQUFNQSxHQUFDLE9BQU9DLFNBQU8sTUFBSUEsU0FBTyxPQUFPQyxPQUFLLE1BQUlBLE9BQUssQ0FBQztBQUFFLFNBQVNDLHdCQUF3QlQsQ0FBQztJQUFFLE9BQU9BLEtBQUdBLEVBQUVVLFVBQVUsSUFBRWIsT0FBT2MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ2IsR0FBRSxhQUFXQSxFQUFFYyxPQUFPLEdBQUNkO0FBQUM7QUFBQ0QsRUFBRVUseUJBQXdCLDRCQUEyQk0sc0JBQXNCLEdBQUNYLGdCQUFlVywrQkFBK0IsR0FBQ04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlby1lZGl0b3ItYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gtbmF0aXZlLXdpdGgtYWdlbnQvZGlzdC9zaGFyZWQvbm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudC42MTc1OGQxMS5janM/NjUzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjt2YXIgbD1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIG89KGUsdCk9PmwoZSxcIm5hbWVcIix7dmFsdWU6dCxjb25maWd1cmFibGU6ITB9KTt2YXIgY29tbW9uanNHbG9iYWw9dHlwZW9mIGdsb2JhbFRoaXM8XCJ1XCI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93PFwidVwiP3dpbmRvdzp0eXBlb2YgZ2xvYmFsPFwidVwiP2dsb2JhbDp0eXBlb2Ygc2VsZjxcInVcIj9zZWxmOnt9O2Z1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiZGVmYXVsdFwiKT9lLmRlZmF1bHQ6ZX1vKGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzLFwiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanNcIiksZXhwb3J0cy5jb21tb25qc0dsb2JhbD1jb21tb25qc0dsb2JhbCxleHBvcnRzLmdldERlZmF1bHRFeHBvcnRGcm9tQ2pzPWdldERlZmF1bHRFeHBvcnRGcm9tQ2pzO1xuIl0sIm5hbWVzIjpbImwiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIm8iLCJlIiwidCIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIiwiX19lc01vZHVsZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlZmF1bHQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.61758d11.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.df7e6bd6.cjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.df7e6bd6.cjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar Dt = Object.defineProperty;\nvar Ft = (e, A, t)=>A in e ? Dt(e, A, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value: t\n    }) : e[A] = t;\nvar o = (e, A)=>Dt(e, \"name\", {\n        value: A,\n        configurable: !0\n    });\nvar NA = (e, A, t)=>(Ft(e, typeof A != \"symbol\" ? A + \"\" : A, t), t), ze = (e, A, t)=>{\n    if (!A.has(e)) throw TypeError(\"Cannot \" + t);\n}, yt = (e, A)=>{\n    if (Object(A) !== A) throw TypeError('Cannot use the \"in\" operator on this value');\n    return e.has(A);\n}, p = (e, A, t)=>(ze(e, A, \"read from private field\"), t ? t.call(e) : A.get(e)), CA = (e, A, t)=>{\n    if (A.has(e)) throw TypeError(\"Cannot add the same private member more than once\");\n    A instanceof WeakSet ? A.add(e) : A.set(e, t);\n}, EA = (e, A, t, n)=>(ze(e, A, \"write to private field\"), n ? n.call(e, t) : A.set(e, t), t);\nvar kA = (e, A, t)=>(ze(e, A, \"access private method\"), t);\nvar ne, se, oe, ie, Qe, Ee, ge, Be, Ce, Ie, ae, ce, he, le, ue, de, fe, De, ye, Re, we, ke, _A, Ne, Fe, pe, Se, Ue, be, me, Le, Me, Ye, Je, Oe, Rt, Ge, Ae, Te;\nconst require$$0 = __webpack_require__(/*! node:assert */ \"node:assert\"), require$$4 = __webpack_require__(/*! node:net */ \"node:net\"), http$1 = __webpack_require__(/*! node:http */ \"node:http\"), Stream = __webpack_require__(/*! node:stream */ \"node:stream\"), require$$6 = __webpack_require__(/*! node:buffer */ \"node:buffer\"), require$$0$1 = __webpack_require__(/*! node:util */ \"node:util\"), require$$8 = __webpack_require__(/*! node:querystring */ \"node:querystring\"), require$$0$2 = __webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\"), require$$0$3 = __webpack_require__(/*! node:events */ \"node:events\"), _commonjsHelpers = __webpack_require__(/*! ./node-fetch-native-with-agent.61758d11.cjs */ \"(rsc)/./node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.61758d11.cjs\"), require$$4$1 = __webpack_require__(/*! node:tls */ \"node:tls\"), zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\"), require$$5 = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\"), require$$8$1 = __webpack_require__(/*! node:util/types */ \"node:util/types\"), require$$0$4 = __webpack_require__(/*! node:os */ \"node:os\"), require$$1 = __webpack_require__(/*! node:url */ \"node:url\"), require$$5$1 = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\n__webpack_require__(/*! node:console */ \"node:console\");\nconst require$$5$2 = __webpack_require__(/*! string_decoder */ \"string_decoder\"), require$$2 = __webpack_require__(/*! node:worker_threads */ \"node:worker_threads\");\nfunction _interopDefaultCompat(e) {\n    return e && typeof e == \"object\" && \"default\" in e ? e.default : e;\n}\no(_interopDefaultCompat, \"_interopDefaultCompat\");\nconst require$$0__default = _interopDefaultCompat(require$$0), require$$4__default = _interopDefaultCompat(require$$4), http__default = _interopDefaultCompat(http$1), Stream__default = _interopDefaultCompat(Stream), require$$6__default = _interopDefaultCompat(require$$6), require$$0__default$1 = _interopDefaultCompat(require$$0$1), require$$8__default = _interopDefaultCompat(require$$8), require$$0__default$2 = _interopDefaultCompat(require$$0$2), require$$0__default$3 = _interopDefaultCompat(require$$0$3), require$$4__default$1 = _interopDefaultCompat(require$$4$1), zlib__default = _interopDefaultCompat(zlib), require$$5__default = _interopDefaultCompat(require$$5), require$$8__default$1 = _interopDefaultCompat(require$$8$1), require$$0__default$4 = _interopDefaultCompat(require$$0$4), require$$1__default = _interopDefaultCompat(require$$1), require$$5__default$1 = _interopDefaultCompat(require$$5$1), require$$5__default$2 = _interopDefaultCompat(require$$5$2), require$$2__default = _interopDefaultCompat(require$$2);\nvar symbols$4 = {\n    kClose: Symbol(\"close\"),\n    kDestroy: Symbol(\"destroy\"),\n    kDispatch: Symbol(\"dispatch\"),\n    kUrl: Symbol(\"url\"),\n    kWriting: Symbol(\"writing\"),\n    kResuming: Symbol(\"resuming\"),\n    kQueue: Symbol(\"queue\"),\n    kConnect: Symbol(\"connect\"),\n    kConnecting: Symbol(\"connecting\"),\n    kHeadersList: Symbol(\"headers list\"),\n    kKeepAliveDefaultTimeout: Symbol(\"default keep alive timeout\"),\n    kKeepAliveMaxTimeout: Symbol(\"max keep alive timeout\"),\n    kKeepAliveTimeoutThreshold: Symbol(\"keep alive timeout threshold\"),\n    kKeepAliveTimeoutValue: Symbol(\"keep alive timeout\"),\n    kKeepAlive: Symbol(\"keep alive\"),\n    kHeadersTimeout: Symbol(\"headers timeout\"),\n    kBodyTimeout: Symbol(\"body timeout\"),\n    kServerName: Symbol(\"server name\"),\n    kLocalAddress: Symbol(\"local address\"),\n    kHost: Symbol(\"host\"),\n    kNoRef: Symbol(\"no ref\"),\n    kBodyUsed: Symbol(\"used\"),\n    kRunning: Symbol(\"running\"),\n    kBlocking: Symbol(\"blocking\"),\n    kPending: Symbol(\"pending\"),\n    kSize: Symbol(\"size\"),\n    kBusy: Symbol(\"busy\"),\n    kQueued: Symbol(\"queued\"),\n    kFree: Symbol(\"free\"),\n    kConnected: Symbol(\"connected\"),\n    kClosed: Symbol(\"closed\"),\n    kNeedDrain: Symbol(\"need drain\"),\n    kReset: Symbol(\"reset\"),\n    kDestroyed: Symbol.for(\"nodejs.stream.destroyed\"),\n    kResume: Symbol(\"resume\"),\n    kOnError: Symbol(\"on error\"),\n    kMaxHeadersSize: Symbol(\"max headers size\"),\n    kRunningIdx: Symbol(\"running index\"),\n    kPendingIdx: Symbol(\"pending index\"),\n    kError: Symbol(\"error\"),\n    kClients: Symbol(\"clients\"),\n    kClient: Symbol(\"client\"),\n    kParser: Symbol(\"parser\"),\n    kOnDestroyed: Symbol(\"destroy callbacks\"),\n    kPipelining: Symbol(\"pipelining\"),\n    kSocket: Symbol(\"socket\"),\n    kHostHeader: Symbol(\"host header\"),\n    kConnector: Symbol(\"connector\"),\n    kStrictContentLength: Symbol(\"strict content length\"),\n    kMaxRedirections: Symbol(\"maxRedirections\"),\n    kMaxRequests: Symbol(\"maxRequestsPerClient\"),\n    kProxy: Symbol(\"proxy agent options\"),\n    kCounter: Symbol(\"socket request counter\"),\n    kInterceptors: Symbol(\"dispatch interceptors\"),\n    kMaxResponseSize: Symbol(\"max response size\"),\n    kHTTP2Session: Symbol(\"http2Session\"),\n    kHTTP2SessionState: Symbol(\"http2Session state\"),\n    kRetryHandlerDefaultRetry: Symbol(\"retry agent default retry\"),\n    kConstruct: Symbol(\"constructable\"),\n    kListeners: Symbol(\"listeners\"),\n    kHTTPContext: Symbol(\"http context\"),\n    kMaxConcurrentStreams: Symbol(\"max concurrent streams\")\n};\nlet UndiciError$1 = (ne = class extends Error {\n    constructor(A){\n        super(A), this.name = \"UndiciError\", this.code = \"UND_ERR\";\n    }\n}, o(ne, \"UndiciError\"), ne), ConnectTimeoutError$1 = (se = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"ConnectTimeoutError\", this.message = A || \"Connect Timeout Error\", this.code = \"UND_ERR_CONNECT_TIMEOUT\";\n    }\n}, o(se, \"ConnectTimeoutError\"), se), HeadersTimeoutError$1 = (oe = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"HeadersTimeoutError\", this.message = A || \"Headers Timeout Error\", this.code = \"UND_ERR_HEADERS_TIMEOUT\";\n    }\n}, o(oe, \"HeadersTimeoutError\"), oe), HeadersOverflowError$1 = (ie = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"HeadersOverflowError\", this.message = A || \"Headers Overflow Error\", this.code = \"UND_ERR_HEADERS_OVERFLOW\";\n    }\n}, o(ie, \"HeadersOverflowError\"), ie), BodyTimeoutError$1 = (Qe = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"BodyTimeoutError\", this.message = A || \"Body Timeout Error\", this.code = \"UND_ERR_BODY_TIMEOUT\";\n    }\n}, o(Qe, \"BodyTimeoutError\"), Qe), ResponseStatusCodeError$1 = (Ee = class extends UndiciError$1 {\n    constructor(A, t, n, r){\n        super(A), this.name = \"ResponseStatusCodeError\", this.message = A || \"Response Status Code Error\", this.code = \"UND_ERR_RESPONSE_STATUS_CODE\", this.body = r, this.status = t, this.statusCode = t, this.headers = n;\n    }\n}, o(Ee, \"ResponseStatusCodeError\"), Ee), InvalidArgumentError$k = (ge = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"InvalidArgumentError\", this.message = A || \"Invalid Argument Error\", this.code = \"UND_ERR_INVALID_ARG\";\n    }\n}, o(ge, \"InvalidArgumentError\"), ge), InvalidReturnValueError$2 = (Be = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"InvalidReturnValueError\", this.message = A || \"Invalid Return Value Error\", this.code = \"UND_ERR_INVALID_RETURN_VALUE\";\n    }\n}, o(Be, \"InvalidReturnValueError\"), Be), AbortError$1 = (Ce = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"AbortError\", this.message = A || \"The operation was aborted\";\n    }\n}, o(Ce, \"AbortError\"), Ce), RequestAbortedError$6 = (Ie = class extends AbortError$1 {\n    constructor(A){\n        super(A), this.name = \"AbortError\", this.message = A || \"Request aborted\", this.code = \"UND_ERR_ABORTED\";\n    }\n}, o(Ie, \"RequestAbortedError\"), Ie), InformationalError$3 = (ae = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"InformationalError\", this.message = A || \"Request information\", this.code = \"UND_ERR_INFO\";\n    }\n}, o(ae, \"InformationalError\"), ae), RequestContentLengthMismatchError$2 = (ce = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"RequestContentLengthMismatchError\", this.message = A || \"Request body length does not match content-length header\", this.code = \"UND_ERR_REQ_CONTENT_LENGTH_MISMATCH\";\n    }\n}, o(ce, \"RequestContentLengthMismatchError\"), ce), ResponseContentLengthMismatchError$1 = (he = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"ResponseContentLengthMismatchError\", this.message = A || \"Response body length does not match content-length header\", this.code = \"UND_ERR_RES_CONTENT_LENGTH_MISMATCH\";\n    }\n}, o(he, \"ResponseContentLengthMismatchError\"), he), ClientDestroyedError$2 = (le = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"ClientDestroyedError\", this.message = A || \"The client is destroyed\", this.code = \"UND_ERR_DESTROYED\";\n    }\n}, o(le, \"ClientDestroyedError\"), le), ClientClosedError$1 = (ue = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"ClientClosedError\", this.message = A || \"The client is closed\", this.code = \"UND_ERR_CLOSED\";\n    }\n}, o(ue, \"ClientClosedError\"), ue), SocketError$4 = (de = class extends UndiciError$1 {\n    constructor(A, t){\n        super(A), this.name = \"SocketError\", this.message = A || \"Socket error\", this.code = \"UND_ERR_SOCKET\", this.socket = t;\n    }\n}, o(de, \"SocketError\"), de), NotSupportedError$2 = (fe = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"NotSupportedError\", this.message = A || \"Not supported error\", this.code = \"UND_ERR_NOT_SUPPORTED\";\n    }\n}, o(fe, \"NotSupportedError\"), fe);\nconst At = class At extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"MissingUpstreamError\", this.message = A || \"No upstream has been added to the BalancedPool\", this.code = \"UND_ERR_BPL_MISSING_UPSTREAM\";\n    }\n};\no(At, \"BalancedPoolMissingUpstreamError\");\nlet BalancedPoolMissingUpstreamError = At, HTTPParserError$1 = (De = class extends Error {\n    constructor(A, t, n){\n        super(A), this.name = \"HTTPParserError\", this.code = t ? `HPE_${t}` : void 0, this.data = n ? n.toString() : void 0;\n    }\n}, o(De, \"HTTPParserError\"), De), ResponseExceededMaxSizeError$1 = (ye = class extends UndiciError$1 {\n    constructor(A){\n        super(A), this.name = \"ResponseExceededMaxSizeError\", this.message = A || \"Response content exceeded max size\", this.code = \"UND_ERR_RES_EXCEEDED_MAX_SIZE\";\n    }\n}, o(ye, \"ResponseExceededMaxSizeError\"), ye);\nconst et = class et extends UndiciError$1 {\n    constructor(A, t, { headers: n, data: r }){\n        super(A), this.name = \"RequestRetryError\", this.message = A || \"Request retry error\", this.code = \"UND_ERR_REQ_RETRY\", this.statusCode = t, this.data = r, this.headers = n;\n    }\n};\no(et, \"RequestRetryError\");\nlet RequestRetryError = et, SecureProxyConnectionError$1 = (Re = class extends UndiciError$1 {\n    constructor(A, t, n){\n        super(t, {\n            cause: A,\n            ...n ?? {}\n        }), this.name = \"SecureProxyConnectionError\", this.message = t || \"Secure Proxy Connection failed\", this.code = \"UND_ERR_PRX_TLS\", this.cause = A;\n    }\n}, o(Re, \"SecureProxyConnectionError\"), Re);\nvar errors$1 = {\n    AbortError: AbortError$1,\n    HTTPParserError: HTTPParserError$1,\n    UndiciError: UndiciError$1,\n    HeadersTimeoutError: HeadersTimeoutError$1,\n    HeadersOverflowError: HeadersOverflowError$1,\n    BodyTimeoutError: BodyTimeoutError$1,\n    RequestContentLengthMismatchError: RequestContentLengthMismatchError$2,\n    ConnectTimeoutError: ConnectTimeoutError$1,\n    ResponseStatusCodeError: ResponseStatusCodeError$1,\n    InvalidArgumentError: InvalidArgumentError$k,\n    InvalidReturnValueError: InvalidReturnValueError$2,\n    RequestAbortedError: RequestAbortedError$6,\n    ClientDestroyedError: ClientDestroyedError$2,\n    ClientClosedError: ClientClosedError$1,\n    InformationalError: InformationalError$3,\n    SocketError: SocketError$4,\n    NotSupportedError: NotSupportedError$2,\n    ResponseContentLengthMismatchError: ResponseContentLengthMismatchError$1,\n    BalancedPoolMissingUpstreamError,\n    ResponseExceededMaxSizeError: ResponseExceededMaxSizeError$1,\n    RequestRetryError,\n    SecureProxyConnectionError: SecureProxyConnectionError$1\n};\nconst headerNameLowerCasedRecord$3 = {}, wellknownHeaderNames$1 = [\n    \"Accept\",\n    \"Accept-Encoding\",\n    \"Accept-Language\",\n    \"Accept-Ranges\",\n    \"Access-Control-Allow-Credentials\",\n    \"Access-Control-Allow-Headers\",\n    \"Access-Control-Allow-Methods\",\n    \"Access-Control-Allow-Origin\",\n    \"Access-Control-Expose-Headers\",\n    \"Access-Control-Max-Age\",\n    \"Access-Control-Request-Headers\",\n    \"Access-Control-Request-Method\",\n    \"Age\",\n    \"Allow\",\n    \"Alt-Svc\",\n    \"Alt-Used\",\n    \"Authorization\",\n    \"Cache-Control\",\n    \"Clear-Site-Data\",\n    \"Connection\",\n    \"Content-Disposition\",\n    \"Content-Encoding\",\n    \"Content-Language\",\n    \"Content-Length\",\n    \"Content-Location\",\n    \"Content-Range\",\n    \"Content-Security-Policy\",\n    \"Content-Security-Policy-Report-Only\",\n    \"Content-Type\",\n    \"Cookie\",\n    \"Cross-Origin-Embedder-Policy\",\n    \"Cross-Origin-Opener-Policy\",\n    \"Cross-Origin-Resource-Policy\",\n    \"Date\",\n    \"Device-Memory\",\n    \"Downlink\",\n    \"ECT\",\n    \"ETag\",\n    \"Expect\",\n    \"Expect-CT\",\n    \"Expires\",\n    \"Forwarded\",\n    \"From\",\n    \"Host\",\n    \"If-Match\",\n    \"If-Modified-Since\",\n    \"If-None-Match\",\n    \"If-Range\",\n    \"If-Unmodified-Since\",\n    \"Keep-Alive\",\n    \"Last-Modified\",\n    \"Link\",\n    \"Location\",\n    \"Max-Forwards\",\n    \"Origin\",\n    \"Permissions-Policy\",\n    \"Pragma\",\n    \"Proxy-Authenticate\",\n    \"Proxy-Authorization\",\n    \"RTT\",\n    \"Range\",\n    \"Referer\",\n    \"Referrer-Policy\",\n    \"Refresh\",\n    \"Retry-After\",\n    \"Sec-WebSocket-Accept\",\n    \"Sec-WebSocket-Extensions\",\n    \"Sec-WebSocket-Key\",\n    \"Sec-WebSocket-Protocol\",\n    \"Sec-WebSocket-Version\",\n    \"Server\",\n    \"Server-Timing\",\n    \"Service-Worker-Allowed\",\n    \"Service-Worker-Navigation-Preload\",\n    \"Set-Cookie\",\n    \"SourceMap\",\n    \"Strict-Transport-Security\",\n    \"Supports-Loading-Mode\",\n    \"TE\",\n    \"Timing-Allow-Origin\",\n    \"Trailer\",\n    \"Transfer-Encoding\",\n    \"Upgrade\",\n    \"Upgrade-Insecure-Requests\",\n    \"User-Agent\",\n    \"Vary\",\n    \"Via\",\n    \"WWW-Authenticate\",\n    \"X-Content-Type-Options\",\n    \"X-DNS-Prefetch-Control\",\n    \"X-Frame-Options\",\n    \"X-Permitted-Cross-Domain-Policies\",\n    \"X-Powered-By\",\n    \"X-Requested-With\",\n    \"X-XSS-Protection\"\n];\nfor(let e = 0; e < wellknownHeaderNames$1.length; ++e){\n    const A = wellknownHeaderNames$1[e], t = A.toLowerCase();\n    headerNameLowerCasedRecord$3[A] = headerNameLowerCasedRecord$3[t] = t;\n}\nObject.setPrototypeOf(headerNameLowerCasedRecord$3, null);\nvar constants$5 = {\n    wellknownHeaderNames: wellknownHeaderNames$1,\n    headerNameLowerCasedRecord: headerNameLowerCasedRecord$3\n};\nconst { wellknownHeaderNames, headerNameLowerCasedRecord: headerNameLowerCasedRecord$2 } = constants$5, xA = class xA {\n    constructor(A, t, n){\n        NA(this, \"value\", null);\n        NA(this, \"left\", null);\n        NA(this, \"middle\", null);\n        NA(this, \"right\", null);\n        NA(this, \"code\");\n        if (n === void 0 || n >= A.length) throw new TypeError(\"Unreachable\");\n        if ((this.code = A.charCodeAt(n)) > 127) throw new TypeError(\"key must be ascii string\");\n        A.length !== ++n ? this.middle = new xA(A, t, n) : this.value = t;\n    }\n    add(A, t) {\n        const n = A.length;\n        if (n === 0) throw new TypeError(\"Unreachable\");\n        let r = 0, s = this;\n        for(;;){\n            const i = A.charCodeAt(r);\n            if (i > 127) throw new TypeError(\"key must be ascii string\");\n            if (s.code === i) if (n === ++r) {\n                s.value = t;\n                break;\n            } else if (s.middle !== null) s = s.middle;\n            else {\n                s.middle = new xA(A, t, r);\n                break;\n            }\n            else if (s.code < i) if (s.left !== null) s = s.left;\n            else {\n                s.left = new xA(A, t, r);\n                break;\n            }\n            else if (s.right !== null) s = s.right;\n            else {\n                s.right = new xA(A, t, r);\n                break;\n            }\n        }\n    }\n    search(A) {\n        const t = A.length;\n        let n = 0, r = this;\n        for(; r !== null && n < t;){\n            let s = A[n];\n            for(s <= 90 && s >= 65 && (s |= 32); r !== null;){\n                if (s === r.code) {\n                    if (t === ++n) return r;\n                    r = r.middle;\n                    break;\n                }\n                r = r.code < s ? r.left : r.right;\n            }\n        }\n        return null;\n    }\n};\no(xA, \"TstNode\");\nlet TstNode = xA;\nconst tt = class tt {\n    constructor(){\n        NA(this, \"node\", null);\n    }\n    insert(A, t) {\n        this.node === null ? this.node = new TstNode(A, t, 0) : this.node.add(A, t);\n    }\n    lookup(A) {\n        return this.node?.search(A)?.value ?? null;\n    }\n};\no(tt, \"TernarySearchTree\");\nlet TernarySearchTree = tt;\nconst tree$1 = new TernarySearchTree;\nfor(let e = 0; e < wellknownHeaderNames.length; ++e){\n    const A = headerNameLowerCasedRecord$2[wellknownHeaderNames[e]];\n    tree$1.insert(A, A);\n}\nvar tree_1 = {\n    TernarySearchTree,\n    tree: tree$1\n};\nconst assert$d = require$$0__default, { kDestroyed: kDestroyed$1, kBodyUsed: kBodyUsed$1, kListeners } = symbols$4, { IncomingMessage } = http__default, stream$1 = Stream__default, net$2 = require$$4__default, { InvalidArgumentError: InvalidArgumentError$j } = errors$1, { Blob: Blob$1 } = require$$6__default, nodeUtil = require$$0__default$1, { stringify } = require$$8__default, { headerNameLowerCasedRecord: headerNameLowerCasedRecord$1 } = constants$5, { tree } = tree_1, [nodeMajor, nodeMinor] = process.versions.node.split(\".\").map((e)=>Number(e));\nfunction nop() {}\no(nop, \"nop\");\nfunction isStream$1(e) {\n    return e && typeof e == \"object\" && typeof e.pipe == \"function\" && typeof e.on == \"function\";\n}\no(isStream$1, \"isStream$1\");\nfunction isBlobLike$1(e) {\n    if (e === null) return !1;\n    if (e instanceof Blob$1) return !0;\n    if (typeof e != \"object\") return !1;\n    {\n        const A = e[Symbol.toStringTag];\n        return (A === \"Blob\" || A === \"File\") && (\"stream\" in e && typeof e.stream == \"function\" || \"arrayBuffer\" in e && typeof e.arrayBuffer == \"function\");\n    }\n}\no(isBlobLike$1, \"isBlobLike$1\");\nfunction buildURL$3(e, A) {\n    if (e.includes(\"?\") || e.includes(\"#\")) throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".');\n    const t = stringify(A);\n    return t && (e += \"?\" + t), e;\n}\no(buildURL$3, \"buildURL$3\");\nfunction parseURL(e) {\n    if (typeof e == \"string\") {\n        if (e = new URL(e), !/^https?:/.test(e.origin || e.protocol)) throw new InvalidArgumentError$j(\"Invalid URL protocol: the URL must start with `http:` or `https:`.\");\n        return e;\n    }\n    if (!e || typeof e != \"object\") throw new InvalidArgumentError$j(\"Invalid URL: The URL argument must be a non-null object.\");\n    if (!/^https?:/.test(e.origin || e.protocol)) throw new InvalidArgumentError$j(\"Invalid URL protocol: the URL must start with `http:` or `https:`.\");\n    if (!(e instanceof URL)) {\n        if (e.port != null && e.port !== \"\" && !Number.isFinite(parseInt(e.port))) throw new InvalidArgumentError$j(\"Invalid URL: port must be a valid integer or a string representation of an integer.\");\n        if (e.path != null && typeof e.path != \"string\") throw new InvalidArgumentError$j(\"Invalid URL path: the path must be a string or null/undefined.\");\n        if (e.pathname != null && typeof e.pathname != \"string\") throw new InvalidArgumentError$j(\"Invalid URL pathname: the pathname must be a string or null/undefined.\");\n        if (e.hostname != null && typeof e.hostname != \"string\") throw new InvalidArgumentError$j(\"Invalid URL hostname: the hostname must be a string or null/undefined.\");\n        if (e.origin != null && typeof e.origin != \"string\") throw new InvalidArgumentError$j(\"Invalid URL origin: the origin must be a string or null/undefined.\");\n        const A = e.port != null ? e.port : e.protocol === \"https:\" ? 443 : 80;\n        let t = e.origin != null ? e.origin : `${e.protocol}//${e.hostname}:${A}`, n = e.path != null ? e.path : `${e.pathname || \"\"}${e.search || \"\"}`;\n        t.endsWith(\"/\") && (t = t.substring(0, t.length - 1)), n && !n.startsWith(\"/\") && (n = `/${n}`), e = new URL(t + n);\n    }\n    return e;\n}\no(parseURL, \"parseURL\");\nfunction parseOrigin(e) {\n    if (e = parseURL(e), e.pathname !== \"/\" || e.search || e.hash) throw new InvalidArgumentError$j(\"invalid url\");\n    return e;\n}\no(parseOrigin, \"parseOrigin\");\nfunction getHostname(e) {\n    if (e[0] === \"[\") {\n        const t = e.indexOf(\"]\");\n        return assert$d(t !== -1), e.substring(1, t);\n    }\n    const A = e.indexOf(\":\");\n    return A === -1 ? e : e.substring(0, A);\n}\no(getHostname, \"getHostname\");\nfunction getServerName$1(e) {\n    if (!e) return null;\n    assert$d.strictEqual(typeof e, \"string\");\n    const A = getHostname(e);\n    return net$2.isIP(A) ? \"\" : A;\n}\no(getServerName$1, \"getServerName$1\");\nfunction deepClone(e) {\n    return JSON.parse(JSON.stringify(e));\n}\no(deepClone, \"deepClone\");\nfunction isAsyncIterable(e) {\n    return e != null && typeof e[Symbol.asyncIterator] == \"function\";\n}\no(isAsyncIterable, \"isAsyncIterable\");\nfunction isIterable$1(e) {\n    return e != null && (typeof e[Symbol.iterator] == \"function\" || typeof e[Symbol.asyncIterator] == \"function\");\n}\no(isIterable$1, \"isIterable$1\");\nfunction bodyLength(e) {\n    if (e == null) return 0;\n    if (isStream$1(e)) {\n        const A = e._readableState;\n        return A && A.objectMode === !1 && A.ended === !0 && Number.isFinite(A.length) ? A.length : null;\n    } else {\n        if (isBlobLike$1(e)) return e.size != null ? e.size : null;\n        if (isBuffer$1(e)) return e.byteLength;\n    }\n    return null;\n}\no(bodyLength, \"bodyLength\");\nfunction isDestroyed(e) {\n    return e && !!(e.destroyed || e[kDestroyed$1] || stream$1.isDestroyed?.(e));\n}\no(isDestroyed, \"isDestroyed\");\nfunction isReadableAborted(e) {\n    const A = e?._readableState;\n    return isDestroyed(e) && A && !A.endEmitted;\n}\no(isReadableAborted, \"isReadableAborted\");\nfunction destroy$1(e, A) {\n    e == null || !isStream$1(e) || isDestroyed(e) || (typeof e.destroy == \"function\" ? (Object.getPrototypeOf(e).constructor === IncomingMessage && (e.socket = null), e.destroy(A)) : A && queueMicrotask(()=>{\n        e.emit(\"error\", A);\n    }), e.destroyed !== !0 && (e[kDestroyed$1] = !0));\n}\no(destroy$1, \"destroy$1\");\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/;\nfunction parseKeepAliveTimeout(e) {\n    const A = e.toString().match(KEEPALIVE_TIMEOUT_EXPR);\n    return A ? parseInt(A[1], 10) * 1e3 : null;\n}\no(parseKeepAliveTimeout, \"parseKeepAliveTimeout\");\nfunction headerNameToString(e) {\n    return typeof e == \"string\" ? headerNameLowerCasedRecord$1[e] ?? e.toLowerCase() : tree.lookup(e) ?? e.toString(\"latin1\").toLowerCase();\n}\no(headerNameToString, \"headerNameToString\");\nfunction bufferToLowerCasedHeaderName(e) {\n    return tree.lookup(e) ?? e.toString(\"latin1\").toLowerCase();\n}\no(bufferToLowerCasedHeaderName, \"bufferToLowerCasedHeaderName\");\nfunction parseHeaders(e, A) {\n    A === void 0 && (A = {});\n    for(let t = 0; t < e.length; t += 2){\n        const n = headerNameToString(e[t]);\n        let r = A[n];\n        if (r) typeof r == \"string\" && (r = [\n            r\n        ], A[n] = r), r.push(e[t + 1].toString(\"utf8\"));\n        else {\n            const s = e[t + 1];\n            typeof s == \"string\" ? A[n] = s : A[n] = Array.isArray(s) ? s.map((i)=>i.toString(\"utf8\")) : s.toString(\"utf8\");\n        }\n    }\n    return \"content-length\" in A && \"content-disposition\" in A && (A[\"content-disposition\"] = Buffer.from(A[\"content-disposition\"]).toString(\"latin1\")), A;\n}\no(parseHeaders, \"parseHeaders\");\nfunction parseRawHeaders(e) {\n    const A = e.length, t = new Array(A);\n    let n = !1, r = -1, s, i, E = 0;\n    for(let Q = 0; Q < e.length; Q += 2)s = e[Q], i = e[Q + 1], typeof s != \"string\" && (s = s.toString()), typeof i != \"string\" && (i = i.toString(\"utf8\")), E = s.length, E === 14 && s[7] === \"-\" && (s === \"content-length\" || s.toLowerCase() === \"content-length\") ? n = !0 : E === 19 && s[7] === \"-\" && (s === \"content-disposition\" || s.toLowerCase() === \"content-disposition\") && (r = Q + 1), t[Q] = s, t[Q + 1] = i;\n    return n && r !== -1 && (t[r] = Buffer.from(t[r]).toString(\"latin1\")), t;\n}\no(parseRawHeaders, \"parseRawHeaders\");\nfunction isBuffer$1(e) {\n    return e instanceof Uint8Array || Buffer.isBuffer(e);\n}\no(isBuffer$1, \"isBuffer$1\");\nfunction validateHandler$1(e, A, t) {\n    if (!e || typeof e != \"object\") throw new InvalidArgumentError$j(\"handler must be an object\");\n    if (typeof e.onConnect != \"function\") throw new InvalidArgumentError$j(\"invalid onConnect method\");\n    if (typeof e.onError != \"function\") throw new InvalidArgumentError$j(\"invalid onError method\");\n    if (typeof e.onBodySent != \"function\" && e.onBodySent !== void 0) throw new InvalidArgumentError$j(\"invalid onBodySent method\");\n    if (t || A === \"CONNECT\") {\n        if (typeof e.onUpgrade != \"function\") throw new InvalidArgumentError$j(\"invalid onUpgrade method\");\n    } else {\n        if (typeof e.onHeaders != \"function\") throw new InvalidArgumentError$j(\"invalid onHeaders method\");\n        if (typeof e.onData != \"function\") throw new InvalidArgumentError$j(\"invalid onData method\");\n        if (typeof e.onComplete != \"function\") throw new InvalidArgumentError$j(\"invalid onComplete method\");\n    }\n}\no(validateHandler$1, \"validateHandler$1\");\nfunction isDisturbed(e) {\n    return !!(e && (stream$1.isDisturbed(e) || e[kBodyUsed$1]));\n}\no(isDisturbed, \"isDisturbed\");\nfunction isErrored(e) {\n    return !!(e && stream$1.isErrored(e));\n}\no(isErrored, \"isErrored\");\nfunction isReadable(e) {\n    return !!(e && stream$1.isReadable(e));\n}\no(isReadable, \"isReadable\");\nfunction getSocketInfo(e) {\n    return {\n        localAddress: e.localAddress,\n        localPort: e.localPort,\n        remoteAddress: e.remoteAddress,\n        remotePort: e.remotePort,\n        remoteFamily: e.remoteFamily,\n        timeout: e.timeout,\n        bytesWritten: e.bytesWritten,\n        bytesRead: e.bytesRead\n    };\n}\no(getSocketInfo, \"getSocketInfo\");\nfunction ReadableStreamFrom$1(e) {\n    let A;\n    return new ReadableStream({\n        async start () {\n            A = e[Symbol.asyncIterator]();\n        },\n        async pull (t) {\n            const { done: n, value: r } = await A.next();\n            if (n) queueMicrotask(()=>{\n                t.close(), t.byobRequest?.respond(0);\n            });\n            else {\n                const s = Buffer.isBuffer(r) ? r : Buffer.from(r);\n                s.byteLength && t.enqueue(new Uint8Array(s));\n            }\n            return t.desiredSize > 0;\n        },\n        async cancel (t) {\n            await A.return();\n        },\n        type: \"bytes\"\n    });\n}\no(ReadableStreamFrom$1, \"ReadableStreamFrom$1\");\nfunction isFormDataLike$1(e) {\n    return e && typeof e == \"object\" && typeof e.append == \"function\" && typeof e.delete == \"function\" && typeof e.get == \"function\" && typeof e.getAll == \"function\" && typeof e.has == \"function\" && typeof e.set == \"function\" && e[Symbol.toStringTag] === \"FormData\";\n}\no(isFormDataLike$1, \"isFormDataLike$1\");\nfunction addAbortListener$1(e, A) {\n    return \"addEventListener\" in e ? (e.addEventListener(\"abort\", A, {\n        once: !0\n    }), ()=>e.removeEventListener(\"abort\", A)) : (e.addListener(\"abort\", A), ()=>e.removeListener(\"abort\", A));\n}\no(addAbortListener$1, \"addAbortListener$1\");\nconst hasToWellFormed = typeof String.prototype.toWellFormed == \"function\", hasIsWellFormed = typeof String.prototype.isWellFormed == \"function\";\nfunction toUSVString(e) {\n    return hasToWellFormed ? `${e}`.toWellFormed() : nodeUtil.toUSVString(e);\n}\no(toUSVString, \"toUSVString\");\nfunction isUSVString(e) {\n    return hasIsWellFormed ? `${e}`.isWellFormed() : toUSVString(e) === `${e}`;\n}\no(isUSVString, \"isUSVString\");\nfunction isTokenCharCode(e) {\n    switch(e){\n        case 34:\n        case 40:\n        case 41:\n        case 44:\n        case 47:\n        case 58:\n        case 59:\n        case 60:\n        case 61:\n        case 62:\n        case 63:\n        case 64:\n        case 91:\n        case 92:\n        case 93:\n        case 123:\n        case 125:\n            return !1;\n        default:\n            return e >= 33 && e <= 126;\n    }\n}\no(isTokenCharCode, \"isTokenCharCode\");\nfunction isValidHTTPToken$1(e) {\n    if (e.length === 0) return !1;\n    for(let A = 0; A < e.length; ++A)if (!isTokenCharCode(e.charCodeAt(A))) return !1;\n    return !0;\n}\no(isValidHTTPToken$1, \"isValidHTTPToken$1\");\nconst headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\nfunction isValidHeaderChar$1(e) {\n    return !headerCharRegex.test(e);\n}\no(isValidHeaderChar$1, \"isValidHeaderChar$1\");\nfunction parseRangeHeader(e) {\n    if (e == null || e === \"\") return {\n        start: 0,\n        end: null,\n        size: null\n    };\n    const A = e ? e.match(/^bytes (\\d+)-(\\d+)\\/(\\d+)?$/) : null;\n    return A ? {\n        start: parseInt(A[1]),\n        end: A[2] ? parseInt(A[2]) : null,\n        size: A[3] ? parseInt(A[3]) : null\n    } : null;\n}\no(parseRangeHeader, \"parseRangeHeader\");\nfunction addListener$1(e, A, t) {\n    return (e[kListeners] ?? (e[kListeners] = [])).push([\n        A,\n        t\n    ]), e.on(A, t), e;\n}\no(addListener$1, \"addListener$1\");\nfunction removeAllListeners$1(e) {\n    for (const [A, t] of e[kListeners] ?? [])e.removeListener(A, t);\n    e[kListeners] = null;\n}\no(removeAllListeners$1, \"removeAllListeners$1\");\nfunction errorRequest(e, A, t) {\n    try {\n        A.onError(t), assert$d(A.aborted);\n    } catch (n) {\n        e.emit(\"error\", n);\n    }\n}\no(errorRequest, \"errorRequest\");\nconst kEnumerableProperty = Object.create(null);\nkEnumerableProperty.enumerable = !0;\nvar util$m = {\n    kEnumerableProperty,\n    nop,\n    isDisturbed,\n    isErrored,\n    isReadable,\n    toUSVString,\n    isUSVString,\n    isReadableAborted,\n    isBlobLike: isBlobLike$1,\n    parseOrigin,\n    parseURL,\n    getServerName: getServerName$1,\n    isStream: isStream$1,\n    isIterable: isIterable$1,\n    isAsyncIterable,\n    isDestroyed,\n    headerNameToString,\n    bufferToLowerCasedHeaderName,\n    addListener: addListener$1,\n    removeAllListeners: removeAllListeners$1,\n    errorRequest,\n    parseRawHeaders,\n    parseHeaders,\n    parseKeepAliveTimeout,\n    destroy: destroy$1,\n    bodyLength,\n    deepClone,\n    ReadableStreamFrom: ReadableStreamFrom$1,\n    isBuffer: isBuffer$1,\n    validateHandler: validateHandler$1,\n    getSocketInfo,\n    isFormDataLike: isFormDataLike$1,\n    buildURL: buildURL$3,\n    addAbortListener: addAbortListener$1,\n    isValidHTTPToken: isValidHTTPToken$1,\n    isValidHeaderChar: isValidHeaderChar$1,\n    isTokenCharCode,\n    parseRangeHeader,\n    nodeMajor,\n    nodeMinor,\n    nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,\n    safeHTTPMethods: [\n        \"GET\",\n        \"HEAD\",\n        \"OPTIONS\",\n        \"TRACE\"\n    ]\n};\nconst diagnosticsChannel = require$$0__default$2, util$l = require$$0__default$1, undiciDebugLog = util$l.debuglog(\"undici\"), fetchDebuglog = util$l.debuglog(\"fetch\"), websocketDebuglog = util$l.debuglog(\"websocket\");\nlet isClientSet = !1;\nconst channels$3 = {\n    beforeConnect: diagnosticsChannel.channel(\"undici:client:beforeConnect\"),\n    connected: diagnosticsChannel.channel(\"undici:client:connected\"),\n    connectError: diagnosticsChannel.channel(\"undici:client:connectError\"),\n    sendHeaders: diagnosticsChannel.channel(\"undici:client:sendHeaders\"),\n    create: diagnosticsChannel.channel(\"undici:request:create\"),\n    bodySent: diagnosticsChannel.channel(\"undici:request:bodySent\"),\n    headers: diagnosticsChannel.channel(\"undici:request:headers\"),\n    trailers: diagnosticsChannel.channel(\"undici:request:trailers\"),\n    error: diagnosticsChannel.channel(\"undici:request:error\"),\n    open: diagnosticsChannel.channel(\"undici:websocket:open\"),\n    close: diagnosticsChannel.channel(\"undici:websocket:close\"),\n    socketError: diagnosticsChannel.channel(\"undici:websocket:socket_error\"),\n    ping: diagnosticsChannel.channel(\"undici:websocket:ping\"),\n    pong: diagnosticsChannel.channel(\"undici:websocket:pong\")\n};\nif (undiciDebugLog.enabled || fetchDebuglog.enabled) {\n    const e = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog;\n    diagnosticsChannel.channel(\"undici:client:beforeConnect\").subscribe((A)=>{\n        const { connectParams: { version: t, protocol: n, port: r, host: s } } = A;\n        e(\"connecting to %s using %s%s\", `${s}${r ? `:${r}` : \"\"}`, n, t);\n    }), diagnosticsChannel.channel(\"undici:client:connected\").subscribe((A)=>{\n        const { connectParams: { version: t, protocol: n, port: r, host: s } } = A;\n        e(\"connected to %s using %s%s\", `${s}${r ? `:${r}` : \"\"}`, n, t);\n    }), diagnosticsChannel.channel(\"undici:client:connectError\").subscribe((A)=>{\n        const { connectParams: { version: t, protocol: n, port: r, host: s }, error: i } = A;\n        e(\"connection to %s using %s%s errored - %s\", `${s}${r ? `:${r}` : \"\"}`, n, t, i.message);\n    }), diagnosticsChannel.channel(\"undici:client:sendHeaders\").subscribe((A)=>{\n        const { request: { method: t, path: n, origin: r } } = A;\n        e(\"sending request to %s %s/%s\", t, r, n);\n    }), diagnosticsChannel.channel(\"undici:request:headers\").subscribe((A)=>{\n        const { request: { method: t, path: n, origin: r }, response: { statusCode: s } } = A;\n        e(\"received response to %s %s/%s - HTTP %d\", t, r, n, s);\n    }), diagnosticsChannel.channel(\"undici:request:trailers\").subscribe((A)=>{\n        const { request: { method: t, path: n, origin: r } } = A;\n        e(\"trailers received from %s %s/%s\", t, r, n);\n    }), diagnosticsChannel.channel(\"undici:request:error\").subscribe((A)=>{\n        const { request: { method: t, path: n, origin: r }, error: s } = A;\n        e(\"request to %s %s/%s errored - %s\", t, r, n, s.message);\n    }), isClientSet = !0;\n}\nif (websocketDebuglog.enabled) {\n    if (!isClientSet) {\n        const e = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog;\n        diagnosticsChannel.channel(\"undici:client:beforeConnect\").subscribe((A)=>{\n            const { connectParams: { version: t, protocol: n, port: r, host: s } } = A;\n            e(\"connecting to %s%s using %s%s\", s, r ? `:${r}` : \"\", n, t);\n        }), diagnosticsChannel.channel(\"undici:client:connected\").subscribe((A)=>{\n            const { connectParams: { version: t, protocol: n, port: r, host: s } } = A;\n            e(\"connected to %s%s using %s%s\", s, r ? `:${r}` : \"\", n, t);\n        }), diagnosticsChannel.channel(\"undici:client:connectError\").subscribe((A)=>{\n            const { connectParams: { version: t, protocol: n, port: r, host: s }, error: i } = A;\n            e(\"connection to %s%s using %s%s errored - %s\", s, r ? `:${r}` : \"\", n, t, i.message);\n        }), diagnosticsChannel.channel(\"undici:client:sendHeaders\").subscribe((A)=>{\n            const { request: { method: t, path: n, origin: r } } = A;\n            e(\"sending request to %s %s/%s\", t, r, n);\n        });\n    }\n    diagnosticsChannel.channel(\"undici:websocket:open\").subscribe((e)=>{\n        const { address: { address: A, port: t } } = e;\n        websocketDebuglog(\"connection opened %s%s\", A, t ? `:${t}` : \"\");\n    }), diagnosticsChannel.channel(\"undici:websocket:close\").subscribe((e)=>{\n        const { websocket: A, code: t, reason: n } = e;\n        websocketDebuglog(\"closed connection to %s - %s %s\", A.url, t, n);\n    }), diagnosticsChannel.channel(\"undici:websocket:socket_error\").subscribe((e)=>{\n        websocketDebuglog(\"connection errored - %s\", e.message);\n    }), diagnosticsChannel.channel(\"undici:websocket:ping\").subscribe((e)=>{\n        websocketDebuglog(\"ping received\");\n    }), diagnosticsChannel.channel(\"undici:websocket:pong\").subscribe((e)=>{\n        websocketDebuglog(\"pong received\");\n    });\n}\nvar diagnostics = {\n    channels: channels$3\n};\nconst { InvalidArgumentError: InvalidArgumentError$i, NotSupportedError: NotSupportedError$1 } = errors$1, assert$c = require$$0__default, { isValidHTTPToken, isValidHeaderChar, isStream, destroy, isBuffer, isFormDataLike, isIterable, isBlobLike, buildURL: buildURL$2, validateHandler, getServerName } = util$m, { channels: channels$2 } = diagnostics, { headerNameLowerCasedRecord } = constants$5, invalidPathRegex = /[^\\u0021-\\u00ff]/, kHandler = Symbol(\"handler\");\nlet Request$1 = (we = class {\n    constructor(A, { path: t, method: n, body: r, headers: s, query: i, idempotent: E, blocking: Q, upgrade: C, headersTimeout: I, bodyTimeout: a, reset: f, throwOnError: h, expectContinue: L, servername: c }, l){\n        if (typeof t != \"string\") throw new InvalidArgumentError$i(\"path must be a string\");\n        if (t[0] !== \"/\" && !(t.startsWith(\"http://\") || t.startsWith(\"https://\")) && n !== \"CONNECT\") throw new InvalidArgumentError$i(\"path must be an absolute URL or start with a slash\");\n        if (invalidPathRegex.exec(t) !== null) throw new InvalidArgumentError$i(\"invalid request path\");\n        if (typeof n != \"string\") throw new InvalidArgumentError$i(\"method must be a string\");\n        if (!isValidHTTPToken(n)) throw new InvalidArgumentError$i(\"invalid request method\");\n        if (C && typeof C != \"string\") throw new InvalidArgumentError$i(\"upgrade must be a string\");\n        if (I != null && (!Number.isFinite(I) || I < 0)) throw new InvalidArgumentError$i(\"invalid headersTimeout\");\n        if (a != null && (!Number.isFinite(a) || a < 0)) throw new InvalidArgumentError$i(\"invalid bodyTimeout\");\n        if (f != null && typeof f != \"boolean\") throw new InvalidArgumentError$i(\"invalid reset\");\n        if (L != null && typeof L != \"boolean\") throw new InvalidArgumentError$i(\"invalid expectContinue\");\n        if (this.headersTimeout = I, this.bodyTimeout = a, this.throwOnError = h === !0, this.method = n, this.abort = null, r == null) this.body = null;\n        else if (isStream(r)) {\n            this.body = r;\n            const S = this.body._readableState;\n            (!S || !S.autoDestroy) && (this.endHandler = o(function() {\n                destroy(this);\n            }, \"autoDestroy\"), this.body.on(\"end\", this.endHandler)), this.errorHandler = (k)=>{\n                this.abort ? this.abort(k) : this.error = k;\n            }, this.body.on(\"error\", this.errorHandler);\n        } else if (isBuffer(r)) this.body = r.byteLength ? r : null;\n        else if (ArrayBuffer.isView(r)) this.body = r.buffer.byteLength ? Buffer.from(r.buffer, r.byteOffset, r.byteLength) : null;\n        else if (r instanceof ArrayBuffer) this.body = r.byteLength ? Buffer.from(r) : null;\n        else if (typeof r == \"string\") this.body = r.length ? Buffer.from(r) : null;\n        else if (isFormDataLike(r) || isIterable(r) || isBlobLike(r)) this.body = r;\n        else throw new InvalidArgumentError$i(\"body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable\");\n        if (this.completed = !1, this.aborted = !1, this.upgrade = C || null, this.path = i ? buildURL$2(t, i) : t, this.origin = A, this.idempotent = E ?? (n === \"HEAD\" || n === \"GET\"), this.blocking = Q ?? !1, this.reset = f ?? null, this.host = null, this.contentLength = null, this.contentType = null, this.headers = [], this.expectContinue = L ?? !1, Array.isArray(s)) {\n            if (s.length % 2 !== 0) throw new InvalidArgumentError$i(\"headers array must be even\");\n            for(let S = 0; S < s.length; S += 2)processHeader(this, s[S], s[S + 1]);\n        } else if (s && typeof s == \"object\") if (s[Symbol.iterator]) for (const S of s){\n            if (!Array.isArray(S) || S.length !== 2) throw new InvalidArgumentError$i(\"headers must be in key-value pair format\");\n            processHeader(this, S[0], S[1]);\n        }\n        else {\n            const S = Object.keys(s);\n            for(let k = 0; k < S.length; ++k)processHeader(this, S[k], s[S[k]]);\n        }\n        else if (s != null) throw new InvalidArgumentError$i(\"headers must be an object or an array\");\n        validateHandler(l, n, C), this.servername = c || getServerName(this.host), this[kHandler] = l, channels$2.create.hasSubscribers && channels$2.create.publish({\n            request: this\n        });\n    }\n    onBodySent(A) {\n        if (this[kHandler].onBodySent) try {\n            return this[kHandler].onBodySent(A);\n        } catch (t) {\n            this.abort(t);\n        }\n    }\n    onRequestSent() {\n        if (channels$2.bodySent.hasSubscribers && channels$2.bodySent.publish({\n            request: this\n        }), this[kHandler].onRequestSent) try {\n            return this[kHandler].onRequestSent();\n        } catch (A) {\n            this.abort(A);\n        }\n    }\n    onConnect(A) {\n        if (assert$c(!this.aborted), assert$c(!this.completed), this.error) A(this.error);\n        else return this.abort = A, this[kHandler].onConnect(A);\n    }\n    onResponseStarted() {\n        return this[kHandler].onResponseStarted?.();\n    }\n    onHeaders(A, t, n, r) {\n        assert$c(!this.aborted), assert$c(!this.completed), channels$2.headers.hasSubscribers && channels$2.headers.publish({\n            request: this,\n            response: {\n                statusCode: A,\n                headers: t,\n                statusText: r\n            }\n        });\n        try {\n            return this[kHandler].onHeaders(A, t, n, r);\n        } catch (s) {\n            this.abort(s);\n        }\n    }\n    onData(A) {\n        assert$c(!this.aborted), assert$c(!this.completed);\n        try {\n            return this[kHandler].onData(A);\n        } catch (t) {\n            return this.abort(t), !1;\n        }\n    }\n    onUpgrade(A, t, n) {\n        return assert$c(!this.aborted), assert$c(!this.completed), this[kHandler].onUpgrade(A, t, n);\n    }\n    onComplete(A) {\n        this.onFinally(), assert$c(!this.aborted), this.completed = !0, channels$2.trailers.hasSubscribers && channels$2.trailers.publish({\n            request: this,\n            trailers: A\n        });\n        try {\n            return this[kHandler].onComplete(A);\n        } catch (t) {\n            this.onError(t);\n        }\n    }\n    onError(A) {\n        if (this.onFinally(), channels$2.error.hasSubscribers && channels$2.error.publish({\n            request: this,\n            error: A\n        }), !this.aborted) return this.aborted = !0, this[kHandler].onError(A);\n    }\n    onFinally() {\n        this.errorHandler && (this.body.off(\"error\", this.errorHandler), this.errorHandler = null), this.endHandler && (this.body.off(\"end\", this.endHandler), this.endHandler = null);\n    }\n    addHeader(A, t) {\n        return processHeader(this, A, t), this;\n    }\n}, o(we, \"Request\"), we);\nfunction processHeader(e, A, t) {\n    if (t && typeof t == \"object\" && !Array.isArray(t)) throw new InvalidArgumentError$i(`invalid ${A} header`);\n    if (t === void 0) return;\n    let n = headerNameLowerCasedRecord[A];\n    if (n === void 0 && (n = A.toLowerCase(), headerNameLowerCasedRecord[n] === void 0 && !isValidHTTPToken(n))) throw new InvalidArgumentError$i(\"invalid header key\");\n    if (Array.isArray(t)) {\n        const r = [];\n        for(let s = 0; s < t.length; s++)if (typeof t[s] == \"string\") {\n            if (!isValidHeaderChar(t[s])) throw new InvalidArgumentError$i(`invalid ${A} header`);\n            r.push(t[s]);\n        } else if (t[s] === null) r.push(\"\");\n        else {\n            if (typeof t[s] == \"object\") throw new InvalidArgumentError$i(`invalid ${A} header`);\n            r.push(`${t[s]}`);\n        }\n        t = r;\n    } else if (typeof t == \"string\") {\n        if (!isValidHeaderChar(t)) throw new InvalidArgumentError$i(`invalid ${A} header`);\n    } else if (t === null) t = \"\";\n    else {\n        if (typeof t == \"object\") throw new InvalidArgumentError$i(`invalid ${A} header`);\n        t = `${t}`;\n    }\n    if (e.host === null && n === \"host\") {\n        if (typeof t != \"string\") throw new InvalidArgumentError$i(\"invalid host header\");\n        e.host = t;\n    } else if (e.contentLength === null && n === \"content-length\") {\n        if (e.contentLength = parseInt(t, 10), !Number.isFinite(e.contentLength)) throw new InvalidArgumentError$i(\"invalid content-length header\");\n    } else if (e.contentType === null && n === \"content-type\") e.contentType = t, e.headers.push(A, t);\n    else {\n        if (n === \"transfer-encoding\" || n === \"keep-alive\" || n === \"upgrade\") throw new InvalidArgumentError$i(`invalid ${n} header`);\n        if (n === \"connection\") {\n            const r = typeof t == \"string\" ? t.toLowerCase() : null;\n            if (r !== \"close\" && r !== \"keep-alive\") throw new InvalidArgumentError$i(\"invalid connection header\");\n            r === \"close\" && (e.reset = !0);\n        } else {\n            if (n === \"expect\") throw new NotSupportedError$1(\"expect header not supported\");\n            e.headers.push(A, t);\n        }\n    }\n}\no(processHeader, \"processHeader\");\nvar request$2 = Request$1;\nconst EventEmitter = require$$0__default$3;\nlet Dispatcher$2 = (ke = class extends EventEmitter {\n    dispatch() {\n        throw new Error(\"not implemented\");\n    }\n    close() {\n        throw new Error(\"not implemented\");\n    }\n    destroy() {\n        throw new Error(\"not implemented\");\n    }\n    compose(...A) {\n        const t = Array.isArray(A[0]) ? A[0] : A;\n        let n = this.dispatch.bind(this);\n        for (const r of t)if (r != null) {\n            if (typeof r != \"function\") throw new TypeError(`invalid interceptor, expected function received ${typeof r}`);\n            if (n = r(n), n == null || typeof n != \"function\" || n.length !== 2) throw new TypeError(\"invalid interceptor\");\n        }\n        return new ComposedDispatcher(this, n);\n    }\n}, o(ke, \"Dispatcher\"), ke);\nconst rt = class rt extends Dispatcher$2 {\n    constructor(t, n){\n        super();\n        CA(this, _A, null);\n        CA(this, Ne, null);\n        EA(this, _A, t), EA(this, Ne, n);\n    }\n    dispatch(...t) {\n        p(this, Ne).call(this, ...t);\n    }\n    close(...t) {\n        return p(this, _A).close(...t);\n    }\n    destroy(...t) {\n        return p(this, _A).destroy(...t);\n    }\n};\n_A = new WeakMap, Ne = new WeakMap, o(rt, \"ComposedDispatcher\");\nlet ComposedDispatcher = rt;\nvar dispatcher = Dispatcher$2;\nconst Dispatcher$1 = dispatcher, { ClientDestroyedError: ClientDestroyedError$1, ClientClosedError, InvalidArgumentError: InvalidArgumentError$h } = errors$1, { kDestroy: kDestroy$4, kClose: kClose$6, kDispatch: kDispatch$3, kInterceptors: kInterceptors$4 } = symbols$4, kDestroyed = Symbol(\"destroyed\"), kClosed = Symbol(\"closed\"), kOnDestroyed = Symbol(\"onDestroyed\"), kOnClosed = Symbol(\"onClosed\"), kInterceptedDispatch = Symbol(\"Intercepted Dispatch\");\nlet DispatcherBase$4 = (Fe = class extends Dispatcher$1 {\n    constructor(){\n        super(), this[kDestroyed] = !1, this[kOnDestroyed] = null, this[kClosed] = !1, this[kOnClosed] = [];\n    }\n    get destroyed() {\n        return this[kDestroyed];\n    }\n    get closed() {\n        return this[kClosed];\n    }\n    get interceptors() {\n        return this[kInterceptors$4];\n    }\n    set interceptors(A) {\n        if (A) {\n            for(let t = A.length - 1; t >= 0; t--)if (typeof this[kInterceptors$4][t] != \"function\") throw new InvalidArgumentError$h(\"interceptor must be an function\");\n        }\n        this[kInterceptors$4] = A;\n    }\n    close(A) {\n        if (A === void 0) return new Promise((n, r)=>{\n            this.close((s, i)=>s ? r(s) : n(i));\n        });\n        if (typeof A != \"function\") throw new InvalidArgumentError$h(\"invalid callback\");\n        if (this[kDestroyed]) {\n            queueMicrotask(()=>A(new ClientDestroyedError$1, null));\n            return;\n        }\n        if (this[kClosed]) {\n            this[kOnClosed] ? this[kOnClosed].push(A) : queueMicrotask(()=>A(null, null));\n            return;\n        }\n        this[kClosed] = !0, this[kOnClosed].push(A);\n        const t = o(()=>{\n            const n = this[kOnClosed];\n            this[kOnClosed] = null;\n            for(let r = 0; r < n.length; r++)n[r](null, null);\n        }, \"onClosed\");\n        this[kClose$6]().then(()=>this.destroy()).then(()=>{\n            queueMicrotask(t);\n        });\n    }\n    destroy(A, t) {\n        if (typeof A == \"function\" && (t = A, A = null), t === void 0) return new Promise((r, s)=>{\n            this.destroy(A, (i, E)=>i ? s(i) : r(E));\n        });\n        if (typeof t != \"function\") throw new InvalidArgumentError$h(\"invalid callback\");\n        if (this[kDestroyed]) {\n            this[kOnDestroyed] ? this[kOnDestroyed].push(t) : queueMicrotask(()=>t(null, null));\n            return;\n        }\n        A || (A = new ClientDestroyedError$1), this[kDestroyed] = !0, this[kOnDestroyed] = this[kOnDestroyed] || [], this[kOnDestroyed].push(t);\n        const n = o(()=>{\n            const r = this[kOnDestroyed];\n            this[kOnDestroyed] = null;\n            for(let s = 0; s < r.length; s++)r[s](null, null);\n        }, \"onDestroyed\");\n        this[kDestroy$4](A).then(()=>{\n            queueMicrotask(n);\n        });\n    }\n    [kInterceptedDispatch](A, t) {\n        if (!this[kInterceptors$4] || this[kInterceptors$4].length === 0) return this[kInterceptedDispatch] = this[kDispatch$3], this[kDispatch$3](A, t);\n        let n = this[kDispatch$3].bind(this);\n        for(let r = this[kInterceptors$4].length - 1; r >= 0; r--)n = this[kInterceptors$4][r](n);\n        return this[kInterceptedDispatch] = n, n(A, t);\n    }\n    dispatch(A, t) {\n        if (!t || typeof t != \"object\") throw new InvalidArgumentError$h(\"handler must be an object\");\n        try {\n            if (!A || typeof A != \"object\") throw new InvalidArgumentError$h(\"opts must be an object.\");\n            if (this[kDestroyed] || this[kOnDestroyed]) throw new ClientDestroyedError$1;\n            if (this[kClosed]) throw new ClientClosedError;\n            return this[kInterceptedDispatch](A, t);\n        } catch (n) {\n            if (typeof t.onError != \"function\") throw new InvalidArgumentError$h(\"invalid onError method\");\n            return t.onError(n), !1;\n        }\n    }\n}, o(Fe, \"DispatcherBase\"), Fe);\nvar dispatcherBase = DispatcherBase$4;\nconst net$1 = require$$4__default, assert$b = require$$0__default, util$k = util$m, { InvalidArgumentError: InvalidArgumentError$g, ConnectTimeoutError } = errors$1;\nlet tls, SessionCache;\n_commonjsHelpers.commonjsGlobal.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG) ? SessionCache = (pe = class {\n    constructor(A){\n        this._maxCachedSessions = A, this._sessionCache = new Map, this._sessionRegistry = new _commonjsHelpers.commonjsGlobal.FinalizationRegistry((t)=>{\n            if (this._sessionCache.size < this._maxCachedSessions) return;\n            const n = this._sessionCache.get(t);\n            n !== void 0 && n.deref() === void 0 && this._sessionCache.delete(t);\n        });\n    }\n    get(A) {\n        const t = this._sessionCache.get(A);\n        return t ? t.deref() : null;\n    }\n    set(A, t) {\n        this._maxCachedSessions !== 0 && (this._sessionCache.set(A, new WeakRef(t)), this._sessionRegistry.register(t, A));\n    }\n}, o(pe, \"WeakSessionCache\"), pe) : SessionCache = (Se = class {\n    constructor(A){\n        this._maxCachedSessions = A, this._sessionCache = new Map;\n    }\n    get(A) {\n        return this._sessionCache.get(A);\n    }\n    set(A, t) {\n        if (this._maxCachedSessions !== 0) {\n            if (this._sessionCache.size >= this._maxCachedSessions) {\n                const { value: n } = this._sessionCache.keys().next();\n                this._sessionCache.delete(n);\n            }\n            this._sessionCache.set(A, t);\n        }\n    }\n}, o(Se, \"SimpleSessionCache\"), Se);\nfunction buildConnector$3({ allowH2: e, maxCachedSessions: A, socketPath: t, timeout: n, ...r }) {\n    if (A != null && (!Number.isInteger(A) || A < 0)) throw new InvalidArgumentError$g(\"maxCachedSessions must be a positive integer or zero\");\n    const s = {\n        path: t,\n        ...r\n    }, i = new SessionCache(A ?? 100);\n    return n = n ?? 1e4, e = e ?? !1, o(function({ hostname: Q, host: C, protocol: I, port: a, servername: f, localAddress: h, httpSocket: L }, c) {\n        let l;\n        if (I === \"https:\") {\n            tls || (tls = require$$4__default$1), f = f || s.servername || util$k.getServerName(C) || null;\n            const k = f || Q, w = i.get(k) || null;\n            assert$b(k), l = tls.connect({\n                highWaterMark: 16384,\n                ...s,\n                servername: f,\n                session: w,\n                localAddress: h,\n                ALPNProtocols: e ? [\n                    \"http/1.1\",\n                    \"h2\"\n                ] : [\n                    \"http/1.1\"\n                ],\n                socket: L,\n                port: a || 443,\n                host: Q\n            }), l.on(\"session\", function(U) {\n                i.set(k, U);\n            });\n        } else assert$b(!L, \"httpSocket can only be sent on TLS update\"), l = net$1.connect({\n            highWaterMark: 64 * 1024,\n            ...s,\n            localAddress: h,\n            port: a || 80,\n            host: Q\n        });\n        if (s.keepAlive == null || s.keepAlive) {\n            const k = s.keepAliveInitialDelay === void 0 ? 6e4 : s.keepAliveInitialDelay;\n            l.setKeepAlive(!0, k);\n        }\n        const S = setupTimeout(()=>onConnectTimeout(l), n);\n        return l.setNoDelay(!0).once(I === \"https:\" ? \"secureConnect\" : \"connect\", function() {\n            if (S(), c) {\n                const k = c;\n                c = null, k(null, this);\n            }\n        }).on(\"error\", function(k) {\n            if (S(), c) {\n                const w = c;\n                c = null, w(k);\n            }\n        }), l;\n    }, \"connect\");\n}\no(buildConnector$3, \"buildConnector$3\");\nfunction setupTimeout(e, A) {\n    if (!A) return ()=>{};\n    let t = null, n = null;\n    const r = setTimeout(()=>{\n        t = setImmediate(()=>{\n            process.platform === \"win32\" ? n = setImmediate(()=>e()) : e();\n        });\n    }, A);\n    return ()=>{\n        clearTimeout(r), clearImmediate(t), clearImmediate(n);\n    };\n}\no(setupTimeout, \"setupTimeout\");\nfunction onConnectTimeout(e) {\n    let A = \"Connect Timeout Error\";\n    Array.isArray(e.autoSelectFamilyAttemptedAddresses) && (A += ` (attempted addresses: ${e.autoSelectFamilyAttemptedAddresses.join(\", \")})`), util$k.destroy(e, new ConnectTimeoutError(A));\n}\no(onConnectTimeout, \"onConnectTimeout\");\nvar connect$2 = buildConnector$3;\nlet fastNow = Date.now(), fastNowTimeout;\nconst fastTimers = [];\nfunction onTimeout() {\n    fastNow = Date.now();\n    let e = fastTimers.length, A = 0;\n    for(; A < e;){\n        const t = fastTimers[A];\n        t.state === 0 ? t.state = fastNow + t.delay : t.state > 0 && fastNow >= t.state && (t.state = -1, t.callback(t.opaque)), t.state === -1 ? (t.state = -2, A !== e - 1 ? fastTimers[A] = fastTimers.pop() : fastTimers.pop(), e -= 1) : A += 1;\n    }\n    fastTimers.length > 0 && refreshTimeout();\n}\no(onTimeout, \"onTimeout\");\nfunction refreshTimeout() {\n    fastNowTimeout?.refresh ? fastNowTimeout.refresh() : (clearTimeout(fastNowTimeout), fastNowTimeout = setTimeout(onTimeout, 1e3), fastNowTimeout.unref && fastNowTimeout.unref());\n}\no(refreshTimeout, \"refreshTimeout\");\nconst nt = class nt {\n    constructor(A, t, n){\n        this.callback = A, this.delay = t, this.opaque = n, this.state = -2, this.refresh();\n    }\n    refresh() {\n        this.state === -2 && (fastTimers.push(this), (!fastNowTimeout || fastTimers.length === 1) && refreshTimeout()), this.state = 0;\n    }\n    clear() {\n        this.state = -1;\n    }\n};\no(nt, \"Timeout\");\nlet Timeout = nt;\nvar timers$1 = {\n    setTimeout (e, A, t) {\n        return A < 1e3 ? setTimeout(e, A, t) : new Timeout(e, A, t);\n    },\n    clearTimeout (e) {\n        e instanceof Timeout ? e.clear() : clearTimeout(e);\n    }\n}, constants$4 = {}, utils = {};\nObject.defineProperty(utils, \"__esModule\", {\n    value: !0\n}), utils.enumToMap = void 0;\nfunction enumToMap(e) {\n    const A = {};\n    return Object.keys(e).forEach((t)=>{\n        const n = e[t];\n        typeof n == \"number\" && (A[t] = n);\n    }), A;\n}\no(enumToMap, \"enumToMap\"), utils.enumToMap = enumToMap, function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.SPECIAL_HEADERS = e.HEADER_STATE = e.MINOR = e.MAJOR = e.CONNECTION_TOKEN_CHARS = e.HEADER_CHARS = e.TOKEN = e.STRICT_TOKEN = e.HEX = e.URL_CHAR = e.STRICT_URL_CHAR = e.USERINFO_CHARS = e.MARK = e.ALPHANUM = e.NUM = e.HEX_MAP = e.NUM_MAP = e.ALPHA = e.FINISH = e.H_METHOD_MAP = e.METHOD_MAP = e.METHODS_RTSP = e.METHODS_ICE = e.METHODS_HTTP = e.METHODS = e.LENIENT_FLAGS = e.FLAGS = e.TYPE = e.ERROR = void 0;\n    const A = utils;\n    (function(r) {\n        r[r.OK = 0] = \"OK\", r[r.INTERNAL = 1] = \"INTERNAL\", r[r.STRICT = 2] = \"STRICT\", r[r.LF_EXPECTED = 3] = \"LF_EXPECTED\", r[r.UNEXPECTED_CONTENT_LENGTH = 4] = \"UNEXPECTED_CONTENT_LENGTH\", r[r.CLOSED_CONNECTION = 5] = \"CLOSED_CONNECTION\", r[r.INVALID_METHOD = 6] = \"INVALID_METHOD\", r[r.INVALID_URL = 7] = \"INVALID_URL\", r[r.INVALID_CONSTANT = 8] = \"INVALID_CONSTANT\", r[r.INVALID_VERSION = 9] = \"INVALID_VERSION\", r[r.INVALID_HEADER_TOKEN = 10] = \"INVALID_HEADER_TOKEN\", r[r.INVALID_CONTENT_LENGTH = 11] = \"INVALID_CONTENT_LENGTH\", r[r.INVALID_CHUNK_SIZE = 12] = \"INVALID_CHUNK_SIZE\", r[r.INVALID_STATUS = 13] = \"INVALID_STATUS\", r[r.INVALID_EOF_STATE = 14] = \"INVALID_EOF_STATE\", r[r.INVALID_TRANSFER_ENCODING = 15] = \"INVALID_TRANSFER_ENCODING\", r[r.CB_MESSAGE_BEGIN = 16] = \"CB_MESSAGE_BEGIN\", r[r.CB_HEADERS_COMPLETE = 17] = \"CB_HEADERS_COMPLETE\", r[r.CB_MESSAGE_COMPLETE = 18] = \"CB_MESSAGE_COMPLETE\", r[r.CB_CHUNK_HEADER = 19] = \"CB_CHUNK_HEADER\", r[r.CB_CHUNK_COMPLETE = 20] = \"CB_CHUNK_COMPLETE\", r[r.PAUSED = 21] = \"PAUSED\", r[r.PAUSED_UPGRADE = 22] = \"PAUSED_UPGRADE\", r[r.PAUSED_H2_UPGRADE = 23] = \"PAUSED_H2_UPGRADE\", r[r.USER = 24] = \"USER\";\n    })(e.ERROR || (e.ERROR = {})), function(r) {\n        r[r.BOTH = 0] = \"BOTH\", r[r.REQUEST = 1] = \"REQUEST\", r[r.RESPONSE = 2] = \"RESPONSE\";\n    }(e.TYPE || (e.TYPE = {})), function(r) {\n        r[r.CONNECTION_KEEP_ALIVE = 1] = \"CONNECTION_KEEP_ALIVE\", r[r.CONNECTION_CLOSE = 2] = \"CONNECTION_CLOSE\", r[r.CONNECTION_UPGRADE = 4] = \"CONNECTION_UPGRADE\", r[r.CHUNKED = 8] = \"CHUNKED\", r[r.UPGRADE = 16] = \"UPGRADE\", r[r.CONTENT_LENGTH = 32] = \"CONTENT_LENGTH\", r[r.SKIPBODY = 64] = \"SKIPBODY\", r[r.TRAILING = 128] = \"TRAILING\", r[r.TRANSFER_ENCODING = 512] = \"TRANSFER_ENCODING\";\n    }(e.FLAGS || (e.FLAGS = {})), function(r) {\n        r[r.HEADERS = 1] = \"HEADERS\", r[r.CHUNKED_LENGTH = 2] = \"CHUNKED_LENGTH\", r[r.KEEP_ALIVE = 4] = \"KEEP_ALIVE\";\n    }(e.LENIENT_FLAGS || (e.LENIENT_FLAGS = {}));\n    var t;\n    (function(r) {\n        r[r.DELETE = 0] = \"DELETE\", r[r.GET = 1] = \"GET\", r[r.HEAD = 2] = \"HEAD\", r[r.POST = 3] = \"POST\", r[r.PUT = 4] = \"PUT\", r[r.CONNECT = 5] = \"CONNECT\", r[r.OPTIONS = 6] = \"OPTIONS\", r[r.TRACE = 7] = \"TRACE\", r[r.COPY = 8] = \"COPY\", r[r.LOCK = 9] = \"LOCK\", r[r.MKCOL = 10] = \"MKCOL\", r[r.MOVE = 11] = \"MOVE\", r[r.PROPFIND = 12] = \"PROPFIND\", r[r.PROPPATCH = 13] = \"PROPPATCH\", r[r.SEARCH = 14] = \"SEARCH\", r[r.UNLOCK = 15] = \"UNLOCK\", r[r.BIND = 16] = \"BIND\", r[r.REBIND = 17] = \"REBIND\", r[r.UNBIND = 18] = \"UNBIND\", r[r.ACL = 19] = \"ACL\", r[r.REPORT = 20] = \"REPORT\", r[r.MKACTIVITY = 21] = \"MKACTIVITY\", r[r.CHECKOUT = 22] = \"CHECKOUT\", r[r.MERGE = 23] = \"MERGE\", r[r[\"M-SEARCH\"] = 24] = \"M-SEARCH\", r[r.NOTIFY = 25] = \"NOTIFY\", r[r.SUBSCRIBE = 26] = \"SUBSCRIBE\", r[r.UNSUBSCRIBE = 27] = \"UNSUBSCRIBE\", r[r.PATCH = 28] = \"PATCH\", r[r.PURGE = 29] = \"PURGE\", r[r.MKCALENDAR = 30] = \"MKCALENDAR\", r[r.LINK = 31] = \"LINK\", r[r.UNLINK = 32] = \"UNLINK\", r[r.SOURCE = 33] = \"SOURCE\", r[r.PRI = 34] = \"PRI\", r[r.DESCRIBE = 35] = \"DESCRIBE\", r[r.ANNOUNCE = 36] = \"ANNOUNCE\", r[r.SETUP = 37] = \"SETUP\", r[r.PLAY = 38] = \"PLAY\", r[r.PAUSE = 39] = \"PAUSE\", r[r.TEARDOWN = 40] = \"TEARDOWN\", r[r.GET_PARAMETER = 41] = \"GET_PARAMETER\", r[r.SET_PARAMETER = 42] = \"SET_PARAMETER\", r[r.REDIRECT = 43] = \"REDIRECT\", r[r.RECORD = 44] = \"RECORD\", r[r.FLUSH = 45] = \"FLUSH\";\n    })(t = e.METHODS || (e.METHODS = {})), e.METHODS_HTTP = [\n        t.DELETE,\n        t.GET,\n        t.HEAD,\n        t.POST,\n        t.PUT,\n        t.CONNECT,\n        t.OPTIONS,\n        t.TRACE,\n        t.COPY,\n        t.LOCK,\n        t.MKCOL,\n        t.MOVE,\n        t.PROPFIND,\n        t.PROPPATCH,\n        t.SEARCH,\n        t.UNLOCK,\n        t.BIND,\n        t.REBIND,\n        t.UNBIND,\n        t.ACL,\n        t.REPORT,\n        t.MKACTIVITY,\n        t.CHECKOUT,\n        t.MERGE,\n        t[\"M-SEARCH\"],\n        t.NOTIFY,\n        t.SUBSCRIBE,\n        t.UNSUBSCRIBE,\n        t.PATCH,\n        t.PURGE,\n        t.MKCALENDAR,\n        t.LINK,\n        t.UNLINK,\n        t.PRI,\n        t.SOURCE\n    ], e.METHODS_ICE = [\n        t.SOURCE\n    ], e.METHODS_RTSP = [\n        t.OPTIONS,\n        t.DESCRIBE,\n        t.ANNOUNCE,\n        t.SETUP,\n        t.PLAY,\n        t.PAUSE,\n        t.TEARDOWN,\n        t.GET_PARAMETER,\n        t.SET_PARAMETER,\n        t.REDIRECT,\n        t.RECORD,\n        t.FLUSH,\n        t.GET,\n        t.POST\n    ], e.METHOD_MAP = A.enumToMap(t), e.H_METHOD_MAP = {}, Object.keys(e.METHOD_MAP).forEach((r)=>{\n        /^H/.test(r) && (e.H_METHOD_MAP[r] = e.METHOD_MAP[r]);\n    }), function(r) {\n        r[r.SAFE = 0] = \"SAFE\", r[r.SAFE_WITH_CB = 1] = \"SAFE_WITH_CB\", r[r.UNSAFE = 2] = \"UNSAFE\";\n    }(e.FINISH || (e.FINISH = {})), e.ALPHA = [];\n    for(let r = 65; r <= 90; r++)e.ALPHA.push(String.fromCharCode(r)), e.ALPHA.push(String.fromCharCode(r + 32));\n    e.NUM_MAP = {\n        0: 0,\n        1: 1,\n        2: 2,\n        3: 3,\n        4: 4,\n        5: 5,\n        6: 6,\n        7: 7,\n        8: 8,\n        9: 9\n    }, e.HEX_MAP = {\n        0: 0,\n        1: 1,\n        2: 2,\n        3: 3,\n        4: 4,\n        5: 5,\n        6: 6,\n        7: 7,\n        8: 8,\n        9: 9,\n        A: 10,\n        B: 11,\n        C: 12,\n        D: 13,\n        E: 14,\n        F: 15,\n        a: 10,\n        b: 11,\n        c: 12,\n        d: 13,\n        e: 14,\n        f: 15\n    }, e.NUM = [\n        \"0\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",\n        \"9\"\n    ], e.ALPHANUM = e.ALPHA.concat(e.NUM), e.MARK = [\n        \"-\",\n        \"_\",\n        \".\",\n        \"!\",\n        \"~\",\n        \"*\",\n        \"'\",\n        \"(\",\n        \")\"\n    ], e.USERINFO_CHARS = e.ALPHANUM.concat(e.MARK).concat([\n        \"%\",\n        \";\",\n        \":\",\n        \"&\",\n        \"=\",\n        \"+\",\n        \"$\",\n        \",\"\n    ]), e.STRICT_URL_CHAR = [\n        \"!\",\n        '\"',\n        \"$\",\n        \"%\",\n        \"&\",\n        \"'\",\n        \"(\",\n        \")\",\n        \"*\",\n        \"+\",\n        \",\",\n        \"-\",\n        \".\",\n        \"/\",\n        \":\",\n        \";\",\n        \"<\",\n        \"=\",\n        \">\",\n        \"@\",\n        \"[\",\n        \"\\\\\",\n        \"]\",\n        \"^\",\n        \"_\",\n        \"`\",\n        \"{\",\n        \"|\",\n        \"}\",\n        \"~\"\n    ].concat(e.ALPHANUM), e.URL_CHAR = e.STRICT_URL_CHAR.concat([\n        \"\t\",\n        \"\\f\"\n    ]);\n    for(let r = 128; r <= 255; r++)e.URL_CHAR.push(r);\n    e.HEX = e.NUM.concat([\n        \"a\",\n        \"b\",\n        \"c\",\n        \"d\",\n        \"e\",\n        \"f\",\n        \"A\",\n        \"B\",\n        \"C\",\n        \"D\",\n        \"E\",\n        \"F\"\n    ]), e.STRICT_TOKEN = [\n        \"!\",\n        \"#\",\n        \"$\",\n        \"%\",\n        \"&\",\n        \"'\",\n        \"*\",\n        \"+\",\n        \"-\",\n        \".\",\n        \"^\",\n        \"_\",\n        \"`\",\n        \"|\",\n        \"~\"\n    ].concat(e.ALPHANUM), e.TOKEN = e.STRICT_TOKEN.concat([\n        \" \"\n    ]), e.HEADER_CHARS = [\n        \"\t\"\n    ];\n    for(let r = 32; r <= 255; r++)r !== 127 && e.HEADER_CHARS.push(r);\n    e.CONNECTION_TOKEN_CHARS = e.HEADER_CHARS.filter((r)=>r !== 44), e.MAJOR = e.NUM_MAP, e.MINOR = e.MAJOR;\n    var n;\n    (function(r) {\n        r[r.GENERAL = 0] = \"GENERAL\", r[r.CONNECTION = 1] = \"CONNECTION\", r[r.CONTENT_LENGTH = 2] = \"CONTENT_LENGTH\", r[r.TRANSFER_ENCODING = 3] = \"TRANSFER_ENCODING\", r[r.UPGRADE = 4] = \"UPGRADE\", r[r.CONNECTION_KEEP_ALIVE = 5] = \"CONNECTION_KEEP_ALIVE\", r[r.CONNECTION_CLOSE = 6] = \"CONNECTION_CLOSE\", r[r.CONNECTION_UPGRADE = 7] = \"CONNECTION_UPGRADE\", r[r.TRANSFER_ENCODING_CHUNKED = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n    })(n = e.HEADER_STATE || (e.HEADER_STATE = {})), e.SPECIAL_HEADERS = {\n        connection: n.CONNECTION,\n        \"content-length\": n.CONTENT_LENGTH,\n        \"proxy-connection\": n.CONNECTION,\n        \"transfer-encoding\": n.TRANSFER_ENCODING,\n        upgrade: n.UPGRADE\n    };\n}(constants$4);\nvar llhttpWasm, hasRequiredLlhttpWasm;\nfunction requireLlhttpWasm() {\n    if (hasRequiredLlhttpWasm) return llhttpWasm;\n    hasRequiredLlhttpWasm = 1;\n    const { Buffer: e } = require$$6__default;\n    return llhttpWasm = e.from(\"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCsLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC1kAIABBGGpCADcDACAAQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=\", \"base64\"), llhttpWasm;\n}\no(requireLlhttpWasm, \"requireLlhttpWasm\");\nvar llhttp_simdWasm, hasRequiredLlhttp_simdWasm;\nfunction requireLlhttp_simdWasm() {\n    if (hasRequiredLlhttp_simdWasm) return llhttp_simdWasm;\n    hasRequiredLlhttp_simdWasm = 1;\n    const { Buffer: e } = require$$6__default;\n    return llhttp_simdWasm = e.from(\"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==\", \"base64\"), llhttp_simdWasm;\n}\no(requireLlhttp_simdWasm, \"requireLlhttp_simdWasm\");\nvar constants$3, hasRequiredConstants$2;\nfunction requireConstants$2() {\n    if (hasRequiredConstants$2) return constants$3;\n    hasRequiredConstants$2 = 1;\n    const e = [\n        \"GET\",\n        \"HEAD\",\n        \"POST\"\n    ], A = new Set(e), t = [\n        101,\n        204,\n        205,\n        304\n    ], n = [\n        301,\n        302,\n        303,\n        307,\n        308\n    ], r = new Set(n), s = [\n        \"1\",\n        \"7\",\n        \"9\",\n        \"11\",\n        \"13\",\n        \"15\",\n        \"17\",\n        \"19\",\n        \"20\",\n        \"21\",\n        \"22\",\n        \"23\",\n        \"25\",\n        \"37\",\n        \"42\",\n        \"43\",\n        \"53\",\n        \"69\",\n        \"77\",\n        \"79\",\n        \"87\",\n        \"95\",\n        \"101\",\n        \"102\",\n        \"103\",\n        \"104\",\n        \"109\",\n        \"110\",\n        \"111\",\n        \"113\",\n        \"115\",\n        \"117\",\n        \"119\",\n        \"123\",\n        \"135\",\n        \"137\",\n        \"139\",\n        \"143\",\n        \"161\",\n        \"179\",\n        \"389\",\n        \"427\",\n        \"465\",\n        \"512\",\n        \"513\",\n        \"514\",\n        \"515\",\n        \"526\",\n        \"530\",\n        \"531\",\n        \"532\",\n        \"540\",\n        \"548\",\n        \"554\",\n        \"556\",\n        \"563\",\n        \"587\",\n        \"601\",\n        \"636\",\n        \"989\",\n        \"990\",\n        \"993\",\n        \"995\",\n        \"1719\",\n        \"1720\",\n        \"1723\",\n        \"2049\",\n        \"3659\",\n        \"4045\",\n        \"4190\",\n        \"5060\",\n        \"5061\",\n        \"6000\",\n        \"6566\",\n        \"6665\",\n        \"6666\",\n        \"6667\",\n        \"6668\",\n        \"6669\",\n        \"6679\",\n        \"6697\",\n        \"10080\"\n    ], i = new Set(s), E = [\n        \"\",\n        \"no-referrer\",\n        \"no-referrer-when-downgrade\",\n        \"same-origin\",\n        \"origin\",\n        \"strict-origin\",\n        \"origin-when-cross-origin\",\n        \"strict-origin-when-cross-origin\",\n        \"unsafe-url\"\n    ], Q = new Set(E), C = [\n        \"follow\",\n        \"manual\",\n        \"error\"\n    ], I = [\n        \"GET\",\n        \"HEAD\",\n        \"OPTIONS\",\n        \"TRACE\"\n    ], a = new Set(I), f = [\n        \"navigate\",\n        \"same-origin\",\n        \"no-cors\",\n        \"cors\"\n    ], h = [\n        \"omit\",\n        \"same-origin\",\n        \"include\"\n    ], L = [\n        \"default\",\n        \"no-store\",\n        \"reload\",\n        \"no-cache\",\n        \"force-cache\",\n        \"only-if-cached\"\n    ], c = [\n        \"content-encoding\",\n        \"content-language\",\n        \"content-location\",\n        \"content-type\",\n        \"content-length\"\n    ], l = [\n        \"half\"\n    ], S = [\n        \"CONNECT\",\n        \"TRACE\",\n        \"TRACK\"\n    ], k = new Set(S), w = [\n        \"audio\",\n        \"audioworklet\",\n        \"font\",\n        \"image\",\n        \"manifest\",\n        \"paintworklet\",\n        \"script\",\n        \"style\",\n        \"track\",\n        \"video\",\n        \"xslt\",\n        \"\"\n    ], U = new Set(w);\n    return constants$3 = {\n        subresource: w,\n        forbiddenMethods: S,\n        requestBodyHeader: c,\n        referrerPolicy: E,\n        requestRedirect: C,\n        requestMode: f,\n        requestCredentials: h,\n        requestCache: L,\n        redirectStatus: n,\n        corsSafeListedMethods: e,\n        nullBodyStatus: t,\n        safeMethods: I,\n        badPorts: s,\n        requestDuplex: l,\n        subresourceSet: U,\n        badPortsSet: i,\n        redirectStatusSet: r,\n        corsSafeListedMethodsSet: A,\n        safeMethodsSet: a,\n        forbiddenMethodsSet: k,\n        referrerPolicySet: Q\n    }, constants$3;\n}\no(requireConstants$2, \"requireConstants$2\");\nvar global$1, hasRequiredGlobal;\nfunction requireGlobal() {\n    if (hasRequiredGlobal) return global$1;\n    hasRequiredGlobal = 1;\n    const e = Symbol.for(\"undici.globalOrigin.1\");\n    function A() {\n        return globalThis[e];\n    }\n    o(A, \"getGlobalOrigin\");\n    function t(n) {\n        if (n === void 0) {\n            Object.defineProperty(globalThis, e, {\n                value: void 0,\n                writable: !0,\n                enumerable: !1,\n                configurable: !1\n            });\n            return;\n        }\n        const r = new URL(n);\n        if (r.protocol !== \"http:\" && r.protocol !== \"https:\") throw new TypeError(`Only http & https urls are allowed, received ${r.protocol}`);\n        Object.defineProperty(globalThis, e, {\n            value: r,\n            writable: !0,\n            enumerable: !1,\n            configurable: !1\n        });\n    }\n    return o(t, \"setGlobalOrigin\"), global$1 = {\n        getGlobalOrigin: A,\n        setGlobalOrigin: t\n    }, global$1;\n}\no(requireGlobal, \"requireGlobal\");\nvar dataUrl, hasRequiredDataUrl;\nfunction requireDataUrl() {\n    if (hasRequiredDataUrl) return dataUrl;\n    hasRequiredDataUrl = 1;\n    const e = require$$0__default, A = new TextEncoder, t = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/, n = /[\\u000A\\u000D\\u0009\\u0020]/, r = /[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, s = /[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]/;\n    function i(g) {\n        e(g.protocol === \"data:\");\n        let d = E(g, !0);\n        d = d.slice(5);\n        const F = {\n            position: 0\n        };\n        let N = C(\",\", d, F);\n        const u = N.length;\n        if (N = M(N, !0, !0), F.position >= d.length) return \"failure\";\n        F.position++;\n        const b = d.slice(u + 1);\n        let m = I(b);\n        if (/;(\\u0020){0,}base64$/i.test(N)) {\n            const v = D(m);\n            if (m = c(v), m === \"failure\") return \"failure\";\n            N = N.slice(0, -6), N = N.replace(/(\\u0020)+$/, \"\"), N = N.slice(0, -1);\n        }\n        N.startsWith(\";\") && (N = \"text/plain\" + N);\n        let T = L(N);\n        return T === \"failure\" && (T = L(\"text/plain;charset=US-ASCII\")), {\n            mimeType: T,\n            body: m\n        };\n    }\n    o(i, \"dataURLProcessor\");\n    function E(g, d = !1) {\n        if (!d) return g.href;\n        const F = g.href, N = g.hash.length, u = N === 0 ? F : F.substring(0, F.length - N);\n        return !N && F.endsWith(\"#\") ? u.slice(0, -1) : u;\n    }\n    o(E, \"URLSerializer\");\n    function Q(g, d, F) {\n        let N = \"\";\n        for(; F.position < d.length && g(d[F.position]);)N += d[F.position], F.position++;\n        return N;\n    }\n    o(Q, \"collectASequenceOfCodePoints\");\n    function C(g, d, F) {\n        const N = d.indexOf(g, F.position), u = F.position;\n        return N === -1 ? (F.position = d.length, d.slice(u)) : (F.position = N, d.slice(u, F.position));\n    }\n    o(C, \"collectASequenceOfCodePointsFast\");\n    function I(g) {\n        const d = A.encode(g);\n        return h(d);\n    }\n    o(I, \"stringPercentDecode\");\n    function a(g) {\n        return g >= 48 && g <= 57 || g >= 65 && g <= 70 || g >= 97 && g <= 102;\n    }\n    o(a, \"isHexCharByte\");\n    function f(g) {\n        return g >= 48 && g <= 57 ? g - 48 : (g & 223) - 55;\n    }\n    o(f, \"hexByteToNumber\");\n    function h(g) {\n        const d = g.length, F = new Uint8Array(d);\n        let N = 0;\n        for(let u = 0; u < d; ++u){\n            const b = g[u];\n            b !== 37 ? F[N++] = b : b === 37 && !(a(g[u + 1]) && a(g[u + 2])) ? F[N++] = 37 : (F[N++] = f(g[u + 1]) << 4 | f(g[u + 2]), u += 2);\n        }\n        return d === N ? F : F.subarray(0, N);\n    }\n    o(h, \"percentDecode\");\n    function L(g) {\n        g = w(g, !0, !0);\n        const d = {\n            position: 0\n        }, F = C(\"/\", g, d);\n        if (F.length === 0 || !t.test(F) || d.position > g.length) return \"failure\";\n        d.position++;\n        let N = C(\";\", g, d);\n        if (N = w(N, !1, !0), N.length === 0 || !t.test(N)) return \"failure\";\n        const u = F.toLowerCase(), b = N.toLowerCase(), m = {\n            type: u,\n            subtype: b,\n            parameters: new Map,\n            essence: `${u}/${b}`\n        };\n        for(; d.position < g.length;){\n            d.position++, Q((Z)=>n.test(Z), g, d);\n            let T = Q((Z)=>Z !== \";\" && Z !== \"=\", g, d);\n            if (T = T.toLowerCase(), d.position < g.length) {\n                if (g[d.position] === \";\") continue;\n                d.position++;\n            }\n            if (d.position > g.length) break;\n            let v = null;\n            if (g[d.position] === '\"') v = l(g, d, !0), C(\";\", g, d);\n            else if (v = C(\";\", g, d), v = w(v, !1, !0), v.length === 0) continue;\n            T.length !== 0 && t.test(T) && (v.length === 0 || s.test(v)) && !m.parameters.has(T) && m.parameters.set(T, v);\n        }\n        return m;\n    }\n    o(L, \"parseMIMEType\");\n    function c(g) {\n        g = g.replace(r, \"\");\n        let d = g.length;\n        if (d % 4 === 0 && g.charCodeAt(d - 1) === 61 && (--d, g.charCodeAt(d - 1) === 61 && --d), d % 4 === 1 || /[^+/0-9A-Za-z]/.test(g.length === d ? g : g.substring(0, d))) return \"failure\";\n        const F = Buffer.from(g, \"base64\");\n        return new Uint8Array(F.buffer, F.byteOffset, F.byteLength);\n    }\n    o(c, \"forgivingBase64\");\n    function l(g, d, F) {\n        const N = d.position;\n        let u = \"\";\n        for(e(g[d.position] === '\"'), d.position++; u += Q((m)=>m !== '\"' && m !== \"\\\\\", g, d), !(d.position >= g.length);){\n            const b = g[d.position];\n            if (d.position++, b === \"\\\\\") {\n                if (d.position >= g.length) {\n                    u += \"\\\\\";\n                    break;\n                }\n                u += g[d.position], d.position++;\n            } else {\n                e(b === '\"');\n                break;\n            }\n        }\n        return F ? u : g.slice(N, d.position);\n    }\n    o(l, \"collectAnHTTPQuotedString\");\n    function S(g) {\n        e(g !== \"failure\");\n        const { parameters: d, essence: F } = g;\n        let N = F;\n        for (let [u, b] of d.entries())N += \";\", N += u, N += \"=\", t.test(b) || (b = b.replace(/(\\\\|\")/g, \"\\\\$1\"), b = '\"' + b, b += '\"'), N += b;\n        return N;\n    }\n    o(S, \"serializeAMimeType\");\n    function k(g) {\n        return g === 13 || g === 10 || g === 9 || g === 32;\n    }\n    o(k, \"isHTTPWhiteSpace\");\n    function w(g, d = !0, F = !0) {\n        return B(g, d, F, k);\n    }\n    o(w, \"removeHTTPWhitespace\");\n    function U(g) {\n        return g === 13 || g === 10 || g === 9 || g === 12 || g === 32;\n    }\n    o(U, \"isASCIIWhitespace\");\n    function M(g, d = !0, F = !0) {\n        return B(g, d, F, U);\n    }\n    o(M, \"removeASCIIWhitespace\");\n    function B(g, d, F, N) {\n        let u = 0, b = g.length - 1;\n        if (d) for(; u < g.length && N(g.charCodeAt(u));)u++;\n        if (F) for(; b > 0 && N(g.charCodeAt(b));)b--;\n        return u === 0 && b === g.length - 1 ? g : g.slice(u, b + 1);\n    }\n    o(B, \"removeChars\");\n    function D(g) {\n        const d = g.length;\n        if (65535 > d) return String.fromCharCode.apply(null, g);\n        let F = \"\", N = 0, u = 65535;\n        for(; N < d;)N + u > d && (u = d - N), F += String.fromCharCode.apply(null, g.subarray(N, N += u));\n        return F;\n    }\n    o(D, \"isomorphicDecode\");\n    function G(g) {\n        switch(g.essence){\n            case \"application/ecmascript\":\n            case \"application/javascript\":\n            case \"application/x-ecmascript\":\n            case \"application/x-javascript\":\n            case \"text/ecmascript\":\n            case \"text/javascript\":\n            case \"text/javascript1.0\":\n            case \"text/javascript1.1\":\n            case \"text/javascript1.2\":\n            case \"text/javascript1.3\":\n            case \"text/javascript1.4\":\n            case \"text/javascript1.5\":\n            case \"text/jscript\":\n            case \"text/livescript\":\n            case \"text/x-ecmascript\":\n            case \"text/x-javascript\":\n                return \"text/javascript\";\n            case \"application/json\":\n            case \"text/json\":\n                return \"application/json\";\n            case \"image/svg+xml\":\n                return \"image/svg+xml\";\n            case \"text/xml\":\n            case \"application/xml\":\n                return \"application/xml\";\n        }\n        return g.subtype.endsWith(\"+json\") ? \"application/json\" : g.subtype.endsWith(\"+xml\") ? \"application/xml\" : \"\";\n    }\n    return o(G, \"minimizeSupportedMimeType\"), dataUrl = {\n        dataURLProcessor: i,\n        URLSerializer: E,\n        collectASequenceOfCodePoints: Q,\n        collectASequenceOfCodePointsFast: C,\n        stringPercentDecode: I,\n        parseMIMEType: L,\n        collectAnHTTPQuotedString: l,\n        serializeAMimeType: S,\n        removeChars: B,\n        minimizeSupportedMimeType: G,\n        HTTP_TOKEN_CODEPOINTS: t,\n        isomorphicDecode: D\n    }, dataUrl;\n}\no(requireDataUrl, \"requireDataUrl\");\nvar webidl_1, hasRequiredWebidl;\nfunction requireWebidl() {\n    if (hasRequiredWebidl) return webidl_1;\n    hasRequiredWebidl = 1;\n    const { types: e, inspect: A } = require$$0__default$1, { toUSVString: t } = util$m, n = {};\n    return n.converters = {}, n.util = {}, n.errors = {}, n.errors.exception = function(r) {\n        return new TypeError(`${r.header}: ${r.message}`);\n    }, n.errors.conversionFailed = function(r) {\n        const s = r.types.length === 1 ? \"\" : \" one of\", i = `${r.argument} could not be converted to${s}: ${r.types.join(\", \")}.`;\n        return n.errors.exception({\n            header: r.prefix,\n            message: i\n        });\n    }, n.errors.invalidArgument = function(r) {\n        return n.errors.exception({\n            header: r.prefix,\n            message: `\"${r.value}\" is an invalid ${r.type}.`\n        });\n    }, n.brandCheck = function(r, s, i = void 0) {\n        if (i?.strict !== !1) {\n            if (!(r instanceof s)) throw new TypeError(\"Illegal invocation\");\n        } else if (r?.[Symbol.toStringTag] !== s.prototype[Symbol.toStringTag]) throw new TypeError(\"Illegal invocation\");\n    }, n.argumentLengthCheck = function({ length: r }, s, i) {\n        if (r < s) throw n.errors.exception({\n            message: `${s} argument${s !== 1 ? \"s\" : \"\"} required, but${r ? \" only\" : \"\"} ${r} found.`,\n            ...i\n        });\n    }, n.illegalConstructor = function() {\n        throw n.errors.exception({\n            header: \"TypeError\",\n            message: \"Illegal constructor\"\n        });\n    }, n.util.Type = function(r) {\n        switch(typeof r){\n            case \"undefined\":\n                return \"Undefined\";\n            case \"boolean\":\n                return \"Boolean\";\n            case \"string\":\n                return \"String\";\n            case \"symbol\":\n                return \"Symbol\";\n            case \"number\":\n                return \"Number\";\n            case \"bigint\":\n                return \"BigInt\";\n            case \"function\":\n            case \"object\":\n                return r === null ? \"Null\" : \"Object\";\n        }\n    }, n.util.ConvertToInt = function(r, s, i, E = {}) {\n        let Q, C;\n        s === 64 ? (Q = Math.pow(2, 53) - 1, i === \"unsigned\" ? C = 0 : C = Math.pow(-2, 53) + 1) : i === \"unsigned\" ? (C = 0, Q = Math.pow(2, s) - 1) : (C = Math.pow(-2, s) - 1, Q = Math.pow(2, s - 1) - 1);\n        let I = Number(r);\n        if (I === 0 && (I = 0), E.enforceRange === !0) {\n            if (Number.isNaN(I) || I === Number.POSITIVE_INFINITY || I === Number.NEGATIVE_INFINITY) throw n.errors.exception({\n                header: \"Integer conversion\",\n                message: `Could not convert ${n.util.Stringify(r)} to an integer.`\n            });\n            if (I = n.util.IntegerPart(I), I < C || I > Q) throw n.errors.exception({\n                header: \"Integer conversion\",\n                message: `Value must be between ${C}-${Q}, got ${I}.`\n            });\n            return I;\n        }\n        return !Number.isNaN(I) && E.clamp === !0 ? (I = Math.min(Math.max(I, C), Q), Math.floor(I) % 2 === 0 ? I = Math.floor(I) : I = Math.ceil(I), I) : Number.isNaN(I) || I === 0 && Object.is(0, I) || I === Number.POSITIVE_INFINITY || I === Number.NEGATIVE_INFINITY ? 0 : (I = n.util.IntegerPart(I), I = I % Math.pow(2, s), i === \"signed\" && I >= Math.pow(2, s) - 1 ? I - Math.pow(2, s) : I);\n    }, n.util.IntegerPart = function(r) {\n        const s = Math.floor(Math.abs(r));\n        return r < 0 ? -1 * s : s;\n    }, n.util.Stringify = function(r) {\n        switch(n.util.Type(r)){\n            case \"Symbol\":\n                return `Symbol(${r.description})`;\n            case \"Object\":\n                return A(r);\n            case \"String\":\n                return `\"${r}\"`;\n            default:\n                return `${r}`;\n        }\n    }, n.sequenceConverter = function(r) {\n        return (s, i)=>{\n            if (n.util.Type(s) !== \"Object\") throw n.errors.exception({\n                header: \"Sequence\",\n                message: `Value of type ${n.util.Type(s)} is not an Object.`\n            });\n            const E = typeof i == \"function\" ? i() : s?.[Symbol.iterator]?.(), Q = [];\n            if (E === void 0 || typeof E.next != \"function\") throw n.errors.exception({\n                header: \"Sequence\",\n                message: \"Object is not an iterator.\"\n            });\n            for(;;){\n                const { done: C, value: I } = E.next();\n                if (C) break;\n                Q.push(r(I));\n            }\n            return Q;\n        };\n    }, n.recordConverter = function(r, s) {\n        return (i)=>{\n            if (n.util.Type(i) !== \"Object\") throw n.errors.exception({\n                header: \"Record\",\n                message: `Value of type ${n.util.Type(i)} is not an Object.`\n            });\n            const E = {};\n            if (!e.isProxy(i)) {\n                const C = [\n                    ...Object.getOwnPropertyNames(i),\n                    ...Object.getOwnPropertySymbols(i)\n                ];\n                for (const I of C){\n                    const a = r(I), f = s(i[I]);\n                    E[a] = f;\n                }\n                return E;\n            }\n            const Q = Reflect.ownKeys(i);\n            for (const C of Q)if (Reflect.getOwnPropertyDescriptor(i, C)?.enumerable) {\n                const a = r(C), f = s(i[C]);\n                E[a] = f;\n            }\n            return E;\n        };\n    }, n.interfaceConverter = function(r) {\n        return (s, i = {})=>{\n            if (i.strict !== !1 && !(s instanceof r)) throw n.errors.exception({\n                header: r.name,\n                message: `Expected ${n.util.Stringify(s)} to be an instance of ${r.name}.`\n            });\n            return s;\n        };\n    }, n.dictionaryConverter = function(r) {\n        return (s)=>{\n            const i = n.util.Type(s), E = {};\n            if (i === \"Null\" || i === \"Undefined\") return E;\n            if (i !== \"Object\") throw n.errors.exception({\n                header: \"Dictionary\",\n                message: `Expected ${s} to be one of: Null, Undefined, Object.`\n            });\n            for (const Q of r){\n                const { key: C, defaultValue: I, required: a, converter: f } = Q;\n                if (a === !0 && !Object.hasOwn(s, C)) throw n.errors.exception({\n                    header: \"Dictionary\",\n                    message: `Missing required key \"${C}\".`\n                });\n                let h = s[C];\n                const L = Object.hasOwn(Q, \"defaultValue\");\n                if (L && h !== null && (h = h ?? I), a || L || h !== void 0) {\n                    if (h = f(h), Q.allowedValues && !Q.allowedValues.includes(h)) throw n.errors.exception({\n                        header: \"Dictionary\",\n                        message: `${h} is not an accepted type. Expected one of ${Q.allowedValues.join(\", \")}.`\n                    });\n                    E[C] = h;\n                }\n            }\n            return E;\n        };\n    }, n.nullableConverter = function(r) {\n        return (s)=>s === null ? s : r(s);\n    }, n.converters.DOMString = function(r, s = {}) {\n        if (r === null && s.legacyNullToEmptyString) return \"\";\n        if (typeof r == \"symbol\") throw new TypeError(\"Could not convert argument of type symbol to string.\");\n        return String(r);\n    }, n.converters.ByteString = function(r) {\n        const s = n.converters.DOMString(r);\n        for(let i = 0; i < s.length; i++)if (s.charCodeAt(i) > 255) throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${i} has a value of ${s.charCodeAt(i)} which is greater than 255.`);\n        return s;\n    }, n.converters.USVString = t, n.converters.boolean = function(r) {\n        return !!r;\n    }, n.converters.any = function(r) {\n        return r;\n    }, n.converters[\"long long\"] = function(r) {\n        return n.util.ConvertToInt(r, 64, \"signed\");\n    }, n.converters[\"unsigned long long\"] = function(r) {\n        return n.util.ConvertToInt(r, 64, \"unsigned\");\n    }, n.converters[\"unsigned long\"] = function(r) {\n        return n.util.ConvertToInt(r, 32, \"unsigned\");\n    }, n.converters[\"unsigned short\"] = function(r, s) {\n        return n.util.ConvertToInt(r, 16, \"unsigned\", s);\n    }, n.converters.ArrayBuffer = function(r, s = {}) {\n        if (n.util.Type(r) !== \"Object\" || !e.isAnyArrayBuffer(r)) throw n.errors.conversionFailed({\n            prefix: n.util.Stringify(r),\n            argument: n.util.Stringify(r),\n            types: [\n                \"ArrayBuffer\"\n            ]\n        });\n        if (s.allowShared === !1 && e.isSharedArrayBuffer(r)) throw n.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n        if (r.resizable || r.growable) throw n.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"Received a resizable ArrayBuffer.\"\n        });\n        return r;\n    }, n.converters.TypedArray = function(r, s, i = {}) {\n        if (n.util.Type(r) !== \"Object\" || !e.isTypedArray(r) || r.constructor.name !== s.name) throw n.errors.conversionFailed({\n            prefix: `${s.name}`,\n            argument: n.util.Stringify(r),\n            types: [\n                s.name\n            ]\n        });\n        if (i.allowShared === !1 && e.isSharedArrayBuffer(r.buffer)) throw n.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n        if (r.buffer.resizable || r.buffer.growable) throw n.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"Received a resizable ArrayBuffer.\"\n        });\n        return r;\n    }, n.converters.DataView = function(r, s = {}) {\n        if (n.util.Type(r) !== \"Object\" || !e.isDataView(r)) throw n.errors.exception({\n            header: \"DataView\",\n            message: \"Object is not a DataView.\"\n        });\n        if (s.allowShared === !1 && e.isSharedArrayBuffer(r.buffer)) throw n.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n        if (r.buffer.resizable || r.buffer.growable) throw n.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"Received a resizable ArrayBuffer.\"\n        });\n        return r;\n    }, n.converters.BufferSource = function(r, s = {}) {\n        if (e.isAnyArrayBuffer(r)) return n.converters.ArrayBuffer(r, {\n            ...s,\n            allowShared: !1\n        });\n        if (e.isTypedArray(r)) return n.converters.TypedArray(r, r.constructor, {\n            ...s,\n            allowShared: !1\n        });\n        if (e.isDataView(r)) return n.converters.DataView(r, s, {\n            ...s,\n            allowShared: !1\n        });\n        throw new TypeError(`Could not convert ${n.util.Stringify(r)} to a BufferSource.`);\n    }, n.converters[\"sequence<ByteString>\"] = n.sequenceConverter(n.converters.ByteString), n.converters[\"sequence<sequence<ByteString>>\"] = n.sequenceConverter(n.converters[\"sequence<ByteString>\"]), n.converters[\"record<ByteString, ByteString>\"] = n.recordConverter(n.converters.ByteString, n.converters.ByteString), webidl_1 = {\n        webidl: n\n    }, webidl_1;\n}\no(requireWebidl, \"requireWebidl\");\nvar util$j, hasRequiredUtil$5;\nfunction requireUtil$5() {\n    if (hasRequiredUtil$5) return util$j;\n    hasRequiredUtil$5 = 1;\n    const { Transform: e } = Stream__default, A = zlib__default, { redirectStatusSet: t, referrerPolicySet: n, badPortsSet: r } = requireConstants$2(), { getGlobalOrigin: s } = requireGlobal(), { collectASequenceOfCodePoints: i, collectAnHTTPQuotedString: E, removeChars: Q, parseMIMEType: C } = requireDataUrl(), { performance: I } = require$$5__default, { isBlobLike: a, ReadableStreamFrom: f, isValidHTTPToken: h } = util$m, L = require$$0__default, { isUint8Array: c } = require$$8__default$1, { webidl: l } = requireWebidl();\n    let S = [], k;\n    try {\n        k = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n        const y = [\n            \"sha256\",\n            \"sha384\",\n            \"sha512\"\n        ];\n        S = k.getHashes().filter((Y)=>y.includes(Y));\n    } catch  {}\n    function w(y) {\n        const Y = y.urlList, W = Y.length;\n        return W === 0 ? null : Y[W - 1].toString();\n    }\n    o(w, \"responseURL\");\n    function U(y, Y) {\n        if (!t.has(y.status)) return null;\n        let W = y.headersList.get(\"location\", !0);\n        return W !== null && N(W) && (M(W) || (W = B(W)), W = new URL(W, w(y))), W && !W.hash && (W.hash = Y), W;\n    }\n    o(U, \"responseLocationURL\");\n    function M(y) {\n        for (const Y of y){\n            const W = Y.charCodeAt(0);\n            if (W >= 128 || W >= 0 && W <= 31 || W === 127) return !1;\n        }\n        return !0;\n    }\n    o(M, \"isValidEncodedURL\");\n    function B(y) {\n        return Buffer.from(y, \"binary\").toString(\"utf8\");\n    }\n    o(B, \"normalizeBinaryStringToUtf8\");\n    function D(y) {\n        return y.urlList[y.urlList.length - 1];\n    }\n    o(D, \"requestCurrentURL\");\n    function G(y) {\n        const Y = D(y);\n        return ZA(Y) && r.has(Y.port) ? \"blocked\" : \"allowed\";\n    }\n    o(G, \"requestBadPort\");\n    function g(y) {\n        return y instanceof Error || y?.constructor?.name === \"Error\" || y?.constructor?.name === \"DOMException\";\n    }\n    o(g, \"isErrorLike\");\n    function d(y) {\n        for(let Y = 0; Y < y.length; ++Y){\n            const W = y.charCodeAt(Y);\n            if (!(W === 9 || W >= 32 && W <= 126 || W >= 128 && W <= 255)) return !1;\n        }\n        return !0;\n    }\n    o(d, \"isValidReasonPhrase\");\n    const F = h;\n    function N(y) {\n        return !(y.startsWith(\"\t\") || y.startsWith(\" \") || y.endsWith(\"\t\") || y.endsWith(\" \") || y.includes(\"\\x00\") || y.includes(\"\\r\") || y.includes(`\n`));\n    }\n    o(N, \"isValidHeaderValue\");\n    function u(y, Y) {\n        const { headersList: W } = Y, j = (W.get(\"referrer-policy\", !0) ?? \"\").split(\",\");\n        let nA = \"\";\n        if (j.length > 0) for(let R = j.length; R !== 0; R--){\n            const O = j[R - 1].trim();\n            if (n.has(O)) {\n                nA = O;\n                break;\n            }\n        }\n        nA !== \"\" && (y.referrerPolicy = nA);\n    }\n    o(u, \"setRequestReferrerPolicyOnRedirect\");\n    function b() {\n        return \"allowed\";\n    }\n    o(b, \"crossOriginResourcePolicyCheck\");\n    function m() {\n        return \"success\";\n    }\n    o(m, \"corsCheck\");\n    function T() {\n        return \"success\";\n    }\n    o(T, \"TAOCheck\");\n    function v(y) {\n        let Y = null;\n        Y = y.mode, y.headersList.set(\"sec-fetch-mode\", Y, !0);\n    }\n    o(v, \"appendFetchMetadata\");\n    function Z(y) {\n        let Y = y.origin;\n        if (y.responseTainting === \"cors\" || y.mode === \"websocket\") Y && y.headersList.append(\"origin\", Y, !0);\n        else if (y.method !== \"GET\" && y.method !== \"HEAD\") {\n            switch(y.referrerPolicy){\n                case \"no-referrer\":\n                    Y = null;\n                    break;\n                case \"no-referrer-when-downgrade\":\n                case \"strict-origin\":\n                case \"strict-origin-when-cross-origin\":\n                    y.origin && ee(y.origin) && !ee(D(y)) && (Y = null);\n                    break;\n                case \"same-origin\":\n                    yA(y, D(y)) || (Y = null);\n                    break;\n            }\n            Y && y.headersList.append(\"origin\", Y, !0);\n        }\n    }\n    o(Z, \"appendRequestOriginHeader\");\n    function P(y, Y) {\n        return y;\n    }\n    o(P, \"coarsenTime\");\n    function AA(y, Y, W) {\n        return !y?.startTime || y.startTime < Y ? {\n            domainLookupStartTime: Y,\n            domainLookupEndTime: Y,\n            connectionStartTime: Y,\n            connectionEndTime: Y,\n            secureConnectionStartTime: Y,\n            ALPNNegotiatedProtocol: y?.ALPNNegotiatedProtocol\n        } : {\n            domainLookupStartTime: P(y.domainLookupStartTime),\n            domainLookupEndTime: P(y.domainLookupEndTime),\n            connectionStartTime: P(y.connectionStartTime),\n            connectionEndTime: P(y.connectionEndTime),\n            secureConnectionStartTime: P(y.secureConnectionStartTime),\n            ALPNNegotiatedProtocol: y.ALPNNegotiatedProtocol\n        };\n    }\n    o(AA, \"clampAndCoarsenConnectionTimingInfo\");\n    function K(y) {\n        return P(I.now());\n    }\n    o(K, \"coarsenedSharedCurrentTime\");\n    function tA(y) {\n        return {\n            startTime: y.startTime ?? 0,\n            redirectStartTime: 0,\n            redirectEndTime: 0,\n            postRedirectStartTime: y.startTime ?? 0,\n            finalServiceWorkerStartTime: 0,\n            finalNetworkResponseStartTime: 0,\n            finalNetworkRequestStartTime: 0,\n            endTime: 0,\n            encodedBodySize: 0,\n            decodedBodySize: 0,\n            finalConnectionTimingInfo: null\n        };\n    }\n    o(tA, \"createOpaqueTimingInfo\");\n    function aA() {\n        return {\n            referrerPolicy: \"strict-origin-when-cross-origin\"\n        };\n    }\n    o(aA, \"makePolicyContainer\");\n    function X(y) {\n        return {\n            referrerPolicy: y.referrerPolicy\n        };\n    }\n    o(X, \"clonePolicyContainer\");\n    function $(y) {\n        const Y = y.referrerPolicy;\n        L(Y);\n        let W = null;\n        if (y.referrer === \"client\") {\n            const H = s();\n            if (!H || H.origin === \"null\") return \"no-referrer\";\n            W = new URL(H);\n        } else y.referrer instanceof URL && (W = y.referrer);\n        let j = V(W);\n        const nA = V(W, !0);\n        j.toString().length > 4096 && (j = nA);\n        const R = yA(y, j), O = q(j) && !q(y.url);\n        switch(Y){\n            case \"origin\":\n                return nA ?? V(W, !0);\n            case \"unsafe-url\":\n                return j;\n            case \"same-origin\":\n                return R ? nA : \"no-referrer\";\n            case \"origin-when-cross-origin\":\n                return R ? j : nA;\n            case \"strict-origin-when-cross-origin\":\n                {\n                    const H = D(y);\n                    return yA(j, H) ? j : q(j) && !q(H) ? \"no-referrer\" : nA;\n                }\n            case \"strict-origin\":\n            case \"no-referrer-when-downgrade\":\n            default:\n                return O ? \"no-referrer\" : nA;\n        }\n    }\n    o($, \"determineRequestsReferrer\");\n    function V(y, Y) {\n        return L(y instanceof URL), y = new URL(y), y.protocol === \"file:\" || y.protocol === \"about:\" || y.protocol === \"blank:\" ? \"no-referrer\" : (y.username = \"\", y.password = \"\", y.hash = \"\", Y && (y.pathname = \"\", y.search = \"\"), y);\n    }\n    o(V, \"stripURLForReferrer\");\n    function q(y) {\n        if (!(y instanceof URL)) return !1;\n        if (y.href === \"about:blank\" || y.href === \"about:srcdoc\" || y.protocol === \"data:\" || y.protocol === \"file:\") return !0;\n        return Y(y.origin);\n        function Y(W) {\n            if (W == null || W === \"null\") return !1;\n            const j = new URL(W);\n            return !!(j.protocol === \"https:\" || j.protocol === \"wss:\" || /^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(j.hostname) || j.hostname === \"localhost\" || j.hostname.includes(\"localhost.\") || j.hostname.endsWith(\".localhost\"));\n        }\n    }\n    o(q, \"isURLPotentiallyTrustworthy\");\n    function z(y, Y) {\n        if (k === void 0) return !0;\n        const W = iA(Y);\n        if (W === \"no metadata\" || W.length === 0) return !0;\n        const j = gA(W), nA = BA(W, j);\n        for (const R of nA){\n            const O = R.algo, H = R.hash;\n            let J = k.createHash(O).update(y).digest(\"base64\");\n            if (J[J.length - 1] === \"=\" && (J[J.length - 2] === \"=\" ? J = J.slice(0, -2) : J = J.slice(0, -1)), sA(J, H)) return !0;\n        }\n        return !1;\n    }\n    o(z, \"bytesMatch\");\n    const rA = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\\s|$)( +[!-~]*)?)?/i;\n    function iA(y) {\n        const Y = [];\n        let W = !0;\n        for (const j of y.split(\" \")){\n            W = !1;\n            const nA = rA.exec(j);\n            if (nA === null || nA.groups === void 0 || nA.groups.algo === void 0) continue;\n            const R = nA.groups.algo.toLowerCase();\n            S.includes(R) && Y.push(nA.groups);\n        }\n        return W === !0 ? \"no metadata\" : Y;\n    }\n    o(iA, \"parseMetadata\");\n    function gA(y) {\n        let Y = y[0].algo;\n        if (Y[3] === \"5\") return Y;\n        for(let W = 1; W < y.length; ++W){\n            const j = y[W];\n            if (j.algo[3] === \"5\") {\n                Y = \"sha512\";\n                break;\n            } else {\n                if (Y[3] === \"3\") continue;\n                j.algo[3] === \"3\" && (Y = \"sha384\");\n            }\n        }\n        return Y;\n    }\n    o(gA, \"getStrongestMetadata\");\n    function BA(y, Y) {\n        if (y.length === 1) return y;\n        let W = 0;\n        for(let j = 0; j < y.length; ++j)y[j].algo === Y && (y[W++] = y[j]);\n        return y.length = W, y;\n    }\n    o(BA, \"filterMetadataListByAlgorithm\");\n    function sA(y, Y) {\n        if (y.length !== Y.length) return !1;\n        for(let W = 0; W < y.length; ++W)if (y[W] !== Y[W]) {\n            if (y[W] === \"+\" && Y[W] === \"-\" || y[W] === \"/\" && Y[W] === \"_\") continue;\n            return !1;\n        }\n        return !0;\n    }\n    o(sA, \"compareBase64Mixed\");\n    function eA(y) {}\n    o(eA, \"tryUpgradeRequestToAPotentiallyTrustworthyURL\");\n    function yA(y, Y) {\n        return y.origin === Y.origin && y.origin === \"null\" || y.protocol === Y.protocol && y.hostname === Y.hostname && y.port === Y.port;\n    }\n    o(yA, \"sameOrigin\");\n    function WA() {\n        let y, Y;\n        return {\n            promise: new Promise((j, nA)=>{\n                y = j, Y = nA;\n            }),\n            resolve: y,\n            reject: Y\n        };\n    }\n    o(WA, \"createDeferredPromise\");\n    function wA(y) {\n        return y.controller.state === \"aborted\";\n    }\n    o(wA, \"isAborted\");\n    function qA(y) {\n        return y.controller.state === \"aborted\" || y.controller.state === \"terminated\";\n    }\n    o(qA, \"isCancelled\");\n    const MA = {\n        delete: \"DELETE\",\n        DELETE: \"DELETE\",\n        get: \"GET\",\n        GET: \"GET\",\n        head: \"HEAD\",\n        HEAD: \"HEAD\",\n        options: \"OPTIONS\",\n        OPTIONS: \"OPTIONS\",\n        post: \"POST\",\n        POST: \"POST\",\n        put: \"PUT\",\n        PUT: \"PUT\"\n    }, HA = {\n        ...MA,\n        patch: \"patch\",\n        PATCH: \"PATCH\"\n    };\n    Object.setPrototypeOf(MA, null), Object.setPrototypeOf(HA, null);\n    function pA(y) {\n        return MA[y.toLowerCase()] ?? y;\n    }\n    o(pA, \"normalizeMethod\");\n    function YA(y) {\n        const Y = JSON.stringify(y);\n        if (Y === void 0) throw new TypeError(\"Value is not JSON serializable\");\n        return L(typeof Y == \"string\"), Y;\n    }\n    o(YA, \"serializeJavascriptValueToJSONString\");\n    const UA = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n    function JA(y, Y, W = 0, j = 1) {\n        var R, O, H;\n        const J = class J {\n            constructor(x, QA){\n                CA(this, R, void 0);\n                CA(this, O, void 0);\n                CA(this, H, void 0);\n                EA(this, R, x), EA(this, O, QA), EA(this, H, 0);\n            }\n            next() {\n                if (typeof this != \"object\" || this === null || !yt(R, this)) throw new TypeError(`'next' called on an object that does not implement interface ${y} Iterator.`);\n                const x = p(this, H), QA = p(this, R)[Y], lA = QA.length;\n                if (x >= lA) return {\n                    value: void 0,\n                    done: !0\n                };\n                const { [W]: uA, [j]: cA } = QA[x];\n                EA(this, H, x + 1);\n                let fA;\n                switch(p(this, O)){\n                    case \"key\":\n                        fA = uA;\n                        break;\n                    case \"value\":\n                        fA = cA;\n                        break;\n                    case \"key+value\":\n                        fA = [\n                            uA,\n                            cA\n                        ];\n                        break;\n                }\n                return {\n                    value: fA,\n                    done: !1\n                };\n            }\n        };\n        R = new WeakMap, O = new WeakMap, H = new WeakMap, o(J, \"FastIterableIterator\");\n        let nA = J;\n        return delete nA.prototype.constructor, Object.setPrototypeOf(nA.prototype, UA), Object.defineProperties(nA.prototype, {\n            [Symbol.toStringTag]: {\n                writable: !1,\n                enumerable: !1,\n                configurable: !0,\n                value: `${y} Iterator`\n            },\n            next: {\n                writable: !0,\n                enumerable: !0,\n                configurable: !0\n            }\n        }), function(_, x) {\n            return new nA(_, x);\n        };\n    }\n    o(JA, \"createIterator\");\n    function VA(y, Y, W, j = 0, nA = 1) {\n        const R = JA(y, W, j, nA), O = {\n            keys: {\n                writable: !0,\n                enumerable: !0,\n                configurable: !0,\n                value: o(function() {\n                    return l.brandCheck(this, Y), R(this, \"key\");\n                }, \"keys\")\n            },\n            values: {\n                writable: !0,\n                enumerable: !0,\n                configurable: !0,\n                value: o(function() {\n                    return l.brandCheck(this, Y), R(this, \"value\");\n                }, \"values\")\n            },\n            entries: {\n                writable: !0,\n                enumerable: !0,\n                configurable: !0,\n                value: o(function() {\n                    return l.brandCheck(this, Y), R(this, \"key+value\");\n                }, \"entries\")\n            },\n            forEach: {\n                writable: !0,\n                enumerable: !0,\n                configurable: !0,\n                value: o(function(J, _ = globalThis) {\n                    if (l.brandCheck(this, Y), l.argumentLengthCheck(arguments, 1, {\n                        header: `${y}.forEach`\n                    }), typeof J != \"function\") throw new TypeError(`Failed to execute 'forEach' on '${y}': parameter 1 is not of type 'Function'.`);\n                    for (const { 0: x, 1: QA } of R(this, \"key+value\"))J.call(_, QA, x, this);\n                }, \"forEach\")\n            }\n        };\n        return Object.defineProperties(Y.prototype, {\n            ...O,\n            [Symbol.iterator]: {\n                writable: !0,\n                enumerable: !1,\n                configurable: !0,\n                value: O.entries.value\n            }\n        });\n    }\n    o(VA, \"iteratorMixin\");\n    async function OA(y, Y, W) {\n        const j = Y, nA = W;\n        let R;\n        try {\n            R = y.stream.getReader();\n        } catch (O) {\n            nA(O);\n            return;\n        }\n        try {\n            const O = await PA(R);\n            j(O);\n        } catch (O) {\n            nA(O);\n        }\n    }\n    o(OA, \"fullyReadBody\");\n    function IA(y) {\n        return y instanceof ReadableStream || y[Symbol.toStringTag] === \"ReadableStream\" && typeof y.tee == \"function\";\n    }\n    o(IA, \"isReadableStreamLike\");\n    function hA(y) {\n        try {\n            y.close(), y.byobRequest?.respond(0);\n        } catch (Y) {\n            if (!Y.message.includes(\"Controller is already closed\") && !Y.message.includes(\"ReadableStream is already closed\")) throw Y;\n        }\n    }\n    o(hA, \"readableStreamClose\");\n    function SA(y) {\n        for(let Y = 0; Y < y.length; Y++)L(y.charCodeAt(Y) <= 255);\n        return y;\n    }\n    o(SA, \"isomorphicEncode\");\n    async function PA(y) {\n        const Y = [];\n        let W = 0;\n        for(;;){\n            const { done: j, value: nA } = await y.read();\n            if (j) return Buffer.concat(Y, W);\n            if (!c(nA)) throw new TypeError(\"Received non-Uint8Array chunk\");\n            Y.push(nA), W += nA.length;\n        }\n    }\n    o(PA, \"readAllBytes\");\n    function Pe(y) {\n        L(\"protocol\" in y);\n        const Y = y.protocol;\n        return Y === \"about:\" || Y === \"blob:\" || Y === \"data:\";\n    }\n    o(Pe, \"urlIsLocal\");\n    function ee(y) {\n        return typeof y == \"string\" ? y.startsWith(\"https:\") : y.protocol === \"https:\";\n    }\n    o(ee, \"urlHasHttpsScheme\");\n    function ZA(y) {\n        L(\"protocol\" in y);\n        const Y = y.protocol;\n        return Y === \"http:\" || Y === \"https:\";\n    }\n    o(ZA, \"urlIsHttpHttpsScheme\");\n    function XA(y, Y) {\n        const W = y;\n        if (!W.startsWith(\"bytes\")) return \"failure\";\n        const j = {\n            position: 5\n        };\n        if (Y && i((J)=>J === \"\t\" || J === \" \", W, j), W.charCodeAt(j.position) !== 61) return \"failure\";\n        j.position++, Y && i((J)=>J === \"\t\" || J === \" \", W, j);\n        const nA = i((J)=>{\n            const _ = J.charCodeAt(0);\n            return _ >= 48 && _ <= 57;\n        }, W, j), R = nA.length ? Number(nA) : null;\n        if (Y && i((J)=>J === \"\t\" || J === \" \", W, j), W.charCodeAt(j.position) !== 45) return \"failure\";\n        j.position++, Y && i((J)=>J === \"\t\" || J === \" \", W, j);\n        const O = i((J)=>{\n            const _ = J.charCodeAt(0);\n            return _ >= 48 && _ <= 57;\n        }, W, j), H = O.length ? Number(O) : null;\n        return j.position < W.length || H === null && R === null || R > H ? \"failure\" : {\n            rangeStartValue: R,\n            rangeEndValue: H\n        };\n    }\n    o(XA, \"simpleRangeHeaderValue\");\n    function Ze(y, Y, W) {\n        let j = \"bytes \";\n        return j += SA(`${y}`), j += \"-\", j += SA(`${Y}`), j += \"/\", j += SA(`${W}`), j;\n    }\n    o(Ze, \"buildContentRange\");\n    const vA = class vA extends e {\n        _transform(Y, W, j) {\n            if (!this._inflateStream) {\n                if (Y.length === 0) {\n                    j();\n                    return;\n                }\n                this._inflateStream = (Y[0] & 15) === 8 ? A.createInflate() : A.createInflateRaw(), this._inflateStream.on(\"data\", this.push.bind(this)), this._inflateStream.on(\"end\", ()=>this.push(null)), this._inflateStream.on(\"error\", (nA)=>this.destroy(nA));\n            }\n            this._inflateStream.write(Y, W, j);\n        }\n        _final(Y) {\n            this._inflateStream && (this._inflateStream.end(), this._inflateStream = null), Y();\n        }\n    };\n    o(vA, \"InflateStream\");\n    let KA = vA;\n    function He() {\n        return new KA;\n    }\n    o(He, \"createInflate\");\n    function te(y) {\n        let Y = null, W = null, j = null;\n        const nA = re(\"content-type\", y);\n        if (nA === null) return \"failure\";\n        for (const R of nA){\n            const O = C(R);\n            O === \"failure\" || O.essence === \"*/*\" || (j = O, j.essence !== W ? (Y = null, j.parameters.has(\"charset\") && (Y = j.parameters.get(\"charset\")), W = j.essence) : !j.parameters.has(\"charset\") && Y !== null && j.parameters.set(\"charset\", Y));\n        }\n        return j ?? \"failure\";\n    }\n    o(te, \"extractMimeType\");\n    function Ve(y) {\n        const Y = y, W = {\n            position: 0\n        }, j = [];\n        let nA = \"\";\n        for(; W.position < Y.length;){\n            if (nA += i((R)=>R !== '\"' && R !== \",\", Y, W), W.position < Y.length) if (Y.charCodeAt(W.position) === 34) {\n                if (nA += E(Y, W), W.position < Y.length) continue;\n            } else L(Y.charCodeAt(W.position) === 44), W.position++;\n            nA = Q(nA, !0, !0, (R)=>R === 9 || R === 32), j.push(nA), nA = \"\";\n        }\n        return j;\n    }\n    o(Ve, \"gettingDecodingSplitting\");\n    function re(y, Y) {\n        const W = Y.get(y, !0);\n        return W === null ? null : Ve(W);\n    }\n    o(re, \"getDecodeSplit\");\n    const ve = new TextDecoder;\n    function Xe(y) {\n        return y.length === 0 ? \"\" : (y[0] === 239 && y[1] === 187 && y[2] === 191 && (y = y.subarray(3)), ve.decode(y));\n    }\n    return o(Xe, \"utf8DecodeBytes\"), util$j = {\n        isAborted: wA,\n        isCancelled: qA,\n        createDeferredPromise: WA,\n        ReadableStreamFrom: f,\n        tryUpgradeRequestToAPotentiallyTrustworthyURL: eA,\n        clampAndCoarsenConnectionTimingInfo: AA,\n        coarsenedSharedCurrentTime: K,\n        determineRequestsReferrer: $,\n        makePolicyContainer: aA,\n        clonePolicyContainer: X,\n        appendFetchMetadata: v,\n        appendRequestOriginHeader: Z,\n        TAOCheck: T,\n        corsCheck: m,\n        crossOriginResourcePolicyCheck: b,\n        createOpaqueTimingInfo: tA,\n        setRequestReferrerPolicyOnRedirect: u,\n        isValidHTTPToken: h,\n        requestBadPort: G,\n        requestCurrentURL: D,\n        responseURL: w,\n        responseLocationURL: U,\n        isBlobLike: a,\n        isURLPotentiallyTrustworthy: q,\n        isValidReasonPhrase: d,\n        sameOrigin: yA,\n        normalizeMethod: pA,\n        serializeJavascriptValueToJSONString: YA,\n        iteratorMixin: VA,\n        createIterator: JA,\n        isValidHeaderName: F,\n        isValidHeaderValue: N,\n        isErrorLike: g,\n        fullyReadBody: OA,\n        bytesMatch: z,\n        isReadableStreamLike: IA,\n        readableStreamClose: hA,\n        isomorphicEncode: SA,\n        urlIsLocal: Pe,\n        urlHasHttpsScheme: ee,\n        urlIsHttpHttpsScheme: ZA,\n        readAllBytes: PA,\n        normalizeMethodRecord: HA,\n        simpleRangeHeaderValue: XA,\n        buildContentRange: Ze,\n        parseMetadata: iA,\n        createInflate: He,\n        extractMimeType: te,\n        getDecodeSplit: re,\n        utf8DecodeBytes: Xe\n    }, util$j;\n}\no(requireUtil$5, \"requireUtil$5\");\nvar symbols$3, hasRequiredSymbols$3;\nfunction requireSymbols$3() {\n    return hasRequiredSymbols$3 || (hasRequiredSymbols$3 = 1, symbols$3 = {\n        kUrl: Symbol(\"url\"),\n        kHeaders: Symbol(\"headers\"),\n        kSignal: Symbol(\"signal\"),\n        kState: Symbol(\"state\"),\n        kGuard: Symbol(\"guard\"),\n        kRealm: Symbol(\"realm\"),\n        kDispatcher: Symbol(\"dispatcher\")\n    }), symbols$3;\n}\no(requireSymbols$3, \"requireSymbols$3\");\nvar file, hasRequiredFile;\nfunction requireFile() {\n    if (hasRequiredFile) return file;\n    hasRequiredFile = 1;\n    const { EOL: e } = require$$0__default$4, { Blob: A, File: t } = require$$6__default, { types: n } = require$$0__default$1, { kState: r } = requireSymbols$3(), { isBlobLike: s } = requireUtil$5(), { webidl: i } = requireWebidl(), { parseMIMEType: E, serializeAMimeType: Q } = requireDataUrl(), { kEnumerableProperty: C } = util$m, I = new TextEncoder, l = class l extends A {\n        constructor(w, U, M = {}){\n            i.argumentLengthCheck(arguments, 2, {\n                header: \"File constructor\"\n            }), w = i.converters[\"sequence<BlobPart>\"](w), U = i.converters.USVString(U), M = i.converters.FilePropertyBag(M);\n            const B = U;\n            let D = M.type, G;\n            A: {\n                if (D) {\n                    if (D = E(D), D === \"failure\") {\n                        D = \"\";\n                        break A;\n                    }\n                    D = Q(D).toLowerCase();\n                }\n                G = M.lastModified;\n            }\n            super(h(w, M), {\n                type: D\n            }), this[r] = {\n                name: B,\n                lastModified: G,\n                type: D\n            };\n        }\n        get name() {\n            return i.brandCheck(this, l), this[r].name;\n        }\n        get lastModified() {\n            return i.brandCheck(this, l), this[r].lastModified;\n        }\n        get type() {\n            return i.brandCheck(this, l), this[r].type;\n        }\n    };\n    o(l, \"File\");\n    let a = l;\n    const S = class S {\n        constructor(w, U, M = {}){\n            const B = U, D = M.type, G = M.lastModified ?? Date.now();\n            this[r] = {\n                blobLike: w,\n                name: B,\n                type: D,\n                lastModified: G\n            };\n        }\n        stream(...w) {\n            return i.brandCheck(this, S), this[r].blobLike.stream(...w);\n        }\n        arrayBuffer(...w) {\n            return i.brandCheck(this, S), this[r].blobLike.arrayBuffer(...w);\n        }\n        slice(...w) {\n            return i.brandCheck(this, S), this[r].blobLike.slice(...w);\n        }\n        text(...w) {\n            return i.brandCheck(this, S), this[r].blobLike.text(...w);\n        }\n        get size() {\n            return i.brandCheck(this, S), this[r].blobLike.size;\n        }\n        get type() {\n            return i.brandCheck(this, S), this[r].blobLike.type;\n        }\n        get name() {\n            return i.brandCheck(this, S), this[r].name;\n        }\n        get lastModified() {\n            return i.brandCheck(this, S), this[r].lastModified;\n        }\n        get [Symbol.toStringTag]() {\n            return \"File\";\n        }\n    };\n    o(S, \"FileLike\");\n    let f = S;\n    Object.defineProperties(a.prototype, {\n        [Symbol.toStringTag]: {\n            value: \"File\",\n            configurable: !0\n        },\n        name: C,\n        lastModified: C\n    }), i.converters.Blob = i.interfaceConverter(A), i.converters.BlobPart = function(k, w) {\n        if (i.util.Type(k) === \"Object\") {\n            if (s(k)) return i.converters.Blob(k, {\n                strict: !1\n            });\n            if (ArrayBuffer.isView(k) || n.isAnyArrayBuffer(k)) return i.converters.BufferSource(k, w);\n        }\n        return i.converters.USVString(k, w);\n    }, i.converters[\"sequence<BlobPart>\"] = i.sequenceConverter(i.converters.BlobPart), i.converters.FilePropertyBag = i.dictionaryConverter([\n        {\n            key: \"lastModified\",\n            converter: i.converters[\"long long\"],\n            get defaultValue () {\n                return Date.now();\n            }\n        },\n        {\n            key: \"type\",\n            converter: i.converters.DOMString,\n            defaultValue: \"\"\n        },\n        {\n            key: \"endings\",\n            converter: (k)=>(k = i.converters.DOMString(k), k = k.toLowerCase(), k !== \"native\" && (k = \"transparent\"), k),\n            defaultValue: \"transparent\"\n        }\n    ]);\n    function h(k, w) {\n        const U = [];\n        for (const M of k)if (typeof M == \"string\") {\n            let B = M;\n            w.endings === \"native\" && (B = L(B)), U.push(I.encode(B));\n        } else ArrayBuffer.isView(M) || n.isArrayBuffer(M) ? M.buffer ? U.push(new Uint8Array(M.buffer, M.byteOffset, M.byteLength)) : U.push(new Uint8Array(M)) : s(M) && U.push(M);\n        return U;\n    }\n    o(h, \"processBlobParts\");\n    function L(k) {\n        return k.replace(/\\r?\\n/g, e);\n    }\n    o(L, \"convertLineEndingsNative\");\n    function c(k) {\n        return t && k instanceof t || k instanceof a || k && (typeof k.stream == \"function\" || typeof k.arrayBuffer == \"function\") && k[Symbol.toStringTag] === \"File\";\n    }\n    return o(c, \"isFileLike\"), file = {\n        File: a,\n        FileLike: f,\n        isFileLike: c\n    }, file;\n}\no(requireFile, \"requireFile\");\nvar formdata, hasRequiredFormdata;\nfunction requireFormdata() {\n    if (hasRequiredFormdata) return formdata;\n    hasRequiredFormdata = 1;\n    const { isBlobLike: e, iteratorMixin: A } = requireUtil$5(), { kState: t } = requireSymbols$3(), { kEnumerableProperty: n } = util$m, { File: r, FileLike: s, isFileLike: i } = requireFile(), { webidl: E } = requireWebidl(), { File: Q } = require$$6__default, C = require$$0__default$1, I = Q ?? r, h = class h {\n        constructor(c){\n            if (c !== void 0) throw E.errors.conversionFailed({\n                prefix: \"FormData constructor\",\n                argument: \"Argument 1\",\n                types: [\n                    \"undefined\"\n                ]\n            });\n            this[t] = [];\n        }\n        append(c, l, S = void 0) {\n            if (E.brandCheck(this, h), E.argumentLengthCheck(arguments, 2, {\n                header: \"FormData.append\"\n            }), arguments.length === 3 && !e(l)) throw new TypeError(\"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\");\n            c = E.converters.USVString(c), l = e(l) ? E.converters.Blob(l, {\n                strict: !1\n            }) : E.converters.USVString(l), S = arguments.length === 3 ? E.converters.USVString(S) : void 0;\n            const k = f(c, l, S);\n            this[t].push(k);\n        }\n        delete(c) {\n            E.brandCheck(this, h), E.argumentLengthCheck(arguments, 1, {\n                header: \"FormData.delete\"\n            }), c = E.converters.USVString(c), this[t] = this[t].filter((l)=>l.name !== c);\n        }\n        get(c) {\n            E.brandCheck(this, h), E.argumentLengthCheck(arguments, 1, {\n                header: \"FormData.get\"\n            }), c = E.converters.USVString(c);\n            const l = this[t].findIndex((S)=>S.name === c);\n            return l === -1 ? null : this[t][l].value;\n        }\n        getAll(c) {\n            return E.brandCheck(this, h), E.argumentLengthCheck(arguments, 1, {\n                header: \"FormData.getAll\"\n            }), c = E.converters.USVString(c), this[t].filter((l)=>l.name === c).map((l)=>l.value);\n        }\n        has(c) {\n            return E.brandCheck(this, h), E.argumentLengthCheck(arguments, 1, {\n                header: \"FormData.has\"\n            }), c = E.converters.USVString(c), this[t].findIndex((l)=>l.name === c) !== -1;\n        }\n        set(c, l, S = void 0) {\n            if (E.brandCheck(this, h), E.argumentLengthCheck(arguments, 2, {\n                header: \"FormData.set\"\n            }), arguments.length === 3 && !e(l)) throw new TypeError(\"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\");\n            c = E.converters.USVString(c), l = e(l) ? E.converters.Blob(l, {\n                strict: !1\n            }) : E.converters.USVString(l), S = arguments.length === 3 ? E.converters.USVString(S) : void 0;\n            const k = f(c, l, S), w = this[t].findIndex((U)=>U.name === c);\n            w !== -1 ? this[t] = [\n                ...this[t].slice(0, w),\n                k,\n                ...this[t].slice(w + 1).filter((U)=>U.name !== c)\n            ] : this[t].push(k);\n        }\n        [C.inspect.custom](c, l) {\n            const S = this[t].reduce((w, U)=>(w[U.name] ? Array.isArray(w[U.name]) ? w[U.name].push(U.value) : w[U.name] = [\n                    w[U.name],\n                    U.value\n                ] : w[U.name] = U.value, w), {\n                __proto__: null\n            });\n            l.depth ?? (l.depth = c), l.colors ?? (l.colors = !0);\n            const k = C.formatWithOptions(l, S);\n            return `FormData ${k.slice(k.indexOf(\"]\") + 2)}`;\n        }\n    };\n    o(h, \"FormData\");\n    let a = h;\n    A(\"FormData\", a, t, \"name\", \"value\"), Object.defineProperties(a.prototype, {\n        append: n,\n        delete: n,\n        get: n,\n        getAll: n,\n        has: n,\n        set: n,\n        [Symbol.toStringTag]: {\n            value: \"FormData\",\n            configurable: !0\n        }\n    });\n    function f(L, c, l) {\n        if (typeof c != \"string\") {\n            if (i(c) || (c = c instanceof Blob ? new I([\n                c\n            ], \"blob\", {\n                type: c.type\n            }) : new s(c, \"blob\", {\n                type: c.type\n            })), l !== void 0) {\n                const S = {\n                    type: c.type,\n                    lastModified: c.lastModified\n                };\n                c = Q && c instanceof Q || c instanceof r ? new I([\n                    c\n                ], l, S) : new s(c, l, S);\n            }\n        }\n        return {\n            name: L,\n            value: c\n        };\n    }\n    return o(f, \"makeEntry\"), formdata = {\n        FormData: a,\n        makeEntry: f\n    }, formdata;\n}\no(requireFormdata, \"requireFormdata\");\nvar formdataParser, hasRequiredFormdataParser;\nfunction requireFormdataParser() {\n    if (hasRequiredFormdataParser) return formdataParser;\n    hasRequiredFormdataParser = 1;\n    const { toUSVString: e, isUSVString: A, bufferToLowerCasedHeaderName: t } = util$m, { utf8DecodeBytes: n } = requireUtil$5(), { HTTP_TOKEN_CODEPOINTS: r, isomorphicDecode: s } = requireDataUrl(), { isFileLike: i, File: E } = requireFile(), { makeEntry: Q } = requireFormdata(), C = require$$0__default, { File: I } = require$$6__default, a = globalThis.File ?? I ?? E, f = Buffer.from('form-data; name=\"'), h = Buffer.from(\"; filename\"), L = Buffer.from(\"--\"), c = Buffer.from(`--\\r\n`);\n    function l(g) {\n        for(let d = 0; d < g.length; ++d)if (g.charCodeAt(d) & -128) return !1;\n        return !0;\n    }\n    o(l, \"isAsciiString\");\n    function S(g) {\n        const d = g.length;\n        if (d < 27 || d > 70) return !1;\n        for(let F = 0; F < d; ++F){\n            const N = g.charCodeAt(F);\n            if (!(N >= 48 && N <= 57 || N >= 65 && N <= 90 || N >= 97 && N <= 122 || N === 39 || N === 45 || N === 95)) return !1;\n        }\n        return !0;\n    }\n    o(S, \"validateBoundary\");\n    function k(g, d = \"utf-8\", F = !1) {\n        return F ? g = e(g) : (C(A(g)), g = g.replace(/\\r\\n?|\\r?\\n/g, `\\r\n`)), C(Buffer.isEncoding(d)), g = g.replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\"), Buffer.from(g, d);\n    }\n    o(k, \"escapeFormDataName\");\n    function w(g, d) {\n        C(d !== \"failure\" && d.essence === \"multipart/form-data\");\n        const F = d.parameters.get(\"boundary\");\n        if (F === void 0) return \"failure\";\n        const N = Buffer.from(`--${F}`, \"utf8\"), u = [], b = {\n            position: 0\n        };\n        for(g[0] === 13 && g[1] === 10 && (b.position += 2);;){\n            if (g.subarray(b.position, b.position + N.length).equals(N)) b.position += N.length;\n            else return \"failure\";\n            if (b.position === g.length - 2 && G(g, L, b) || b.position === g.length - 4 && G(g, c, b)) return u;\n            if (g[b.position] !== 13 || g[b.position + 1] !== 10) return \"failure\";\n            b.position += 2;\n            const m = U(g, b);\n            if (m === \"failure\") return \"failure\";\n            let { name: T, filename: v, contentType: Z, encoding: P } = m;\n            b.position += 2;\n            let AA;\n            {\n                const tA = g.indexOf(N.subarray(2), b.position);\n                if (tA === -1) return \"failure\";\n                AA = g.subarray(b.position, tA - 4), b.position += AA.length, P === \"base64\" && (AA = Buffer.from(AA.toString(), \"base64\"));\n            }\n            if (g[b.position] !== 13 || g[b.position + 1] !== 10) return \"failure\";\n            b.position += 2;\n            let K;\n            v !== null ? (Z ?? (Z = \"text/plain\"), l(Z) || (Z = \"\"), K = new a([\n                AA\n            ], v, {\n                type: Z\n            })) : K = n(Buffer.from(AA)), C(A(T)), C(typeof K == \"string\" && A(K) || i(K)), u.push(Q(T, K, v));\n        }\n    }\n    o(w, \"multipartFormDataParser\");\n    function U(g, d) {\n        let F = null, N = null, u = null, b = null;\n        for(;;){\n            if (g[d.position] === 13 && g[d.position + 1] === 10) return F === null ? \"failure\" : {\n                name: F,\n                filename: N,\n                contentType: u,\n                encoding: b\n            };\n            let m = B((T)=>T !== 10 && T !== 13 && T !== 58, g, d);\n            if (m = D(m, !0, !0, (T)=>T === 9 || T === 32), !r.test(m.toString()) || g[d.position] !== 58) return \"failure\";\n            switch(d.position++, B((T)=>T === 32 || T === 9, g, d), t(m)){\n                case \"content-disposition\":\n                    {\n                        if (F = N = null, !G(g, f, d) || (d.position += 17, F = M(g, d), F === null)) return \"failure\";\n                        if (G(g, h, d)) {\n                            let T = d.position + h.length;\n                            if (g[T] === 42 && (d.position += 1, T += 1), g[T] !== 61 || g[T + 1] !== 34 || (d.position += 12, N = M(g, d), N === null)) return \"failure\";\n                        }\n                        break;\n                    }\n                case \"content-type\":\n                    {\n                        let T = B((v)=>v !== 10 && v !== 13, g, d);\n                        T = D(T, !1, !0, (v)=>v === 9 || v === 32), u = s(T);\n                        break;\n                    }\n                case \"content-transfer-encoding\":\n                    {\n                        let T = B((v)=>v !== 10 && v !== 13, g, d);\n                        T = D(T, !1, !0, (v)=>v === 9 || v === 32), b = s(T);\n                        break;\n                    }\n                default:\n                    B((T)=>T !== 10 && T !== 13, g, d);\n            }\n            if (g[d.position] !== 13 && g[d.position + 1] !== 10) return \"failure\";\n            d.position += 2;\n        }\n    }\n    o(U, \"parseMultipartFormDataHeaders\");\n    function M(g, d) {\n        C(g[d.position - 1] === 34);\n        let F = B((N)=>N !== 10 && N !== 13 && N !== 34, g, d);\n        return g[d.position] !== 34 ? null : (d.position++, F = new TextDecoder().decode(F).replace(/%0A/ig, `\n`).replace(/%0D/ig, \"\\r\").replace(/%22/g, '\"'), F);\n    }\n    o(M, \"parseMultipartFormDataName\");\n    function B(g, d, F) {\n        let N = F.position;\n        for(; N < d.length && g(d[N]);)++N;\n        return d.subarray(F.position, F.position = N);\n    }\n    o(B, \"collectASequenceOfBytes\");\n    function D(g, d, F, N) {\n        let u = 0, b = g.length - 1;\n        if (d) for(; u < g.length && N(g[u]);)u++;\n        if (F) for(; b > 0 && N(g[b]);)b--;\n        return u === 0 && b === g.length - 1 ? g : g.subarray(u, b + 1);\n    }\n    o(D, \"removeChars\");\n    function G(g, d, F) {\n        if (g.length < d.length) return !1;\n        for(let N = 0; N < d.length; N++)if (d[N] !== g[F.position + N]) return !1;\n        return !0;\n    }\n    return o(G, \"bufferStartsWith\"), formdataParser = {\n        multipartFormDataParser: w,\n        validateBoundary: S,\n        escapeFormDataName: k\n    }, formdataParser;\n}\no(requireFormdataParser, \"requireFormdataParser\");\nvar body, hasRequiredBody;\nfunction requireBody() {\n    if (hasRequiredBody) return body;\n    hasRequiredBody = 1;\n    const e = util$m, { ReadableStreamFrom: A, isBlobLike: t, isReadableStreamLike: n, readableStreamClose: r, createDeferredPromise: s, fullyReadBody: i, extractMimeType: E, utf8DecodeBytes: Q } = requireUtil$5(), { FormData: C } = requireFormdata(), { kState: I } = requireSymbols$3(), { webidl: a } = requireWebidl(), { Blob: f } = require$$6__default, h = require$$0__default, { isErrored: L } = util$m, { isArrayBuffer: c } = require$$8__default$1, { serializeAMimeType: l } = requireDataUrl(), { multipartFormDataParser: S } = requireFormdataParser(), k = new TextEncoder;\n    function w(u, b = !1) {\n        let m = null;\n        u instanceof ReadableStream ? m = u : t(u) ? m = u.stream() : m = new ReadableStream({\n            async pull (K) {\n                const tA = typeof v == \"string\" ? k.encode(v) : v;\n                tA.byteLength && K.enqueue(tA), queueMicrotask(()=>r(K));\n            },\n            start () {},\n            type: \"bytes\"\n        }), h(n(m));\n        let T = null, v = null, Z = null, P = null;\n        if (typeof u == \"string\") v = u, P = \"text/plain;charset=UTF-8\";\n        else if (u instanceof URLSearchParams) v = u.toString(), P = \"application/x-www-form-urlencoded;charset=UTF-8\";\n        else if (c(u)) v = new Uint8Array(u.slice());\n        else if (ArrayBuffer.isView(u)) v = new Uint8Array(u.buffer.slice(u.byteOffset, u.byteOffset + u.byteLength));\n        else if (e.isFormDataLike(u)) {\n            const K = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, \"0\")}`, tA = `--${K}\\r\nContent-Disposition: form-data`; /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ \n            const aA = o((rA)=>rA.replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\"), \"escape\"), X = o((rA)=>rA.replace(/\\r?\\n|\\r/g, `\\r\n`), \"normalizeLinefeeds\"), $ = [], V = new Uint8Array([\n                13,\n                10\n            ]);\n            Z = 0;\n            let q = !1;\n            for (const [rA, iA] of u)if (typeof iA == \"string\") {\n                const gA = k.encode(tA + `; name=\"${aA(X(rA))}\"\\r\n\\r\n${X(iA)}\\r\n`);\n                $.push(gA), Z += gA.byteLength;\n            } else {\n                const gA = k.encode(`${tA}; name=\"${aA(X(rA))}\"` + (iA.name ? `; filename=\"${aA(iA.name)}\"` : \"\") + `\\r\nContent-Type: ${iA.type || \"application/octet-stream\"}\\r\n\\r\n`);\n                $.push(gA, iA, V), typeof iA.size == \"number\" ? Z += gA.byteLength + iA.size + V.byteLength : q = !0;\n            }\n            const z = k.encode(`--${K}--`);\n            $.push(z), Z += z.byteLength, q && (Z = null), v = u, T = o(async function*() {\n                for (const rA of $)rA.stream ? yield* rA.stream() : yield rA;\n            }, \"action\"), P = `multipart/form-data; boundary=${K}`;\n        } else if (t(u)) v = u, Z = u.size, u.type && (P = u.type);\n        else if (typeof u[Symbol.asyncIterator] == \"function\") {\n            if (b) throw new TypeError(\"keepalive\");\n            if (e.isDisturbed(u) || u.locked) throw new TypeError(\"Response body object should not be disturbed or locked\");\n            m = u instanceof ReadableStream ? u : A(u);\n        }\n        if ((typeof v == \"string\" || e.isBuffer(v)) && (Z = Buffer.byteLength(v)), T != null) {\n            let K;\n            m = new ReadableStream({\n                async start () {\n                    K = T(u)[Symbol.asyncIterator]();\n                },\n                async pull (tA) {\n                    const { value: aA, done: X } = await K.next();\n                    if (X) queueMicrotask(()=>{\n                        tA.close(), tA.byobRequest?.respond(0);\n                    });\n                    else if (!L(m)) {\n                        const $ = new Uint8Array(aA);\n                        $.byteLength && tA.enqueue($);\n                    }\n                    return tA.desiredSize > 0;\n                },\n                async cancel (tA) {\n                    await K.return();\n                },\n                type: \"bytes\"\n            });\n        }\n        return [\n            {\n                stream: m,\n                source: v,\n                length: Z\n            },\n            P\n        ];\n    }\n    o(w, \"extractBody\");\n    function U(u, b = !1) {\n        return u instanceof ReadableStream && (h(!e.isDisturbed(u), \"The body has already been consumed.\"), h(!u.locked, \"The stream is locked.\")), w(u, b);\n    }\n    o(U, \"safelyExtractBody\");\n    function M(u) {\n        const [b, m] = u.stream.tee();\n        return u.stream = b, {\n            stream: m,\n            length: u.length,\n            source: u.source\n        };\n    }\n    o(M, \"cloneBody\");\n    function B(u) {\n        if (u.aborted) throw new DOMException(\"The operation was aborted.\", \"AbortError\");\n    }\n    o(B, \"throwIfAborted\");\n    function D(u) {\n        return {\n            blob () {\n                return g(this, (m)=>{\n                    let T = N(this);\n                    return T === null ? T = \"\" : T && (T = l(T)), new f([\n                        m\n                    ], {\n                        type: T\n                    });\n                }, u);\n            },\n            arrayBuffer () {\n                return g(this, (m)=>new Uint8Array(m).buffer, u);\n            },\n            text () {\n                return g(this, Q, u);\n            },\n            json () {\n                return g(this, F, u);\n            },\n            formData () {\n                return g(this, (m)=>{\n                    const T = N(this);\n                    if (T !== null) switch(T.essence){\n                        case \"multipart/form-data\":\n                            {\n                                const v = S(m, T);\n                                if (v === \"failure\") throw new TypeError(\"Failed to parse body as FormData.\");\n                                const Z = new C;\n                                return Z[I] = v, Z;\n                            }\n                        case \"application/x-www-form-urlencoded\":\n                            {\n                                const v = new URLSearchParams(m.toString()), Z = new C;\n                                for (const [P, AA] of v)Z.append(P, AA);\n                                return Z;\n                            }\n                    }\n                    throw new TypeError('Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".');\n                }, u);\n            }\n        };\n    }\n    o(D, \"bodyMixinMethods\");\n    function G(u) {\n        Object.assign(u.prototype, D(u));\n    }\n    o(G, \"mixinBody\");\n    async function g(u, b, m) {\n        if (a.brandCheck(u, m), B(u[I]), d(u[I].body)) throw new TypeError(\"Body is unusable\");\n        const T = s(), v = o((P)=>T.reject(P), \"errorSteps\"), Z = o((P)=>{\n            try {\n                T.resolve(b(P));\n            } catch (AA) {\n                v(AA);\n            }\n        }, \"successSteps\");\n        return u[I].body == null ? (Z(new Uint8Array), T.promise) : (await i(u[I].body, Z, v), T.promise);\n    }\n    o(g, \"consumeBody\");\n    function d(u) {\n        return u != null && (u.stream.locked || e.isDisturbed(u.stream));\n    }\n    o(d, \"bodyUnusable\");\n    function F(u) {\n        return JSON.parse(Q(u));\n    }\n    o(F, \"parseJSONFromBytes\");\n    function N(u) {\n        const b = u[I].headersList, m = E(b);\n        return m === \"failure\" ? null : m;\n    }\n    return o(N, \"bodyMimeType\"), body = {\n        extractBody: w,\n        safelyExtractBody: U,\n        cloneBody: M,\n        mixinBody: G\n    }, body;\n}\no(requireBody, \"requireBody\");\nconst assert$a = require$$0__default, util$i = util$m, { channels: channels$1 } = diagnostics, timers = timers$1, { RequestContentLengthMismatchError: RequestContentLengthMismatchError$1, ResponseContentLengthMismatchError, RequestAbortedError: RequestAbortedError$5, HeadersTimeoutError, HeadersOverflowError, SocketError: SocketError$3, InformationalError: InformationalError$2, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError } = errors$1, { kUrl: kUrl$4, kReset: kReset$1, kClient: kClient$3, kParser, kBlocking, kRunning: kRunning$5, kPending: kPending$4, kSize: kSize$4, kWriting, kQueue: kQueue$3, kNoRef, kKeepAliveDefaultTimeout: kKeepAliveDefaultTimeout$1, kHostHeader: kHostHeader$1, kPendingIdx: kPendingIdx$2, kRunningIdx: kRunningIdx$2, kError: kError$2, kPipelining: kPipelining$1, kSocket: kSocket$1, kKeepAliveTimeoutValue: kKeepAliveTimeoutValue$1, kMaxHeadersSize: kMaxHeadersSize$1, kKeepAliveMaxTimeout: kKeepAliveMaxTimeout$1, kKeepAliveTimeoutThreshold: kKeepAliveTimeoutThreshold$1, kHeadersTimeout: kHeadersTimeout$1, kBodyTimeout: kBodyTimeout$1, kStrictContentLength: kStrictContentLength$2, kMaxRequests: kMaxRequests$1, kCounter: kCounter$1, kMaxResponseSize: kMaxResponseSize$1, kOnError: kOnError$2, kResume: kResume$3, kHTTPContext: kHTTPContext$1 } = symbols$4, constants$2 = constants$4, EMPTY_BUF = Buffer.alloc(0), FastBuffer = Buffer[Symbol.species], addListener = util$i.addListener, removeAllListeners = util$i.removeAllListeners;\nlet extractBody;\nasync function lazyllhttp() {\n    const e = process.env.JEST_WORKER_ID ? requireLlhttpWasm() : void 0;\n    let A;\n    try {\n        A = await WebAssembly.compile(requireLlhttp_simdWasm());\n    } catch  {\n        A = await WebAssembly.compile(e || requireLlhttpWasm());\n    }\n    return await WebAssembly.instantiate(A, {\n        env: {\n            wasm_on_url: (t, n, r)=>0,\n            wasm_on_status: (t, n, r)=>{\n                assert$a.strictEqual(currentParser.ptr, t);\n                const s = n - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, s, r)) || 0;\n            },\n            wasm_on_message_begin: (t)=>(assert$a.strictEqual(currentParser.ptr, t), currentParser.onMessageBegin() || 0),\n            wasm_on_header_field: (t, n, r)=>{\n                assert$a.strictEqual(currentParser.ptr, t);\n                const s = n - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, s, r)) || 0;\n            },\n            wasm_on_header_value: (t, n, r)=>{\n                assert$a.strictEqual(currentParser.ptr, t);\n                const s = n - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, s, r)) || 0;\n            },\n            wasm_on_headers_complete: (t, n, r, s)=>(assert$a.strictEqual(currentParser.ptr, t), currentParser.onHeadersComplete(n, !!r, !!s) || 0),\n            wasm_on_body: (t, n, r)=>{\n                assert$a.strictEqual(currentParser.ptr, t);\n                const s = n - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, s, r)) || 0;\n            },\n            wasm_on_message_complete: (t)=>(assert$a.strictEqual(currentParser.ptr, t), currentParser.onMessageComplete() || 0)\n        }\n    });\n}\no(lazyllhttp, \"lazyllhttp\");\nlet llhttpInstance = null, llhttpPromise = lazyllhttp();\nllhttpPromise.catch();\nlet currentParser = null, currentBufferRef = null, currentBufferSize = 0, currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1, TIMEOUT_BODY = 2, TIMEOUT_IDLE = 3, st = class st {\n    constructor(A, t, { exports: n }){\n        assert$a(Number.isFinite(A[kMaxHeadersSize$1]) && A[kMaxHeadersSize$1] > 0), this.llhttp = n, this.ptr = this.llhttp.llhttp_alloc(constants$2.TYPE.RESPONSE), this.client = A, this.socket = t, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = null, this.statusText = \"\", this.upgrade = !1, this.headers = [], this.headersSize = 0, this.headersMaxSize = A[kMaxHeadersSize$1], this.shouldKeepAlive = !1, this.paused = !1, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = \"\", this.contentLength = \"\", this.connection = \"\", this.maxResponseSize = A[kMaxResponseSize$1];\n    }\n    setTimeout(A, t) {\n        this.timeoutType = t, A !== this.timeoutValue ? (timers.clearTimeout(this.timeout), A ? (this.timeout = timers.setTimeout(onParserTimeout, A, this), this.timeout.unref && this.timeout.unref()) : this.timeout = null, this.timeoutValue = A) : this.timeout && this.timeout.refresh && this.timeout.refresh();\n    }\n    resume() {\n        this.socket.destroyed || !this.paused || (assert$a(this.ptr != null), assert$a(currentParser == null), this.llhttp.llhttp_resume(this.ptr), assert$a(this.timeoutType === TIMEOUT_BODY), this.timeout && this.timeout.refresh && this.timeout.refresh(), this.paused = !1, this.execute(this.socket.read() || EMPTY_BUF), this.readMore());\n    }\n    readMore() {\n        for(; !this.paused && this.ptr;){\n            const A = this.socket.read();\n            if (A === null) break;\n            this.execute(A);\n        }\n    }\n    execute(A) {\n        assert$a(this.ptr != null), assert$a(currentParser == null), assert$a(!this.paused);\n        const { socket: t, llhttp: n } = this;\n        A.length > currentBufferSize && (currentBufferPtr && n.free(currentBufferPtr), currentBufferSize = Math.ceil(A.length / 4096) * 4096, currentBufferPtr = n.malloc(currentBufferSize)), new Uint8Array(n.memory.buffer, currentBufferPtr, currentBufferSize).set(A);\n        try {\n            let r;\n            try {\n                currentBufferRef = A, currentParser = this, r = n.llhttp_execute(this.ptr, currentBufferPtr, A.length);\n            } catch (i) {\n                throw i;\n            } finally{\n                currentParser = null, currentBufferRef = null;\n            }\n            const s = n.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n            if (r === constants$2.ERROR.PAUSED_UPGRADE) this.onUpgrade(A.slice(s));\n            else if (r === constants$2.ERROR.PAUSED) this.paused = !0, t.unshift(A.slice(s));\n            else if (r !== constants$2.ERROR.OK) {\n                const i = n.llhttp_get_error_reason(this.ptr);\n                let E = \"\";\n                if (i) {\n                    const Q = new Uint8Array(n.memory.buffer, i).indexOf(0);\n                    E = \"Response does not match the HTTP/1.1 protocol (\" + Buffer.from(n.memory.buffer, i, Q).toString() + \")\";\n                }\n                throw new HTTPParserError(E, constants$2.ERROR[r], A.slice(s));\n            }\n        } catch (r) {\n            util$i.destroy(t, r);\n        }\n    }\n    destroy() {\n        assert$a(this.ptr != null), assert$a(currentParser == null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, timers.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = !1;\n    }\n    onStatus(A) {\n        this.statusText = A.toString();\n    }\n    onMessageBegin() {\n        const { socket: A, client: t } = this;\n        if (A.destroyed) return -1;\n        const n = t[kQueue$3][t[kRunningIdx$2]];\n        if (!n) return -1;\n        n.onResponseStarted();\n    }\n    onHeaderField(A) {\n        const t = this.headers.length;\n        t & 1 ? this.headers[t - 1] = Buffer.concat([\n            this.headers[t - 1],\n            A\n        ]) : this.headers.push(A), this.trackHeader(A.length);\n    }\n    onHeaderValue(A) {\n        let t = this.headers.length;\n        (t & 1) === 1 ? (this.headers.push(A), t += 1) : this.headers[t - 1] = Buffer.concat([\n            this.headers[t - 1],\n            A\n        ]);\n        const n = this.headers[t - 2];\n        if (n.length === 10) {\n            const r = util$i.bufferToLowerCasedHeaderName(n);\n            r === \"keep-alive\" ? this.keepAlive += A.toString() : r === \"connection\" && (this.connection += A.toString());\n        } else n.length === 14 && util$i.bufferToLowerCasedHeaderName(n) === \"content-length\" && (this.contentLength += A.toString());\n        this.trackHeader(A.length);\n    }\n    trackHeader(A) {\n        this.headersSize += A, this.headersSize >= this.headersMaxSize && util$i.destroy(this.socket, new HeadersOverflowError);\n    }\n    onUpgrade(A) {\n        const { upgrade: t, client: n, socket: r, headers: s, statusCode: i } = this;\n        assert$a(t);\n        const E = n[kQueue$3][n[kRunningIdx$2]];\n        assert$a(E), assert$a(!r.destroyed), assert$a(r === n[kSocket$1]), assert$a(!this.paused), assert$a(E.upgrade || E.method === \"CONNECT\"), this.statusCode = null, this.statusText = \"\", this.shouldKeepAlive = null, assert$a(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, r.unshift(A), r[kParser].destroy(), r[kParser] = null, r[kClient$3] = null, r[kError$2] = null, removeAllListeners(r), n[kSocket$1] = null, n[kHTTPContext$1] = null, n[kQueue$3][n[kRunningIdx$2]++] = null, n.emit(\"disconnect\", n[kUrl$4], [\n            n\n        ], new InformationalError$2(\"upgrade\"));\n        try {\n            E.onUpgrade(i, s, r);\n        } catch (Q) {\n            util$i.destroy(r, Q);\n        }\n        n[kResume$3]();\n    }\n    onHeadersComplete(A, t, n) {\n        const { client: r, socket: s, headers: i, statusText: E } = this;\n        if (s.destroyed) return -1;\n        const Q = r[kQueue$3][r[kRunningIdx$2]];\n        if (!Q) return -1;\n        if (assert$a(!this.upgrade), assert$a(this.statusCode < 200), A === 100) return util$i.destroy(s, new SocketError$3(\"bad response\", util$i.getSocketInfo(s))), -1;\n        if (t && !Q.upgrade) return util$i.destroy(s, new SocketError$3(\"bad upgrade\", util$i.getSocketInfo(s))), -1;\n        if (assert$a.strictEqual(this.timeoutType, TIMEOUT_HEADERS), this.statusCode = A, this.shouldKeepAlive = n || Q.method === \"HEAD\" && !s[kReset$1] && this.connection.toLowerCase() === \"keep-alive\", this.statusCode >= 200) {\n            const I = Q.bodyTimeout != null ? Q.bodyTimeout : r[kBodyTimeout$1];\n            this.setTimeout(I, TIMEOUT_BODY);\n        } else this.timeout && this.timeout.refresh && this.timeout.refresh();\n        if (Q.method === \"CONNECT\") return assert$a(r[kRunning$5] === 1), this.upgrade = !0, 2;\n        if (t) return assert$a(r[kRunning$5] === 1), this.upgrade = !0, 2;\n        if (assert$a(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && r[kPipelining$1]) {\n            const I = this.keepAlive ? util$i.parseKeepAliveTimeout(this.keepAlive) : null;\n            if (I != null) {\n                const a = Math.min(I - r[kKeepAliveTimeoutThreshold$1], r[kKeepAliveMaxTimeout$1]);\n                a <= 0 ? s[kReset$1] = !0 : r[kKeepAliveTimeoutValue$1] = a;\n            } else r[kKeepAliveTimeoutValue$1] = r[kKeepAliveDefaultTimeout$1];\n        } else s[kReset$1] = !0;\n        const C = Q.onHeaders(A, i, this.resume, E) === !1;\n        return Q.aborted ? -1 : Q.method === \"HEAD\" || A < 200 ? 1 : (s[kBlocking] && (s[kBlocking] = !1, r[kResume$3]()), C ? constants$2.ERROR.PAUSED : 0);\n    }\n    onBody(A) {\n        const { client: t, socket: n, statusCode: r, maxResponseSize: s } = this;\n        if (n.destroyed) return -1;\n        const i = t[kQueue$3][t[kRunningIdx$2]];\n        if (assert$a(i), assert$a.strictEqual(this.timeoutType, TIMEOUT_BODY), this.timeout && this.timeout.refresh && this.timeout.refresh(), assert$a(r >= 200), s > -1 && this.bytesRead + A.length > s) return util$i.destroy(n, new ResponseExceededMaxSizeError), -1;\n        if (this.bytesRead += A.length, i.onData(A) === !1) return constants$2.ERROR.PAUSED;\n    }\n    onMessageComplete() {\n        const { client: A, socket: t, statusCode: n, upgrade: r, headers: s, contentLength: i, bytesRead: E, shouldKeepAlive: Q } = this;\n        if (t.destroyed && (!n || Q)) return -1;\n        if (r) return;\n        const C = A[kQueue$3][A[kRunningIdx$2]];\n        if (assert$a(C), assert$a(n >= 100), this.statusCode = null, this.statusText = \"\", this.bytesRead = 0, this.contentLength = \"\", this.keepAlive = \"\", this.connection = \"\", assert$a(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, !(n < 200)) {\n            if (C.method !== \"HEAD\" && i && E !== parseInt(i, 10)) return util$i.destroy(t, new ResponseContentLengthMismatchError), -1;\n            if (C.onComplete(s), A[kQueue$3][A[kRunningIdx$2]++] = null, t[kWriting]) return assert$a.strictEqual(A[kRunning$5], 0), util$i.destroy(t, new InformationalError$2(\"reset\")), constants$2.ERROR.PAUSED;\n            if (Q) {\n                if (t[kReset$1] && A[kRunning$5] === 0) return util$i.destroy(t, new InformationalError$2(\"reset\")), constants$2.ERROR.PAUSED;\n                A[kPipelining$1] == null || A[kPipelining$1] === 1 ? setImmediate(()=>A[kResume$3]()) : A[kResume$3]();\n            } else return util$i.destroy(t, new InformationalError$2(\"reset\")), constants$2.ERROR.PAUSED;\n        }\n    }\n};\no(st, \"Parser\");\nlet Parser = st;\nfunction onParserTimeout(e) {\n    const { socket: A, timeoutType: t, client: n } = e;\n    t === TIMEOUT_HEADERS ? (!A[kWriting] || A.writableNeedDrain || n[kRunning$5] > 1) && (assert$a(!e.paused, \"cannot be paused while waiting for headers\"), util$i.destroy(A, new HeadersTimeoutError)) : t === TIMEOUT_BODY ? e.paused || util$i.destroy(A, new BodyTimeoutError) : t === TIMEOUT_IDLE && (assert$a(n[kRunning$5] === 0 && n[kKeepAliveTimeoutValue$1]), util$i.destroy(A, new InformationalError$2(\"socket idle timeout\")));\n}\no(onParserTimeout, \"onParserTimeout\");\nasync function connectH1$1(e, A) {\n    e[kSocket$1] = A, llhttpInstance || (llhttpInstance = await llhttpPromise, llhttpPromise = null), A[kNoRef] = !1, A[kWriting] = !1, A[kReset$1] = !1, A[kBlocking] = !1, A[kParser] = new Parser(e, A, llhttpInstance), addListener(A, \"error\", function(n) {\n        const r = this[kParser];\n        if (assert$a(n.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\"), n.code === \"ECONNRESET\" && r.statusCode && !r.shouldKeepAlive) {\n            r.onMessageComplete();\n            return;\n        }\n        this[kError$2] = n, this[kClient$3][kOnError$2](n);\n    }), addListener(A, \"readable\", function() {\n        const n = this[kParser];\n        n && n.readMore();\n    }), addListener(A, \"end\", function() {\n        const n = this[kParser];\n        if (n.statusCode && !n.shouldKeepAlive) {\n            n.onMessageComplete();\n            return;\n        }\n        util$i.destroy(this, new SocketError$3(\"other side closed\", util$i.getSocketInfo(this)));\n    }), addListener(A, \"close\", function() {\n        const n = this[kClient$3], r = this[kParser];\n        r && (!this[kError$2] && r.statusCode && !r.shouldKeepAlive && r.onMessageComplete(), this[kParser].destroy(), this[kParser] = null);\n        const s = this[kError$2] || new SocketError$3(\"closed\", util$i.getSocketInfo(this));\n        if (n[kSocket$1] = null, n[kHTTPContext$1] = null, n.destroyed) {\n            assert$a(n[kPending$4] === 0);\n            const i = n[kQueue$3].splice(n[kRunningIdx$2]);\n            for(let E = 0; E < i.length; E++){\n                const Q = i[E];\n                util$i.errorRequest(n, Q, s);\n            }\n        } else if (n[kRunning$5] > 0 && s.code !== \"UND_ERR_INFO\") {\n            const i = n[kQueue$3][n[kRunningIdx$2]];\n            n[kQueue$3][n[kRunningIdx$2]++] = null, util$i.errorRequest(n, i, s);\n        }\n        n[kPendingIdx$2] = n[kRunningIdx$2], assert$a(n[kRunning$5] === 0), n.emit(\"disconnect\", n[kUrl$4], [\n            n\n        ], s), n[kResume$3]();\n    });\n    let t = !1;\n    return A.on(\"close\", ()=>{\n        t = !0;\n    }), {\n        version: \"h1\",\n        defaultPipelining: 1,\n        write (...n) {\n            return writeH1(e, ...n);\n        },\n        resume () {\n            resumeH1(e);\n        },\n        destroy (n, r) {\n            t ? queueMicrotask(r) : A.destroy(n).on(\"close\", r);\n        },\n        get destroyed () {\n            return A.destroyed;\n        },\n        busy (n) {\n            return !!(A[kWriting] || A[kReset$1] || A[kBlocking] || n && (e[kRunning$5] > 0 && !n.idempotent || e[kRunning$5] > 0 && (n.upgrade || n.method === \"CONNECT\") || e[kRunning$5] > 0 && util$i.bodyLength(n.body) !== 0 && (util$i.isStream(n.body) || util$i.isAsyncIterable(n.body) || util$i.isFormDataLike(n.body))));\n        }\n    };\n}\no(connectH1$1, \"connectH1$1\");\nfunction resumeH1(e) {\n    const A = e[kSocket$1];\n    if (A && !A.destroyed) {\n        if (e[kSize$4] === 0 ? !A[kNoRef] && A.unref && (A.unref(), A[kNoRef] = !0) : A[kNoRef] && A.ref && (A.ref(), A[kNoRef] = !1), e[kSize$4] === 0) A[kParser].timeoutType !== TIMEOUT_IDLE && A[kParser].setTimeout(e[kKeepAliveTimeoutValue$1], TIMEOUT_IDLE);\n        else if (e[kRunning$5] > 0 && A[kParser].statusCode < 200 && A[kParser].timeoutType !== TIMEOUT_HEADERS) {\n            const t = e[kQueue$3][e[kRunningIdx$2]], n = t.headersTimeout != null ? t.headersTimeout : e[kHeadersTimeout$1];\n            A[kParser].setTimeout(n, TIMEOUT_HEADERS);\n        }\n    }\n}\no(resumeH1, \"resumeH1\");\nfunction shouldSendContentLength$1(e) {\n    return e !== \"GET\" && e !== \"HEAD\" && e !== \"OPTIONS\" && e !== \"TRACE\" && e !== \"CONNECT\";\n}\no(shouldSendContentLength$1, \"shouldSendContentLength$1\");\nfunction writeH1(e, A) {\n    const { method: t, path: n, host: r, upgrade: s, blocking: i, reset: E } = A;\n    let { body: Q, headers: C, contentLength: I } = A;\n    const a = t === \"PUT\" || t === \"POST\" || t === \"PATCH\";\n    if (util$i.isFormDataLike(Q)) {\n        extractBody || (extractBody = requireBody().extractBody);\n        const [l, S] = extractBody(Q);\n        A.contentType == null && C.push(\"content-type\", S), Q = l.stream, I = l.length;\n    } else util$i.isBlobLike(Q) && A.contentType == null && Q.type && C.push(\"content-type\", Q.type);\n    Q && typeof Q.read == \"function\" && Q.read(0);\n    const f = util$i.bodyLength(Q);\n    if (I = f ?? I, I === null && (I = A.contentLength), I === 0 && !a && (I = null), shouldSendContentLength$1(t) && I > 0 && A.contentLength !== null && A.contentLength !== I) {\n        if (e[kStrictContentLength$2]) return util$i.errorRequest(e, A, new RequestContentLengthMismatchError$1), !1;\n        process.emitWarning(new RequestContentLengthMismatchError$1);\n    }\n    const h = e[kSocket$1], L = o((l)=>{\n        A.aborted || A.completed || (util$i.errorRequest(e, A, l || new RequestAbortedError$5), util$i.destroy(Q), util$i.destroy(h, new InformationalError$2(\"aborted\")));\n    }, \"abort\");\n    try {\n        A.onConnect(L);\n    } catch (l) {\n        util$i.errorRequest(e, A, l);\n    }\n    if (A.aborted) return !1;\n    t === \"HEAD\" && (h[kReset$1] = !0), (s || t === \"CONNECT\") && (h[kReset$1] = !0), E != null && (h[kReset$1] = E), e[kMaxRequests$1] && h[kCounter$1]++ >= e[kMaxRequests$1] && (h[kReset$1] = !0), i && (h[kBlocking] = !0);\n    let c = `${t} ${n} HTTP/1.1\\r\n`;\n    if (typeof r == \"string\" ? c += `host: ${r}\\r\n` : c += e[kHostHeader$1], s ? c += `connection: upgrade\\r\nupgrade: ${s}\\r\n` : e[kPipelining$1] && !h[kReset$1] ? c += `connection: keep-alive\\r\n` : c += `connection: close\\r\n`, Array.isArray(C)) for(let l = 0; l < C.length; l += 2){\n        const S = C[l + 0], k = C[l + 1];\n        if (Array.isArray(k)) for(let w = 0; w < k.length; w++)c += `${S}: ${k[w]}\\r\n`;\n        else c += `${S}: ${k}\\r\n`;\n    }\n    return channels$1.sendHeaders.hasSubscribers && channels$1.sendHeaders.publish({\n        request: A,\n        headers: c,\n        socket: h\n    }), !Q || f === 0 ? writeBuffer({\n        abort: L,\n        body: null,\n        client: e,\n        request: A,\n        socket: h,\n        contentLength: I,\n        header: c,\n        expectsPayload: a\n    }) : util$i.isBuffer(Q) ? writeBuffer({\n        abort: L,\n        body: Q,\n        client: e,\n        request: A,\n        socket: h,\n        contentLength: I,\n        header: c,\n        expectsPayload: a\n    }) : util$i.isBlobLike(Q) ? typeof Q.stream == \"function\" ? writeIterable$1({\n        abort: L,\n        body: Q.stream(),\n        client: e,\n        request: A,\n        socket: h,\n        contentLength: I,\n        header: c,\n        expectsPayload: a\n    }) : writeBlob$1({\n        abort: L,\n        body: Q,\n        client: e,\n        request: A,\n        socket: h,\n        contentLength: I,\n        header: c,\n        expectsPayload: a\n    }) : util$i.isStream(Q) ? writeStream$1({\n        abort: L,\n        body: Q,\n        client: e,\n        request: A,\n        socket: h,\n        contentLength: I,\n        header: c,\n        expectsPayload: a\n    }) : util$i.isIterable(Q) ? writeIterable$1({\n        abort: L,\n        body: Q,\n        client: e,\n        request: A,\n        socket: h,\n        contentLength: I,\n        header: c,\n        expectsPayload: a\n    }) : assert$a(!1), !0;\n}\no(writeH1, \"writeH1\");\nfunction writeStream$1({ abort: e, body: A, client: t, request: n, socket: r, contentLength: s, header: i, expectsPayload: E }) {\n    assert$a(s !== 0 || t[kRunning$5] === 0, \"stream body cannot be pipelined\");\n    let Q = !1;\n    const C = new AsyncWriter({\n        abort: e,\n        socket: r,\n        request: n,\n        contentLength: s,\n        client: t,\n        expectsPayload: E,\n        header: i\n    }), I = o(function(L) {\n        if (!Q) try {\n            !C.write(L) && this.pause && this.pause();\n        } catch (c) {\n            util$i.destroy(this, c);\n        }\n    }, \"onData\"), a = o(function() {\n        Q || A.resume && A.resume();\n    }, \"onDrain\"), f = o(function() {\n        if (queueMicrotask(()=>{\n            A.removeListener(\"error\", h);\n        }), !Q) {\n            const L = new RequestAbortedError$5;\n            queueMicrotask(()=>h(L));\n        }\n    }, \"onClose\"), h = o(function(L) {\n        if (!Q) {\n            if (Q = !0, assert$a(r.destroyed || r[kWriting] && t[kRunning$5] <= 1), r.off(\"drain\", a).off(\"error\", h), A.removeListener(\"data\", I).removeListener(\"end\", h).removeListener(\"close\", f), !L) try {\n                C.end();\n            } catch (c) {\n                L = c;\n            }\n            C.destroy(L), L && (L.code !== \"UND_ERR_INFO\" || L.message !== \"reset\") ? util$i.destroy(A, L) : util$i.destroy(A);\n        }\n    }, \"onFinished\");\n    A.on(\"data\", I).on(\"end\", h).on(\"error\", h).on(\"close\", f), A.resume && A.resume(), r.on(\"drain\", a).on(\"error\", h), A.errorEmitted ?? A.errored ? setImmediate(()=>h(A.errored)) : (A.endEmitted ?? A.readableEnded) && setImmediate(()=>h(null)), (A.closeEmitted ?? A.closed) && setImmediate(f);\n}\no(writeStream$1, \"writeStream$1\");\nasync function writeBuffer({ abort: e, body: A, client: t, request: n, socket: r, contentLength: s, header: i, expectsPayload: E }) {\n    try {\n        A ? util$i.isBuffer(A) && (assert$a(s === A.byteLength, \"buffer body must have content length\"), r.cork(), r.write(`${i}content-length: ${s}\\r\n\\r\n`, \"latin1\"), r.write(A), r.uncork(), n.onBodySent(A), E || (r[kReset$1] = !0)) : s === 0 ? r.write(`${i}content-length: 0\\r\n\\r\n`, \"latin1\") : (assert$a(s === null, \"no body must not have content length\"), r.write(`${i}\\r\n`, \"latin1\")), n.onRequestSent(), t[kResume$3]();\n    } catch (Q) {\n        e(Q);\n    }\n}\no(writeBuffer, \"writeBuffer\");\nasync function writeBlob$1({ abort: e, body: A, client: t, request: n, socket: r, contentLength: s, header: i, expectsPayload: E }) {\n    assert$a(s === A.size, \"blob body must have content length\");\n    try {\n        if (s != null && s !== A.size) throw new RequestContentLengthMismatchError$1;\n        const Q = Buffer.from(await A.arrayBuffer());\n        r.cork(), r.write(`${i}content-length: ${s}\\r\n\\r\n`, \"latin1\"), r.write(Q), r.uncork(), n.onBodySent(Q), n.onRequestSent(), E || (r[kReset$1] = !0), t[kResume$3]();\n    } catch (Q) {\n        e(Q);\n    }\n}\no(writeBlob$1, \"writeBlob$1\");\nasync function writeIterable$1({ abort: e, body: A, client: t, request: n, socket: r, contentLength: s, header: i, expectsPayload: E }) {\n    assert$a(s !== 0 || t[kRunning$5] === 0, \"iterator body cannot be pipelined\");\n    let Q = null;\n    function C() {\n        if (Q) {\n            const f = Q;\n            Q = null, f();\n        }\n    }\n    o(C, \"onDrain\");\n    const I = o(()=>new Promise((f, h)=>{\n            assert$a(Q === null), r[kError$2] ? h(r[kError$2]) : Q = f;\n        }), \"waitForDrain\");\n    r.on(\"close\", C).on(\"drain\", C);\n    const a = new AsyncWriter({\n        abort: e,\n        socket: r,\n        request: n,\n        contentLength: s,\n        client: t,\n        expectsPayload: E,\n        header: i\n    });\n    try {\n        for await (const f of A){\n            if (r[kError$2]) throw r[kError$2];\n            a.write(f) || await I();\n        }\n        a.end();\n    } catch (f) {\n        a.destroy(f);\n    } finally{\n        r.off(\"close\", C).off(\"drain\", C);\n    }\n}\no(writeIterable$1, \"writeIterable$1\");\nconst ot = class ot {\n    constructor({ abort: A, socket: t, request: n, contentLength: r, client: s, expectsPayload: i, header: E }){\n        this.socket = t, this.request = n, this.contentLength = r, this.client = s, this.bytesWritten = 0, this.expectsPayload = i, this.header = E, this.abort = A, t[kWriting] = !0;\n    }\n    write(A) {\n        const { socket: t, request: n, contentLength: r, client: s, bytesWritten: i, expectsPayload: E, header: Q } = this;\n        if (t[kError$2]) throw t[kError$2];\n        if (t.destroyed) return !1;\n        const C = Buffer.byteLength(A);\n        if (!C) return !0;\n        if (r !== null && i + C > r) {\n            if (s[kStrictContentLength$2]) throw new RequestContentLengthMismatchError$1;\n            process.emitWarning(new RequestContentLengthMismatchError$1);\n        }\n        t.cork(), i === 0 && (E || (t[kReset$1] = !0), r === null ? t.write(`${Q}transfer-encoding: chunked\\r\n`, \"latin1\") : t.write(`${Q}content-length: ${r}\\r\n\\r\n`, \"latin1\")), r === null && t.write(`\\r\n${C.toString(16)}\\r\n`, \"latin1\"), this.bytesWritten += C;\n        const I = t.write(A);\n        return t.uncork(), n.onBodySent(A), I || t[kParser].timeout && t[kParser].timeoutType === TIMEOUT_HEADERS && t[kParser].timeout.refresh && t[kParser].timeout.refresh(), I;\n    }\n    end() {\n        const { socket: A, contentLength: t, client: n, bytesWritten: r, expectsPayload: s, header: i, request: E } = this;\n        if (E.onRequestSent(), A[kWriting] = !1, A[kError$2]) throw A[kError$2];\n        if (!A.destroyed) {\n            if (r === 0 ? s ? A.write(`${i}content-length: 0\\r\n\\r\n`, \"latin1\") : A.write(`${i}\\r\n`, \"latin1\") : t === null && A.write(`\\r\n0\\r\n\\r\n`, \"latin1\"), t !== null && r !== t) {\n                if (n[kStrictContentLength$2]) throw new RequestContentLengthMismatchError$1;\n                process.emitWarning(new RequestContentLengthMismatchError$1);\n            }\n            A[kParser].timeout && A[kParser].timeoutType === TIMEOUT_HEADERS && A[kParser].timeout.refresh && A[kParser].timeout.refresh(), n[kResume$3]();\n        }\n    }\n    destroy(A) {\n        const { socket: t, client: n, abort: r } = this;\n        t[kWriting] = !1, A && (assert$a(n[kRunning$5] <= 1, \"pipeline should only contain this request\"), r(A));\n    }\n};\no(ot, \"AsyncWriter\");\nlet AsyncWriter = ot;\nvar clientH1 = connectH1$1;\nconst assert$9 = require$$0__default, { pipeline: pipeline$1 } = Stream__default, util$h = util$m, { RequestContentLengthMismatchError, RequestAbortedError: RequestAbortedError$4, SocketError: SocketError$2, InformationalError: InformationalError$1 } = errors$1, { kUrl: kUrl$3, kReset, kClient: kClient$2, kRunning: kRunning$4, kPending: kPending$3, kQueue: kQueue$2, kPendingIdx: kPendingIdx$1, kRunningIdx: kRunningIdx$1, kError: kError$1, kSocket, kStrictContentLength: kStrictContentLength$1, kOnError: kOnError$1, kMaxConcurrentStreams: kMaxConcurrentStreams$1, kHTTP2Session, kResume: kResume$2 } = symbols$4, kOpenStreams = Symbol(\"open streams\");\nlet h2ExperimentalWarned = !1, http2;\ntry {\n    http2 = __webpack_require__(/*! node:http2 */ \"node:http2\");\n} catch  {\n    http2 = {\n        constants: {}\n    };\n}\nconst { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;\nfunction parseH2Headers(e) {\n    const A = [];\n    for (const [t, n] of Object.entries(e))if (Array.isArray(n)) for (const r of n)A.push(Buffer.from(t), Buffer.from(r));\n    else A.push(Buffer.from(t), Buffer.from(n));\n    return A;\n}\no(parseH2Headers, \"parseH2Headers\");\nasync function connectH2$1(e, A) {\n    e[kSocket] = A, h2ExperimentalWarned || (h2ExperimentalWarned = !0, process.emitWarning(\"H2 support is experimental, expect them to change at any time.\", {\n        code: \"UNDICI-H2\"\n    }));\n    const t = http2.connect(e[kUrl$3], {\n        createConnection: ()=>A,\n        peerMaxConcurrentStreams: e[kMaxConcurrentStreams$1]\n    });\n    t[kOpenStreams] = 0, t[kClient$2] = e, t[kSocket] = A, util$h.addListener(t, \"error\", onHttp2SessionError), util$h.addListener(t, \"frameError\", onHttp2FrameError), util$h.addListener(t, \"end\", onHttp2SessionEnd), util$h.addListener(t, \"goaway\", onHTTP2GoAway), util$h.addListener(t, \"close\", function() {\n        const { [kClient$2]: r } = this, s = this[kSocket][kError$1] || new SocketError$2(\"closed\", util$h.getSocketInfo(this));\n        r[kSocket] = null, r[kHTTP2Session] = null, assert$9(r[kPending$3] === 0);\n        const i = r[kQueue$2].splice(r[kRunningIdx$1]);\n        for(let E = 0; E < i.length; E++){\n            const Q = i[E];\n            util$h.errorRequest(r, Q, s);\n        }\n        r[kPendingIdx$1] = r[kRunningIdx$1], assert$9(r[kRunning$4] === 0), r.emit(\"disconnect\", r[kUrl$3], [\n            r\n        ], s), r[kResume$2]();\n    }), t.unref(), e[kHTTP2Session] = t, A[kHTTP2Session] = t, util$h.addListener(A, \"error\", function(r) {\n        assert$9(r.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\"), this[kError$1] = r, this[kClient$2][kOnError$1](r);\n    }), util$h.addListener(A, \"end\", function() {\n        util$h.destroy(this, new SocketError$2(\"other side closed\", util$h.getSocketInfo(this)));\n    });\n    let n = !1;\n    return A.on(\"close\", ()=>{\n        n = !0;\n    }), {\n        version: \"h2\",\n        defaultPipelining: 1 / 0,\n        write (...r) {\n            writeH2(e, ...r);\n        },\n        resume () {},\n        destroy (r, s) {\n            t.destroy(r), n ? queueMicrotask(s) : A.destroy(r).on(\"close\", s);\n        },\n        get destroyed () {\n            return A.destroyed;\n        },\n        busy () {\n            return !1;\n        }\n    };\n}\no(connectH2$1, \"connectH2$1\");\nfunction onHttp2SessionError(e) {\n    assert$9(e.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\"), this[kSocket][kError$1] = e, this[kClient$2][kOnError$1](e);\n}\no(onHttp2SessionError, \"onHttp2SessionError\");\nfunction onHttp2FrameError(e, A, t) {\n    if (t === 0) {\n        const n = new InformationalError$1(`HTTP/2: \"frameError\" received - type ${e}, code ${A}`);\n        this[kSocket][kError$1] = n, this[kClient$2][kOnError$1](n);\n    }\n}\no(onHttp2FrameError, \"onHttp2FrameError\");\nfunction onHttp2SessionEnd() {\n    const e = new SocketError$2(\"other side closed\", util$h.getSocketInfo(this[kSocket]));\n    this.destroy(e), util$h.destroy(this[kSocket], e);\n}\no(onHttp2SessionEnd, \"onHttp2SessionEnd\");\nfunction onHTTP2GoAway(e) {\n    const A = new InformationalError$1(`HTTP/2: \"GOAWAY\" frame received with code ${e}`);\n    this[kSocket][kError$1] = A, this[kClient$2][kOnError$1](A), this.unref(), this.destroy(), util$h.destroy(this[kSocket], A);\n}\no(onHTTP2GoAway, \"onHTTP2GoAway\");\nfunction shouldSendContentLength(e) {\n    return e !== \"GET\" && e !== \"HEAD\" && e !== \"OPTIONS\" && e !== \"TRACE\" && e !== \"CONNECT\";\n}\no(shouldSendContentLength, \"shouldSendContentLength\");\nfunction writeH2(e, A) {\n    const t = e[kHTTP2Session], { body: n, method: r, path: s, host: i, upgrade: E, expectContinue: Q, signal: C, headers: I } = A;\n    if (E) return util$h.errorRequest(e, A, new Error(\"Upgrade not supported for H2\")), !1;\n    if (A.aborted) return !1;\n    const a = {};\n    for(let w = 0; w < I.length; w += 2){\n        const U = I[w + 0], M = I[w + 1];\n        if (Array.isArray(M)) for(let B = 0; B < M.length; B++)a[U] ? a[U] += `,${M[B]}` : a[U] = M[B];\n        else a[U] = M;\n    }\n    let f;\n    const { hostname: h, port: L } = e[kUrl$3];\n    a[HTTP2_HEADER_AUTHORITY] = i || `${h}${L ? `:${L}` : \"\"}`, a[HTTP2_HEADER_METHOD] = r;\n    try {\n        A.onConnect((w)=>{\n            A.aborted || A.completed || (w = w || new RequestAbortedError$4, f != null && (util$h.destroy(f, w), t[kOpenStreams] -= 1, t[kOpenStreams] === 0 && t.unref()), util$h.errorRequest(e, A, w));\n        });\n    } catch (w) {\n        util$h.errorRequest(e, A, w);\n    }\n    if (r === \"CONNECT\") return t.ref(), f = t.request(a, {\n        endStream: !1,\n        signal: C\n    }), f.id && !f.pending ? (A.onUpgrade(null, null, f), ++t[kOpenStreams]) : f.once(\"ready\", ()=>{\n        A.onUpgrade(null, null, f), ++t[kOpenStreams];\n    }), f.once(\"close\", ()=>{\n        t[kOpenStreams] -= 1, t[kOpenStreams] === 0 && t.unref();\n    }), !0;\n    a[HTTP2_HEADER_PATH] = s, a[HTTP2_HEADER_SCHEME] = \"https\";\n    const c = r === \"PUT\" || r === \"POST\" || r === \"PATCH\";\n    n && typeof n.read == \"function\" && n.read(0);\n    let l = util$h.bodyLength(n);\n    if (l == null && (l = A.contentLength), (l === 0 || !c) && (l = null), shouldSendContentLength(r) && l > 0 && A.contentLength != null && A.contentLength !== l) {\n        if (e[kStrictContentLength$1]) return util$h.errorRequest(e, A, new RequestContentLengthMismatchError), !1;\n        process.emitWarning(new RequestContentLengthMismatchError);\n    }\n    l != null && (assert$9(n, \"no body must not have content length\"), a[HTTP2_HEADER_CONTENT_LENGTH] = `${l}`), t.ref();\n    const S = r === \"GET\" || r === \"HEAD\" || n === null;\n    return Q ? (a[HTTP2_HEADER_EXPECT] = \"100-continue\", f = t.request(a, {\n        endStream: S,\n        signal: C\n    }), f.once(\"continue\", k)) : (f = t.request(a, {\n        endStream: S,\n        signal: C\n    }), k()), ++t[kOpenStreams], f.once(\"response\", (w)=>{\n        const { [HTTP2_HEADER_STATUS]: U, ...M } = w;\n        if (A.onResponseStarted(), A.aborted || A.completed) {\n            const B = new RequestAbortedError$4;\n            util$h.errorRequest(e, A, B), util$h.destroy(f, B);\n            return;\n        }\n        A.onHeaders(Number(U), parseH2Headers(M), f.resume.bind(f), \"\") === !1 && f.pause(), f.on(\"data\", (B)=>{\n            A.onData(B) === !1 && f.pause();\n        });\n    }), f.once(\"end\", ()=>{\n        if (f.state?.state == null || f.state.state < 6) {\n            A.onComplete([]);\n            return;\n        }\n        t[kOpenStreams] -= 1, t[kOpenStreams] === 0 && t.unref();\n        const w = new InformationalError$1(\"HTTP/2: stream half-closed (remote)\");\n        util$h.errorRequest(e, A, w), util$h.destroy(f, w);\n    }), f.once(\"close\", ()=>{\n        t[kOpenStreams] -= 1, t[kOpenStreams] === 0 && t.unref();\n    }), f.once(\"error\", function(w) {\n        e[kHTTP2Session] && !e[kHTTP2Session].destroyed && !this.closed && !this.destroyed && (t[kOpenStreams] -= 1, util$h.errorRequest(e, A, w), util$h.destroy(f, w));\n    }), f.once(\"frameError\", (w, U)=>{\n        const M = new InformationalError$1(`HTTP/2: \"frameError\" received - type ${w}, code ${U}`);\n        util$h.errorRequest(e, A, M), e[kHTTP2Session] && !e[kHTTP2Session].destroyed && !this.closed && !this.destroyed && (t[kOpenStreams] -= 1, util$h.destroy(f, M));\n    }), !0;\n    function k() {\n        n ? util$h.isBuffer(n) ? (assert$9(l === n.byteLength, \"buffer body must have content length\"), f.cork(), f.write(n), f.uncork(), f.end(), A.onBodySent(n), A.onRequestSent()) : util$h.isBlobLike(n) ? typeof n.stream == \"function\" ? writeIterable({\n            client: e,\n            request: A,\n            contentLength: l,\n            h2stream: f,\n            expectsPayload: c,\n            body: n.stream(),\n            socket: e[kSocket],\n            header: \"\"\n        }) : writeBlob({\n            body: n,\n            client: e,\n            request: A,\n            contentLength: l,\n            expectsPayload: c,\n            h2stream: f,\n            header: \"\",\n            socket: e[kSocket]\n        }) : util$h.isStream(n) ? writeStream({\n            body: n,\n            client: e,\n            request: A,\n            contentLength: l,\n            expectsPayload: c,\n            socket: e[kSocket],\n            h2stream: f,\n            header: \"\"\n        }) : util$h.isIterable(n) ? writeIterable({\n            body: n,\n            client: e,\n            request: A,\n            contentLength: l,\n            expectsPayload: c,\n            header: \"\",\n            h2stream: f,\n            socket: e[kSocket]\n        }) : assert$9(!1) : A.onRequestSent();\n    }\n    o(k, \"writeBodyH2\");\n}\no(writeH2, \"writeH2\");\nfunction writeStream({ h2stream: e, body: A, client: t, request: n, socket: r, contentLength: s, header: i, expectsPayload: E }) {\n    assert$9(s !== 0 || t[kRunning$4] === 0, \"stream body cannot be pipelined\");\n    const Q = pipeline$1(A, e, (I)=>{\n        I ? (util$h.destroy(A, I), util$h.destroy(e, I)) : n.onRequestSent();\n    });\n    Q.on(\"data\", C), Q.once(\"end\", ()=>{\n        Q.removeListener(\"data\", C), util$h.destroy(Q);\n    });\n    function C(I) {\n        n.onBodySent(I);\n    }\n    o(C, \"onPipeData\");\n}\no(writeStream, \"writeStream\");\nasync function writeBlob({ h2stream: e, body: A, client: t, request: n, socket: r, contentLength: s, header: i, expectsPayload: E }) {\n    assert$9(s === A.size, \"blob body must have content length\");\n    try {\n        if (s != null && s !== A.size) throw new RequestContentLengthMismatchError;\n        const Q = Buffer.from(await A.arrayBuffer());\n        e.cork(), e.write(Q), e.uncork(), n.onBodySent(Q), n.onRequestSent(), E || (r[kReset] = !0), t[kResume$2]();\n    } catch  {\n        util$h.destroy(e);\n    }\n}\no(writeBlob, \"writeBlob\");\nasync function writeIterable({ h2stream: e, body: A, client: t, request: n, socket: r, contentLength: s, header: i, expectsPayload: E }) {\n    assert$9(s !== 0 || t[kRunning$4] === 0, \"iterator body cannot be pipelined\");\n    let Q = null;\n    function C() {\n        if (Q) {\n            const a = Q;\n            Q = null, a();\n        }\n    }\n    o(C, \"onDrain\");\n    const I = o(()=>new Promise((a, f)=>{\n            assert$9(Q === null), r[kError$1] ? f(r[kError$1]) : Q = a;\n        }), \"waitForDrain\");\n    e.on(\"close\", C).on(\"drain\", C);\n    try {\n        for await (const a of A){\n            if (r[kError$1]) throw r[kError$1];\n            const f = e.write(a);\n            n.onBodySent(a), f || await I();\n        }\n    } catch (a) {\n        e.destroy(a);\n    } finally{\n        n.onRequestSent(), e.end(), e.off(\"close\", C).off(\"drain\", C);\n    }\n}\no(writeIterable, \"writeIterable\");\nvar clientH2 = connectH2$1;\nconst util$g = util$m, { kBodyUsed } = symbols$4, assert$8 = require$$0__default, { InvalidArgumentError: InvalidArgumentError$f } = errors$1, EE = require$$0__default$3, redirectableStatusCodes = [\n    300,\n    301,\n    302,\n    303,\n    307,\n    308\n], kBody$1 = Symbol(\"body\"), it = class it {\n    constructor(A){\n        this[kBody$1] = A, this[kBodyUsed] = !1;\n    }\n    async *[Symbol.asyncIterator]() {\n        assert$8(!this[kBodyUsed], \"disturbed\"), this[kBodyUsed] = !0, yield* this[kBody$1];\n    }\n};\no(it, \"BodyAsyncIterable\");\nlet BodyAsyncIterable = it, RedirectHandler$1 = (Ue = class {\n    constructor(A, t, n, r){\n        if (t != null && (!Number.isInteger(t) || t < 0)) throw new InvalidArgumentError$f(\"maxRedirections must be a positive number\");\n        util$g.validateHandler(r, n.method, n.upgrade), this.dispatch = A, this.location = null, this.abort = null, this.opts = {\n            ...n,\n            maxRedirections: 0\n        }, this.maxRedirections = t, this.handler = r, this.history = [], this.redirectionLimitReached = !1, util$g.isStream(this.opts.body) ? (util$g.bodyLength(this.opts.body) === 0 && this.opts.body.on(\"data\", function() {\n            assert$8(!1);\n        }), typeof this.opts.body.readableDidRead != \"boolean\" && (this.opts.body[kBodyUsed] = !1, EE.prototype.on.call(this.opts.body, \"data\", function() {\n            this[kBodyUsed] = !0;\n        }))) : this.opts.body && typeof this.opts.body.pipeTo == \"function\" ? this.opts.body = new BodyAsyncIterable(this.opts.body) : this.opts.body && typeof this.opts.body != \"string\" && !ArrayBuffer.isView(this.opts.body) && util$g.isIterable(this.opts.body) && (this.opts.body = new BodyAsyncIterable(this.opts.body));\n    }\n    onConnect(A) {\n        this.abort = A, this.handler.onConnect(A, {\n            history: this.history\n        });\n    }\n    onUpgrade(A, t, n) {\n        this.handler.onUpgrade(A, t, n);\n    }\n    onError(A) {\n        this.handler.onError(A);\n    }\n    onHeaders(A, t, n, r) {\n        if (this.location = this.history.length >= this.maxRedirections || util$g.isDisturbed(this.opts.body) ? null : parseLocation(A, t), this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {\n            this.request && this.request.abort(new Error(\"max redirects\")), this.redirectionLimitReached = !0, this.abort(new Error(\"max redirects\"));\n            return;\n        }\n        if (this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location) return this.handler.onHeaders(A, t, n, r);\n        const { origin: s, pathname: i, search: E } = util$g.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), Q = E ? `${i}${E}` : i;\n        this.opts.headers = cleanRequestHeaders(this.opts.headers, A === 303, this.opts.origin !== s), this.opts.path = Q, this.opts.origin = s, this.opts.maxRedirections = 0, this.opts.query = null, A === 303 && this.opts.method !== \"HEAD\" && (this.opts.method = \"GET\", this.opts.body = null);\n    }\n    onData(A) {\n        if (!this.location) return this.handler.onData(A);\n    }\n    onComplete(A) {\n        this.location ? (this.location = null, this.abort = null, this.dispatch(this.opts, this)) : this.handler.onComplete(A);\n    }\n    onBodySent(A) {\n        this.handler.onBodySent && this.handler.onBodySent(A);\n    }\n}, o(Ue, \"RedirectHandler\"), Ue);\nfunction parseLocation(e, A) {\n    if (redirectableStatusCodes.indexOf(e) === -1) return null;\n    for(let t = 0; t < A.length; t += 2)if (A[t].length === 8 && util$g.headerNameToString(A[t]) === \"location\") return A[t + 1];\n}\no(parseLocation, \"parseLocation\");\nfunction shouldRemoveHeader(e, A, t) {\n    if (e.length === 4) return util$g.headerNameToString(e) === \"host\";\n    if (A && util$g.headerNameToString(e).startsWith(\"content-\")) return !0;\n    if (t && (e.length === 13 || e.length === 6 || e.length === 19)) {\n        const n = util$g.headerNameToString(e);\n        return n === \"authorization\" || n === \"cookie\" || n === \"proxy-authorization\";\n    }\n    return !1;\n}\no(shouldRemoveHeader, \"shouldRemoveHeader\");\nfunction cleanRequestHeaders(e, A, t) {\n    const n = [];\n    if (Array.isArray(e)) for(let r = 0; r < e.length; r += 2)shouldRemoveHeader(e[r], A, t) || n.push(e[r], e[r + 1]);\n    else if (e && typeof e == \"object\") for (const r of Object.keys(e))shouldRemoveHeader(r, A, t) || n.push(r, e[r]);\n    else assert$8(e == null, \"headers must be an object or an array\");\n    return n;\n}\no(cleanRequestHeaders, \"cleanRequestHeaders\");\nvar redirectHandler = RedirectHandler$1;\nconst RedirectHandler = redirectHandler;\nfunction createRedirectInterceptor$2({ maxRedirections: e }) {\n    return (A)=>o(function(n, r) {\n            const { maxRedirections: s = e } = n;\n            if (!s) return A(n, r);\n            const i = new RedirectHandler(A, s, n, r);\n            return n = {\n                ...n,\n                maxRedirections: 0\n            }, A(n, i);\n        }, \"Intercept\");\n}\no(createRedirectInterceptor$2, \"createRedirectInterceptor$2\");\nvar redirectInterceptor = createRedirectInterceptor$2;\nconst assert$7 = require$$0__default, net = require$$4__default, http = http__default, util$f = util$m, { channels } = diagnostics, Request = request$2, DispatcherBase$3 = dispatcherBase, { InvalidArgumentError: InvalidArgumentError$e, InformationalError, ClientDestroyedError } = errors$1, buildConnector$2 = connect$2, { kUrl: kUrl$2, kServerName, kClient: kClient$1, kBusy: kBusy$1, kConnect, kResuming, kRunning: kRunning$3, kPending: kPending$2, kSize: kSize$3, kQueue: kQueue$1, kConnected: kConnected$4, kConnecting, kNeedDrain: kNeedDrain$2, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections: kMaxRedirections$1, kMaxRequests, kCounter, kClose: kClose$5, kDestroy: kDestroy$3, kDispatch: kDispatch$2, kInterceptors: kInterceptors$3, kLocalAddress, kMaxResponseSize, kOnError, kHTTPContext, kMaxConcurrentStreams, kResume: kResume$1 } = symbols$4, connectH1 = clientH1, connectH2 = clientH2;\nlet deprecatedInterceptorWarned = !1;\nconst kClosedResolve$1 = Symbol(\"kClosedResolve\");\nfunction getPipelining(e) {\n    return e[kPipelining] ?? e[kHTTPContext]?.defaultPipelining ?? 1;\n}\no(getPipelining, \"getPipelining\");\nlet Client$3 = (be = class extends DispatcherBase$3 {\n    constructor(A, { interceptors: t, maxHeaderSize: n, headersTimeout: r, socketTimeout: s, requestTimeout: i, connectTimeout: E, bodyTimeout: Q, idleTimeout: C, keepAlive: I, keepAliveTimeout: a, maxKeepAliveTimeout: f, keepAliveMaxTimeout: h, keepAliveTimeoutThreshold: L, socketPath: c, pipelining: l, tls: S, strictContentLength: k, maxCachedSessions: w, maxRedirections: U, connect: M, maxRequestsPerClient: B, localAddress: D, maxResponseSize: G, autoSelectFamily: g, autoSelectFamilyAttemptTimeout: d, maxConcurrentStreams: F, allowH2: N } = {}){\n        if (super(), I !== void 0) throw new InvalidArgumentError$e(\"unsupported keepAlive, use pipelining=0 instead\");\n        if (s !== void 0) throw new InvalidArgumentError$e(\"unsupported socketTimeout, use headersTimeout & bodyTimeout instead\");\n        if (i !== void 0) throw new InvalidArgumentError$e(\"unsupported requestTimeout, use headersTimeout & bodyTimeout instead\");\n        if (C !== void 0) throw new InvalidArgumentError$e(\"unsupported idleTimeout, use keepAliveTimeout instead\");\n        if (f !== void 0) throw new InvalidArgumentError$e(\"unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead\");\n        if (n != null && !Number.isFinite(n)) throw new InvalidArgumentError$e(\"invalid maxHeaderSize\");\n        if (c != null && typeof c != \"string\") throw new InvalidArgumentError$e(\"invalid socketPath\");\n        if (E != null && (!Number.isFinite(E) || E < 0)) throw new InvalidArgumentError$e(\"invalid connectTimeout\");\n        if (a != null && (!Number.isFinite(a) || a <= 0)) throw new InvalidArgumentError$e(\"invalid keepAliveTimeout\");\n        if (h != null && (!Number.isFinite(h) || h <= 0)) throw new InvalidArgumentError$e(\"invalid keepAliveMaxTimeout\");\n        if (L != null && !Number.isFinite(L)) throw new InvalidArgumentError$e(\"invalid keepAliveTimeoutThreshold\");\n        if (r != null && (!Number.isInteger(r) || r < 0)) throw new InvalidArgumentError$e(\"headersTimeout must be a positive integer or zero\");\n        if (Q != null && (!Number.isInteger(Q) || Q < 0)) throw new InvalidArgumentError$e(\"bodyTimeout must be a positive integer or zero\");\n        if (M != null && typeof M != \"function\" && typeof M != \"object\") throw new InvalidArgumentError$e(\"connect must be a function or an object\");\n        if (U != null && (!Number.isInteger(U) || U < 0)) throw new InvalidArgumentError$e(\"maxRedirections must be a positive number\");\n        if (B != null && (!Number.isInteger(B) || B < 0)) throw new InvalidArgumentError$e(\"maxRequestsPerClient must be a positive number\");\n        if (D != null && (typeof D != \"string\" || net.isIP(D) === 0)) throw new InvalidArgumentError$e(\"localAddress must be valid string IP address\");\n        if (G != null && (!Number.isInteger(G) || G < -1)) throw new InvalidArgumentError$e(\"maxResponseSize must be a positive number\");\n        if (d != null && (!Number.isInteger(d) || d < -1)) throw new InvalidArgumentError$e(\"autoSelectFamilyAttemptTimeout must be a positive number\");\n        if (N != null && typeof N != \"boolean\") throw new InvalidArgumentError$e(\"allowH2 must be a valid boolean value\");\n        if (F != null && (typeof F != \"number\" || F < 1)) throw new InvalidArgumentError$e(\"maxConcurrentStreams must be a positive integer, greater than 0\");\n        typeof M != \"function\" && (M = buildConnector$2({\n            ...S,\n            maxCachedSessions: w,\n            allowH2: N,\n            socketPath: c,\n            timeout: E,\n            ...util$f.nodeHasAutoSelectFamily && g ? {\n                autoSelectFamily: g,\n                autoSelectFamilyAttemptTimeout: d\n            } : void 0,\n            ...M\n        })), t?.Client && Array.isArray(t.Client) ? (this[kInterceptors$3] = t.Client, deprecatedInterceptorWarned || (deprecatedInterceptorWarned = !0, process.emitWarning(\"Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.\", {\n            code: \"UNDICI-CLIENT-INTERCEPTOR-DEPRECATED\"\n        }))) : this[kInterceptors$3] = [\n            createRedirectInterceptor$1({\n                maxRedirections: U\n            })\n        ], this[kUrl$2] = util$f.parseOrigin(A), this[kConnector] = M, this[kPipelining] = l ?? 1, this[kMaxHeadersSize] = n || http.maxHeaderSize, this[kKeepAliveDefaultTimeout] = a ?? 4e3, this[kKeepAliveMaxTimeout] = h ?? 6e5, this[kKeepAliveTimeoutThreshold] = L ?? 1e3, this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout], this[kServerName] = null, this[kLocalAddress] = D ?? null, this[kResuming] = 0, this[kNeedDrain$2] = 0, this[kHostHeader] = `host: ${this[kUrl$2].hostname}${this[kUrl$2].port ? `:${this[kUrl$2].port}` : \"\"}\\r\n`, this[kBodyTimeout] = Q ?? 3e5, this[kHeadersTimeout] = r ?? 3e5, this[kStrictContentLength] = k ?? !0, this[kMaxRedirections$1] = U, this[kMaxRequests] = B, this[kClosedResolve$1] = null, this[kMaxResponseSize] = G > -1 ? G : -1, this[kMaxConcurrentStreams] = F ?? 100, this[kHTTPContext] = null, this[kQueue$1] = [], this[kRunningIdx] = 0, this[kPendingIdx] = 0, this[kResume$1] = (u)=>resume(this, u), this[kOnError] = (u)=>onError(this, u);\n    }\n    get pipelining() {\n        return this[kPipelining];\n    }\n    set pipelining(A) {\n        this[kPipelining] = A, this[kResume$1](!0);\n    }\n    get [kPending$2]() {\n        return this[kQueue$1].length - this[kPendingIdx];\n    }\n    get [kRunning$3]() {\n        return this[kPendingIdx] - this[kRunningIdx];\n    }\n    get [kSize$3]() {\n        return this[kQueue$1].length - this[kRunningIdx];\n    }\n    get [kConnected$4]() {\n        return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;\n    }\n    get [kBusy$1]() {\n        return !!(this[kHTTPContext]?.busy(null) || this[kSize$3] >= (getPipelining(this) || 1) || this[kPending$2] > 0);\n    }\n    [kConnect](A) {\n        connect$1(this), this.once(\"connect\", A);\n    }\n    [kDispatch$2](A, t) {\n        const n = A.origin || this[kUrl$2].origin, r = new Request(n, A, t);\n        return this[kQueue$1].push(r), this[kResuming] || (util$f.bodyLength(r.body) == null && util$f.isIterable(r.body) ? (this[kResuming] = 1, queueMicrotask(()=>resume(this))) : this[kResume$1](!0)), this[kResuming] && this[kNeedDrain$2] !== 2 && this[kBusy$1] && (this[kNeedDrain$2] = 2), this[kNeedDrain$2] < 2;\n    }\n    async [kClose$5]() {\n        return new Promise((A)=>{\n            this[kSize$3] ? this[kClosedResolve$1] = A : A(null);\n        });\n    }\n    async [kDestroy$3](A) {\n        return new Promise((t)=>{\n            const n = this[kQueue$1].splice(this[kPendingIdx]);\n            for(let s = 0; s < n.length; s++){\n                const i = n[s];\n                util$f.errorRequest(this, i, A);\n            }\n            const r = o(()=>{\n                this[kClosedResolve$1] && (this[kClosedResolve$1](), this[kClosedResolve$1] = null), t(null);\n            }, \"callback\");\n            this[kHTTPContext] ? (this[kHTTPContext].destroy(A, r), this[kHTTPContext] = null) : queueMicrotask(r), this[kResume$1]();\n        });\n    }\n}, o(be, \"Client\"), be);\nconst createRedirectInterceptor$1 = redirectInterceptor;\nfunction onError(e, A) {\n    if (e[kRunning$3] === 0 && A.code !== \"UND_ERR_INFO\" && A.code !== \"UND_ERR_SOCKET\") {\n        assert$7(e[kPendingIdx] === e[kRunningIdx]);\n        const t = e[kQueue$1].splice(e[kRunningIdx]);\n        for(let n = 0; n < t.length; n++){\n            const r = t[n];\n            util$f.errorRequest(e, r, A);\n        }\n        assert$7(e[kSize$3] === 0);\n    }\n}\no(onError, \"onError\");\nasync function connect$1(e) {\n    assert$7(!e[kConnecting]), assert$7(!e[kHTTPContext]);\n    let { host: A, hostname: t, protocol: n, port: r } = e[kUrl$2];\n    if (t[0] === \"[\") {\n        const s = t.indexOf(\"]\");\n        assert$7(s !== -1);\n        const i = t.substring(1, s);\n        assert$7(net.isIP(i)), t = i;\n    }\n    e[kConnecting] = !0, channels.beforeConnect.hasSubscribers && channels.beforeConnect.publish({\n        connectParams: {\n            host: A,\n            hostname: t,\n            protocol: n,\n            port: r,\n            version: e[kHTTPContext]?.version,\n            servername: e[kServerName],\n            localAddress: e[kLocalAddress]\n        },\n        connector: e[kConnector]\n    });\n    try {\n        const s = await new Promise((i, E)=>{\n            e[kConnector]({\n                host: A,\n                hostname: t,\n                protocol: n,\n                port: r,\n                servername: e[kServerName],\n                localAddress: e[kLocalAddress]\n            }, (Q, C)=>{\n                Q ? E(Q) : i(C);\n            });\n        });\n        if (e.destroyed) {\n            util$f.destroy(s.on(\"error\", ()=>{}), new ClientDestroyedError);\n            return;\n        }\n        assert$7(s);\n        try {\n            e[kHTTPContext] = s.alpnProtocol === \"h2\" ? await connectH2(e, s) : await connectH1(e, s);\n        } catch (i) {\n            throw s.destroy().on(\"error\", ()=>{}), i;\n        }\n        e[kConnecting] = !1, s[kCounter] = 0, s[kMaxRequests] = e[kMaxRequests], s[kClient$1] = e, s[kError] = null, channels.connected.hasSubscribers && channels.connected.publish({\n            connectParams: {\n                host: A,\n                hostname: t,\n                protocol: n,\n                port: r,\n                version: e[kHTTPContext]?.version,\n                servername: e[kServerName],\n                localAddress: e[kLocalAddress]\n            },\n            connector: e[kConnector],\n            socket: s\n        }), e.emit(\"connect\", e[kUrl$2], [\n            e\n        ]);\n    } catch (s) {\n        if (e.destroyed) return;\n        if (e[kConnecting] = !1, channels.connectError.hasSubscribers && channels.connectError.publish({\n            connectParams: {\n                host: A,\n                hostname: t,\n                protocol: n,\n                port: r,\n                version: e[kHTTPContext]?.version,\n                servername: e[kServerName],\n                localAddress: e[kLocalAddress]\n            },\n            connector: e[kConnector],\n            error: s\n        }), s.code === \"ERR_TLS_CERT_ALTNAME_INVALID\") for(assert$7(e[kRunning$3] === 0); e[kPending$2] > 0 && e[kQueue$1][e[kPendingIdx]].servername === e[kServerName];){\n            const i = e[kQueue$1][e[kPendingIdx]++];\n            util$f.errorRequest(e, i, s);\n        }\n        else onError(e, s);\n        e.emit(\"connectionError\", e[kUrl$2], [\n            e\n        ], s);\n    }\n    e[kResume$1]();\n}\no(connect$1, \"connect$1\");\nfunction emitDrain(e) {\n    e[kNeedDrain$2] = 0, e.emit(\"drain\", e[kUrl$2], [\n        e\n    ]);\n}\no(emitDrain, \"emitDrain\");\nfunction resume(e, A) {\n    e[kResuming] !== 2 && (e[kResuming] = 2, _resume(e, A), e[kResuming] = 0, e[kRunningIdx] > 256 && (e[kQueue$1].splice(0, e[kRunningIdx]), e[kPendingIdx] -= e[kRunningIdx], e[kRunningIdx] = 0));\n}\no(resume, \"resume\");\nfunction _resume(e, A) {\n    for(;;){\n        if (e.destroyed) {\n            assert$7(e[kPending$2] === 0);\n            return;\n        }\n        if (e[kClosedResolve$1] && !e[kSize$3]) {\n            e[kClosedResolve$1](), e[kClosedResolve$1] = null;\n            return;\n        }\n        if (e[kHTTPContext] && e[kHTTPContext].resume(), e[kBusy$1]) e[kNeedDrain$2] = 2;\n        else if (e[kNeedDrain$2] === 2) {\n            A ? (e[kNeedDrain$2] = 1, queueMicrotask(()=>emitDrain(e))) : emitDrain(e);\n            continue;\n        }\n        if (e[kPending$2] === 0 || e[kRunning$3] >= (getPipelining(e) || 1)) return;\n        const t = e[kQueue$1][e[kPendingIdx]];\n        if (e[kUrl$2].protocol === \"https:\" && e[kServerName] !== t.servername) {\n            if (e[kRunning$3] > 0) return;\n            e[kServerName] = t.servername, e[kHTTPContext]?.destroy(new InformationalError(\"servername changed\"), ()=>{\n                e[kHTTPContext] = null, resume(e);\n            });\n        }\n        if (e[kConnecting]) return;\n        if (!e[kHTTPContext]) {\n            connect$1(e);\n            return;\n        }\n        if (e[kHTTPContext].destroyed || e[kHTTPContext].busy(t)) return;\n        !t.aborted && e[kHTTPContext].write(t) ? e[kPendingIdx]++ : e[kQueue$1].splice(e[kPendingIdx], 1);\n    }\n}\no(_resume, \"_resume\");\nvar client = Client$3;\nconst kSize$2 = 2048, kMask = kSize$2 - 1, Qt = class Qt {\n    constructor(){\n        this.bottom = 0, this.top = 0, this.list = new Array(kSize$2), this.next = null;\n    }\n    isEmpty() {\n        return this.top === this.bottom;\n    }\n    isFull() {\n        return (this.top + 1 & kMask) === this.bottom;\n    }\n    push(A) {\n        this.list[this.top] = A, this.top = this.top + 1 & kMask;\n    }\n    shift() {\n        const A = this.list[this.bottom];\n        return A === void 0 ? null : (this.list[this.bottom] = void 0, this.bottom = this.bottom + 1 & kMask, A);\n    }\n};\no(Qt, \"FixedCircularBuffer\");\nlet FixedCircularBuffer = Qt;\nvar fixedQueue = (me = class {\n    constructor(){\n        this.head = this.tail = new FixedCircularBuffer;\n    }\n    isEmpty() {\n        return this.head.isEmpty();\n    }\n    push(A) {\n        this.head.isFull() && (this.head = this.head.next = new FixedCircularBuffer), this.head.push(A);\n    }\n    shift() {\n        const A = this.tail, t = A.shift();\n        return A.isEmpty() && A.next !== null && (this.tail = A.next), t;\n    }\n}, o(me, \"FixedQueue\"), me);\nconst { kFree: kFree$1, kConnected: kConnected$3, kPending: kPending$1, kQueued: kQueued$1, kRunning: kRunning$2, kSize: kSize$1 } = symbols$4, kPool = Symbol(\"pool\");\nlet PoolStats$1 = (Le = class {\n    constructor(A){\n        this[kPool] = A;\n    }\n    get connected() {\n        return this[kPool][kConnected$3];\n    }\n    get free() {\n        return this[kPool][kFree$1];\n    }\n    get pending() {\n        return this[kPool][kPending$1];\n    }\n    get queued() {\n        return this[kPool][kQueued$1];\n    }\n    get running() {\n        return this[kPool][kRunning$2];\n    }\n    get size() {\n        return this[kPool][kSize$1];\n    }\n}, o(Le, \"PoolStats\"), Le);\nvar poolStats = PoolStats$1;\nconst DispatcherBase$2 = dispatcherBase, FixedQueue = fixedQueue, { kConnected: kConnected$2, kSize, kRunning: kRunning$1, kPending, kQueued, kBusy, kFree, kUrl: kUrl$1, kClose: kClose$4, kDestroy: kDestroy$2, kDispatch: kDispatch$1 } = symbols$4, PoolStats = poolStats, kClients$2 = Symbol(\"clients\"), kNeedDrain$1 = Symbol(\"needDrain\"), kQueue = Symbol(\"queue\"), kClosedResolve = Symbol(\"closed resolve\"), kOnDrain$1 = Symbol(\"onDrain\"), kOnConnect$1 = Symbol(\"onConnect\"), kOnDisconnect$1 = Symbol(\"onDisconnect\"), kOnConnectionError$1 = Symbol(\"onConnectionError\"), kGetDispatcher$1 = Symbol(\"get dispatcher\"), kAddClient$1 = Symbol(\"add client\"), kRemoveClient = Symbol(\"remove client\"), kStats = Symbol(\"stats\");\nlet PoolBase$1 = (Me = class extends DispatcherBase$2 {\n    constructor(){\n        super(), this[kQueue] = new FixedQueue, this[kClients$2] = [], this[kQueued] = 0;\n        const A = this;\n        this[kOnDrain$1] = o(function(n, r) {\n            const s = A[kQueue];\n            let i = !1;\n            for(; !i;){\n                const E = s.shift();\n                if (!E) break;\n                A[kQueued]--, i = !this.dispatch(E.opts, E.handler);\n            }\n            this[kNeedDrain$1] = i, !this[kNeedDrain$1] && A[kNeedDrain$1] && (A[kNeedDrain$1] = !1, A.emit(\"drain\", n, [\n                A,\n                ...r\n            ])), A[kClosedResolve] && s.isEmpty() && Promise.all(A[kClients$2].map((E)=>E.close())).then(A[kClosedResolve]);\n        }, \"onDrain\"), this[kOnConnect$1] = (t, n)=>{\n            A.emit(\"connect\", t, [\n                A,\n                ...n\n            ]);\n        }, this[kOnDisconnect$1] = (t, n, r)=>{\n            A.emit(\"disconnect\", t, [\n                A,\n                ...n\n            ], r);\n        }, this[kOnConnectionError$1] = (t, n, r)=>{\n            A.emit(\"connectionError\", t, [\n                A,\n                ...n\n            ], r);\n        }, this[kStats] = new PoolStats(this);\n    }\n    get [kBusy]() {\n        return this[kNeedDrain$1];\n    }\n    get [kConnected$2]() {\n        return this[kClients$2].filter((A)=>A[kConnected$2]).length;\n    }\n    get [kFree]() {\n        return this[kClients$2].filter((A)=>A[kConnected$2] && !A[kNeedDrain$1]).length;\n    }\n    get [kPending]() {\n        let A = this[kQueued];\n        for (const { [kPending]: t } of this[kClients$2])A += t;\n        return A;\n    }\n    get [kRunning$1]() {\n        let A = 0;\n        for (const { [kRunning$1]: t } of this[kClients$2])A += t;\n        return A;\n    }\n    get [kSize]() {\n        let A = this[kQueued];\n        for (const { [kSize]: t } of this[kClients$2])A += t;\n        return A;\n    }\n    get stats() {\n        return this[kStats];\n    }\n    async [kClose$4]() {\n        return this[kQueue].isEmpty() ? Promise.all(this[kClients$2].map((A)=>A.close())) : new Promise((A)=>{\n            this[kClosedResolve] = A;\n        });\n    }\n    async [kDestroy$2](A) {\n        for(;;){\n            const t = this[kQueue].shift();\n            if (!t) break;\n            t.handler.onError(A);\n        }\n        return Promise.all(this[kClients$2].map((t)=>t.destroy(A)));\n    }\n    [kDispatch$1](A, t) {\n        const n = this[kGetDispatcher$1]();\n        return n ? n.dispatch(A, t) || (n[kNeedDrain$1] = !0, this[kNeedDrain$1] = !this[kGetDispatcher$1]()) : (this[kNeedDrain$1] = !0, this[kQueue].push({\n            opts: A,\n            handler: t\n        }), this[kQueued]++), !this[kNeedDrain$1];\n    }\n    [kAddClient$1](A) {\n        return A.on(\"drain\", this[kOnDrain$1]).on(\"connect\", this[kOnConnect$1]).on(\"disconnect\", this[kOnDisconnect$1]).on(\"connectionError\", this[kOnConnectionError$1]), this[kClients$2].push(A), this[kNeedDrain$1] && queueMicrotask(()=>{\n            this[kNeedDrain$1] && this[kOnDrain$1](A[kUrl$1], [\n                this,\n                A\n            ]);\n        }), this;\n    }\n    [kRemoveClient](A) {\n        A.close(()=>{\n            const t = this[kClients$2].indexOf(A);\n            t !== -1 && this[kClients$2].splice(t, 1);\n        }), this[kNeedDrain$1] = this[kClients$2].some((t)=>!t[kNeedDrain$1] && t.closed !== !0 && t.destroyed !== !0);\n    }\n}, o(Me, \"PoolBase\"), Me);\nvar poolBase = {\n    PoolBase: PoolBase$1,\n    kClients: kClients$2,\n    kNeedDrain: kNeedDrain$1,\n    kAddClient: kAddClient$1,\n    kRemoveClient,\n    kGetDispatcher: kGetDispatcher$1\n};\nconst { PoolBase, kClients: kClients$1, kNeedDrain, kAddClient, kGetDispatcher } = poolBase, Client$2 = client, { InvalidArgumentError: InvalidArgumentError$d } = errors$1, util$e = util$m, { kUrl, kInterceptors: kInterceptors$2 } = symbols$4, buildConnector$1 = connect$2, kOptions$1 = Symbol(\"options\"), kConnections = Symbol(\"connections\"), kFactory$1 = Symbol(\"factory\");\nfunction defaultFactory$2(e, A) {\n    return new Client$2(e, A);\n}\no(defaultFactory$2, \"defaultFactory$2\");\nlet Pool$3 = (Ye = class extends PoolBase {\n    constructor(A, { connections: t, factory: n = defaultFactory$2, connect: r, connectTimeout: s, tls: i, maxCachedSessions: E, socketPath: Q, autoSelectFamily: C, autoSelectFamilyAttemptTimeout: I, allowH2: a, ...f } = {}){\n        if (super(), t != null && (!Number.isFinite(t) || t < 0)) throw new InvalidArgumentError$d(\"invalid connections\");\n        if (typeof n != \"function\") throw new InvalidArgumentError$d(\"factory must be a function.\");\n        if (r != null && typeof r != \"function\" && typeof r != \"object\") throw new InvalidArgumentError$d(\"connect must be a function or an object\");\n        typeof r != \"function\" && (r = buildConnector$1({\n            ...i,\n            maxCachedSessions: E,\n            allowH2: a,\n            socketPath: Q,\n            timeout: s,\n            ...util$e.nodeHasAutoSelectFamily && C ? {\n                autoSelectFamily: C,\n                autoSelectFamilyAttemptTimeout: I\n            } : void 0,\n            ...r\n        })), this[kInterceptors$2] = f.interceptors?.Pool && Array.isArray(f.interceptors.Pool) ? f.interceptors.Pool : [], this[kConnections] = t || null, this[kUrl] = util$e.parseOrigin(A), this[kOptions$1] = {\n            ...util$e.deepClone(f),\n            connect: r,\n            allowH2: a\n        }, this[kOptions$1].interceptors = f.interceptors ? {\n            ...f.interceptors\n        } : void 0, this[kFactory$1] = n;\n    }\n    [kGetDispatcher]() {\n        for (const A of this[kClients$1])if (!A[kNeedDrain]) return A;\n        if (!this[kConnections] || this[kClients$1].length < this[kConnections]) {\n            const A = this[kFactory$1](this[kUrl], this[kOptions$1]);\n            return this[kAddClient](A), A;\n        }\n    }\n}, o(Ye, \"Pool\"), Ye);\nvar pool = Pool$3;\nconst { InvalidArgumentError: InvalidArgumentError$c } = errors$1, { kClients, kRunning, kClose: kClose$3, kDestroy: kDestroy$1, kDispatch, kInterceptors: kInterceptors$1 } = symbols$4, DispatcherBase$1 = dispatcherBase, Pool$2 = pool, Client$1 = client, util$d = util$m, createRedirectInterceptor = redirectInterceptor, kOnConnect = Symbol(\"onConnect\"), kOnDisconnect = Symbol(\"onDisconnect\"), kOnConnectionError = Symbol(\"onConnectionError\"), kMaxRedirections = Symbol(\"maxRedirections\"), kOnDrain = Symbol(\"onDrain\"), kFactory = Symbol(\"factory\"), kOptions = Symbol(\"options\");\nfunction defaultFactory$1(e, A) {\n    return A && A.connections === 1 ? new Client$1(e, A) : new Pool$2(e, A);\n}\no(defaultFactory$1, \"defaultFactory$1\");\nlet Agent$3 = (Je = class extends DispatcherBase$1 {\n    constructor({ factory: A = defaultFactory$1, maxRedirections: t = 0, connect: n, ...r } = {}){\n        if (super(), typeof A != \"function\") throw new InvalidArgumentError$c(\"factory must be a function.\");\n        if (n != null && typeof n != \"function\" && typeof n != \"object\") throw new InvalidArgumentError$c(\"connect must be a function or an object\");\n        if (!Number.isInteger(t) || t < 0) throw new InvalidArgumentError$c(\"maxRedirections must be a positive number\");\n        n && typeof n != \"function\" && (n = {\n            ...n\n        }), this[kInterceptors$1] = r.interceptors?.Agent && Array.isArray(r.interceptors.Agent) ? r.interceptors.Agent : [\n            createRedirectInterceptor({\n                maxRedirections: t\n            })\n        ], this[kOptions] = {\n            ...util$d.deepClone(r),\n            connect: n\n        }, this[kOptions].interceptors = r.interceptors ? {\n            ...r.interceptors\n        } : void 0, this[kMaxRedirections] = t, this[kFactory] = A, this[kClients] = new Map, this[kOnDrain] = (s, i)=>{\n            this.emit(\"drain\", s, [\n                this,\n                ...i\n            ]);\n        }, this[kOnConnect] = (s, i)=>{\n            this.emit(\"connect\", s, [\n                this,\n                ...i\n            ]);\n        }, this[kOnDisconnect] = (s, i, E)=>{\n            this.emit(\"disconnect\", s, [\n                this,\n                ...i\n            ], E);\n        }, this[kOnConnectionError] = (s, i, E)=>{\n            this.emit(\"connectionError\", s, [\n                this,\n                ...i\n            ], E);\n        };\n    }\n    get [kRunning]() {\n        let A = 0;\n        for (const t of this[kClients].values())A += t[kRunning];\n        return A;\n    }\n    [kDispatch](A, t) {\n        let n;\n        if (A.origin && (typeof A.origin == \"string\" || A.origin instanceof URL)) n = String(A.origin);\n        else throw new InvalidArgumentError$c(\"opts.origin must be a non-empty string or URL.\");\n        let r = this[kClients].get(n);\n        return r || (r = this[kFactory](A.origin, this[kOptions]).on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]), this[kClients].set(n, r)), r.dispatch(A, t);\n    }\n    async [kClose$3]() {\n        const A = [];\n        for (const t of this[kClients].values())A.push(t.close());\n        this[kClients].clear(), await Promise.all(A);\n    }\n    async [kDestroy$1](A) {\n        const t = [];\n        for (const n of this[kClients].values())t.push(n.destroy(A));\n        this[kClients].clear(), await Promise.all(t);\n    }\n}, o(Je, \"Agent\"), Je);\nvar agent = Agent$3;\nconst { kProxy, kClose: kClose$2, kDestroy, kInterceptors } = symbols$4, { URL: URL$1 } = require$$1__default, Agent$2 = agent, Pool$1 = pool, DispatcherBase = dispatcherBase, { InvalidArgumentError: InvalidArgumentError$b, RequestAbortedError: RequestAbortedError$3, SecureProxyConnectionError } = errors$1, buildConnector = connect$2, kAgent = Symbol(\"proxy agent\"), kClient = Symbol(\"proxy client\"), kProxyHeaders = Symbol(\"proxy headers\"), kRequestTls = Symbol(\"request tls settings\"), kProxyTls = Symbol(\"proxy tls settings\"), kConnectEndpoint = Symbol(\"connect endpoint function\");\nfunction defaultProtocolPort(e) {\n    return e === \"https:\" ? 443 : 80;\n}\no(defaultProtocolPort, \"defaultProtocolPort\");\nfunction defaultFactory(e, A) {\n    return new Pool$1(e, A);\n}\no(defaultFactory, \"defaultFactory\");\nlet ProxyAgent$1 = (Ge = class extends DispatcherBase {\n    constructor(t){\n        super();\n        CA(this, Oe);\n        if (!t || typeof t == \"object\" && !(t instanceof URL$1) && !t.uri) throw new InvalidArgumentError$b(\"Proxy uri is mandatory\");\n        const { clientFactory: n = defaultFactory } = t;\n        if (typeof n != \"function\") throw new InvalidArgumentError$b(\"Proxy opts.clientFactory must be a function.\");\n        const r = kA(this, Oe, Rt).call(this, t), { href: s, origin: i, port: E, protocol: Q, username: C, password: I, hostname: a } = r;\n        if (this[kProxy] = {\n            uri: s,\n            protocol: Q\n        }, this[kInterceptors] = t.interceptors?.ProxyAgent && Array.isArray(t.interceptors.ProxyAgent) ? t.interceptors.ProxyAgent : [], this[kRequestTls] = t.requestTls, this[kProxyTls] = t.proxyTls, this[kProxyHeaders] = t.headers || {}, t.auth && t.token) throw new InvalidArgumentError$b(\"opts.auth cannot be used in combination with opts.token\");\n        t.auth ? this[kProxyHeaders][\"proxy-authorization\"] = `Basic ${t.auth}` : t.token ? this[kProxyHeaders][\"proxy-authorization\"] = t.token : C && I && (this[kProxyHeaders][\"proxy-authorization\"] = `Basic ${Buffer.from(`${decodeURIComponent(C)}:${decodeURIComponent(I)}`).toString(\"base64\")}`);\n        const f = buildConnector({\n            ...t.proxyTls\n        });\n        this[kConnectEndpoint] = buildConnector({\n            ...t.requestTls\n        }), this[kClient] = n(r, {\n            connect: f\n        }), this[kAgent] = new Agent$2({\n            ...t,\n            connect: async (h, L)=>{\n                let c = h.host;\n                h.port || (c += `:${defaultProtocolPort(h.protocol)}`);\n                try {\n                    const { socket: l, statusCode: S } = await this[kClient].connect({\n                        origin: i,\n                        port: E,\n                        path: c,\n                        signal: h.signal,\n                        headers: {\n                            ...this[kProxyHeaders],\n                            host: h.host\n                        },\n                        servername: this[kProxyTls]?.servername || a\n                    });\n                    if (S !== 200 && (l.on(\"error\", ()=>{}).destroy(), L(new RequestAbortedError$3(`Proxy response (${S}) !== 200 when HTTP Tunneling`))), h.protocol !== \"https:\") {\n                        L(null, l);\n                        return;\n                    }\n                    let k;\n                    this[kRequestTls] ? k = this[kRequestTls].servername : k = h.servername, this[kConnectEndpoint]({\n                        ...h,\n                        servername: k,\n                        httpSocket: l\n                    }, L);\n                } catch (l) {\n                    l.code === \"ERR_TLS_CERT_ALTNAME_INVALID\" ? L(new SecureProxyConnectionError(l)) : L(l);\n                }\n            }\n        });\n    }\n    dispatch(t, n) {\n        const r = buildHeaders(t.headers);\n        if (throwIfProxyAuthIsSent(r), r && !(\"host\" in r) && !(\"Host\" in r)) {\n            const { host: s } = new URL$1(t.origin);\n            r.host = s;\n        }\n        return this[kAgent].dispatch({\n            ...t,\n            headers: r\n        }, n);\n    }\n    async [kClose$2]() {\n        await this[kAgent].close(), await this[kClient].close();\n    }\n    async [kDestroy]() {\n        await this[kAgent].destroy(), await this[kClient].destroy();\n    }\n}, Oe = new WeakSet, Rt = o(function(t) {\n    return typeof t == \"string\" ? new URL$1(t) : t instanceof URL$1 ? t : new URL$1(t.uri);\n}, \"#getUrl\"), o(Ge, \"ProxyAgent\"), Ge);\nfunction buildHeaders(e) {\n    if (Array.isArray(e)) {\n        const A = {};\n        for(let t = 0; t < e.length; t += 2)A[e[t]] = e[t + 1];\n        return A;\n    }\n    return e;\n}\no(buildHeaders, \"buildHeaders\");\nfunction throwIfProxyAuthIsSent(e) {\n    if (e && Object.keys(e).find((t)=>t.toLowerCase() === \"proxy-authorization\")) throw new InvalidArgumentError$b(\"Proxy-Authorization should be sent in ProxyAgent constructor\");\n}\no(throwIfProxyAuthIsSent, \"throwIfProxyAuthIsSent\");\nvar proxyAgent = ProxyAgent$1, api$1 = {}, apiRequest = {\n    exports: {}\n};\nconst assert$6 = require$$0__default, { Readable: Readable$2 } = Stream__default, { RequestAbortedError: RequestAbortedError$2, NotSupportedError, InvalidArgumentError: InvalidArgumentError$a, AbortError } = errors$1, util$c = util$m, { ReadableStreamFrom } = util$m, kConsume = Symbol(\"kConsume\"), kReading = Symbol(\"kReading\"), kBody = Symbol(\"kBody\"), kAbort = Symbol(\"kAbort\"), kContentType = Symbol(\"kContentType\"), kContentLength$1 = Symbol(\"kContentLength\"), noop = o(()=>{}, \"noop\"), Et = class Et extends Readable$2 {\n    constructor({ resume: A, abort: t, contentType: n = \"\", contentLength: r, highWaterMark: s = 64 * 1024 }){\n        super({\n            autoDestroy: !0,\n            read: A,\n            highWaterMark: s\n        }), this._readableState.dataEmitted = !1, this[kAbort] = t, this[kConsume] = null, this[kBody] = null, this[kContentType] = n, this[kContentLength$1] = r, this[kReading] = !1;\n    }\n    destroy(A) {\n        return !A && !this._readableState.endEmitted && (A = new RequestAbortedError$2), A && this[kAbort](), super.destroy(A);\n    }\n    _destroy(A, t) {\n        queueMicrotask(()=>{\n            t(A);\n        });\n    }\n    on(A, ...t) {\n        return (A === \"data\" || A === \"readable\") && (this[kReading] = !0), super.on(A, ...t);\n    }\n    addListener(A, ...t) {\n        return this.on(A, ...t);\n    }\n    off(A, ...t) {\n        const n = super.off(A, ...t);\n        return (A === \"data\" || A === \"readable\") && (this[kReading] = this.listenerCount(\"data\") > 0 || this.listenerCount(\"readable\") > 0), n;\n    }\n    removeListener(A, ...t) {\n        return this.off(A, ...t);\n    }\n    push(A) {\n        return this[kConsume] && A !== null ? (consumePush(this[kConsume], A), this[kReading] ? super.push(A) : !0) : super.push(A);\n    }\n    async text() {\n        return consume(this, \"text\");\n    }\n    async json() {\n        return consume(this, \"json\");\n    }\n    async blob() {\n        return consume(this, \"blob\");\n    }\n    async arrayBuffer() {\n        return consume(this, \"arrayBuffer\");\n    }\n    async formData() {\n        throw new NotSupportedError;\n    }\n    get bodyUsed() {\n        return util$c.isDisturbed(this);\n    }\n    get body() {\n        return this[kBody] || (this[kBody] = ReadableStreamFrom(this), this[kConsume] && (this[kBody].getReader(), assert$6(this[kBody].locked))), this[kBody];\n    }\n    async dump(A) {\n        let t = Number.isFinite(A?.limit) ? A.limit : 131072;\n        const n = A?.signal;\n        if (n != null && (typeof n != \"object\" || !(\"aborted\" in n))) throw new InvalidArgumentError$a(\"signal must be an AbortSignal\");\n        return n?.throwIfAborted(), this._readableState.closeEmitted ? null : await new Promise((r, s)=>{\n            this[kContentLength$1] > t && this.destroy(new AbortError);\n            const i = o(()=>{\n                this.destroy(n.reason ?? new AbortError);\n            }, \"onAbort\");\n            n?.addEventListener(\"abort\", i), this.on(\"close\", function() {\n                n?.removeEventListener(\"abort\", i), n?.aborted ? s(n.reason ?? new AbortError) : r(null);\n            }).on(\"error\", noop).on(\"data\", function(E) {\n                t -= E.length, t <= 0 && this.destroy();\n            }).resume();\n        });\n    }\n};\no(Et, \"BodyReadable\");\nlet BodyReadable = Et;\nfunction isLocked(e) {\n    return e[kBody] && e[kBody].locked === !0 || e[kConsume];\n}\no(isLocked, \"isLocked\");\nfunction isUnusable(e) {\n    return util$c.isDisturbed(e) || isLocked(e);\n}\no(isUnusable, \"isUnusable\");\nasync function consume(e, A) {\n    return assert$6(!e[kConsume]), new Promise((t, n)=>{\n        if (isUnusable(e)) {\n            const r = e._readableState;\n            r.destroyed && r.closeEmitted === !1 ? e.on(\"error\", (s)=>{\n                n(s);\n            }).on(\"close\", ()=>{\n                n(new TypeError(\"unusable\"));\n            }) : n(r.errored ?? new TypeError(\"unusable\"));\n        } else queueMicrotask(()=>{\n            e[kConsume] = {\n                type: A,\n                stream: e,\n                resolve: t,\n                reject: n,\n                length: 0,\n                body: []\n            }, e.on(\"error\", function(r) {\n                consumeFinish(this[kConsume], r);\n            }).on(\"close\", function() {\n                this[kConsume].body !== null && consumeFinish(this[kConsume], new RequestAbortedError$2);\n            }), consumeStart(e[kConsume]);\n        });\n    });\n}\no(consume, \"consume\");\nfunction consumeStart(e) {\n    if (e.body === null) return;\n    const { _readableState: A } = e.stream;\n    if (A.bufferIndex) {\n        const t = A.bufferIndex, n = A.buffer.length;\n        for(let r = t; r < n; r++)consumePush(e, A.buffer[r]);\n    } else for (const t of A.buffer)consumePush(e, t);\n    for(A.endEmitted ? consumeEnd(this[kConsume]) : e.stream.on(\"end\", function() {\n        consumeEnd(this[kConsume]);\n    }), e.stream.resume(); e.stream.read() != null;);\n}\no(consumeStart, \"consumeStart\");\nfunction chunksDecode$1(e, A) {\n    if (e.length === 0 || A === 0) return \"\";\n    const t = e.length === 1 ? e[0] : Buffer.concat(e, A), n = t.length, r = n > 2 && t[0] === 239 && t[1] === 187 && t[2] === 191 ? 3 : 0;\n    return t.utf8Slice(r, n);\n}\no(chunksDecode$1, \"chunksDecode$1\");\nfunction consumeEnd(e) {\n    const { type: A, body: t, resolve: n, stream: r, length: s } = e;\n    try {\n        if (A === \"text\") n(chunksDecode$1(t, s));\n        else if (A === \"json\") n(JSON.parse(chunksDecode$1(t, s)));\n        else if (A === \"arrayBuffer\") {\n            const i = new Uint8Array(s);\n            let E = 0;\n            for (const Q of t)i.set(Q, E), E += Q.byteLength;\n            n(i.buffer);\n        } else A === \"blob\" && n(new Blob(t, {\n            type: r[kContentType]\n        }));\n        consumeFinish(e);\n    } catch (i) {\n        r.destroy(i);\n    }\n}\no(consumeEnd, \"consumeEnd\");\nfunction consumePush(e, A) {\n    e.length += A.length, e.body.push(A);\n}\no(consumePush, \"consumePush\");\nfunction consumeFinish(e, A) {\n    e.body !== null && (A ? e.reject(A) : e.resolve(), e.type = null, e.stream = null, e.resolve = null, e.reject = null, e.length = 0, e.body = null);\n}\no(consumeFinish, \"consumeFinish\");\nvar readable = {\n    Readable: BodyReadable,\n    chunksDecode: chunksDecode$1\n};\nconst assert$5 = require$$0__default, { ResponseStatusCodeError } = errors$1, { chunksDecode } = readable, CHUNK_LIMIT = 128 * 1024;\nasync function getResolveErrorBodyCallback$2({ callback: e, body: A, contentType: t, statusCode: n, statusMessage: r, headers: s }) {\n    assert$5(A);\n    let i = [], E = 0;\n    for await (const a of A)if (i.push(a), E += a.length, E > CHUNK_LIMIT) {\n        i = null;\n        break;\n    }\n    const Q = `Response status code ${n}${r ? `: ${r}` : \"\"}`;\n    if (n === 204 || !t || !i) {\n        queueMicrotask(()=>e(new ResponseStatusCodeError(Q, n, s)));\n        return;\n    }\n    const C = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    let I;\n    try {\n        isContentTypeApplicationJson(t) ? I = JSON.parse(chunksDecode(i, E)) : isContentTypeText(t) && (I = chunksDecode(i, E));\n    } catch  {} finally{\n        Error.stackTraceLimit = C;\n    }\n    queueMicrotask(()=>e(new ResponseStatusCodeError(Q, n, s, I)));\n}\no(getResolveErrorBodyCallback$2, \"getResolveErrorBodyCallback$2\");\nconst isContentTypeApplicationJson = o((e)=>e.length > 15 && e[11] === \"/\" && e[0] === \"a\" && e[1] === \"p\" && e[2] === \"p\" && e[3] === \"l\" && e[4] === \"i\" && e[5] === \"c\" && e[6] === \"a\" && e[7] === \"t\" && e[8] === \"i\" && e[9] === \"o\" && e[10] === \"n\" && e[12] === \"j\" && e[13] === \"s\" && e[14] === \"o\" && e[15] === \"n\", \"isContentTypeApplicationJson\"), isContentTypeText = o((e)=>e.length > 4 && e[4] === \"/\" && e[0] === \"t\" && e[1] === \"e\" && e[2] === \"x\" && e[3] === \"t\", \"isContentTypeText\");\nvar util$b = {\n    getResolveErrorBodyCallback: getResolveErrorBodyCallback$2,\n    isContentTypeApplicationJson,\n    isContentTypeText\n};\nconst { addAbortListener } = util$m, { RequestAbortedError: RequestAbortedError$1 } = errors$1, kListener = Symbol(\"kListener\"), kSignal = Symbol(\"kSignal\");\nfunction abort(e) {\n    e.abort ? e.abort(e[kSignal]?.reason) : e.reason = e[kSignal]?.reason ?? new RequestAbortedError$1, removeSignal$5(e);\n}\no(abort, \"abort\");\nfunction addSignal$5(e, A) {\n    if (e.reason = null, e[kSignal] = null, e[kListener] = null, !!A) {\n        if (A.aborted) {\n            abort(e);\n            return;\n        }\n        e[kSignal] = A, e[kListener] = ()=>{\n            abort(e);\n        }, addAbortListener(e[kSignal], e[kListener]);\n    }\n}\no(addSignal$5, \"addSignal$5\");\nfunction removeSignal$5(e) {\n    e[kSignal] && (\"removeEventListener\" in e[kSignal] ? e[kSignal].removeEventListener(\"abort\", e[kListener]) : e[kSignal].removeListener(\"abort\", e[kListener]), e[kSignal] = null, e[kListener] = null);\n}\no(removeSignal$5, \"removeSignal$5\");\nvar abortSignal = {\n    addSignal: addSignal$5,\n    removeSignal: removeSignal$5\n};\nconst assert$4 = require$$0__default, { Readable: Readable$1 } = readable, { InvalidArgumentError: InvalidArgumentError$9 } = errors$1, util$a = util$m, { getResolveErrorBodyCallback: getResolveErrorBodyCallback$1 } = util$b, { AsyncResource: AsyncResource$4 } = require$$5__default$1, { addSignal: addSignal$4, removeSignal: removeSignal$4 } = abortSignal, gt = class gt extends AsyncResource$4 {\n    constructor(A, t){\n        if (!A || typeof A != \"object\") throw new InvalidArgumentError$9(\"invalid opts\");\n        const { signal: n, method: r, opaque: s, body: i, onInfo: E, responseHeaders: Q, throwOnError: C, highWaterMark: I } = A;\n        try {\n            if (typeof t != \"function\") throw new InvalidArgumentError$9(\"invalid callback\");\n            if (I && (typeof I != \"number\" || I < 0)) throw new InvalidArgumentError$9(\"invalid highWaterMark\");\n            if (n && typeof n.on != \"function\" && typeof n.addEventListener != \"function\") throw new InvalidArgumentError$9(\"signal must be an EventEmitter or EventTarget\");\n            if (r === \"CONNECT\") throw new InvalidArgumentError$9(\"invalid method\");\n            if (E && typeof E != \"function\") throw new InvalidArgumentError$9(\"invalid onInfo callback\");\n            super(\"UNDICI_REQUEST\");\n        } catch (a) {\n            throw util$a.isStream(i) && util$a.destroy(i.on(\"error\", util$a.nop), a), a;\n        }\n        this.responseHeaders = Q || null, this.opaque = s || null, this.callback = t, this.res = null, this.abort = null, this.body = i, this.trailers = {}, this.context = null, this.onInfo = E || null, this.throwOnError = C, this.highWaterMark = I, util$a.isStream(i) && i.on(\"error\", (a)=>{\n            this.onError(a);\n        }), addSignal$4(this, n);\n    }\n    onConnect(A, t) {\n        if (this.reason) {\n            A(this.reason);\n            return;\n        }\n        assert$4(this.callback), this.abort = A, this.context = t;\n    }\n    onHeaders(A, t, n, r) {\n        const { callback: s, opaque: i, abort: E, context: Q, responseHeaders: C, highWaterMark: I } = this, a = C === \"raw\" ? util$a.parseRawHeaders(t) : util$a.parseHeaders(t);\n        if (A < 200) {\n            this.onInfo && this.onInfo({\n                statusCode: A,\n                headers: a\n            });\n            return;\n        }\n        const f = C === \"raw\" ? util$a.parseHeaders(t) : a, h = f[\"content-type\"], L = f[\"content-length\"], c = new Readable$1({\n            resume: n,\n            abort: E,\n            contentType: h,\n            contentLength: L,\n            highWaterMark: I\n        });\n        this.callback = null, this.res = c, s !== null && (this.throwOnError && A >= 400 ? this.runInAsyncScope(getResolveErrorBodyCallback$1, null, {\n            callback: s,\n            body: c,\n            contentType: h,\n            statusCode: A,\n            statusMessage: r,\n            headers: a\n        }) : this.runInAsyncScope(s, null, null, {\n            statusCode: A,\n            headers: a,\n            trailers: this.trailers,\n            opaque: i,\n            body: c,\n            context: Q\n        }));\n    }\n    onData(A) {\n        const { res: t } = this;\n        return t.push(A);\n    }\n    onComplete(A) {\n        const { res: t } = this;\n        removeSignal$4(this), util$a.parseHeaders(A, this.trailers), t.push(null);\n    }\n    onError(A) {\n        const { res: t, callback: n, body: r, opaque: s } = this;\n        removeSignal$4(this), n && (this.callback = null, queueMicrotask(()=>{\n            this.runInAsyncScope(n, null, A, {\n                opaque: s\n            });\n        })), t && (this.res = null, queueMicrotask(()=>{\n            util$a.destroy(t, A);\n        })), r && (this.body = null, util$a.destroy(r, A));\n    }\n};\no(gt, \"RequestHandler\");\nlet RequestHandler = gt;\nfunction request$1(e, A) {\n    if (A === void 0) return new Promise((t, n)=>{\n        request$1.call(this, e, (r, s)=>r ? n(r) : t(s));\n    });\n    try {\n        this.dispatch(e, new RequestHandler(e, A));\n    } catch (t) {\n        if (typeof A != \"function\") throw t;\n        const n = e?.opaque;\n        queueMicrotask(()=>A(t, {\n                opaque: n\n            }));\n    }\n}\no(request$1, \"request$1\"), apiRequest.exports = request$1, apiRequest.exports.RequestHandler = RequestHandler;\nvar apiRequestExports = apiRequest.exports;\nconst assert$3 = require$$0__default, { finished, PassThrough: PassThrough$1 } = Stream__default, { InvalidArgumentError: InvalidArgumentError$8, InvalidReturnValueError: InvalidReturnValueError$1 } = errors$1, util$9 = util$m, { getResolveErrorBodyCallback } = util$b, { AsyncResource: AsyncResource$3 } = require$$5__default$1, { addSignal: addSignal$3, removeSignal: removeSignal$3 } = abortSignal, Bt = class Bt extends AsyncResource$3 {\n    constructor(A, t, n){\n        if (!A || typeof A != \"object\") throw new InvalidArgumentError$8(\"invalid opts\");\n        const { signal: r, method: s, opaque: i, body: E, onInfo: Q, responseHeaders: C, throwOnError: I } = A;\n        try {\n            if (typeof n != \"function\") throw new InvalidArgumentError$8(\"invalid callback\");\n            if (typeof t != \"function\") throw new InvalidArgumentError$8(\"invalid factory\");\n            if (r && typeof r.on != \"function\" && typeof r.addEventListener != \"function\") throw new InvalidArgumentError$8(\"signal must be an EventEmitter or EventTarget\");\n            if (s === \"CONNECT\") throw new InvalidArgumentError$8(\"invalid method\");\n            if (Q && typeof Q != \"function\") throw new InvalidArgumentError$8(\"invalid onInfo callback\");\n            super(\"UNDICI_STREAM\");\n        } catch (a) {\n            throw util$9.isStream(E) && util$9.destroy(E.on(\"error\", util$9.nop), a), a;\n        }\n        this.responseHeaders = C || null, this.opaque = i || null, this.factory = t, this.callback = n, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = E, this.onInfo = Q || null, this.throwOnError = I || !1, util$9.isStream(E) && E.on(\"error\", (a)=>{\n            this.onError(a);\n        }), addSignal$3(this, r);\n    }\n    onConnect(A, t) {\n        if (this.reason) {\n            A(this.reason);\n            return;\n        }\n        assert$3(this.callback), this.abort = A, this.context = t;\n    }\n    onHeaders(A, t, n, r) {\n        const { factory: s, opaque: i, context: E, callback: Q, responseHeaders: C } = this, I = C === \"raw\" ? util$9.parseRawHeaders(t) : util$9.parseHeaders(t);\n        if (A < 200) {\n            this.onInfo && this.onInfo({\n                statusCode: A,\n                headers: I\n            });\n            return;\n        }\n        this.factory = null;\n        let a;\n        if (this.throwOnError && A >= 400) {\n            const L = (C === \"raw\" ? util$9.parseHeaders(t) : I)[\"content-type\"];\n            a = new PassThrough$1, this.callback = null, this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n                callback: Q,\n                body: a,\n                contentType: L,\n                statusCode: A,\n                statusMessage: r,\n                headers: I\n            });\n        } else {\n            if (s === null) return;\n            if (a = this.runInAsyncScope(s, null, {\n                statusCode: A,\n                headers: I,\n                opaque: i,\n                context: E\n            }), !a || typeof a.write != \"function\" || typeof a.end != \"function\" || typeof a.on != \"function\") throw new InvalidReturnValueError$1(\"expected Writable\");\n            finished(a, {\n                readable: !1\n            }, (h)=>{\n                const { callback: L, res: c, opaque: l, trailers: S, abort: k } = this;\n                this.res = null, (h || !c.readable) && util$9.destroy(c, h), this.callback = null, this.runInAsyncScope(L, null, h || null, {\n                    opaque: l,\n                    trailers: S\n                }), h && k();\n            });\n        }\n        return a.on(\"drain\", n), this.res = a, (a.writableNeedDrain !== void 0 ? a.writableNeedDrain : a._writableState?.needDrain) !== !0;\n    }\n    onData(A) {\n        const { res: t } = this;\n        return t ? t.write(A) : !0;\n    }\n    onComplete(A) {\n        const { res: t } = this;\n        removeSignal$3(this), t && (this.trailers = util$9.parseHeaders(A), t.end());\n    }\n    onError(A) {\n        const { res: t, callback: n, opaque: r, body: s } = this;\n        removeSignal$3(this), this.factory = null, t ? (this.res = null, util$9.destroy(t, A)) : n && (this.callback = null, queueMicrotask(()=>{\n            this.runInAsyncScope(n, null, A, {\n                opaque: r\n            });\n        })), s && (this.body = null, util$9.destroy(s, A));\n    }\n};\no(Bt, \"StreamHandler\");\nlet StreamHandler = Bt;\nfunction stream(e, A, t) {\n    if (t === void 0) return new Promise((n, r)=>{\n        stream.call(this, e, A, (s, i)=>s ? r(s) : n(i));\n    });\n    try {\n        this.dispatch(e, new StreamHandler(e, A, t));\n    } catch (n) {\n        if (typeof t != \"function\") throw n;\n        const r = e?.opaque;\n        queueMicrotask(()=>t(n, {\n                opaque: r\n            }));\n    }\n}\no(stream, \"stream\");\nvar apiStream = stream;\nconst { Readable, Duplex, PassThrough } = Stream__default, { InvalidArgumentError: InvalidArgumentError$7, InvalidReturnValueError, RequestAbortedError } = errors$1, util$8 = util$m, { AsyncResource: AsyncResource$2 } = require$$5__default$1, { addSignal: addSignal$2, removeSignal: removeSignal$2 } = abortSignal, assert$2 = require$$0__default, kResume = Symbol(\"resume\"), Ct = class Ct extends Readable {\n    constructor(){\n        super({\n            autoDestroy: !0\n        }), this[kResume] = null;\n    }\n    _read() {\n        const { [kResume]: A } = this;\n        A && (this[kResume] = null, A());\n    }\n    _destroy(A, t) {\n        this._read(), t(A);\n    }\n};\no(Ct, \"PipelineRequest\");\nlet PipelineRequest = Ct;\nconst It = class It extends Readable {\n    constructor(A){\n        super({\n            autoDestroy: !0\n        }), this[kResume] = A;\n    }\n    _read() {\n        this[kResume]();\n    }\n    _destroy(A, t) {\n        !A && !this._readableState.endEmitted && (A = new RequestAbortedError), t(A);\n    }\n};\no(It, \"PipelineResponse\");\nlet PipelineResponse = It;\nconst at = class at extends AsyncResource$2 {\n    constructor(A, t){\n        if (!A || typeof A != \"object\") throw new InvalidArgumentError$7(\"invalid opts\");\n        if (typeof t != \"function\") throw new InvalidArgumentError$7(\"invalid handler\");\n        const { signal: n, method: r, opaque: s, onInfo: i, responseHeaders: E } = A;\n        if (n && typeof n.on != \"function\" && typeof n.addEventListener != \"function\") throw new InvalidArgumentError$7(\"signal must be an EventEmitter or EventTarget\");\n        if (r === \"CONNECT\") throw new InvalidArgumentError$7(\"invalid method\");\n        if (i && typeof i != \"function\") throw new InvalidArgumentError$7(\"invalid onInfo callback\");\n        super(\"UNDICI_PIPELINE\"), this.opaque = s || null, this.responseHeaders = E || null, this.handler = t, this.abort = null, this.context = null, this.onInfo = i || null, this.req = new PipelineRequest().on(\"error\", util$8.nop), this.ret = new Duplex({\n            readableObjectMode: A.objectMode,\n            autoDestroy: !0,\n            read: ()=>{\n                const { body: Q } = this;\n                Q?.resume && Q.resume();\n            },\n            write: (Q, C, I)=>{\n                const { req: a } = this;\n                a.push(Q, C) || a._readableState.destroyed ? I() : a[kResume] = I;\n            },\n            destroy: (Q, C)=>{\n                const { body: I, req: a, res: f, ret: h, abort: L } = this;\n                !Q && !h._readableState.endEmitted && (Q = new RequestAbortedError), L && Q && L(), util$8.destroy(I, Q), util$8.destroy(a, Q), util$8.destroy(f, Q), removeSignal$2(this), C(Q);\n            }\n        }).on(\"prefinish\", ()=>{\n            const { req: Q } = this;\n            Q.push(null);\n        }), this.res = null, addSignal$2(this, n);\n    }\n    onConnect(A, t) {\n        const { ret: n, res: r } = this;\n        if (this.reason) {\n            A(this.reason);\n            return;\n        }\n        assert$2(!r, \"pipeline cannot be retried\"), assert$2(!n.destroyed), this.abort = A, this.context = t;\n    }\n    onHeaders(A, t, n) {\n        const { opaque: r, handler: s, context: i } = this;\n        if (A < 200) {\n            if (this.onInfo) {\n                const Q = this.responseHeaders === \"raw\" ? util$8.parseRawHeaders(t) : util$8.parseHeaders(t);\n                this.onInfo({\n                    statusCode: A,\n                    headers: Q\n                });\n            }\n            return;\n        }\n        this.res = new PipelineResponse(n);\n        let E;\n        try {\n            this.handler = null;\n            const Q = this.responseHeaders === \"raw\" ? util$8.parseRawHeaders(t) : util$8.parseHeaders(t);\n            E = this.runInAsyncScope(s, null, {\n                statusCode: A,\n                headers: Q,\n                opaque: r,\n                body: this.res,\n                context: i\n            });\n        } catch (Q) {\n            throw this.res.on(\"error\", util$8.nop), Q;\n        }\n        if (!E || typeof E.on != \"function\") throw new InvalidReturnValueError(\"expected Readable\");\n        E.on(\"data\", (Q)=>{\n            const { ret: C, body: I } = this;\n            !C.push(Q) && I.pause && I.pause();\n        }).on(\"error\", (Q)=>{\n            const { ret: C } = this;\n            util$8.destroy(C, Q);\n        }).on(\"end\", ()=>{\n            const { ret: Q } = this;\n            Q.push(null);\n        }).on(\"close\", ()=>{\n            const { ret: Q } = this;\n            Q._readableState.ended || util$8.destroy(Q, new RequestAbortedError);\n        }), this.body = E;\n    }\n    onData(A) {\n        const { res: t } = this;\n        return t.push(A);\n    }\n    onComplete(A) {\n        const { res: t } = this;\n        t.push(null);\n    }\n    onError(A) {\n        const { ret: t } = this;\n        this.handler = null, util$8.destroy(t, A);\n    }\n};\no(at, \"PipelineHandler\");\nlet PipelineHandler = at;\nfunction pipeline(e, A) {\n    try {\n        const t = new PipelineHandler(e, A);\n        return this.dispatch({\n            ...e,\n            body: t.req\n        }, t), t.ret;\n    } catch (t) {\n        return new PassThrough().destroy(t);\n    }\n}\no(pipeline, \"pipeline\");\nvar apiPipeline = pipeline;\nconst { InvalidArgumentError: InvalidArgumentError$6, SocketError: SocketError$1 } = errors$1, { AsyncResource: AsyncResource$1 } = require$$5__default$1, util$7 = util$m, { addSignal: addSignal$1, removeSignal: removeSignal$1 } = abortSignal, assert$1 = require$$0__default, ct = class ct extends AsyncResource$1 {\n    constructor(A, t){\n        if (!A || typeof A != \"object\") throw new InvalidArgumentError$6(\"invalid opts\");\n        if (typeof t != \"function\") throw new InvalidArgumentError$6(\"invalid callback\");\n        const { signal: n, opaque: r, responseHeaders: s } = A;\n        if (n && typeof n.on != \"function\" && typeof n.addEventListener != \"function\") throw new InvalidArgumentError$6(\"signal must be an EventEmitter or EventTarget\");\n        super(\"UNDICI_UPGRADE\"), this.responseHeaders = s || null, this.opaque = r || null, this.callback = t, this.abort = null, this.context = null, addSignal$1(this, n);\n    }\n    onConnect(A, t) {\n        if (this.reason) {\n            A(this.reason);\n            return;\n        }\n        assert$1(this.callback), this.abort = A, this.context = null;\n    }\n    onHeaders() {\n        throw new SocketError$1(\"bad upgrade\", null);\n    }\n    onUpgrade(A, t, n) {\n        const { callback: r, opaque: s, context: i } = this;\n        assert$1.strictEqual(A, 101), removeSignal$1(this), this.callback = null;\n        const E = this.responseHeaders === \"raw\" ? util$7.parseRawHeaders(t) : util$7.parseHeaders(t);\n        this.runInAsyncScope(r, null, null, {\n            headers: E,\n            socket: n,\n            opaque: s,\n            context: i\n        });\n    }\n    onError(A) {\n        const { callback: t, opaque: n } = this;\n        removeSignal$1(this), t && (this.callback = null, queueMicrotask(()=>{\n            this.runInAsyncScope(t, null, A, {\n                opaque: n\n            });\n        }));\n    }\n};\no(ct, \"UpgradeHandler\");\nlet UpgradeHandler = ct;\nfunction upgrade(e, A) {\n    if (A === void 0) return new Promise((t, n)=>{\n        upgrade.call(this, e, (r, s)=>r ? n(r) : t(s));\n    });\n    try {\n        const t = new UpgradeHandler(e, A);\n        this.dispatch({\n            ...e,\n            method: e.method || \"GET\",\n            upgrade: e.protocol || \"Websocket\"\n        }, t);\n    } catch (t) {\n        if (typeof A != \"function\") throw t;\n        const n = e?.opaque;\n        queueMicrotask(()=>A(t, {\n                opaque: n\n            }));\n    }\n}\no(upgrade, \"upgrade\");\nvar apiUpgrade = upgrade;\nconst assert = require$$0__default, { AsyncResource } = require$$5__default$1, { InvalidArgumentError: InvalidArgumentError$5, SocketError } = errors$1, util$6 = util$m, { addSignal, removeSignal } = abortSignal, ht = class ht extends AsyncResource {\n    constructor(A, t){\n        if (!A || typeof A != \"object\") throw new InvalidArgumentError$5(\"invalid opts\");\n        if (typeof t != \"function\") throw new InvalidArgumentError$5(\"invalid callback\");\n        const { signal: n, opaque: r, responseHeaders: s } = A;\n        if (n && typeof n.on != \"function\" && typeof n.addEventListener != \"function\") throw new InvalidArgumentError$5(\"signal must be an EventEmitter or EventTarget\");\n        super(\"UNDICI_CONNECT\"), this.opaque = r || null, this.responseHeaders = s || null, this.callback = t, this.abort = null, addSignal(this, n);\n    }\n    onConnect(A, t) {\n        if (this.reason) {\n            A(this.reason);\n            return;\n        }\n        assert(this.callback), this.abort = A, this.context = t;\n    }\n    onHeaders() {\n        throw new SocketError(\"bad connect\", null);\n    }\n    onUpgrade(A, t, n) {\n        const { callback: r, opaque: s, context: i } = this;\n        removeSignal(this), this.callback = null;\n        let E = t;\n        E != null && (E = this.responseHeaders === \"raw\" ? util$6.parseRawHeaders(t) : util$6.parseHeaders(t)), this.runInAsyncScope(r, null, null, {\n            statusCode: A,\n            headers: E,\n            socket: n,\n            opaque: s,\n            context: i\n        });\n    }\n    onError(A) {\n        const { callback: t, opaque: n } = this;\n        removeSignal(this), t && (this.callback = null, queueMicrotask(()=>{\n            this.runInAsyncScope(t, null, A, {\n                opaque: n\n            });\n        }));\n    }\n};\no(ht, \"ConnectHandler\");\nlet ConnectHandler = ht;\nfunction connect(e, A) {\n    if (A === void 0) return new Promise((t, n)=>{\n        connect.call(this, e, (r, s)=>r ? n(r) : t(s));\n    });\n    try {\n        const t = new ConnectHandler(e, A);\n        this.dispatch({\n            ...e,\n            method: \"CONNECT\"\n        }, t);\n    } catch (t) {\n        if (typeof A != \"function\") throw t;\n        const n = e?.opaque;\n        queueMicrotask(()=>A(t, {\n                opaque: n\n            }));\n    }\n}\no(connect, \"connect\");\nvar apiConnect = connect;\napi$1.request = apiRequestExports, api$1.stream = apiStream, api$1.pipeline = apiPipeline, api$1.upgrade = apiUpgrade, api$1.connect = apiConnect;\nconst { UndiciError } = errors$1;\nlet MockNotMatchedError$1 = (Ae = class extends UndiciError {\n    constructor(A){\n        super(A), Error.captureStackTrace(this, Ae), this.name = \"MockNotMatchedError\", this.message = A || \"The request does not match any registered mock dispatches\", this.code = \"UND_MOCK_ERR_MOCK_NOT_MATCHED\";\n    }\n}, o(Ae, \"MockNotMatchedError\"), Ae);\nvar mockErrors = {\n    MockNotMatchedError: MockNotMatchedError$1\n}, mockSymbols = {\n    kAgent: Symbol(\"agent\"),\n    kOptions: Symbol(\"options\"),\n    kFactory: Symbol(\"factory\"),\n    kDispatches: Symbol(\"dispatches\"),\n    kDispatchKey: Symbol(\"dispatch key\"),\n    kDefaultHeaders: Symbol(\"default headers\"),\n    kDefaultTrailers: Symbol(\"default trailers\"),\n    kContentLength: Symbol(\"content length\"),\n    kMockAgent: Symbol(\"mock agent\"),\n    kMockAgentSet: Symbol(\"mock agent set\"),\n    kMockAgentGet: Symbol(\"mock agent get\"),\n    kMockDispatch: Symbol(\"mock dispatch\"),\n    kClose: Symbol(\"close\"),\n    kOriginalClose: Symbol(\"original agent close\"),\n    kOrigin: Symbol(\"origin\"),\n    kIsMockActive: Symbol(\"is mock active\"),\n    kNetConnect: Symbol(\"net connect\"),\n    kGetNetConnect: Symbol(\"get net connect\"),\n    kConnected: Symbol(\"connected\")\n};\nconst { MockNotMatchedError } = mockErrors, { kDispatches: kDispatches$3, kMockAgent: kMockAgent$2, kOriginalDispatch: kOriginalDispatch$2, kOrigin: kOrigin$2, kGetNetConnect } = mockSymbols, { buildURL: buildURL$1 } = util$m, { STATUS_CODES } = http__default, { types: { isPromise } } = require$$0__default$1;\nfunction matchValue(e, A) {\n    return typeof e == \"string\" ? e === A : e instanceof RegExp ? e.test(A) : typeof e == \"function\" ? e(A) === !0 : !1;\n}\no(matchValue, \"matchValue\");\nfunction lowerCaseEntries(e) {\n    return Object.fromEntries(Object.entries(e).map(([A, t])=>[\n            A.toLocaleLowerCase(),\n            t\n        ]));\n}\no(lowerCaseEntries, \"lowerCaseEntries\");\nfunction getHeaderByName(e, A) {\n    if (Array.isArray(e)) {\n        for(let t = 0; t < e.length; t += 2)if (e[t].toLocaleLowerCase() === A.toLocaleLowerCase()) return e[t + 1];\n        return;\n    } else return typeof e.get == \"function\" ? e.get(A) : lowerCaseEntries(e)[A.toLocaleLowerCase()];\n}\no(getHeaderByName, \"getHeaderByName\");\nfunction buildHeadersFromArray(e) {\n    const A = e.slice(), t = [];\n    for(let n = 0; n < A.length; n += 2)t.push([\n        A[n],\n        A[n + 1]\n    ]);\n    return Object.fromEntries(t);\n}\no(buildHeadersFromArray, \"buildHeadersFromArray\");\nfunction matchHeaders(e, A) {\n    if (typeof e.headers == \"function\") return Array.isArray(A) && (A = buildHeadersFromArray(A)), e.headers(A ? lowerCaseEntries(A) : {});\n    if (typeof e.headers > \"u\") return !0;\n    if (typeof A != \"object\" || typeof e.headers != \"object\") return !1;\n    for (const [t, n] of Object.entries(e.headers)){\n        const r = getHeaderByName(A, t);\n        if (!matchValue(n, r)) return !1;\n    }\n    return !0;\n}\no(matchHeaders, \"matchHeaders\");\nfunction safeUrl(e) {\n    if (typeof e != \"string\") return e;\n    const A = e.split(\"?\");\n    if (A.length !== 2) return e;\n    const t = new URLSearchParams(A.pop());\n    return t.sort(), [\n        ...A,\n        t.toString()\n    ].join(\"?\");\n}\no(safeUrl, \"safeUrl\");\nfunction matchKey(e, { path: A, method: t, body: n, headers: r }) {\n    const s = matchValue(e.path, A), i = matchValue(e.method, t), E = typeof e.body < \"u\" ? matchValue(e.body, n) : !0, Q = matchHeaders(e, r);\n    return s && i && E && Q;\n}\no(matchKey, \"matchKey\");\nfunction getResponseData$1(e) {\n    return Buffer.isBuffer(e) ? e : typeof e == \"object\" ? JSON.stringify(e) : e.toString();\n}\no(getResponseData$1, \"getResponseData$1\");\nfunction getMockDispatch(e, A) {\n    const t = A.query ? buildURL$1(A.path, A.query) : A.path, n = typeof t == \"string\" ? safeUrl(t) : t;\n    let r = e.filter(({ consumed: s })=>!s).filter(({ path: s })=>matchValue(safeUrl(s), n));\n    if (r.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for path '${n}'`);\n    if (r = r.filter(({ method: s })=>matchValue(s, A.method)), r.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for method '${A.method}' on path '${n}'`);\n    if (r = r.filter(({ body: s })=>typeof s < \"u\" ? matchValue(s, A.body) : !0), r.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for body '${A.body}' on path '${n}'`);\n    if (r = r.filter((s)=>matchHeaders(s, A.headers)), r.length === 0) {\n        const s = typeof A.headers == \"object\" ? JSON.stringify(A.headers) : A.headers;\n        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${s}' on path '${n}'`);\n    }\n    return r[0];\n}\no(getMockDispatch, \"getMockDispatch\");\nfunction addMockDispatch$1(e, A, t) {\n    const n = {\n        timesInvoked: 0,\n        times: 1,\n        persist: !1,\n        consumed: !1\n    }, r = typeof t == \"function\" ? {\n        callback: t\n    } : {\n        ...t\n    }, s = {\n        ...n,\n        ...A,\n        pending: !0,\n        data: {\n            error: null,\n            ...r\n        }\n    };\n    return e.push(s), s;\n}\no(addMockDispatch$1, \"addMockDispatch$1\");\nfunction deleteMockDispatch(e, A) {\n    const t = e.findIndex((n)=>n.consumed ? matchKey(n, A) : !1);\n    t !== -1 && e.splice(t, 1);\n}\no(deleteMockDispatch, \"deleteMockDispatch\");\nfunction buildKey$1(e) {\n    const { path: A, method: t, body: n, headers: r, query: s } = e;\n    return {\n        path: A,\n        method: t,\n        body: n,\n        headers: r,\n        query: s\n    };\n}\no(buildKey$1, \"buildKey$1\");\nfunction generateKeyValues(e) {\n    const A = Object.keys(e), t = [];\n    for(let n = 0; n < A.length; ++n){\n        const r = A[n], s = e[r], i = Buffer.from(`${r}`);\n        if (Array.isArray(s)) for(let E = 0; E < s.length; ++E)t.push(i, Buffer.from(`${s[E]}`));\n        else t.push(i, Buffer.from(`${s}`));\n    }\n    return t;\n}\no(generateKeyValues, \"generateKeyValues\");\nfunction getStatusText(e) {\n    return STATUS_CODES[e] || \"unknown\";\n}\no(getStatusText, \"getStatusText\");\nasync function getResponse(e) {\n    const A = [];\n    for await (const t of e)A.push(t);\n    return Buffer.concat(A).toString(\"utf8\");\n}\no(getResponse, \"getResponse\");\nfunction mockDispatch(e, A) {\n    const t = buildKey$1(e), n = getMockDispatch(this[kDispatches$3], t);\n    n.timesInvoked++, n.data.callback && (n.data = {\n        ...n.data,\n        ...n.data.callback(e)\n    });\n    const { data: { statusCode: r, data: s, headers: i, trailers: E, error: Q }, delay: C, persist: I } = n, { timesInvoked: a, times: f } = n;\n    if (n.consumed = !I && a >= f, n.pending = a < f, Q !== null) return deleteMockDispatch(this[kDispatches$3], t), A.onError(Q), !0;\n    typeof C == \"number\" && C > 0 ? setTimeout(()=>{\n        h(this[kDispatches$3]);\n    }, C) : h(this[kDispatches$3]);\n    function h(c, l = s) {\n        const S = Array.isArray(e.headers) ? buildHeadersFromArray(e.headers) : e.headers, k = typeof l == \"function\" ? l({\n            ...e,\n            headers: S\n        }) : l;\n        if (isPromise(k)) {\n            k.then((B)=>h(c, B));\n            return;\n        }\n        const w = getResponseData$1(k), U = generateKeyValues(i), M = generateKeyValues(E);\n        A.onConnect?.((B)=>A.onError(B), null), A.onHeaders?.(r, U, L, getStatusText(r)), A.onData?.(Buffer.from(w)), A.onComplete?.(M), deleteMockDispatch(c, t);\n    }\n    o(h, \"handleReply\");\n    function L() {}\n    return o(L, \"resume\"), !0;\n}\no(mockDispatch, \"mockDispatch\");\nfunction buildMockDispatch$2() {\n    const e = this[kMockAgent$2], A = this[kOrigin$2], t = this[kOriginalDispatch$2];\n    return o(function(r, s) {\n        if (e.isMockActive) try {\n            mockDispatch.call(this, r, s);\n        } catch (i) {\n            if (i instanceof MockNotMatchedError) {\n                const E = e[kGetNetConnect]();\n                if (E === !1) throw new MockNotMatchedError(`${i.message}: subsequent request to origin ${A} was not allowed (net.connect disabled)`);\n                if (checkNetConnect(E, A)) t.call(this, r, s);\n                else throw new MockNotMatchedError(`${i.message}: subsequent request to origin ${A} was not allowed (net.connect is not enabled for this origin)`);\n            } else throw i;\n        }\n        else t.call(this, r, s);\n    }, \"dispatch\");\n}\no(buildMockDispatch$2, \"buildMockDispatch$2\");\nfunction checkNetConnect(e, A) {\n    const t = new URL(A);\n    return e === !0 ? !0 : !!(Array.isArray(e) && e.some((n)=>matchValue(n, t.host)));\n}\no(checkNetConnect, \"checkNetConnect\");\nfunction buildMockOptions(e) {\n    if (e) {\n        const { agent: A, ...t } = e;\n        return t;\n    }\n}\no(buildMockOptions, \"buildMockOptions\");\nvar mockUtils = {\n    getResponseData: getResponseData$1,\n    getMockDispatch,\n    addMockDispatch: addMockDispatch$1,\n    deleteMockDispatch,\n    buildKey: buildKey$1,\n    generateKeyValues,\n    matchValue,\n    getResponse,\n    getStatusText,\n    mockDispatch,\n    buildMockDispatch: buildMockDispatch$2,\n    checkNetConnect,\n    buildMockOptions,\n    getHeaderByName,\n    buildHeadersFromArray\n}, mockInterceptor = {};\nconst { getResponseData, buildKey, addMockDispatch } = mockUtils, { kDispatches: kDispatches$2, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = mockSymbols, { InvalidArgumentError: InvalidArgumentError$4 } = errors$1, { buildURL } = util$m, lt = class lt {\n    constructor(A){\n        this[kMockDispatch] = A;\n    }\n    delay(A) {\n        if (typeof A != \"number\" || !Number.isInteger(A) || A <= 0) throw new InvalidArgumentError$4(\"waitInMs must be a valid integer > 0\");\n        return this[kMockDispatch].delay = A, this;\n    }\n    persist() {\n        return this[kMockDispatch].persist = !0, this;\n    }\n    times(A) {\n        if (typeof A != \"number\" || !Number.isInteger(A) || A <= 0) throw new InvalidArgumentError$4(\"repeatTimes must be a valid integer > 0\");\n        return this[kMockDispatch].times = A, this;\n    }\n};\no(lt, \"MockScope\");\nlet MockScope = lt, MockInterceptor$2 = (Te = class {\n    constructor(A, t){\n        if (typeof A != \"object\") throw new InvalidArgumentError$4(\"opts must be an object\");\n        if (typeof A.path > \"u\") throw new InvalidArgumentError$4(\"opts.path must be defined\");\n        if (typeof A.method > \"u\" && (A.method = \"GET\"), typeof A.path == \"string\") if (A.query) A.path = buildURL(A.path, A.query);\n        else {\n            const n = new URL(A.path, \"data://\");\n            A.path = n.pathname + n.search;\n        }\n        typeof A.method == \"string\" && (A.method = A.method.toUpperCase()), this[kDispatchKey] = buildKey(A), this[kDispatches$2] = t, this[kDefaultHeaders] = {}, this[kDefaultTrailers] = {}, this[kContentLength] = !1;\n    }\n    createMockScopeDispatchData({ statusCode: A, data: t, responseOptions: n }) {\n        const r = getResponseData(t), s = this[kContentLength] ? {\n            \"content-length\": r.length\n        } : {}, i = {\n            ...this[kDefaultHeaders],\n            ...s,\n            ...n.headers\n        }, E = {\n            ...this[kDefaultTrailers],\n            ...n.trailers\n        };\n        return {\n            statusCode: A,\n            data: t,\n            headers: i,\n            trailers: E\n        };\n    }\n    validateReplyParameters(A) {\n        if (typeof A.statusCode > \"u\") throw new InvalidArgumentError$4(\"statusCode must be defined\");\n        if (typeof A.responseOptions != \"object\" || A.responseOptions === null) throw new InvalidArgumentError$4(\"responseOptions must be an object\");\n    }\n    reply(A) {\n        if (typeof A == \"function\") {\n            const s = o((E)=>{\n                const Q = A(E);\n                if (typeof Q != \"object\" || Q === null) throw new InvalidArgumentError$4(\"reply options callback must return an object\");\n                const C = {\n                    data: \"\",\n                    responseOptions: {},\n                    ...Q\n                };\n                return this.validateReplyParameters(C), {\n                    ...this.createMockScopeDispatchData(C)\n                };\n            }, \"wrappedDefaultsCallback\"), i = addMockDispatch(this[kDispatches$2], this[kDispatchKey], s);\n            return new MockScope(i);\n        }\n        const t = {\n            statusCode: A,\n            data: arguments[1] === void 0 ? \"\" : arguments[1],\n            responseOptions: arguments[2] === void 0 ? {} : arguments[2]\n        };\n        this.validateReplyParameters(t);\n        const n = this.createMockScopeDispatchData(t), r = addMockDispatch(this[kDispatches$2], this[kDispatchKey], n);\n        return new MockScope(r);\n    }\n    replyWithError(A) {\n        if (typeof A > \"u\") throw new InvalidArgumentError$4(\"error must be defined\");\n        const t = addMockDispatch(this[kDispatches$2], this[kDispatchKey], {\n            error: A\n        });\n        return new MockScope(t);\n    }\n    defaultReplyHeaders(A) {\n        if (typeof A > \"u\") throw new InvalidArgumentError$4(\"headers must be defined\");\n        return this[kDefaultHeaders] = A, this;\n    }\n    defaultReplyTrailers(A) {\n        if (typeof A > \"u\") throw new InvalidArgumentError$4(\"trailers must be defined\");\n        return this[kDefaultTrailers] = A, this;\n    }\n    replyContentLength() {\n        return this[kContentLength] = !0, this;\n    }\n}, o(Te, \"MockInterceptor\"), Te);\nmockInterceptor.MockInterceptor = MockInterceptor$2, mockInterceptor.MockScope = MockScope;\nconst { promisify: promisify$1 } = require$$0__default$1, Client = client, { buildMockDispatch: buildMockDispatch$1 } = mockUtils, { kDispatches: kDispatches$1, kMockAgent: kMockAgent$1, kClose: kClose$1, kOriginalClose: kOriginalClose$1, kOrigin: kOrigin$1, kOriginalDispatch: kOriginalDispatch$1, kConnected: kConnected$1 } = mockSymbols, { MockInterceptor: MockInterceptor$1 } = mockInterceptor, Symbols$1 = symbols$4, { InvalidArgumentError: InvalidArgumentError$3 } = errors$1, ut = class ut extends Client {\n    constructor(A, t){\n        if (super(A, t), !t || !t.agent || typeof t.agent.dispatch != \"function\") throw new InvalidArgumentError$3(\"Argument opts.agent must implement Agent\");\n        this[kMockAgent$1] = t.agent, this[kOrigin$1] = A, this[kDispatches$1] = [], this[kConnected$1] = 1, this[kOriginalDispatch$1] = this.dispatch, this[kOriginalClose$1] = this.close.bind(this), this.dispatch = buildMockDispatch$1.call(this), this.close = this[kClose$1];\n    }\n    get [Symbols$1.kConnected]() {\n        return this[kConnected$1];\n    }\n    intercept(A) {\n        return new MockInterceptor$1(A, this[kDispatches$1]);\n    }\n    async [kClose$1]() {\n        await promisify$1(this[kOriginalClose$1])(), this[kConnected$1] = 0, this[kMockAgent$1][Symbols$1.kClients].delete(this[kOrigin$1]);\n    }\n};\no(ut, \"MockClient\");\nlet MockClient = ut;\nconst { promisify } = require$$0__default$1, Pool = pool, { buildMockDispatch } = mockUtils, { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = mockSymbols, { MockInterceptor } = mockInterceptor, Symbols = symbols$4, { InvalidArgumentError: InvalidArgumentError$2 } = errors$1, dt = class dt extends Pool {\n    constructor(A, t){\n        if (super(A, t), !t || !t.agent || typeof t.agent.dispatch != \"function\") throw new InvalidArgumentError$2(\"Argument opts.agent must implement Agent\");\n        this[kMockAgent] = t.agent, this[kOrigin] = A, this[kDispatches] = [], this[kConnected] = 1, this[kOriginalDispatch] = this.dispatch, this[kOriginalClose] = this.close.bind(this), this.dispatch = buildMockDispatch.call(this), this.close = this[kClose];\n    }\n    get [Symbols.kConnected]() {\n        return this[kConnected];\n    }\n    intercept(A) {\n        return new MockInterceptor(A, this[kDispatches]);\n    }\n    async [kClose]() {\n        await promisify(this[kOriginalClose])(), this[kConnected] = 0, this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n    }\n};\no(dt, \"MockPool\");\nlet MockPool = dt;\nprocess.versions.icu, process.versions.icu;\nconst globalDispatcher = Symbol.for(\"undici.globalDispatcher.1\"), { InvalidArgumentError: InvalidArgumentError$1 } = errors$1, Agent$1 = agent;\ngetGlobalDispatcher$1() === void 0 && setGlobalDispatcher$1(new Agent$1);\nfunction setGlobalDispatcher$1(e) {\n    if (!e || typeof e.dispatch != \"function\") throw new InvalidArgumentError$1(\"Argument agent must implement Agent\");\n    Object.defineProperty(globalThis, globalDispatcher, {\n        value: e,\n        writable: !0,\n        enumerable: !1,\n        configurable: !1\n    });\n}\no(setGlobalDispatcher$1, \"setGlobalDispatcher$1\");\nfunction getGlobalDispatcher$1() {\n    return globalThis[globalDispatcher];\n}\no(getGlobalDispatcher$1, \"getGlobalDispatcher$1\");\nvar global = {\n    setGlobalDispatcher: setGlobalDispatcher$1,\n    getGlobalDispatcher: getGlobalDispatcher$1\n}, headers, hasRequiredHeaders;\nfunction requireHeaders() {\n    if (hasRequiredHeaders) return headers;\n    hasRequiredHeaders = 1;\n    const { kHeadersList: e, kConstruct: A } = symbols$4, { kGuard: t } = requireSymbols$3(), { kEnumerableProperty: n } = util$m, { iteratorMixin: r, isValidHeaderName: s, isValidHeaderValue: i } = requireUtil$5(), { webidl: E } = requireWebidl(), Q = require$$0__default, C = require$$0__default$1, I = Symbol(\"headers map\"), a = Symbol(\"headers map sorted\");\n    function f(M) {\n        return M === 10 || M === 13 || M === 9 || M === 32;\n    }\n    o(f, \"isHTTPWhiteSpaceCharCode\");\n    function h(M) {\n        let B = 0, D = M.length;\n        for(; D > B && f(M.charCodeAt(D - 1));)--D;\n        for(; D > B && f(M.charCodeAt(B));)++B;\n        return B === 0 && D === M.length ? M : M.substring(B, D);\n    }\n    o(h, \"headerValueNormalize\");\n    function L(M, B) {\n        if (Array.isArray(B)) for(let D = 0; D < B.length; ++D){\n            const G = B[D];\n            if (G.length !== 2) throw E.errors.exception({\n                header: \"Headers constructor\",\n                message: `expected name/value pair to be length 2, found ${G.length}.`\n            });\n            c(M, G[0], G[1]);\n        }\n        else if (typeof B == \"object\" && B !== null) {\n            const D = Object.keys(B);\n            for(let G = 0; G < D.length; ++G)c(M, D[G], B[D[G]]);\n        } else throw E.errors.conversionFailed({\n            prefix: \"Headers constructor\",\n            argument: \"Argument 1\",\n            types: [\n                \"sequence<sequence<ByteString>>\",\n                \"record<ByteString, ByteString>\"\n            ]\n        });\n    }\n    o(L, \"fill\");\n    function c(M, B, D) {\n        if (D = h(D), s(B)) {\n            if (!i(D)) throw E.errors.invalidArgument({\n                prefix: \"Headers.append\",\n                value: D,\n                type: \"header value\"\n            });\n        } else throw E.errors.invalidArgument({\n            prefix: \"Headers.append\",\n            value: B,\n            type: \"header name\"\n        });\n        if (M[t] === \"immutable\") throw new TypeError(\"immutable\");\n        return M[t], M[e].append(B, D, !1);\n    }\n    o(c, \"appendHeader\");\n    function l(M, B) {\n        return M[0] < B[0] ? -1 : 1;\n    }\n    o(l, \"compareHeaderName\");\n    const w = class w {\n        constructor(B){\n            NA(this, \"cookies\", null);\n            B instanceof w ? (this[I] = new Map(B[I]), this[a] = B[a], this.cookies = B.cookies === null ? null : [\n                ...B.cookies\n            ]) : (this[I] = new Map(B), this[a] = null);\n        }\n        contains(B, D) {\n            return this[I].has(D ? B : B.toLowerCase());\n        }\n        clear() {\n            this[I].clear(), this[a] = null, this.cookies = null;\n        }\n        append(B, D, G) {\n            this[a] = null;\n            const g = G ? B : B.toLowerCase(), d = this[I].get(g);\n            if (d) {\n                const F = g === \"cookie\" ? \"; \" : \", \";\n                this[I].set(g, {\n                    name: d.name,\n                    value: `${d.value}${F}${D}`\n                });\n            } else this[I].set(g, {\n                name: B,\n                value: D\n            });\n            g === \"set-cookie\" && (this.cookies ?? (this.cookies = [])).push(D);\n        }\n        set(B, D, G) {\n            this[a] = null;\n            const g = G ? B : B.toLowerCase();\n            g === \"set-cookie\" && (this.cookies = [\n                D\n            ]), this[I].set(g, {\n                name: B,\n                value: D\n            });\n        }\n        delete(B, D) {\n            this[a] = null, D || (B = B.toLowerCase()), B === \"set-cookie\" && (this.cookies = null), this[I].delete(B);\n        }\n        get(B, D) {\n            return this[I].get(D ? B : B.toLowerCase())?.value ?? null;\n        }\n        *[Symbol.iterator]() {\n            for (const { 0: B, 1: { value: D } } of this[I])yield [\n                B,\n                D\n            ];\n        }\n        get entries() {\n            const B = {};\n            if (this[I].size) for (const { name: D, value: G } of this[I].values())B[D] = G;\n            return B;\n        }\n        toSortedArray() {\n            const B = this[I].size, D = new Array(B);\n            if (B <= 32) {\n                if (B === 0) return D;\n                const G = this[I][Symbol.iterator](), g = G.next().value;\n                D[0] = [\n                    g[0],\n                    g[1].value\n                ], Q(g[1].value !== null);\n                for(let d = 1, F = 0, N = 0, u = 0, b = 0, m, T; d < B; ++d){\n                    for(T = G.next().value, m = D[d] = [\n                        T[0],\n                        T[1].value\n                    ], Q(m[1] !== null), u = 0, N = d; u < N;)b = u + (N - u >> 1), D[b][0] <= m[0] ? u = b + 1 : N = b;\n                    if (d !== b) {\n                        for(F = d; F > u;)D[F] = D[--F];\n                        D[u] = m;\n                    }\n                }\n                if (!G.next().done) throw new TypeError(\"Unreachable\");\n                return D;\n            } else {\n                let G = 0;\n                for (const { 0: g, 1: { value: d } } of this[I])D[G++] = [\n                    g,\n                    d\n                ], Q(d !== null);\n                return D.sort(l);\n            }\n        }\n    };\n    o(w, \"HeadersList\");\n    let S = w;\n    const U = class U {\n        constructor(B = void 0){\n            B !== A && (this[e] = new S, this[t] = \"none\", B !== void 0 && (B = E.converters.HeadersInit(B), L(this, B)));\n        }\n        append(B, D) {\n            return E.brandCheck(this, U), E.argumentLengthCheck(arguments, 2, {\n                header: \"Headers.append\"\n            }), B = E.converters.ByteString(B), D = E.converters.ByteString(D), c(this, B, D);\n        }\n        delete(B) {\n            if (E.brandCheck(this, U), E.argumentLengthCheck(arguments, 1, {\n                header: \"Headers.delete\"\n            }), B = E.converters.ByteString(B), !s(B)) throw E.errors.invalidArgument({\n                prefix: \"Headers.delete\",\n                value: B,\n                type: \"header name\"\n            });\n            if (this[t] === \"immutable\") throw new TypeError(\"immutable\");\n            this[t], this[e].contains(B, !1) && this[e].delete(B, !1);\n        }\n        get(B) {\n            if (E.brandCheck(this, U), E.argumentLengthCheck(arguments, 1, {\n                header: \"Headers.get\"\n            }), B = E.converters.ByteString(B), !s(B)) throw E.errors.invalidArgument({\n                prefix: \"Headers.get\",\n                value: B,\n                type: \"header name\"\n            });\n            return this[e].get(B, !1);\n        }\n        has(B) {\n            if (E.brandCheck(this, U), E.argumentLengthCheck(arguments, 1, {\n                header: \"Headers.has\"\n            }), B = E.converters.ByteString(B), !s(B)) throw E.errors.invalidArgument({\n                prefix: \"Headers.has\",\n                value: B,\n                type: \"header name\"\n            });\n            return this[e].contains(B, !1);\n        }\n        set(B, D) {\n            if (E.brandCheck(this, U), E.argumentLengthCheck(arguments, 2, {\n                header: \"Headers.set\"\n            }), B = E.converters.ByteString(B), D = E.converters.ByteString(D), D = h(D), s(B)) {\n                if (!i(D)) throw E.errors.invalidArgument({\n                    prefix: \"Headers.set\",\n                    value: D,\n                    type: \"header value\"\n                });\n            } else throw E.errors.invalidArgument({\n                prefix: \"Headers.set\",\n                value: B,\n                type: \"header name\"\n            });\n            if (this[t] === \"immutable\") throw new TypeError(\"immutable\");\n            this[t], this[e].set(B, D, !1);\n        }\n        getSetCookie() {\n            E.brandCheck(this, U);\n            const B = this[e].cookies;\n            return B ? [\n                ...B\n            ] : [];\n        }\n        get [a]() {\n            if (this[e][a]) return this[e][a];\n            const B = [], D = this[e].toSortedArray(), G = this[e].cookies;\n            if (G === null || G.length === 1) return this[e][a] = D;\n            for(let g = 0; g < D.length; ++g){\n                const { 0: d, 1: F } = D[g];\n                if (d === \"set-cookie\") for(let N = 0; N < G.length; ++N)B.push([\n                    d,\n                    G[N]\n                ]);\n                else B.push([\n                    d,\n                    F\n                ]);\n            }\n            return this[e][a] = B;\n        }\n        [C.inspect.custom](B, D) {\n            return D.depth ?? (D.depth = B), `Headers ${C.formatWithOptions(D, this[e].entries)}`;\n        }\n    };\n    o(U, \"Headers\");\n    let k = U;\n    return Object.defineProperty(k.prototype, C.inspect.custom, {\n        enumerable: !1\n    }), r(\"Headers\", k, a, 0, 1), Object.defineProperties(k.prototype, {\n        append: n,\n        delete: n,\n        get: n,\n        has: n,\n        set: n,\n        getSetCookie: n,\n        [Symbol.toStringTag]: {\n            value: \"Headers\",\n            configurable: !0\n        }\n    }), E.converters.HeadersInit = function(M) {\n        if (E.util.Type(M) === \"Object\") {\n            const B = Reflect.get(M, Symbol.iterator);\n            return typeof B == \"function\" ? E.converters[\"sequence<sequence<ByteString>>\"](M, B.bind(M)) : E.converters[\"record<ByteString, ByteString>\"](M);\n        }\n        throw E.errors.conversionFailed({\n            prefix: \"Headers constructor\",\n            argument: \"Argument 1\",\n            types: [\n                \"sequence<sequence<ByteString>>\",\n                \"record<ByteString, ByteString>\"\n            ]\n        });\n    }, headers = {\n        fill: L,\n        compareHeaderName: l,\n        Headers: k,\n        HeadersList: S\n    }, headers;\n}\no(requireHeaders, \"requireHeaders\");\nvar response, hasRequiredResponse;\nfunction requireResponse() {\n    if (hasRequiredResponse) return response;\n    hasRequiredResponse = 1;\n    const { Headers: e, HeadersList: A, fill: t } = requireHeaders(), { extractBody: n, cloneBody: r, mixinBody: s } = requireBody(), i = util$m, E = require$$0__default$1, { kEnumerableProperty: Q } = i, { isValidReasonPhrase: C, isCancelled: I, isAborted: a, isBlobLike: f, serializeJavascriptValueToJSONString: h, isErrorLike: L, isomorphicEncode: c } = requireUtil$5(), { redirectStatusSet: l, nullBodyStatus: S } = requireConstants$2(), { kState: k, kHeaders: w, kGuard: U, kRealm: M } = requireSymbols$3(), { webidl: B } = requireWebidl(), { FormData: D } = requireFormdata(), { getGlobalOrigin: G } = requireGlobal(), { URLSerializer: g } = requireDataUrl(), { kHeadersList: d, kConstruct: F } = symbols$4, N = require$$0__default, { types: u } = require$$0__default$1, b = new TextEncoder(\"utf-8\"), $ = class $ {\n        static error() {\n            const q = {\n                settingsObject: {}\n            };\n            return X(Z(), \"immutable\", q);\n        }\n        static json(q, z = {}) {\n            B.argumentLengthCheck(arguments, 1, {\n                header: \"Response.json\"\n            }), z !== null && (z = B.converters.ResponseInit(z));\n            const rA = b.encode(h(q)), iA = n(rA), gA = {\n                settingsObject: {}\n            }, BA = X(v({}), \"response\", gA);\n            return aA(BA, z, {\n                body: iA[0],\n                type: \"application/json\"\n            }), BA;\n        }\n        static redirect(q, z = 302) {\n            const rA = {\n                settingsObject: {}\n            };\n            B.argumentLengthCheck(arguments, 1, {\n                header: \"Response.redirect\"\n            }), q = B.converters.USVString(q), z = B.converters[\"unsigned short\"](z);\n            let iA;\n            try {\n                iA = new URL(q, G());\n            } catch (sA) {\n                throw new TypeError(`Failed to parse URL from ${q}`, {\n                    cause: sA\n                });\n            }\n            if (!l.has(z)) throw new RangeError(`Invalid status code ${z}`);\n            const gA = X(v({}), \"immutable\", rA);\n            gA[k].status = z;\n            const BA = c(g(iA));\n            return gA[k].headersList.append(\"location\", BA, !0), gA;\n        }\n        constructor(q = null, z = {}){\n            if (q === F) return;\n            q !== null && (q = B.converters.BodyInit(q)), z = B.converters.ResponseInit(z), this[M] = {\n                settingsObject: {}\n            }, this[k] = v({}), this[w] = new e(F), this[w][U] = \"response\", this[w][d] = this[k].headersList, this[w][M] = this[M];\n            let rA = null;\n            if (q != null) {\n                const [iA, gA] = n(q);\n                rA = {\n                    body: iA,\n                    type: gA\n                };\n            }\n            aA(this, z, rA);\n        }\n        get type() {\n            return B.brandCheck(this, $), this[k].type;\n        }\n        get url() {\n            B.brandCheck(this, $);\n            const q = this[k].urlList, z = q[q.length - 1] ?? null;\n            return z === null ? \"\" : g(z, !0);\n        }\n        get redirected() {\n            return B.brandCheck(this, $), this[k].urlList.length > 1;\n        }\n        get status() {\n            return B.brandCheck(this, $), this[k].status;\n        }\n        get ok() {\n            return B.brandCheck(this, $), this[k].status >= 200 && this[k].status <= 299;\n        }\n        get statusText() {\n            return B.brandCheck(this, $), this[k].statusText;\n        }\n        get headers() {\n            return B.brandCheck(this, $), this[w];\n        }\n        get body() {\n            return B.brandCheck(this, $), this[k].body ? this[k].body.stream : null;\n        }\n        get bodyUsed() {\n            return B.brandCheck(this, $), !!this[k].body && i.isDisturbed(this[k].body.stream);\n        }\n        clone() {\n            if (B.brandCheck(this, $), this.bodyUsed || this.body?.locked) throw B.errors.exception({\n                header: \"Response.clone\",\n                message: \"Body has already been consumed.\"\n            });\n            const q = T(this[k]);\n            return X(q, this[w][U], this[M]);\n        }\n        [E.inspect.custom](q, z) {\n            z.depth === null && (z.depth = 2), z.colors ?? (z.colors = !0);\n            const rA = {\n                status: this.status,\n                statusText: this.statusText,\n                headers: this.headers,\n                body: this.body,\n                bodyUsed: this.bodyUsed,\n                ok: this.ok,\n                redirected: this.redirected,\n                type: this.type,\n                url: this.url\n            };\n            return `Response ${E.formatWithOptions(z, rA)}`;\n        }\n    };\n    o($, \"Response\");\n    let m = $;\n    s(m), Object.defineProperties(m.prototype, {\n        type: Q,\n        url: Q,\n        status: Q,\n        ok: Q,\n        redirected: Q,\n        statusText: Q,\n        headers: Q,\n        clone: Q,\n        body: Q,\n        bodyUsed: Q,\n        [Symbol.toStringTag]: {\n            value: \"Response\",\n            configurable: !0\n        }\n    }), Object.defineProperties(m, {\n        json: Q,\n        redirect: Q,\n        error: Q\n    });\n    function T(V) {\n        if (V.internalResponse) return K(T(V.internalResponse), V.type);\n        const q = v({\n            ...V,\n            body: null\n        });\n        return V.body != null && (q.body = r(V.body)), q;\n    }\n    o(T, \"cloneResponse\");\n    function v(V) {\n        return {\n            aborted: !1,\n            rangeRequested: !1,\n            timingAllowPassed: !1,\n            requestIncludesCredentials: !1,\n            type: \"default\",\n            status: 200,\n            timingInfo: null,\n            cacheState: \"\",\n            statusText: \"\",\n            ...V,\n            headersList: V?.headersList ? new A(V?.headersList) : new A,\n            urlList: V?.urlList ? [\n                ...V.urlList\n            ] : []\n        };\n    }\n    o(v, \"makeResponse\");\n    function Z(V) {\n        const q = L(V);\n        return v({\n            type: \"error\",\n            status: 0,\n            error: q ? V : new Error(V && String(V)),\n            aborted: V && V.name === \"AbortError\"\n        });\n    }\n    o(Z, \"makeNetworkError\");\n    function P(V) {\n        return V.type === \"error\" && V.status === 0;\n    }\n    o(P, \"isNetworkError\");\n    function AA(V, q) {\n        return q = {\n            internalResponse: V,\n            ...q\n        }, new Proxy(V, {\n            get (z, rA) {\n                return rA in q ? q[rA] : z[rA];\n            },\n            set (z, rA, iA) {\n                return N(!(rA in q)), z[rA] = iA, !0;\n            }\n        });\n    }\n    o(AA, \"makeFilteredResponse\");\n    function K(V, q) {\n        if (q === \"basic\") return AA(V, {\n            type: \"basic\",\n            headersList: V.headersList\n        });\n        if (q === \"cors\") return AA(V, {\n            type: \"cors\",\n            headersList: V.headersList\n        });\n        if (q === \"opaque\") return AA(V, {\n            type: \"opaque\",\n            urlList: Object.freeze([]),\n            status: 0,\n            statusText: \"\",\n            body: null\n        });\n        if (q === \"opaqueredirect\") return AA(V, {\n            type: \"opaqueredirect\",\n            status: 0,\n            statusText: \"\",\n            headersList: [],\n            body: null\n        });\n        N(!1);\n    }\n    o(K, \"filterResponse\");\n    function tA(V, q = null) {\n        return N(I(V)), a(V) ? Z(Object.assign(new DOMException(\"The operation was aborted.\", \"AbortError\"), {\n            cause: q\n        })) : Z(Object.assign(new DOMException(\"Request was cancelled.\"), {\n            cause: q\n        }));\n    }\n    o(tA, \"makeAppropriateNetworkError\");\n    function aA(V, q, z) {\n        if (q.status !== null && (q.status < 200 || q.status > 599)) throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.');\n        if (\"statusText\" in q && q.statusText != null && !C(String(q.statusText))) throw new TypeError(\"Invalid statusText\");\n        if (\"status\" in q && q.status != null && (V[k].status = q.status), \"statusText\" in q && q.statusText != null && (V[k].statusText = q.statusText), \"headers\" in q && q.headers != null && t(V[w], q.headers), z) {\n            if (S.includes(V.status)) throw B.errors.exception({\n                header: \"Response constructor\",\n                message: `Invalid response status code ${V.status}`\n            });\n            V[k].body = z.body, z.type != null && !V[k].headersList.contains(\"content-type\", !0) && V[k].headersList.append(\"content-type\", z.type, !0);\n        }\n    }\n    o(aA, \"initializeResponse\");\n    function X(V, q, z) {\n        const rA = new m(F);\n        return rA[k] = V, rA[M] = z, rA[w] = new e(F), rA[w][d] = V.headersList, rA[w][U] = q, rA[w][M] = z, rA;\n    }\n    return o(X, \"fromInnerResponse\"), B.converters.ReadableStream = B.interfaceConverter(ReadableStream), B.converters.FormData = B.interfaceConverter(D), B.converters.URLSearchParams = B.interfaceConverter(URLSearchParams), B.converters.XMLHttpRequestBodyInit = function(V) {\n        return typeof V == \"string\" ? B.converters.USVString(V) : f(V) ? B.converters.Blob(V, {\n            strict: !1\n        }) : ArrayBuffer.isView(V) || u.isArrayBuffer(V) ? B.converters.BufferSource(V) : i.isFormDataLike(V) ? B.converters.FormData(V, {\n            strict: !1\n        }) : V instanceof URLSearchParams ? B.converters.URLSearchParams(V) : B.converters.DOMString(V);\n    }, B.converters.BodyInit = function(V) {\n        return V instanceof ReadableStream ? B.converters.ReadableStream(V) : V?.[Symbol.asyncIterator] ? V : B.converters.XMLHttpRequestBodyInit(V);\n    }, B.converters.ResponseInit = B.dictionaryConverter([\n        {\n            key: \"status\",\n            converter: B.converters[\"unsigned short\"],\n            defaultValue: 200\n        },\n        {\n            key: \"statusText\",\n            converter: B.converters.ByteString,\n            defaultValue: \"\"\n        },\n        {\n            key: \"headers\",\n            converter: B.converters.HeadersInit\n        }\n    ]), response = {\n        isNetworkError: P,\n        makeNetworkError: Z,\n        makeResponse: v,\n        makeAppropriateNetworkError: tA,\n        filterResponse: K,\n        Response: m,\n        cloneResponse: T,\n        fromInnerResponse: X\n    }, response;\n}\no(requireResponse, \"requireResponse\");\nvar dispatcherWeakref, hasRequiredDispatcherWeakref;\nfunction requireDispatcherWeakref() {\n    if (hasRequiredDispatcherWeakref) return dispatcherWeakref;\n    hasRequiredDispatcherWeakref = 1;\n    const { kConnected: e, kSize: A } = symbols$4, r = class r {\n        constructor(E){\n            this.value = E;\n        }\n        deref() {\n            return this.value[e] === 0 && this.value[A] === 0 ? void 0 : this.value;\n        }\n    };\n    o(r, \"CompatWeakRef\");\n    let t = r;\n    const s = class s {\n        constructor(E){\n            this.finalizer = E;\n        }\n        register(E, Q) {\n            E.on && E.on(\"disconnect\", ()=>{\n                E[e] === 0 && E[A] === 0 && this.finalizer(Q);\n            });\n        }\n        unregister(E) {}\n    };\n    o(s, \"CompatFinalizer\");\n    let n = s;\n    return dispatcherWeakref = o(function() {\n        return process.env.NODE_V8_COVERAGE ? {\n            WeakRef: t,\n            FinalizationRegistry: n\n        } : {\n            WeakRef,\n            FinalizationRegistry\n        };\n    }, \"dispatcherWeakref\"), dispatcherWeakref;\n}\no(requireDispatcherWeakref, \"requireDispatcherWeakref\");\nvar request, hasRequiredRequest;\nfunction requireRequest() {\n    if (hasRequiredRequest) return request;\n    hasRequiredRequest = 1;\n    const { extractBody: e, mixinBody: A, cloneBody: t } = requireBody(), { Headers: n, fill: r, HeadersList: s } = requireHeaders(), { FinalizationRegistry: i } = requireDispatcherWeakref()(), E = util$m, Q = require$$0__default$1, { isValidHTTPToken: C, sameOrigin: I, normalizeMethod: a, makePolicyContainer: f, normalizeMethodRecord: h } = requireUtil$5(), { forbiddenMethodsSet: L, corsSafeListedMethodsSet: c, referrerPolicy: l, requestRedirect: S, requestMode: k, requestCredentials: w, requestCache: U, requestDuplex: M } = requireConstants$2(), { kEnumerableProperty: B } = E, { kHeaders: D, kSignal: G, kState: g, kGuard: d, kRealm: F, kDispatcher: N } = requireSymbols$3(), { webidl: u } = requireWebidl(), { getGlobalOrigin: b } = requireGlobal(), { URLSerializer: m } = requireDataUrl(), { kHeadersList: T, kConstruct: v } = symbols$4, Z = require$$0__default, { getMaxListeners: P, setMaxListeners: AA, getEventListeners: K, defaultMaxListeners: tA } = require$$0__default$3, aA = Symbol(\"abortController\"), X = new i(({ signal: gA, abort: BA })=>{\n        gA.removeEventListener(\"abort\", BA);\n    });\n    let $ = !1;\n    const iA = class iA {\n        constructor(BA, sA = {}){\n            if (BA === v) return;\n            u.argumentLengthCheck(arguments, 1, {\n                header: \"Request constructor\"\n            }), BA = u.converters.RequestInfo(BA), sA = u.converters.RequestInit(sA), this[F] = {\n                settingsObject: {\n                    baseUrl: b(),\n                    get origin () {\n                        return this.baseUrl?.origin;\n                    },\n                    policyContainer: f()\n                }\n            };\n            let eA = null, yA = null;\n            const WA = this[F].settingsObject.baseUrl;\n            let wA = null;\n            if (typeof BA == \"string\") {\n                this[N] = sA.dispatcher;\n                let IA;\n                try {\n                    IA = new URL(BA, WA);\n                } catch (hA) {\n                    throw new TypeError(\"Failed to parse URL from \" + BA, {\n                        cause: hA\n                    });\n                }\n                if (IA.username || IA.password) throw new TypeError(\"Request cannot be constructed from a URL that includes credentials: \" + BA);\n                eA = q({\n                    urlList: [\n                        IA\n                    ]\n                }), yA = \"cors\";\n            } else this[N] = sA.dispatcher || BA[N], Z(BA instanceof iA), eA = BA[g], wA = BA[G];\n            const qA = this[F].settingsObject.origin;\n            let MA = \"client\";\n            if (eA.window?.constructor?.name === \"EnvironmentSettingsObject\" && I(eA.window, qA) && (MA = eA.window), sA.window != null) throw new TypeError(`'window' option '${MA}' must be null`);\n            \"window\" in sA && (MA = \"no-window\"), eA = q({\n                method: eA.method,\n                headersList: eA.headersList,\n                unsafeRequest: eA.unsafeRequest,\n                client: this[F].settingsObject,\n                window: MA,\n                priority: eA.priority,\n                origin: eA.origin,\n                referrer: eA.referrer,\n                referrerPolicy: eA.referrerPolicy,\n                mode: eA.mode,\n                credentials: eA.credentials,\n                cache: eA.cache,\n                redirect: eA.redirect,\n                integrity: eA.integrity,\n                keepalive: eA.keepalive,\n                reloadNavigation: eA.reloadNavigation,\n                historyNavigation: eA.historyNavigation,\n                urlList: [\n                    ...eA.urlList\n                ]\n            });\n            const HA = Object.keys(sA).length !== 0;\n            if (HA && (eA.mode === \"navigate\" && (eA.mode = \"same-origin\"), eA.reloadNavigation = !1, eA.historyNavigation = !1, eA.origin = \"client\", eA.referrer = \"client\", eA.referrerPolicy = \"\", eA.url = eA.urlList[eA.urlList.length - 1], eA.urlList = [\n                eA.url\n            ]), sA.referrer !== void 0) {\n                const IA = sA.referrer;\n                if (IA === \"\") eA.referrer = \"no-referrer\";\n                else {\n                    let hA;\n                    try {\n                        hA = new URL(IA, WA);\n                    } catch (SA) {\n                        throw new TypeError(`Referrer \"${IA}\" is not a valid URL.`, {\n                            cause: SA\n                        });\n                    }\n                    hA.protocol === \"about:\" && hA.hostname === \"client\" || qA && !I(hA, this[F].settingsObject.baseUrl) ? eA.referrer = \"client\" : eA.referrer = hA;\n                }\n            }\n            sA.referrerPolicy !== void 0 && (eA.referrerPolicy = sA.referrerPolicy);\n            let pA;\n            if (sA.mode !== void 0 ? pA = sA.mode : pA = yA, pA === \"navigate\") throw u.errors.exception({\n                header: \"Request constructor\",\n                message: \"invalid request mode navigate.\"\n            });\n            if (pA != null && (eA.mode = pA), sA.credentials !== void 0 && (eA.credentials = sA.credentials), sA.cache !== void 0 && (eA.cache = sA.cache), eA.cache === \"only-if-cached\" && eA.mode !== \"same-origin\") throw new TypeError(\"'only-if-cached' can be set only with 'same-origin' mode\");\n            if (sA.redirect !== void 0 && (eA.redirect = sA.redirect), sA.integrity != null && (eA.integrity = String(sA.integrity)), sA.keepalive !== void 0 && (eA.keepalive = !!sA.keepalive), sA.method !== void 0) {\n                let IA = sA.method;\n                const hA = h[IA];\n                if (hA !== void 0) eA.method = hA;\n                else {\n                    if (!C(IA)) throw new TypeError(`'${IA}' is not a valid HTTP method.`);\n                    if (L.has(IA.toUpperCase())) throw new TypeError(`'${IA}' HTTP method is unsupported.`);\n                    IA = a(IA), eA.method = IA;\n                }\n                !$ && eA.method === \"patch\" && (process.emitWarning(\"Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.\", {\n                    code: \"UNDICI-FETCH-patch\"\n                }), $ = !0);\n            }\n            sA.signal !== void 0 && (wA = sA.signal), this[g] = eA;\n            const YA = new AbortController;\n            if (this[G] = YA.signal, this[G][F] = this[F], wA != null) {\n                if (!wA || typeof wA.aborted != \"boolean\" || typeof wA.addEventListener != \"function\") throw new TypeError(\"Failed to construct 'Request': member signal is not of type AbortSignal.\");\n                if (wA.aborted) YA.abort(wA.reason);\n                else {\n                    this[aA] = YA;\n                    const IA = new WeakRef(YA), hA = o(function() {\n                        const SA = IA.deref();\n                        SA !== void 0 && (X.unregister(hA), this.removeEventListener(\"abort\", hA), SA.abort(this.reason));\n                    }, \"abort\");\n                    try {\n                        (typeof P == \"function\" && P(wA) === tA || K(wA, \"abort\").length >= tA) && AA(100, wA);\n                    } catch  {}\n                    E.addAbortListener(wA, hA), X.register(YA, {\n                        signal: wA,\n                        abort: hA\n                    }, hA);\n                }\n            }\n            if (this[D] = new n(v), this[D][T] = eA.headersList, this[D][d] = \"request\", this[D][F] = this[F], pA === \"no-cors\") {\n                if (!c.has(eA.method)) throw new TypeError(`'${eA.method} is unsupported in no-cors mode.`);\n                this[D][d] = \"request-no-cors\";\n            }\n            if (HA) {\n                const IA = this[D][T], hA = sA.headers !== void 0 ? sA.headers : new s(IA);\n                if (IA.clear(), hA instanceof s) {\n                    for (const [SA, PA] of hA)IA.append(SA, PA);\n                    IA.cookies = hA.cookies;\n                } else r(this[D], hA);\n            }\n            const UA = BA instanceof iA ? BA[g].body : null;\n            if ((sA.body != null || UA != null) && (eA.method === \"GET\" || eA.method === \"HEAD\")) throw new TypeError(\"Request with GET/HEAD method cannot have body.\");\n            let JA = null;\n            if (sA.body != null) {\n                const [IA, hA] = e(sA.body, eA.keepalive);\n                JA = IA, hA && !this[D][T].contains(\"content-type\", !0) && this[D].append(\"content-type\", hA);\n            }\n            const VA = JA ?? UA;\n            if (VA != null && VA.source == null) {\n                if (JA != null && sA.duplex == null) throw new TypeError(\"RequestInit: duplex option is required when sending a body.\");\n                if (eA.mode !== \"same-origin\" && eA.mode !== \"cors\") throw new TypeError('If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"');\n                eA.useCORSPreflightFlag = !0;\n            }\n            let OA = VA;\n            if (JA == null && UA != null) {\n                if (E.isDisturbed(UA.stream) || UA.stream.locked) throw new TypeError(\"Cannot construct a Request with a Request object that has already been used.\");\n                const IA = new TransformStream;\n                UA.stream.pipeThrough(IA), OA = {\n                    source: UA.source,\n                    length: UA.length,\n                    stream: IA.readable\n                };\n            }\n            this[g].body = OA;\n        }\n        get method() {\n            return u.brandCheck(this, iA), this[g].method;\n        }\n        get url() {\n            return u.brandCheck(this, iA), m(this[g].url);\n        }\n        get headers() {\n            return u.brandCheck(this, iA), this[D];\n        }\n        get destination() {\n            return u.brandCheck(this, iA), this[g].destination;\n        }\n        get referrer() {\n            return u.brandCheck(this, iA), this[g].referrer === \"no-referrer\" ? \"\" : this[g].referrer === \"client\" ? \"about:client\" : this[g].referrer.toString();\n        }\n        get referrerPolicy() {\n            return u.brandCheck(this, iA), this[g].referrerPolicy;\n        }\n        get mode() {\n            return u.brandCheck(this, iA), this[g].mode;\n        }\n        get credentials() {\n            return this[g].credentials;\n        }\n        get cache() {\n            return u.brandCheck(this, iA), this[g].cache;\n        }\n        get redirect() {\n            return u.brandCheck(this, iA), this[g].redirect;\n        }\n        get integrity() {\n            return u.brandCheck(this, iA), this[g].integrity;\n        }\n        get keepalive() {\n            return u.brandCheck(this, iA), this[g].keepalive;\n        }\n        get isReloadNavigation() {\n            return u.brandCheck(this, iA), this[g].reloadNavigation;\n        }\n        get isHistoryNavigation() {\n            return u.brandCheck(this, iA), this[g].historyNavigation;\n        }\n        get signal() {\n            return u.brandCheck(this, iA), this[G];\n        }\n        get body() {\n            return u.brandCheck(this, iA), this[g].body ? this[g].body.stream : null;\n        }\n        get bodyUsed() {\n            return u.brandCheck(this, iA), !!this[g].body && E.isDisturbed(this[g].body.stream);\n        }\n        get duplex() {\n            return u.brandCheck(this, iA), \"half\";\n        }\n        clone() {\n            if (u.brandCheck(this, iA), this.bodyUsed || this.body?.locked) throw new TypeError(\"unusable\");\n            const BA = z(this[g]), sA = new AbortController;\n            return this.signal.aborted ? sA.abort(this.signal.reason) : E.addAbortListener(this.signal, ()=>{\n                sA.abort(this.signal.reason);\n            }), rA(BA, sA.signal, this[D][d], this[F]);\n        }\n        [Q.inspect.custom](BA, sA) {\n            sA.depth === null && (sA.depth = 2), sA.colors ?? (sA.colors = !0);\n            const eA = {\n                method: this.method,\n                url: this.url,\n                headers: this.headers,\n                destination: this.destination,\n                referrer: this.referrer,\n                referrerPolicy: this.referrerPolicy,\n                mode: this.mode,\n                credentials: this.credentials,\n                cache: this.cache,\n                redirect: this.redirect,\n                integrity: this.integrity,\n                keepalive: this.keepalive,\n                isReloadNavigation: this.isReloadNavigation,\n                isHistoryNavigation: this.isHistoryNavigation,\n                signal: this.signal\n            };\n            return `Request ${Q.formatWithOptions(sA, eA)}`;\n        }\n    };\n    o(iA, \"Request\");\n    let V = iA;\n    A(V);\n    function q(gA) {\n        const BA = {\n            method: \"GET\",\n            localURLsOnly: !1,\n            unsafeRequest: !1,\n            body: null,\n            client: null,\n            reservedClient: null,\n            replacesClientId: \"\",\n            window: \"client\",\n            keepalive: !1,\n            serviceWorkers: \"all\",\n            initiator: \"\",\n            destination: \"\",\n            priority: null,\n            origin: \"client\",\n            policyContainer: \"client\",\n            referrer: \"client\",\n            referrerPolicy: \"\",\n            mode: \"no-cors\",\n            useCORSPreflightFlag: !1,\n            credentials: \"same-origin\",\n            useCredentials: !1,\n            cache: \"default\",\n            redirect: \"follow\",\n            integrity: \"\",\n            cryptoGraphicsNonceMetadata: \"\",\n            parserMetadata: \"\",\n            reloadNavigation: !1,\n            historyNavigation: !1,\n            userActivation: !1,\n            taintedOrigin: !1,\n            redirectCount: 0,\n            responseTainting: \"basic\",\n            preventNoCacheCacheControlHeaderModification: !1,\n            done: !1,\n            timingAllowFailed: !1,\n            ...gA,\n            headersList: gA.headersList ? new s(gA.headersList) : new s\n        };\n        return BA.url = BA.urlList[0], BA;\n    }\n    o(q, \"makeRequest\");\n    function z(gA) {\n        const BA = q({\n            ...gA,\n            body: null\n        });\n        return gA.body != null && (BA.body = t(gA.body)), BA;\n    }\n    o(z, \"cloneRequest\");\n    function rA(gA, BA, sA, eA) {\n        const yA = new V(v);\n        return yA[g] = gA, yA[F] = eA, yA[G] = BA, yA[G][F] = eA, yA[D] = new n(v), yA[D][T] = gA.headersList, yA[D][d] = sA, yA[D][F] = eA, yA;\n    }\n    return o(rA, \"fromInnerRequest\"), Object.defineProperties(V.prototype, {\n        method: B,\n        url: B,\n        headers: B,\n        redirect: B,\n        clone: B,\n        signal: B,\n        duplex: B,\n        destination: B,\n        body: B,\n        bodyUsed: B,\n        isHistoryNavigation: B,\n        isReloadNavigation: B,\n        keepalive: B,\n        integrity: B,\n        cache: B,\n        credentials: B,\n        attribute: B,\n        referrerPolicy: B,\n        referrer: B,\n        mode: B,\n        [Symbol.toStringTag]: {\n            value: \"Request\",\n            configurable: !0\n        }\n    }), u.converters.Request = u.interfaceConverter(V), u.converters.RequestInfo = function(gA) {\n        return typeof gA == \"string\" ? u.converters.USVString(gA) : gA instanceof V ? u.converters.Request(gA) : u.converters.USVString(gA);\n    }, u.converters.AbortSignal = u.interfaceConverter(AbortSignal), u.converters.RequestInit = u.dictionaryConverter([\n        {\n            key: \"method\",\n            converter: u.converters.ByteString\n        },\n        {\n            key: \"headers\",\n            converter: u.converters.HeadersInit\n        },\n        {\n            key: \"body\",\n            converter: u.nullableConverter(u.converters.BodyInit)\n        },\n        {\n            key: \"referrer\",\n            converter: u.converters.USVString\n        },\n        {\n            key: \"referrerPolicy\",\n            converter: u.converters.DOMString,\n            allowedValues: l\n        },\n        {\n            key: \"mode\",\n            converter: u.converters.DOMString,\n            allowedValues: k\n        },\n        {\n            key: \"credentials\",\n            converter: u.converters.DOMString,\n            allowedValues: w\n        },\n        {\n            key: \"cache\",\n            converter: u.converters.DOMString,\n            allowedValues: U\n        },\n        {\n            key: \"redirect\",\n            converter: u.converters.DOMString,\n            allowedValues: S\n        },\n        {\n            key: \"integrity\",\n            converter: u.converters.DOMString\n        },\n        {\n            key: \"keepalive\",\n            converter: u.converters.boolean\n        },\n        {\n            key: \"signal\",\n            converter: u.nullableConverter((gA)=>u.converters.AbortSignal(gA, {\n                    strict: !1\n                }))\n        },\n        {\n            key: \"window\",\n            converter: u.converters.any\n        },\n        {\n            key: \"duplex\",\n            converter: u.converters.DOMString,\n            allowedValues: M\n        },\n        {\n            key: \"dispatcher\",\n            converter: u.converters.any\n        }\n    ]), request = {\n        Request: V,\n        makeRequest: q,\n        fromInnerRequest: rA,\n        cloneRequest: z\n    }, request;\n}\no(requireRequest, \"requireRequest\");\nvar fetch_1, hasRequiredFetch;\nfunction requireFetch() {\n    if (hasRequiredFetch) return fetch_1;\n    hasRequiredFetch = 1;\n    const { makeNetworkError: e, makeAppropriateNetworkError: A, filterResponse: t, makeResponse: n, fromInnerResponse: r } = requireResponse(), { HeadersList: s } = requireHeaders(), { Request: i, cloneRequest: E } = requireRequest(), Q = zlib__default, { bytesMatch: C, makePolicyContainer: I, clonePolicyContainer: a, requestBadPort: f, TAOCheck: h, appendRequestOriginHeader: L, responseLocationURL: c, requestCurrentURL: l, setRequestReferrerPolicyOnRedirect: S, tryUpgradeRequestToAPotentiallyTrustworthyURL: k, createOpaqueTimingInfo: w, appendFetchMetadata: U, corsCheck: M, crossOriginResourcePolicyCheck: B, determineRequestsReferrer: D, coarsenedSharedCurrentTime: G, createDeferredPromise: g, isBlobLike: d, sameOrigin: F, isCancelled: N, isAborted: u, isErrorLike: b, fullyReadBody: m, readableStreamClose: T, isomorphicEncode: v, urlIsLocal: Z, urlIsHttpHttpsScheme: P, urlHasHttpsScheme: AA, clampAndCoarsenConnectionTimingInfo: K, simpleRangeHeaderValue: tA, buildContentRange: aA, createInflate: X, extractMimeType: $ } = requireUtil$5(), { kState: V, kDispatcher: q } = requireSymbols$3(), z = require$$0__default, { safelyExtractBody: rA, extractBody: iA } = requireBody(), { redirectStatusSet: gA, nullBodyStatus: BA, safeMethodsSet: sA, requestBodyHeader: eA, subresourceSet: yA } = requireConstants$2(), WA = require$$0__default$3, { Readable: wA, pipeline: qA } = Stream__default, { addAbortListener: MA, isErrored: HA, isReadable: pA, nodeMajor: YA, nodeMinor: UA, bufferToLowerCasedHeaderName: JA } = util$m, { dataURLProcessor: VA, serializeAMimeType: OA, minimizeSupportedMimeType: IA } = requireDataUrl(), { getGlobalDispatcher: hA } = global, { webidl: SA } = requireWebidl(), { STATUS_CODES: PA } = http__default, Pe = [\n        \"GET\",\n        \"HEAD\"\n    ], ee = typeof __UNDICI_IS_NODE__ < \"u\" || typeof esbuildDetection < \"u\" ? \"node\" : \"undici\";\n    let ZA;\n    const nA = class nA extends WA {\n        constructor(O){\n            super(), this.dispatcher = O, this.connection = null, this.dump = !1, this.state = \"ongoing\";\n        }\n        terminate(O) {\n            this.state === \"ongoing\" && (this.state = \"terminated\", this.connection?.destroy(O), this.emit(\"terminated\", O));\n        }\n        abort(O) {\n            this.state === \"ongoing\" && (this.state = \"aborted\", O || (O = new DOMException(\"The operation was aborted.\", \"AbortError\")), this.serializedAbortReason = O, this.connection?.destroy(O), this.emit(\"terminated\", O));\n        }\n    };\n    o(nA, \"Fetch\");\n    let XA = nA;\n    function Ze(R, O = void 0) {\n        SA.argumentLengthCheck(arguments, 1, {\n            header: \"globalThis.fetch\"\n        });\n        const H = g();\n        let J;\n        try {\n            J = new i(R, O);\n        } catch (oA) {\n            return H.reject(oA), H.promise;\n        }\n        const _ = J[V];\n        if (J.signal.aborted) return te(H, _, null, J.signal.reason), H.promise;\n        _.client.globalObject?.constructor?.name === \"ServiceWorkerGlobalScope\" && (_.serviceWorkers = \"none\");\n        let QA = null;\n        const lA = null;\n        let uA = !1, cA = null;\n        return MA(J.signal, ()=>{\n            uA = !0, z(cA != null), cA.abort(J.signal.reason), te(H, _, QA, J.signal.reason);\n        }), cA = Ve({\n            request: _,\n            processResponseEndOfBody: o((oA)=>KA(oA, \"fetch\"), \"handleFetchDone\"),\n            processResponse: o((oA)=>{\n                if (!uA) {\n                    if (oA.aborted) {\n                        te(H, _, QA, cA.serializedAbortReason);\n                        return;\n                    }\n                    if (oA.type === \"error\") {\n                        H.reject(new TypeError(\"fetch failed\", {\n                            cause: oA.error\n                        }));\n                        return;\n                    }\n                    QA = r(oA, \"immutable\", lA), H.resolve(QA);\n                }\n            }, \"processResponse\"),\n            dispatcher: J[q]\n        }), H.promise;\n    }\n    o(Ze, \"fetch\");\n    function KA(R, O = \"other\") {\n        if (R.type === \"error\" && R.aborted || !R.urlList?.length) return;\n        const H = R.urlList[0];\n        let J = R.timingInfo, _ = R.cacheState;\n        P(H) && J !== null && (R.timingAllowPassed || (J = w({\n            startTime: J.startTime\n        }), _ = \"\"), J.endTime = G(), R.timingInfo = J, He(J, H.href, O, globalThis, _));\n    }\n    o(KA, \"finalizeAndReportTiming\");\n    const He = YA > 18 || YA === 18 && UA >= 2 ? performance.markResourceTiming : ()=>{};\n    function te(R, O, H, J) {\n        if (R.reject(J), O.body != null && pA(O.body?.stream) && O.body.stream.cancel(J).catch((x)=>{\n            if (x.code !== \"ERR_INVALID_STATE\") throw x;\n        }), H == null) return;\n        const _ = H[V];\n        _.body != null && pA(_.body?.stream) && _.body.stream.cancel(J).catch((x)=>{\n            if (x.code !== \"ERR_INVALID_STATE\") throw x;\n        });\n    }\n    o(te, \"abortFetch\");\n    function Ve({ request: R, processRequestBodyChunkLength: O, processRequestEndOfBody: H, processResponse: J, processResponseEndOfBody: _, processResponseConsumeBody: x, useParallelQueue: QA = !1, dispatcher: lA = hA() }) {\n        z(lA);\n        let uA = null, cA = !1;\n        R.client != null && (uA = R.client.globalObject, cA = R.client.crossOriginIsolatedCapability);\n        const fA = G(cA), mA = w({\n            startTime: fA\n        }), oA = {\n            controller: new XA(lA),\n            request: R,\n            timingInfo: mA,\n            processRequestBodyChunkLength: O,\n            processRequestEndOfBody: H,\n            processResponse: J,\n            processResponseConsumeBody: x,\n            processResponseEndOfBody: _,\n            taskDestination: uA,\n            crossOriginIsolatedCapability: cA\n        };\n        return z(!R.body || R.body.stream), R.window === \"client\" && (R.window = R.client?.globalObject?.constructor?.name === \"Window\" ? R.client : \"no-window\"), R.origin === \"client\" && (R.origin = R.client?.origin), R.policyContainer === \"client\" && (R.client != null ? R.policyContainer = a(R.client.policyContainer) : R.policyContainer = I()), R.headersList.contains(\"accept\", !0) || R.headersList.append(\"accept\", \"*/*\", !0), R.headersList.contains(\"accept-language\", !0) || R.headersList.append(\"accept-language\", \"*\", !0), R.priority, yA.has(R.destination), re(oA).catch((RA)=>{\n            oA.controller.terminate(RA);\n        }), oA.controller;\n    }\n    o(Ve, \"fetching\");\n    async function re(R, O = !1) {\n        const H = R.request;\n        let J = null;\n        if (H.localURLsOnly && !Z(l(H)) && (J = e(\"local URLs only\")), k(H), f(H) === \"blocked\" && (J = e(\"bad port\")), H.referrerPolicy === \"\" && (H.referrerPolicy = H.policyContainer.referrerPolicy), H.referrer !== \"no-referrer\" && (H.referrer = D(H)), J === null && (J = await (async ()=>{\n            const x = l(H);\n            return F(x, H.url) && H.responseTainting === \"basic\" || x.protocol === \"data:\" || H.mode === \"navigate\" || H.mode === \"websocket\" ? (H.responseTainting = \"basic\", await ve(R)) : H.mode === \"same-origin\" ? e('request mode cannot be \"same-origin\"') : H.mode === \"no-cors\" ? H.redirect !== \"follow\" ? e('redirect mode cannot be \"follow\" for \"no-cors\" request') : (H.responseTainting = \"opaque\", await ve(R)) : P(l(H)) ? (H.responseTainting = \"cors\", await y(R)) : e(\"URL scheme must be a HTTP(S) scheme\");\n        })()), O) return J;\n        J.status !== 0 && !J.internalResponse && (H.responseTainting, H.responseTainting === \"basic\" ? J = t(J, \"basic\") : H.responseTainting === \"cors\" ? J = t(J, \"cors\") : H.responseTainting === \"opaque\" ? J = t(J, \"opaque\") : z(!1));\n        let _ = J.status === 0 ? J : J.internalResponse;\n        if (_.urlList.length === 0 && _.urlList.push(...H.urlList), H.timingAllowFailed || (J.timingAllowPassed = !0), J.type === \"opaque\" && _.status === 206 && _.rangeRequested && !H.headers.contains(\"range\", !0) && (J = _ = e()), J.status !== 0 && (H.method === \"HEAD\" || H.method === \"CONNECT\" || BA.includes(_.status)) && (_.body = null, R.controller.dump = !0), H.integrity) {\n            const x = o((lA)=>vA(R, e(lA)), \"processBodyError\");\n            if (H.responseTainting === \"opaque\" || J.body == null) {\n                x(J.error);\n                return;\n            }\n            const QA = o((lA)=>{\n                if (!C(lA, H.integrity)) {\n                    x(\"integrity mismatch\");\n                    return;\n                }\n                J.body = rA(lA)[0], vA(R, J);\n            }, \"processBody\");\n            await m(J.body, QA, x);\n        } else vA(R, J);\n    }\n    o(re, \"mainFetch\");\n    function ve(R) {\n        if (N(R) && R.request.redirectCount === 0) return Promise.resolve(A(R));\n        const { request: O } = R, { protocol: H } = l(O);\n        switch(H){\n            case \"about:\":\n                return Promise.resolve(e(\"about scheme is not supported\"));\n            case \"blob:\":\n                {\n                    ZA || (ZA = require$$6__default.resolveObjectURL);\n                    const J = l(O);\n                    if (J.search.length !== 0) return Promise.resolve(e(\"NetworkError when attempting to fetch resource.\"));\n                    const _ = ZA(J.toString());\n                    if (O.method !== \"GET\" || !d(_)) return Promise.resolve(e(\"invalid method\"));\n                    const x = n(), QA = _.size, lA = v(`${QA}`), uA = _.type;\n                    if (O.headersList.contains(\"range\", !0)) {\n                        x.rangeRequested = !0;\n                        const cA = O.headersList.get(\"range\", !0), fA = tA(cA, !0);\n                        if (fA === \"failure\") return Promise.resolve(e(\"failed to fetch the data URL\"));\n                        let { rangeStartValue: mA, rangeEndValue: oA } = fA;\n                        if (mA === null) mA = QA - oA, oA = mA + oA - 1;\n                        else {\n                            if (mA >= QA) return Promise.resolve(e(\"Range start is greater than the blob's size.\"));\n                            (oA === null || oA >= QA) && (oA = QA - 1);\n                        }\n                        const RA = _.slice(mA, oA, uA), bA = iA(RA);\n                        x.body = bA[0];\n                        const dA = v(`${RA.size}`), GA = aA(mA, oA, QA);\n                        x.status = 206, x.statusText = \"Partial Content\", x.headersList.set(\"content-length\", dA, !0), x.headersList.set(\"content-type\", uA, !0), x.headersList.set(\"content-range\", GA, !0);\n                    } else {\n                        const cA = iA(_);\n                        x.statusText = \"OK\", x.body = cA[0], x.headersList.set(\"content-length\", lA, !0), x.headersList.set(\"content-type\", uA, !0);\n                    }\n                    return Promise.resolve(x);\n                }\n            case \"data:\":\n                {\n                    const J = l(O), _ = VA(J);\n                    if (_ === \"failure\") return Promise.resolve(e(\"failed to fetch the data URL\"));\n                    const x = OA(_.mimeType);\n                    return Promise.resolve(n({\n                        statusText: \"OK\",\n                        headersList: [\n                            [\n                                \"content-type\",\n                                {\n                                    name: \"Content-Type\",\n                                    value: x\n                                }\n                            ]\n                        ],\n                        body: rA(_.body)[0]\n                    }));\n                }\n            case \"file:\":\n                return Promise.resolve(e(\"not implemented... yet...\"));\n            case \"http:\":\n            case \"https:\":\n                return y(R).catch((J)=>e(J));\n            default:\n                return Promise.resolve(e(\"unknown scheme\"));\n        }\n    }\n    o(ve, \"schemeFetch\");\n    function Xe(R, O) {\n        R.request.done = !0, R.processResponseDone != null && queueMicrotask(()=>R.processResponseDone(O));\n    }\n    o(Xe, \"finalizeResponse\");\n    function vA(R, O) {\n        let H = R.timingInfo;\n        const J = o(()=>{\n            const x = Date.now();\n            R.request.destination === \"document\" && (R.controller.fullTimingInfo = H), R.controller.reportTimingSteps = ()=>{\n                if (R.request.url.protocol !== \"https:\") return;\n                H.endTime = x;\n                let lA = O.cacheState;\n                const uA = O.bodyInfo;\n                O.timingAllowPassed || (H = w(H), lA = \"\");\n                let cA = 0;\n                if (R.request.mode !== \"navigator\" || !O.hasCrossOriginRedirects) {\n                    cA = O.status;\n                    const fA = $(O.headersList);\n                    fA !== \"failure\" && (uA.contentType = IA(fA));\n                }\n                R.request.initiatorType != null && He(H, R.request.url.href, R.request.initiatorType, globalThis, lA, uA, cA);\n            };\n            const QA = o(()=>{\n                R.request.done = !0, R.processResponseEndOfBody != null && queueMicrotask(()=>R.processResponseEndOfBody(O)), R.request.initiatorType != null && R.controller.reportTimingSteps();\n            }, \"processResponseEndOfBodyTask\");\n            queueMicrotask(()=>QA());\n        }, \"processResponseEndOfBody\");\n        R.processResponse != null && queueMicrotask(()=>R.processResponse(O));\n        const _ = O.type === \"error\" ? O : O.internalResponse ?? O;\n        if (_.body == null) J();\n        else {\n            const x = new TransformStream({\n                start () {},\n                transform (lA, uA) {\n                    uA.enqueue(lA);\n                },\n                flush: J\n            });\n            _.body.stream.pipeThrough(x);\n            const QA = new ReadableStream({\n                readableStream: x.readable,\n                async start () {\n                    this._bodyReader = this.readableStream.getReader();\n                },\n                async pull (lA) {\n                    for(; lA.desiredSize >= 0;){\n                        const { done: uA, value: cA } = await this._bodyReader.read();\n                        if (uA) {\n                            queueMicrotask(()=>T(lA));\n                            break;\n                        }\n                        lA.enqueue(cA);\n                    }\n                },\n                type: \"bytes\"\n            });\n            _.body.stream = QA;\n        }\n    }\n    o(vA, \"fetchFinale\");\n    async function y(R) {\n        const O = R.request;\n        let H = null, J = null;\n        const _ = R.timingInfo;\n        if (O.serviceWorkers, H === null) {\n            if (O.redirect === \"follow\" && (O.serviceWorkers = \"none\"), J = H = await W(R), O.responseTainting === \"cors\" && M(O, H) === \"failure\") return e(\"cors failure\");\n            h(O, H) === \"failure\" && (O.timingAllowFailed = !0);\n        }\n        return (O.responseTainting === \"opaque\" || H.type === \"opaque\") && B(O.origin, O.client, O.destination, J) === \"blocked\" ? e(\"blocked\") : (gA.has(J.status) && (O.redirect !== \"manual\" && R.controller.connection.destroy(void 0, !1), O.redirect === \"error\" ? H = e(\"unexpected redirect\") : O.redirect === \"manual\" ? H = J : O.redirect === \"follow\" ? H = await Y(R, H) : z(!1)), H.timingInfo = _, H);\n    }\n    o(y, \"httpFetch\");\n    function Y(R, O) {\n        const H = R.request, J = O.internalResponse ? O.internalResponse : O;\n        let _;\n        try {\n            if (_ = c(J, l(H).hash), _ == null) return O;\n        } catch (QA) {\n            return Promise.resolve(e(QA));\n        }\n        if (!P(_)) return Promise.resolve(e(\"URL scheme must be a HTTP(S) scheme\"));\n        if (H.redirectCount === 20) return Promise.resolve(e(\"redirect count exceeded\"));\n        if (H.redirectCount += 1, H.mode === \"cors\" && (_.username || _.password) && !F(H, _)) return Promise.resolve(e('cross origin not allowed for request mode \"cors\"'));\n        if (H.responseTainting === \"cors\" && (_.username || _.password)) return Promise.resolve(e('URL cannot contain credentials for request mode \"cors\"'));\n        if (J.status !== 303 && H.body != null && H.body.source == null) return Promise.resolve(e());\n        if ([\n            301,\n            302\n        ].includes(J.status) && H.method === \"POST\" || J.status === 303 && !Pe.includes(H.method)) {\n            H.method = \"GET\", H.body = null;\n            for (const QA of eA)H.headersList.delete(QA);\n        }\n        F(l(H), _) || (H.headersList.delete(\"authorization\", !0), H.headersList.delete(\"proxy-authorization\", !0), H.headersList.delete(\"cookie\", !0), H.headersList.delete(\"host\", !0)), H.body != null && (z(H.body.source != null), H.body = rA(H.body.source)[0]);\n        const x = R.timingInfo;\n        return x.redirectEndTime = x.postRedirectStartTime = G(R.crossOriginIsolatedCapability), x.redirectStartTime === 0 && (x.redirectStartTime = x.startTime), H.urlList.push(_), S(H, J), re(R, !0);\n    }\n    o(Y, \"httpRedirectFetch\");\n    async function W(R, O = !1, H = !1) {\n        const J = R.request;\n        let _ = null, x = null, QA = null;\n        J.window === \"no-window\" && J.redirect === \"error\" ? (_ = R, x = J) : (x = E(J), _ = {\n            ...R\n        }, _.request = x);\n        const lA = J.credentials === \"include\" || J.credentials === \"same-origin\" && J.responseTainting === \"basic\", uA = x.body ? x.body.length : null;\n        let cA = null;\n        if (x.body == null && [\n            \"POST\",\n            \"PUT\"\n        ].includes(x.method) && (cA = \"0\"), uA != null && (cA = v(`${uA}`)), cA != null && x.headersList.append(\"content-length\", cA, !0), uA != null && x.keepalive, x.referrer instanceof URL && x.headersList.append(\"referer\", v(x.referrer.href), !0), L(x), U(x), x.headersList.contains(\"user-agent\", !0) || x.headersList.append(\"user-agent\", ee), x.cache === \"default\" && (x.headersList.contains(\"if-modified-since\", !0) || x.headersList.contains(\"if-none-match\", !0) || x.headersList.contains(\"if-unmodified-since\", !0) || x.headersList.contains(\"if-match\", !0) || x.headersList.contains(\"if-range\", !0)) && (x.cache = \"no-store\"), x.cache === \"no-cache\" && !x.preventNoCacheCacheControlHeaderModification && !x.headersList.contains(\"cache-control\", !0) && x.headersList.append(\"cache-control\", \"max-age=0\", !0), (x.cache === \"no-store\" || x.cache === \"reload\") && (x.headersList.contains(\"pragma\", !0) || x.headersList.append(\"pragma\", \"no-cache\", !0), x.headersList.contains(\"cache-control\", !0) || x.headersList.append(\"cache-control\", \"no-cache\", !0)), x.headersList.contains(\"range\", !0) && x.headersList.append(\"accept-encoding\", \"identity\", !0), x.headersList.contains(\"accept-encoding\", !0) || (AA(l(x)) ? x.headersList.append(\"accept-encoding\", \"br, gzip, deflate\", !0) : x.headersList.append(\"accept-encoding\", \"gzip, deflate\", !0)), x.headersList.delete(\"host\", !0), x.cache = \"no-store\", x.mode !== \"no-store\" && x.mode, QA == null) {\n            if (x.mode === \"only-if-cached\") return e(\"only if cached\");\n            const fA = await j(_, lA, H);\n            !sA.has(x.method) && fA.status >= 200 && fA.status <= 399, QA == null && (QA = fA);\n        }\n        if (QA.urlList = [\n            ...x.urlList\n        ], x.headersList.contains(\"range\", !0) && (QA.rangeRequested = !0), QA.requestIncludesCredentials = lA, QA.status === 407) return J.window === \"no-window\" ? e() : N(R) ? A(R) : e(\"proxy authentication required\");\n        if (QA.status === 421 && !H && (J.body == null || J.body.source != null)) {\n            if (N(R)) return A(R);\n            R.controller.connection.destroy(), QA = await W(R, O, !0);\n        }\n        return QA;\n    }\n    o(W, \"httpNetworkOrCacheFetch\");\n    async function j(R, O = !1, H = !1) {\n        z(!R.controller.connection || R.controller.connection.destroyed), R.controller.connection = {\n            abort: null,\n            destroyed: !1,\n            destroy (oA, RA = !0) {\n                this.destroyed || (this.destroyed = !0, RA && this.abort?.(oA ?? new DOMException(\"The operation was aborted.\", \"AbortError\")));\n            }\n        };\n        const J = R.request;\n        let _ = null;\n        const x = R.timingInfo;\n        J.cache = \"no-store\", J.mode;\n        let QA = null;\n        if (J.body == null && R.processRequestEndOfBody) queueMicrotask(()=>R.processRequestEndOfBody());\n        else if (J.body != null) {\n            const oA = o(async function*(dA) {\n                N(R) || (yield dA, R.processRequestBodyChunkLength?.(dA.byteLength));\n            }, \"processBodyChunk\"), RA = o(()=>{\n                N(R) || R.processRequestEndOfBody && R.processRequestEndOfBody();\n            }, \"processEndOfBody\"), bA = o((dA)=>{\n                N(R) || (dA.name === \"AbortError\" ? R.controller.abort() : R.controller.terminate(dA));\n            }, \"processBodyError\");\n            QA = async function*() {\n                try {\n                    for await (const dA of J.body.stream)yield* oA(dA);\n                    RA();\n                } catch (dA) {\n                    bA(dA);\n                }\n            }();\n        }\n        try {\n            const { body: oA, status: RA, statusText: bA, headersList: dA, socket: GA } = await mA({\n                body: QA\n            });\n            if (GA) _ = n({\n                status: RA,\n                statusText: bA,\n                headersList: dA,\n                socket: GA\n            });\n            else {\n                const DA = oA[Symbol.asyncIterator]();\n                R.controller.next = ()=>DA.next(), _ = n({\n                    status: RA,\n                    statusText: bA,\n                    headersList: dA\n                });\n            }\n        } catch (oA) {\n            return oA.name === \"AbortError\" ? (R.controller.connection.destroy(), A(R, oA)) : e(oA);\n        }\n        const lA = o(async ()=>{\n            await R.controller.resume();\n        }, \"pullAlgorithm\"), uA = o((oA)=>{\n            R.controller.abort(oA);\n        }, \"cancelAlgorithm\"), cA = new ReadableStream({\n            async start (oA) {\n                R.controller.controller = oA;\n            },\n            async pull (oA) {\n                await lA();\n            },\n            async cancel (oA) {\n                await uA(oA);\n            },\n            type: \"bytes\"\n        });\n        _.body = {\n            stream: cA,\n            source: null,\n            length: null\n        }, R.controller.onAborted = fA, R.controller.on(\"terminated\", fA), R.controller.resume = async ()=>{\n            for(;;){\n                let oA, RA;\n                try {\n                    const { done: dA, value: GA } = await R.controller.next();\n                    if (u(R)) break;\n                    oA = dA ? void 0 : GA;\n                } catch (dA) {\n                    R.controller.ended && !x.encodedBodySize ? oA = void 0 : (oA = dA, RA = !0);\n                }\n                if (oA === void 0) {\n                    T(R.controller.controller), Xe(R, _);\n                    return;\n                }\n                if (x.decodedBodySize += oA?.byteLength ?? 0, RA) {\n                    R.controller.terminate(oA);\n                    return;\n                }\n                const bA = new Uint8Array(oA);\n                if (bA.byteLength && R.controller.controller.enqueue(bA), HA(cA)) {\n                    R.controller.terminate();\n                    return;\n                }\n                if (R.controller.controller.desiredSize <= 0) return;\n            }\n        };\n        function fA(oA) {\n            u(R) ? (_.aborted = !0, pA(cA) && R.controller.controller.error(R.controller.serializedAbortReason)) : pA(cA) && R.controller.controller.error(new TypeError(\"terminated\", {\n                cause: b(oA) ? oA : void 0\n            })), R.controller.connection.destroy();\n        }\n        return o(fA, \"onAborted\"), _;\n        function mA({ body: oA }) {\n            const RA = l(J), bA = R.controller.dispatcher;\n            return new Promise((dA, GA)=>bA.dispatch({\n                    path: RA.pathname + RA.search,\n                    origin: RA.origin,\n                    method: J.method,\n                    body: bA.isMockActive ? J.body && (J.body.source || J.body.stream) : oA,\n                    headers: J.headersList.entries,\n                    maxRedirections: 0,\n                    upgrade: J.mode === \"websocket\" ? \"websocket\" : void 0\n                }, {\n                    body: null,\n                    abort: null,\n                    onConnect (DA) {\n                        const { connection: FA } = R.controller;\n                        x.finalConnectionTimingInfo = K(void 0, x.postRedirectStartTime, R.crossOriginIsolatedCapability), FA.destroyed ? DA(new DOMException(\"The operation was aborted.\", \"AbortError\")) : (R.controller.on(\"terminated\", DA), this.abort = FA.abort = DA), x.finalNetworkRequestStartTime = G(R.crossOriginIsolatedCapability);\n                    },\n                    onResponseStarted () {\n                        x.finalNetworkResponseStartTime = G(R.crossOriginIsolatedCapability);\n                    },\n                    onHeaders (DA, FA, Ke, xe) {\n                        if (DA < 200) return;\n                        let TA = [], ft = \"\";\n                        const We = new s;\n                        if (Array.isArray(FA)) {\n                            for(let LA = 0; LA < FA.length; LA += 2)We.append(JA(FA[LA]), FA[LA + 1].toString(\"latin1\"), !0);\n                            const jA = We.get(\"content-encoding\", !0);\n                            jA && (TA = jA.toLowerCase().split(\",\").map((LA)=>LA.trim())), ft = We.get(\"location\", !0);\n                        }\n                        this.body = new wA({\n                            read: Ke\n                        });\n                        const zA = [], Nt = ft && J.redirect === \"follow\" && gA.has(DA);\n                        if (J.method !== \"HEAD\" && J.method !== \"CONNECT\" && !BA.includes(DA) && !Nt) for(let jA = 0; jA < TA.length; ++jA){\n                            const LA = TA[jA];\n                            if (LA === \"x-gzip\" || LA === \"gzip\") zA.push(Q.createGunzip({\n                                flush: Q.constants.Z_SYNC_FLUSH,\n                                finishFlush: Q.constants.Z_SYNC_FLUSH\n                            }));\n                            else if (LA === \"deflate\") zA.push(X());\n                            else if (LA === \"br\") zA.push(Q.createBrotliDecompress());\n                            else {\n                                zA.length = 0;\n                                break;\n                            }\n                        }\n                        return dA({\n                            status: DA,\n                            statusText: xe,\n                            headersList: We,\n                            body: zA.length ? qA(this.body, ...zA, ()=>{}) : this.body.on(\"error\", ()=>{})\n                        }), !0;\n                    },\n                    onData (DA) {\n                        if (R.controller.dump) return;\n                        const FA = DA;\n                        return x.encodedBodySize += FA.byteLength, this.body.push(FA);\n                    },\n                    onComplete () {\n                        this.abort && R.controller.off(\"terminated\", this.abort), R.controller.onAborted && R.controller.off(\"terminated\", R.controller.onAborted), R.controller.ended = !0, this.body.push(null);\n                    },\n                    onError (DA) {\n                        this.abort && R.controller.off(\"terminated\", this.abort), this.body?.destroy(DA), R.controller.terminate(DA), GA(DA);\n                    },\n                    onUpgrade (DA, FA, Ke) {\n                        if (DA !== 101) return;\n                        const xe = new s;\n                        for(let TA = 0; TA < FA.length; TA += 2)xe.append(JA(FA[TA]), FA[TA + 1].toString(\"latin1\"), !0);\n                        return dA({\n                            status: DA,\n                            statusText: PA[DA],\n                            headersList: xe,\n                            socket: Ke\n                        }), !0;\n                    }\n                }));\n        }\n        o(mA, \"dispatch\");\n    }\n    return o(j, \"httpNetworkFetch\"), fetch_1 = {\n        fetch: Ze,\n        Fetch: XA,\n        fetching: Ve,\n        finalizeAndReportTiming: KA\n    }, fetch_1;\n}\no(requireFetch, \"requireFetch\");\nvar symbols$2, hasRequiredSymbols$2;\nfunction requireSymbols$2() {\n    return hasRequiredSymbols$2 || (hasRequiredSymbols$2 = 1, symbols$2 = {\n        kState: Symbol(\"FileReader state\"),\n        kResult: Symbol(\"FileReader result\"),\n        kError: Symbol(\"FileReader error\"),\n        kLastProgressEventFired: Symbol(\"FileReader last progress event fired timestamp\"),\n        kEvents: Symbol(\"FileReader events\"),\n        kAborted: Symbol(\"FileReader aborted\")\n    }), symbols$2;\n}\no(requireSymbols$2, \"requireSymbols$2\");\nvar progressevent, hasRequiredProgressevent;\nfunction requireProgressevent() {\n    if (hasRequiredProgressevent) return progressevent;\n    hasRequiredProgressevent = 1;\n    const { webidl: e } = requireWebidl(), A = Symbol(\"ProgressEvent state\"), n = class n extends Event {\n        constructor(s, i = {}){\n            s = e.converters.DOMString(s), i = e.converters.ProgressEventInit(i ?? {}), super(s, i), this[A] = {\n                lengthComputable: i.lengthComputable,\n                loaded: i.loaded,\n                total: i.total\n            };\n        }\n        get lengthComputable() {\n            return e.brandCheck(this, n), this[A].lengthComputable;\n        }\n        get loaded() {\n            return e.brandCheck(this, n), this[A].loaded;\n        }\n        get total() {\n            return e.brandCheck(this, n), this[A].total;\n        }\n    };\n    o(n, \"ProgressEvent\");\n    let t = n;\n    return e.converters.ProgressEventInit = e.dictionaryConverter([\n        {\n            key: \"lengthComputable\",\n            converter: e.converters.boolean,\n            defaultValue: !1\n        },\n        {\n            key: \"loaded\",\n            converter: e.converters[\"unsigned long long\"],\n            defaultValue: 0\n        },\n        {\n            key: \"total\",\n            converter: e.converters[\"unsigned long long\"],\n            defaultValue: 0\n        },\n        {\n            key: \"bubbles\",\n            converter: e.converters.boolean,\n            defaultValue: !1\n        },\n        {\n            key: \"cancelable\",\n            converter: e.converters.boolean,\n            defaultValue: !1\n        },\n        {\n            key: \"composed\",\n            converter: e.converters.boolean,\n            defaultValue: !1\n        }\n    ]), progressevent = {\n        ProgressEvent: t\n    }, progressevent;\n}\no(requireProgressevent, \"requireProgressevent\");\nvar encoding, hasRequiredEncoding;\nfunction requireEncoding() {\n    if (hasRequiredEncoding) return encoding;\n    hasRequiredEncoding = 1;\n    function e(A) {\n        if (!A) return \"failure\";\n        switch(A.trim().toLowerCase()){\n            case \"unicode-1-1-utf-8\":\n            case \"unicode11utf8\":\n            case \"unicode20utf8\":\n            case \"utf-8\":\n            case \"utf8\":\n            case \"x-unicode20utf8\":\n                return \"UTF-8\";\n            case \"866\":\n            case \"cp866\":\n            case \"csibm866\":\n            case \"ibm866\":\n                return \"IBM866\";\n            case \"csisolatin2\":\n            case \"iso-8859-2\":\n            case \"iso-ir-101\":\n            case \"iso8859-2\":\n            case \"iso88592\":\n            case \"iso_8859-2\":\n            case \"iso_8859-2:1987\":\n            case \"l2\":\n            case \"latin2\":\n                return \"ISO-8859-2\";\n            case \"csisolatin3\":\n            case \"iso-8859-3\":\n            case \"iso-ir-109\":\n            case \"iso8859-3\":\n            case \"iso88593\":\n            case \"iso_8859-3\":\n            case \"iso_8859-3:1988\":\n            case \"l3\":\n            case \"latin3\":\n                return \"ISO-8859-3\";\n            case \"csisolatin4\":\n            case \"iso-8859-4\":\n            case \"iso-ir-110\":\n            case \"iso8859-4\":\n            case \"iso88594\":\n            case \"iso_8859-4\":\n            case \"iso_8859-4:1988\":\n            case \"l4\":\n            case \"latin4\":\n                return \"ISO-8859-4\";\n            case \"csisolatincyrillic\":\n            case \"cyrillic\":\n            case \"iso-8859-5\":\n            case \"iso-ir-144\":\n            case \"iso8859-5\":\n            case \"iso88595\":\n            case \"iso_8859-5\":\n            case \"iso_8859-5:1988\":\n                return \"ISO-8859-5\";\n            case \"arabic\":\n            case \"asmo-708\":\n            case \"csiso88596e\":\n            case \"csiso88596i\":\n            case \"csisolatinarabic\":\n            case \"ecma-114\":\n            case \"iso-8859-6\":\n            case \"iso-8859-6-e\":\n            case \"iso-8859-6-i\":\n            case \"iso-ir-127\":\n            case \"iso8859-6\":\n            case \"iso88596\":\n            case \"iso_8859-6\":\n            case \"iso_8859-6:1987\":\n                return \"ISO-8859-6\";\n            case \"csisolatingreek\":\n            case \"ecma-118\":\n            case \"elot_928\":\n            case \"greek\":\n            case \"greek8\":\n            case \"iso-8859-7\":\n            case \"iso-ir-126\":\n            case \"iso8859-7\":\n            case \"iso88597\":\n            case \"iso_8859-7\":\n            case \"iso_8859-7:1987\":\n            case \"sun_eu_greek\":\n                return \"ISO-8859-7\";\n            case \"csiso88598e\":\n            case \"csisolatinhebrew\":\n            case \"hebrew\":\n            case \"iso-8859-8\":\n            case \"iso-8859-8-e\":\n            case \"iso-ir-138\":\n            case \"iso8859-8\":\n            case \"iso88598\":\n            case \"iso_8859-8\":\n            case \"iso_8859-8:1988\":\n            case \"visual\":\n                return \"ISO-8859-8\";\n            case \"csiso88598i\":\n            case \"iso-8859-8-i\":\n            case \"logical\":\n                return \"ISO-8859-8-I\";\n            case \"csisolatin6\":\n            case \"iso-8859-10\":\n            case \"iso-ir-157\":\n            case \"iso8859-10\":\n            case \"iso885910\":\n            case \"l6\":\n            case \"latin6\":\n                return \"ISO-8859-10\";\n            case \"iso-8859-13\":\n            case \"iso8859-13\":\n            case \"iso885913\":\n                return \"ISO-8859-13\";\n            case \"iso-8859-14\":\n            case \"iso8859-14\":\n            case \"iso885914\":\n                return \"ISO-8859-14\";\n            case \"csisolatin9\":\n            case \"iso-8859-15\":\n            case \"iso8859-15\":\n            case \"iso885915\":\n            case \"iso_8859-15\":\n            case \"l9\":\n                return \"ISO-8859-15\";\n            case \"iso-8859-16\":\n                return \"ISO-8859-16\";\n            case \"cskoi8r\":\n            case \"koi\":\n            case \"koi8\":\n            case \"koi8-r\":\n            case \"koi8_r\":\n                return \"KOI8-R\";\n            case \"koi8-ru\":\n            case \"koi8-u\":\n                return \"KOI8-U\";\n            case \"csmacintosh\":\n            case \"mac\":\n            case \"macintosh\":\n            case \"x-mac-roman\":\n                return \"macintosh\";\n            case \"iso-8859-11\":\n            case \"iso8859-11\":\n            case \"iso885911\":\n            case \"tis-620\":\n            case \"windows-874\":\n                return \"windows-874\";\n            case \"cp1250\":\n            case \"windows-1250\":\n            case \"x-cp1250\":\n                return \"windows-1250\";\n            case \"cp1251\":\n            case \"windows-1251\":\n            case \"x-cp1251\":\n                return \"windows-1251\";\n            case \"ansi_x3.4-1968\":\n            case \"ascii\":\n            case \"cp1252\":\n            case \"cp819\":\n            case \"csisolatin1\":\n            case \"ibm819\":\n            case \"iso-8859-1\":\n            case \"iso-ir-100\":\n            case \"iso8859-1\":\n            case \"iso88591\":\n            case \"iso_8859-1\":\n            case \"iso_8859-1:1987\":\n            case \"l1\":\n            case \"latin1\":\n            case \"us-ascii\":\n            case \"windows-1252\":\n            case \"x-cp1252\":\n                return \"windows-1252\";\n            case \"cp1253\":\n            case \"windows-1253\":\n            case \"x-cp1253\":\n                return \"windows-1253\";\n            case \"cp1254\":\n            case \"csisolatin5\":\n            case \"iso-8859-9\":\n            case \"iso-ir-148\":\n            case \"iso8859-9\":\n            case \"iso88599\":\n            case \"iso_8859-9\":\n            case \"iso_8859-9:1989\":\n            case \"l5\":\n            case \"latin5\":\n            case \"windows-1254\":\n            case \"x-cp1254\":\n                return \"windows-1254\";\n            case \"cp1255\":\n            case \"windows-1255\":\n            case \"x-cp1255\":\n                return \"windows-1255\";\n            case \"cp1256\":\n            case \"windows-1256\":\n            case \"x-cp1256\":\n                return \"windows-1256\";\n            case \"cp1257\":\n            case \"windows-1257\":\n            case \"x-cp1257\":\n                return \"windows-1257\";\n            case \"cp1258\":\n            case \"windows-1258\":\n            case \"x-cp1258\":\n                return \"windows-1258\";\n            case \"x-mac-cyrillic\":\n            case \"x-mac-ukrainian\":\n                return \"x-mac-cyrillic\";\n            case \"chinese\":\n            case \"csgb2312\":\n            case \"csiso58gb231280\":\n            case \"gb2312\":\n            case \"gb_2312\":\n            case \"gb_2312-80\":\n            case \"gbk\":\n            case \"iso-ir-58\":\n            case \"x-gbk\":\n                return \"GBK\";\n            case \"gb18030\":\n                return \"gb18030\";\n            case \"big5\":\n            case \"big5-hkscs\":\n            case \"cn-big5\":\n            case \"csbig5\":\n            case \"x-x-big5\":\n                return \"Big5\";\n            case \"cseucpkdfmtjapanese\":\n            case \"euc-jp\":\n            case \"x-euc-jp\":\n                return \"EUC-JP\";\n            case \"csiso2022jp\":\n            case \"iso-2022-jp\":\n                return \"ISO-2022-JP\";\n            case \"csshiftjis\":\n            case \"ms932\":\n            case \"ms_kanji\":\n            case \"shift-jis\":\n            case \"shift_jis\":\n            case \"sjis\":\n            case \"windows-31j\":\n            case \"x-sjis\":\n                return \"Shift_JIS\";\n            case \"cseuckr\":\n            case \"csksc56011987\":\n            case \"euc-kr\":\n            case \"iso-ir-149\":\n            case \"korean\":\n            case \"ks_c_5601-1987\":\n            case \"ks_c_5601-1989\":\n            case \"ksc5601\":\n            case \"ksc_5601\":\n            case \"windows-949\":\n                return \"EUC-KR\";\n            case \"csiso2022kr\":\n            case \"hz-gb-2312\":\n            case \"iso-2022-cn\":\n            case \"iso-2022-cn-ext\":\n            case \"iso-2022-kr\":\n            case \"replacement\":\n                return \"replacement\";\n            case \"unicodefffe\":\n            case \"utf-16be\":\n                return \"UTF-16BE\";\n            case \"csunicode\":\n            case \"iso-10646-ucs-2\":\n            case \"ucs-2\":\n            case \"unicode\":\n            case \"unicodefeff\":\n            case \"utf-16\":\n            case \"utf-16le\":\n                return \"UTF-16LE\";\n            case \"x-user-defined\":\n                return \"x-user-defined\";\n            default:\n                return \"failure\";\n        }\n    }\n    return o(e, \"getEncoding\"), encoding = {\n        getEncoding: e\n    }, encoding;\n}\no(requireEncoding, \"requireEncoding\");\nvar util$5, hasRequiredUtil$4;\nfunction requireUtil$4() {\n    if (hasRequiredUtil$4) return util$5;\n    hasRequiredUtil$4 = 1;\n    const { kState: e, kError: A, kResult: t, kAborted: n, kLastProgressEventFired: r } = requireSymbols$2(), { ProgressEvent: s } = requireProgressevent(), { getEncoding: i } = requireEncoding(), { serializeAMimeType: E, parseMIMEType: Q } = requireDataUrl(), { types: C } = require$$0__default$1, { StringDecoder: I } = require$$5__default$2, { btoa: a } = require$$6__default, f = {\n        enumerable: !0,\n        writable: !1,\n        configurable: !1\n    };\n    function h(w, U, M, B) {\n        if (w[e] === \"loading\") throw new DOMException(\"Invalid state\", \"InvalidStateError\");\n        w[e] = \"loading\", w[t] = null, w[A] = null;\n        const G = U.stream().getReader(), g = [];\n        let d = G.read(), F = !0;\n        (async ()=>{\n            for(; !w[n];)try {\n                const { done: N, value: u } = await d;\n                if (F && !w[n] && queueMicrotask(()=>{\n                    L(\"loadstart\", w);\n                }), F = !1, !N && C.isUint8Array(u)) g.push(u), (w[r] === void 0 || Date.now() - w[r] >= 50) && !w[n] && (w[r] = Date.now(), queueMicrotask(()=>{\n                    L(\"progress\", w);\n                })), d = G.read();\n                else if (N) {\n                    queueMicrotask(()=>{\n                        w[e] = \"done\";\n                        try {\n                            const b = c(g, M, U.type, B);\n                            if (w[n]) return;\n                            w[t] = b, L(\"load\", w);\n                        } catch (b) {\n                            w[A] = b, L(\"error\", w);\n                        }\n                        w[e] !== \"loading\" && L(\"loadend\", w);\n                    });\n                    break;\n                }\n            } catch (N) {\n                if (w[n]) return;\n                queueMicrotask(()=>{\n                    w[e] = \"done\", w[A] = N, L(\"error\", w), w[e] !== \"loading\" && L(\"loadend\", w);\n                });\n                break;\n            }\n        })();\n    }\n    o(h, \"readOperation\");\n    function L(w, U) {\n        const M = new s(w, {\n            bubbles: !1,\n            cancelable: !1\n        });\n        U.dispatchEvent(M);\n    }\n    o(L, \"fireAProgressEvent\");\n    function c(w, U, M, B) {\n        switch(U){\n            case \"DataURL\":\n                {\n                    let D = \"data:\";\n                    const G = Q(M || \"application/octet-stream\");\n                    G !== \"failure\" && (D += E(G)), D += \";base64,\";\n                    const g = new I(\"latin1\");\n                    for (const d of w)D += a(g.write(d));\n                    return D += a(g.end()), D;\n                }\n            case \"Text\":\n                {\n                    let D = \"failure\";\n                    if (B && (D = i(B)), D === \"failure\" && M) {\n                        const G = Q(M);\n                        G !== \"failure\" && (D = i(G.parameters.get(\"charset\")));\n                    }\n                    return D === \"failure\" && (D = \"UTF-8\"), l(w, D);\n                }\n            case \"ArrayBuffer\":\n                return k(w).buffer;\n            case \"BinaryString\":\n                {\n                    let D = \"\";\n                    const G = new I(\"latin1\");\n                    for (const g of w)D += G.write(g);\n                    return D += G.end(), D;\n                }\n        }\n    }\n    o(c, \"packageData\");\n    function l(w, U) {\n        const M = k(w), B = S(M);\n        let D = 0;\n        B !== null && (U = B, D = B === \"UTF-8\" ? 3 : 2);\n        const G = M.slice(D);\n        return new TextDecoder(U).decode(G);\n    }\n    o(l, \"decode\");\n    function S(w) {\n        const [U, M, B] = w;\n        return U === 239 && M === 187 && B === 191 ? \"UTF-8\" : U === 254 && M === 255 ? \"UTF-16BE\" : U === 255 && M === 254 ? \"UTF-16LE\" : null;\n    }\n    o(S, \"BOMSniffing\");\n    function k(w) {\n        const U = w.reduce((B, D)=>B + D.byteLength, 0);\n        let M = 0;\n        return w.reduce((B, D)=>(B.set(D, M), M += D.byteLength, B), new Uint8Array(U));\n    }\n    return o(k, \"combineByteSequences\"), util$5 = {\n        staticPropertyDescriptors: f,\n        readOperation: h,\n        fireAProgressEvent: L\n    }, util$5;\n}\no(requireUtil$4, \"requireUtil$4\");\nvar filereader, hasRequiredFilereader;\nfunction requireFilereader() {\n    if (hasRequiredFilereader) return filereader;\n    hasRequiredFilereader = 1;\n    const { staticPropertyDescriptors: e, readOperation: A, fireAProgressEvent: t } = requireUtil$4(), { kState: n, kError: r, kResult: s, kEvents: i, kAborted: E } = requireSymbols$2(), { webidl: Q } = requireWebidl(), { kEnumerableProperty: C } = util$m, a = class a extends EventTarget {\n        constructor(){\n            super(), this[n] = \"empty\", this[s] = null, this[r] = null, this[i] = {\n                loadend: null,\n                error: null,\n                abort: null,\n                load: null,\n                progress: null,\n                loadstart: null\n            };\n        }\n        readAsArrayBuffer(h) {\n            Q.brandCheck(this, a), Q.argumentLengthCheck(arguments, 1, {\n                header: \"FileReader.readAsArrayBuffer\"\n            }), h = Q.converters.Blob(h, {\n                strict: !1\n            }), A(this, h, \"ArrayBuffer\");\n        }\n        readAsBinaryString(h) {\n            Q.brandCheck(this, a), Q.argumentLengthCheck(arguments, 1, {\n                header: \"FileReader.readAsBinaryString\"\n            }), h = Q.converters.Blob(h, {\n                strict: !1\n            }), A(this, h, \"BinaryString\");\n        }\n        readAsText(h, L = void 0) {\n            Q.brandCheck(this, a), Q.argumentLengthCheck(arguments, 1, {\n                header: \"FileReader.readAsText\"\n            }), h = Q.converters.Blob(h, {\n                strict: !1\n            }), L !== void 0 && (L = Q.converters.DOMString(L)), A(this, h, \"Text\", L);\n        }\n        readAsDataURL(h) {\n            Q.brandCheck(this, a), Q.argumentLengthCheck(arguments, 1, {\n                header: \"FileReader.readAsDataURL\"\n            }), h = Q.converters.Blob(h, {\n                strict: !1\n            }), A(this, h, \"DataURL\");\n        }\n        abort() {\n            if (this[n] === \"empty\" || this[n] === \"done\") {\n                this[s] = null;\n                return;\n            }\n            this[n] === \"loading\" && (this[n] = \"done\", this[s] = null), this[E] = !0, t(\"abort\", this), this[n] !== \"loading\" && t(\"loadend\", this);\n        }\n        get readyState() {\n            switch(Q.brandCheck(this, a), this[n]){\n                case \"empty\":\n                    return this.EMPTY;\n                case \"loading\":\n                    return this.LOADING;\n                case \"done\":\n                    return this.DONE;\n            }\n        }\n        get result() {\n            return Q.brandCheck(this, a), this[s];\n        }\n        get error() {\n            return Q.brandCheck(this, a), this[r];\n        }\n        get onloadend() {\n            return Q.brandCheck(this, a), this[i].loadend;\n        }\n        set onloadend(h) {\n            Q.brandCheck(this, a), this[i].loadend && this.removeEventListener(\"loadend\", this[i].loadend), typeof h == \"function\" ? (this[i].loadend = h, this.addEventListener(\"loadend\", h)) : this[i].loadend = null;\n        }\n        get onerror() {\n            return Q.brandCheck(this, a), this[i].error;\n        }\n        set onerror(h) {\n            Q.brandCheck(this, a), this[i].error && this.removeEventListener(\"error\", this[i].error), typeof h == \"function\" ? (this[i].error = h, this.addEventListener(\"error\", h)) : this[i].error = null;\n        }\n        get onloadstart() {\n            return Q.brandCheck(this, a), this[i].loadstart;\n        }\n        set onloadstart(h) {\n            Q.brandCheck(this, a), this[i].loadstart && this.removeEventListener(\"loadstart\", this[i].loadstart), typeof h == \"function\" ? (this[i].loadstart = h, this.addEventListener(\"loadstart\", h)) : this[i].loadstart = null;\n        }\n        get onprogress() {\n            return Q.brandCheck(this, a), this[i].progress;\n        }\n        set onprogress(h) {\n            Q.brandCheck(this, a), this[i].progress && this.removeEventListener(\"progress\", this[i].progress), typeof h == \"function\" ? (this[i].progress = h, this.addEventListener(\"progress\", h)) : this[i].progress = null;\n        }\n        get onload() {\n            return Q.brandCheck(this, a), this[i].load;\n        }\n        set onload(h) {\n            Q.brandCheck(this, a), this[i].load && this.removeEventListener(\"load\", this[i].load), typeof h == \"function\" ? (this[i].load = h, this.addEventListener(\"load\", h)) : this[i].load = null;\n        }\n        get onabort() {\n            return Q.brandCheck(this, a), this[i].abort;\n        }\n        set onabort(h) {\n            Q.brandCheck(this, a), this[i].abort && this.removeEventListener(\"abort\", this[i].abort), typeof h == \"function\" ? (this[i].abort = h, this.addEventListener(\"abort\", h)) : this[i].abort = null;\n        }\n    };\n    o(a, \"FileReader\");\n    let I = a;\n    return I.EMPTY = I.prototype.EMPTY = 0, I.LOADING = I.prototype.LOADING = 1, I.DONE = I.prototype.DONE = 2, Object.defineProperties(I.prototype, {\n        EMPTY: e,\n        LOADING: e,\n        DONE: e,\n        readAsArrayBuffer: C,\n        readAsBinaryString: C,\n        readAsText: C,\n        readAsDataURL: C,\n        abort: C,\n        readyState: C,\n        result: C,\n        error: C,\n        onloadstart: C,\n        onprogress: C,\n        onload: C,\n        onabort: C,\n        onerror: C,\n        onloadend: C,\n        [Symbol.toStringTag]: {\n            value: \"FileReader\",\n            writable: !1,\n            enumerable: !1,\n            configurable: !0\n        }\n    }), Object.defineProperties(I, {\n        EMPTY: e,\n        LOADING: e,\n        DONE: e\n    }), filereader = {\n        FileReader: I\n    }, filereader;\n}\no(requireFilereader, \"requireFilereader\");\nvar symbols$1, hasRequiredSymbols$1;\nfunction requireSymbols$1() {\n    return hasRequiredSymbols$1 || (hasRequiredSymbols$1 = 1, symbols$1 = {\n        kConstruct: symbols$4.kConstruct\n    }), symbols$1;\n}\no(requireSymbols$1, \"requireSymbols$1\");\nvar util$4, hasRequiredUtil$3;\nfunction requireUtil$3() {\n    if (hasRequiredUtil$3) return util$4;\n    hasRequiredUtil$3 = 1;\n    const e = require$$0__default, { URLSerializer: A } = requireDataUrl(), { isValidHeaderName: t } = requireUtil$5();\n    function n(s, i, E = !1) {\n        const Q = A(s, E), C = A(i, E);\n        return Q === C;\n    }\n    o(n, \"urlEquals\");\n    function r(s) {\n        e(s !== null);\n        const i = [];\n        for (let E of s.split(\",\"))E = E.trim(), t(E) && i.push(E);\n        return i;\n    }\n    return o(r, \"getFieldValues\"), util$4 = {\n        urlEquals: n,\n        getFieldValues: r\n    }, util$4;\n}\no(requireUtil$3, \"requireUtil$3\");\nvar cache, hasRequiredCache;\nfunction requireCache() {\n    var w, U, qe, B, $A, G, wt, d, je;\n    if (hasRequiredCache) return cache;\n    hasRequiredCache = 1;\n    const { kConstruct: e } = requireSymbols$1(), { urlEquals: A, getFieldValues: t } = requireUtil$3(), { kEnumerableProperty: n, isDisturbed: r } = util$m, { webidl: s } = requireWebidl(), { Response: i, cloneResponse: E, fromInnerResponse: Q } = requireResponse(), { Request: C, fromInnerRequest: I } = requireRequest(), { kState: a } = requireSymbols$3(), { fetching: f } = requireFetch(), { urlIsHttpHttpsScheme: h, createDeferredPromise: L, readAllBytes: c } = requireUtil$5(), l = require$$0__default, N = class N {\n        constructor(){\n            CA(this, U);\n            CA(this, B);\n            CA(this, G);\n            CA(this, d);\n            CA(this, w, void 0);\n            arguments[0] !== e && s.illegalConstructor(), EA(this, w, arguments[1]);\n        }\n        async match(b, m = {}) {\n            s.brandCheck(this, N), s.argumentLengthCheck(arguments, 1, {\n                header: \"Cache.match\"\n            }), b = s.converters.RequestInfo(b), m = s.converters.CacheQueryOptions(m);\n            const T = kA(this, d, je).call(this, b, m, 1);\n            if (T.length !== 0) return T[0];\n        }\n        async matchAll(b = void 0, m = {}) {\n            return s.brandCheck(this, N), b !== void 0 && (b = s.converters.RequestInfo(b)), m = s.converters.CacheQueryOptions(m), kA(this, d, je).call(this, b, m);\n        }\n        async add(b) {\n            s.brandCheck(this, N), s.argumentLengthCheck(arguments, 1, {\n                header: \"Cache.add\"\n            }), b = s.converters.RequestInfo(b);\n            const m = [\n                b\n            ];\n            return await this.addAll(m);\n        }\n        async addAll(b) {\n            s.brandCheck(this, N), s.argumentLengthCheck(arguments, 1, {\n                header: \"Cache.addAll\"\n            });\n            const m = [], T = [];\n            for (let X of b){\n                if (X === void 0) throw s.errors.conversionFailed({\n                    prefix: \"Cache.addAll\",\n                    argument: \"Argument 1\",\n                    types: [\n                        \"undefined is not allowed\"\n                    ]\n                });\n                if (X = s.converters.RequestInfo(X), typeof X == \"string\") continue;\n                const $ = X[a];\n                if (!h($.url) || $.method !== \"GET\") throw s.errors.exception({\n                    header: \"Cache.addAll\",\n                    message: \"Expected http/s scheme when method is not GET.\"\n                });\n            }\n            const v = [];\n            for (const X of b){\n                const $ = new C(X)[a];\n                if (!h($.url)) throw s.errors.exception({\n                    header: \"Cache.addAll\",\n                    message: \"Expected http/s scheme.\"\n                });\n                $.initiator = \"fetch\", $.destination = \"subresource\", T.push($);\n                const V = L();\n                v.push(f({\n                    request: $,\n                    processResponse (q) {\n                        if (q.type === \"error\" || q.status === 206 || q.status < 200 || q.status > 299) V.reject(s.errors.exception({\n                            header: \"Cache.addAll\",\n                            message: \"Received an invalid status code or the request failed.\"\n                        }));\n                        else if (q.headersList.contains(\"vary\")) {\n                            const z = t(q.headersList.get(\"vary\"));\n                            for (const rA of z)if (rA === \"*\") {\n                                V.reject(s.errors.exception({\n                                    header: \"Cache.addAll\",\n                                    message: \"invalid vary field value\"\n                                }));\n                                for (const iA of v)iA.abort();\n                                return;\n                            }\n                        }\n                    },\n                    processResponseEndOfBody (q) {\n                        if (q.aborted) {\n                            V.reject(new DOMException(\"aborted\", \"AbortError\"));\n                            return;\n                        }\n                        V.resolve(q);\n                    }\n                })), m.push(V.promise);\n            }\n            const P = await Promise.all(m), AA = [];\n            let K = 0;\n            for (const X of P){\n                const $ = {\n                    type: \"put\",\n                    request: T[K],\n                    response: X\n                };\n                AA.push($), K++;\n            }\n            const tA = L();\n            let aA = null;\n            try {\n                kA(this, U, qe).call(this, AA);\n            } catch (X) {\n                aA = X;\n            }\n            return queueMicrotask(()=>{\n                aA === null ? tA.resolve(void 0) : tA.reject(aA);\n            }), tA.promise;\n        }\n        async put(b, m) {\n            s.brandCheck(this, N), s.argumentLengthCheck(arguments, 2, {\n                header: \"Cache.put\"\n            }), b = s.converters.RequestInfo(b), m = s.converters.Response(m);\n            let T = null;\n            if (b instanceof C ? T = b[a] : T = new C(b)[a], !h(T.url) || T.method !== \"GET\") throw s.errors.exception({\n                header: \"Cache.put\",\n                message: \"Expected an http/s scheme when method is not GET\"\n            });\n            const v = m[a];\n            if (v.status === 206) throw s.errors.exception({\n                header: \"Cache.put\",\n                message: \"Got 206 status\"\n            });\n            if (v.headersList.contains(\"vary\")) {\n                const $ = t(v.headersList.get(\"vary\"));\n                for (const V of $)if (V === \"*\") throw s.errors.exception({\n                    header: \"Cache.put\",\n                    message: \"Got * vary field value\"\n                });\n            }\n            if (v.body && (r(v.body.stream) || v.body.stream.locked)) throw s.errors.exception({\n                header: \"Cache.put\",\n                message: \"Response body is locked or disturbed\"\n            });\n            const Z = E(v), P = L();\n            if (v.body != null) {\n                const V = v.body.stream.getReader();\n                c(V).then(P.resolve, P.reject);\n            } else P.resolve(void 0);\n            const AA = [], K = {\n                type: \"put\",\n                request: T,\n                response: Z\n            };\n            AA.push(K);\n            const tA = await P.promise;\n            Z.body != null && (Z.body.source = tA);\n            const aA = L();\n            let X = null;\n            try {\n                kA(this, U, qe).call(this, AA);\n            } catch ($) {\n                X = $;\n            }\n            return queueMicrotask(()=>{\n                X === null ? aA.resolve() : aA.reject(X);\n            }), aA.promise;\n        }\n        async delete(b, m = {}) {\n            s.brandCheck(this, N), s.argumentLengthCheck(arguments, 1, {\n                header: \"Cache.delete\"\n            }), b = s.converters.RequestInfo(b), m = s.converters.CacheQueryOptions(m);\n            let T = null;\n            if (b instanceof C) {\n                if (T = b[a], T.method !== \"GET\" && !m.ignoreMethod) return !1;\n            } else l(typeof b == \"string\"), T = new C(b)[a];\n            const v = [], Z = {\n                type: \"delete\",\n                request: T,\n                options: m\n            };\n            v.push(Z);\n            const P = L();\n            let AA = null, K;\n            try {\n                K = kA(this, U, qe).call(this, v);\n            } catch (tA) {\n                AA = tA;\n            }\n            return queueMicrotask(()=>{\n                AA === null ? P.resolve(!!K?.length) : P.reject(AA);\n            }), P.promise;\n        }\n        async keys(b = void 0, m = {}) {\n            s.brandCheck(this, N), b !== void 0 && (b = s.converters.RequestInfo(b)), m = s.converters.CacheQueryOptions(m);\n            let T = null;\n            if (b !== void 0) if (b instanceof C) {\n                if (T = b[a], T.method !== \"GET\" && !m.ignoreMethod) return [];\n            } else typeof b == \"string\" && (T = new C(b)[a]);\n            const v = L(), Z = [];\n            if (b === void 0) for (const P of p(this, w))Z.push(P[0]);\n            else {\n                const P = kA(this, B, $A).call(this, T, m);\n                for (const AA of P)Z.push(AA[0]);\n            }\n            return queueMicrotask(()=>{\n                const P = [];\n                for (const AA of Z){\n                    const K = I(AA, new AbortController().signal, \"immutable\", {\n                        settingsObject: AA.client\n                    });\n                    P.push(K);\n                }\n                v.resolve(Object.freeze(P));\n            }), v.promise;\n        }\n    };\n    w = new WeakMap, U = new WeakSet, qe = o(function(b) {\n        const m = p(this, w), T = [\n            ...m\n        ], v = [], Z = [];\n        try {\n            for (const P of b){\n                if (P.type !== \"delete\" && P.type !== \"put\") throw s.errors.exception({\n                    header: \"Cache.#batchCacheOperations\",\n                    message: 'operation type does not match \"delete\" or \"put\"'\n                });\n                if (P.type === \"delete\" && P.response != null) throw s.errors.exception({\n                    header: \"Cache.#batchCacheOperations\",\n                    message: \"delete operation should not have an associated response\"\n                });\n                if (kA(this, B, $A).call(this, P.request, P.options, v).length) throw new DOMException(\"???\", \"InvalidStateError\");\n                let AA;\n                if (P.type === \"delete\") {\n                    if (AA = kA(this, B, $A).call(this, P.request, P.options), AA.length === 0) return [];\n                    for (const K of AA){\n                        const tA = m.indexOf(K);\n                        l(tA !== -1), m.splice(tA, 1);\n                    }\n                } else if (P.type === \"put\") {\n                    if (P.response == null) throw s.errors.exception({\n                        header: \"Cache.#batchCacheOperations\",\n                        message: \"put operation should have an associated response\"\n                    });\n                    const K = P.request;\n                    if (!h(K.url)) throw s.errors.exception({\n                        header: \"Cache.#batchCacheOperations\",\n                        message: \"expected http or https scheme\"\n                    });\n                    if (K.method !== \"GET\") throw s.errors.exception({\n                        header: \"Cache.#batchCacheOperations\",\n                        message: \"not get method\"\n                    });\n                    if (P.options != null) throw s.errors.exception({\n                        header: \"Cache.#batchCacheOperations\",\n                        message: \"options must not be defined\"\n                    });\n                    AA = kA(this, B, $A).call(this, P.request);\n                    for (const tA of AA){\n                        const aA = m.indexOf(tA);\n                        l(aA !== -1), m.splice(aA, 1);\n                    }\n                    m.push([\n                        P.request,\n                        P.response\n                    ]), v.push([\n                        P.request,\n                        P.response\n                    ]);\n                }\n                Z.push([\n                    P.request,\n                    P.response\n                ]);\n            }\n            return Z;\n        } catch (P) {\n            throw p(this, w).length = 0, EA(this, w, T), P;\n        }\n    }, \"#batchCacheOperations\"), B = new WeakSet, $A = o(function(b, m, T) {\n        const v = [], Z = T ?? p(this, w);\n        for (const P of Z){\n            const [AA, K] = P;\n            kA(this, G, wt).call(this, b, AA, K, m) && v.push(P);\n        }\n        return v;\n    }, \"#queryCache\"), G = new WeakSet, wt = o(function(b, m, T = null, v) {\n        const Z = new URL(b.url), P = new URL(m.url);\n        if (v?.ignoreSearch && (P.search = \"\", Z.search = \"\"), !A(Z, P, !0)) return !1;\n        if (T == null || v?.ignoreVary || !T.headersList.contains(\"vary\")) return !0;\n        const AA = t(T.headersList.get(\"vary\"));\n        for (const K of AA){\n            if (K === \"*\") return !1;\n            const tA = m.headersList.get(K), aA = b.headersList.get(K);\n            if (tA !== aA) return !1;\n        }\n        return !0;\n    }, \"#requestMatchesCachedItem\"), d = new WeakSet, je = o(function(b, m, T = 1 / 0) {\n        let v = null;\n        if (b !== void 0) if (b instanceof C) {\n            if (v = b[a], v.method !== \"GET\" && !m.ignoreMethod) return [];\n        } else typeof b == \"string\" && (v = new C(b)[a]);\n        const Z = [];\n        if (b === void 0) for (const AA of p(this, w))Z.push(AA[1]);\n        else {\n            const AA = kA(this, B, $A).call(this, v, m);\n            for (const K of AA)Z.push(K[1]);\n        }\n        const P = [];\n        for (const AA of Z){\n            const K = Q(AA, \"immutable\", {\n                settingsObject: {}\n            });\n            if (P.push(K.clone()), P.length >= T) break;\n        }\n        return Object.freeze(P);\n    }, \"#internalMatchAll\"), o(N, \"Cache\");\n    let S = N;\n    Object.defineProperties(S.prototype, {\n        [Symbol.toStringTag]: {\n            value: \"Cache\",\n            configurable: !0\n        },\n        match: n,\n        matchAll: n,\n        add: n,\n        addAll: n,\n        put: n,\n        delete: n,\n        keys: n\n    });\n    const k = [\n        {\n            key: \"ignoreSearch\",\n            converter: s.converters.boolean,\n            defaultValue: !1\n        },\n        {\n            key: \"ignoreMethod\",\n            converter: s.converters.boolean,\n            defaultValue: !1\n        },\n        {\n            key: \"ignoreVary\",\n            converter: s.converters.boolean,\n            defaultValue: !1\n        }\n    ];\n    return s.converters.CacheQueryOptions = s.dictionaryConverter(k), s.converters.MultiCacheQueryOptions = s.dictionaryConverter([\n        ...k,\n        {\n            key: \"cacheName\",\n            converter: s.converters.DOMString\n        }\n    ]), s.converters.Response = s.interfaceConverter(i), s.converters[\"sequence<RequestInfo>\"] = s.sequenceConverter(s.converters.RequestInfo), cache = {\n        Cache: S\n    }, cache;\n}\no(requireCache, \"requireCache\");\nvar cachestorage, hasRequiredCachestorage;\nfunction requireCachestorage() {\n    var s;\n    if (hasRequiredCachestorage) return cachestorage;\n    hasRequiredCachestorage = 1;\n    const { kConstruct: e } = requireSymbols$1(), { Cache: A } = requireCache(), { webidl: t } = requireWebidl(), { kEnumerableProperty: n } = util$m, i = class i {\n        constructor(){\n            CA(this, s, new Map);\n            arguments[0] !== e && t.illegalConstructor();\n        }\n        async match(Q, C = {}) {\n            if (t.brandCheck(this, i), t.argumentLengthCheck(arguments, 1, {\n                header: \"CacheStorage.match\"\n            }), Q = t.converters.RequestInfo(Q), C = t.converters.MultiCacheQueryOptions(C), C.cacheName != null) {\n                if (p(this, s).has(C.cacheName)) {\n                    const I = p(this, s).get(C.cacheName);\n                    return await new A(e, I).match(Q, C);\n                }\n            } else for (const I of p(this, s).values()){\n                const f = await new A(e, I).match(Q, C);\n                if (f !== void 0) return f;\n            }\n        }\n        async has(Q) {\n            return t.brandCheck(this, i), t.argumentLengthCheck(arguments, 1, {\n                header: \"CacheStorage.has\"\n            }), Q = t.converters.DOMString(Q), p(this, s).has(Q);\n        }\n        async open(Q) {\n            if (t.brandCheck(this, i), t.argumentLengthCheck(arguments, 1, {\n                header: \"CacheStorage.open\"\n            }), Q = t.converters.DOMString(Q), p(this, s).has(Q)) {\n                const I = p(this, s).get(Q);\n                return new A(e, I);\n            }\n            const C = [];\n            return p(this, s).set(Q, C), new A(e, C);\n        }\n        async delete(Q) {\n            return t.brandCheck(this, i), t.argumentLengthCheck(arguments, 1, {\n                header: \"CacheStorage.delete\"\n            }), Q = t.converters.DOMString(Q), p(this, s).delete(Q);\n        }\n        async keys() {\n            return t.brandCheck(this, i), [\n                ...p(this, s).keys()\n            ];\n        }\n    };\n    s = new WeakMap, o(i, \"CacheStorage\");\n    let r = i;\n    return Object.defineProperties(r.prototype, {\n        [Symbol.toStringTag]: {\n            value: \"CacheStorage\",\n            configurable: !0\n        },\n        match: n,\n        has: n,\n        open: n,\n        delete: n,\n        keys: n\n    }), cachestorage = {\n        CacheStorage: r\n    }, cachestorage;\n}\no(requireCachestorage, \"requireCachestorage\");\nvar constants$1, hasRequiredConstants$1;\nfunction requireConstants$1() {\n    return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, constants$1 = {\n        maxAttributeValueSize: 1024,\n        maxNameValuePairSize: 4096\n    }), constants$1;\n}\no(requireConstants$1, \"requireConstants$1\");\nvar util$3, hasRequiredUtil$2;\nfunction requireUtil$2() {\n    if (hasRequiredUtil$2) return util$3;\n    hasRequiredUtil$2 = 1;\n    const e = require$$0__default, { kHeadersList: A } = symbols$4;\n    function t(c) {\n        for(let l = 0; l < c.length; ++l){\n            const S = c.charCodeAt(l);\n            if (S >= 0 && S <= 8 || S >= 10 && S <= 31 || S === 127) return !0;\n        }\n        return !1;\n    }\n    o(t, \"isCTLExcludingHtab\");\n    function n(c) {\n        for(let l = 0; l < c.length; ++l){\n            const S = c.charCodeAt(l);\n            if (S < 33 || S > 126 || S === 34 || S === 40 || S === 41 || S === 60 || S === 62 || S === 64 || S === 44 || S === 59 || S === 58 || S === 92 || S === 47 || S === 91 || S === 93 || S === 63 || S === 61 || S === 123 || S === 125) throw new Error(\"Invalid cookie name\");\n        }\n    }\n    o(n, \"validateCookieName\");\n    function r(c) {\n        let l = c.length, S = 0;\n        if (c[0] === '\"') {\n            if (l === 1 || c[l - 1] !== '\"') throw new Error(\"Invalid cookie value\");\n            --l, ++S;\n        }\n        for(; S < l;){\n            const k = c.charCodeAt(S++);\n            if (k < 33 || k > 126 || k === 34 || k === 44 || k === 59 || k === 92) throw new Error(\"Invalid cookie value\");\n        }\n    }\n    o(r, \"validateCookieValue\");\n    function s(c) {\n        for(let l = 0; l < c.length; ++l){\n            const S = c.charCodeAt(l);\n            if (S < 32 || S === 127 || S === 59) throw new Error(\"Invalid cookie path\");\n        }\n    }\n    o(s, \"validateCookiePath\");\n    function i(c) {\n        if (c.startsWith(\"-\") || c.endsWith(\".\") || c.endsWith(\"-\")) throw new Error(\"Invalid cookie domain\");\n    }\n    o(i, \"validateCookieDomain\");\n    const E = [\n        \"Sun\",\n        \"Mon\",\n        \"Tue\",\n        \"Wed\",\n        \"Thu\",\n        \"Fri\",\n        \"Sat\"\n    ], Q = [\n        \"Jan\",\n        \"Feb\",\n        \"Mar\",\n        \"Apr\",\n        \"May\",\n        \"Jun\",\n        \"Jul\",\n        \"Aug\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Dec\"\n    ], C = Array(61).fill(0).map((c, l)=>l.toString().padStart(2, \"0\"));\n    function I(c) {\n        return typeof c == \"number\" && (c = new Date(c)), `${E[c.getUTCDay()]}, ${C[c.getUTCDate()]} ${Q[c.getUTCMonth()]} ${c.getUTCFullYear()} ${C[c.getUTCHours()]}:${C[c.getUTCMinutes()]}:${C[c.getUTCSeconds()]} GMT`;\n    }\n    o(I, \"toIMFDate\");\n    function a(c) {\n        if (c < 0) throw new Error(\"Invalid cookie max-age\");\n    }\n    o(a, \"validateCookieMaxAge\");\n    function f(c) {\n        if (c.name.length === 0) return null;\n        n(c.name), r(c.value);\n        const l = [\n            `${c.name}=${c.value}`\n        ];\n        c.name.startsWith(\"__Secure-\") && (c.secure = !0), c.name.startsWith(\"__Host-\") && (c.secure = !0, c.domain = null, c.path = \"/\"), c.secure && l.push(\"Secure\"), c.httpOnly && l.push(\"HttpOnly\"), typeof c.maxAge == \"number\" && (a(c.maxAge), l.push(`Max-Age=${c.maxAge}`)), c.domain && (i(c.domain), l.push(`Domain=${c.domain}`)), c.path && (s(c.path), l.push(`Path=${c.path}`)), c.expires && c.expires.toString() !== \"Invalid Date\" && l.push(`Expires=${I(c.expires)}`), c.sameSite && l.push(`SameSite=${c.sameSite}`);\n        for (const S of c.unparsed){\n            if (!S.includes(\"=\")) throw new Error(\"Invalid unparsed\");\n            const [k, ...w] = S.split(\"=\");\n            l.push(`${k.trim()}=${w.join(\"=\")}`);\n        }\n        return l.join(\"; \");\n    }\n    o(f, \"stringify\");\n    let h;\n    function L(c) {\n        if (c[A]) return c[A];\n        h || (h = Object.getOwnPropertySymbols(c).find((S)=>S.description === \"headers list\"), e(h, \"Headers cannot be parsed\"));\n        const l = c[h];\n        return e(l), l;\n    }\n    return o(L, \"getHeadersList\"), util$3 = {\n        isCTLExcludingHtab: t,\n        validateCookieName: n,\n        validateCookiePath: s,\n        validateCookieValue: r,\n        toIMFDate: I,\n        stringify: f,\n        getHeadersList: L\n    }, util$3;\n}\no(requireUtil$2, \"requireUtil$2\");\nvar parse, hasRequiredParse;\nfunction requireParse() {\n    if (hasRequiredParse) return parse;\n    hasRequiredParse = 1;\n    const { maxNameValuePairSize: e, maxAttributeValueSize: A } = requireConstants$1(), { isCTLExcludingHtab: t } = requireUtil$2(), { collectASequenceOfCodePointsFast: n } = requireDataUrl(), r = require$$0__default;\n    function s(E) {\n        if (t(E)) return null;\n        let Q = \"\", C = \"\", I = \"\", a = \"\";\n        if (E.includes(\";\")) {\n            const f = {\n                position: 0\n            };\n            Q = n(\";\", E, f), C = E.slice(f.position);\n        } else Q = E;\n        if (!Q.includes(\"=\")) a = Q;\n        else {\n            const f = {\n                position: 0\n            };\n            I = n(\"=\", Q, f), a = Q.slice(f.position + 1);\n        }\n        return I = I.trim(), a = a.trim(), I.length + a.length > e ? null : {\n            name: I,\n            value: a,\n            ...i(C)\n        };\n    }\n    o(s, \"parseSetCookie\");\n    function i(E, Q = {}) {\n        if (E.length === 0) return Q;\n        r(E[0] === \";\"), E = E.slice(1);\n        let C = \"\";\n        E.includes(\";\") ? (C = n(\";\", E, {\n            position: 0\n        }), E = E.slice(C.length)) : (C = E, E = \"\");\n        let I = \"\", a = \"\";\n        if (C.includes(\"=\")) {\n            const h = {\n                position: 0\n            };\n            I = n(\"=\", C, h), a = C.slice(h.position + 1);\n        } else I = C;\n        if (I = I.trim(), a = a.trim(), a.length > A) return i(E, Q);\n        const f = I.toLowerCase();\n        if (f === \"expires\") {\n            const h = new Date(a);\n            Q.expires = h;\n        } else if (f === \"max-age\") {\n            const h = a.charCodeAt(0);\n            if ((h < 48 || h > 57) && a[0] !== \"-\" || !/^\\d+$/.test(a)) return i(E, Q);\n            const L = Number(a);\n            Q.maxAge = L;\n        } else if (f === \"domain\") {\n            let h = a;\n            h[0] === \".\" && (h = h.slice(1)), h = h.toLowerCase(), Q.domain = h;\n        } else if (f === \"path\") {\n            let h = \"\";\n            a.length === 0 || a[0] !== \"/\" ? h = \"/\" : h = a, Q.path = h;\n        } else if (f === \"secure\") Q.secure = !0;\n        else if (f === \"httponly\") Q.httpOnly = !0;\n        else if (f === \"samesite\") {\n            let h = \"Default\";\n            const L = a.toLowerCase();\n            L.includes(\"none\") && (h = \"None\"), L.includes(\"strict\") && (h = \"Strict\"), L.includes(\"lax\") && (h = \"Lax\"), Q.sameSite = h;\n        } else Q.unparsed ?? (Q.unparsed = []), Q.unparsed.push(`${I}=${a}`);\n        return i(E, Q);\n    }\n    return o(i, \"parseUnparsedAttributes\"), parse = {\n        parseSetCookie: s,\n        parseUnparsedAttributes: i\n    }, parse;\n}\no(requireParse, \"requireParse\");\nvar cookies, hasRequiredCookies;\nfunction requireCookies() {\n    if (hasRequiredCookies) return cookies;\n    hasRequiredCookies = 1;\n    const { parseSetCookie: e } = requireParse(), { stringify: A, getHeadersList: t } = requireUtil$2(), { webidl: n } = requireWebidl(), { Headers: r } = requireHeaders();\n    function s(C) {\n        n.argumentLengthCheck(arguments, 1, {\n            header: \"getCookies\"\n        }), n.brandCheck(C, r, {\n            strict: !1\n        });\n        const I = C.get(\"cookie\"), a = {};\n        if (!I) return a;\n        for (const f of I.split(\";\")){\n            const [h, ...L] = f.split(\"=\");\n            a[h.trim()] = L.join(\"=\");\n        }\n        return a;\n    }\n    o(s, \"getCookies\");\n    function i(C, I, a) {\n        n.argumentLengthCheck(arguments, 2, {\n            header: \"deleteCookie\"\n        }), n.brandCheck(C, r, {\n            strict: !1\n        }), I = n.converters.DOMString(I), a = n.converters.DeleteCookieAttributes(a), Q(C, {\n            name: I,\n            value: \"\",\n            expires: new Date(0),\n            ...a\n        });\n    }\n    o(i, \"deleteCookie\");\n    function E(C) {\n        n.argumentLengthCheck(arguments, 1, {\n            header: \"getSetCookies\"\n        }), n.brandCheck(C, r, {\n            strict: !1\n        });\n        const I = t(C).cookies;\n        return I ? I.map((a)=>e(Array.isArray(a) ? a[1] : a)) : [];\n    }\n    o(E, \"getSetCookies\");\n    function Q(C, I) {\n        n.argumentLengthCheck(arguments, 2, {\n            header: \"setCookie\"\n        }), n.brandCheck(C, r, {\n            strict: !1\n        }), I = n.converters.Cookie(I);\n        const a = A(I);\n        a && C.append(\"Set-Cookie\", a);\n    }\n    return o(Q, \"setCookie\"), n.converters.DeleteCookieAttributes = n.dictionaryConverter([\n        {\n            converter: n.nullableConverter(n.converters.DOMString),\n            key: \"path\",\n            defaultValue: null\n        },\n        {\n            converter: n.nullableConverter(n.converters.DOMString),\n            key: \"domain\",\n            defaultValue: null\n        }\n    ]), n.converters.Cookie = n.dictionaryConverter([\n        {\n            converter: n.converters.DOMString,\n            key: \"name\"\n        },\n        {\n            converter: n.converters.DOMString,\n            key: \"value\"\n        },\n        {\n            converter: n.nullableConverter((C)=>typeof C == \"number\" ? n.converters[\"unsigned long long\"](C) : new Date(C)),\n            key: \"expires\",\n            defaultValue: null\n        },\n        {\n            converter: n.nullableConverter(n.converters[\"long long\"]),\n            key: \"maxAge\",\n            defaultValue: null\n        },\n        {\n            converter: n.nullableConverter(n.converters.DOMString),\n            key: \"domain\",\n            defaultValue: null\n        },\n        {\n            converter: n.nullableConverter(n.converters.DOMString),\n            key: \"path\",\n            defaultValue: null\n        },\n        {\n            converter: n.nullableConverter(n.converters.boolean),\n            key: \"secure\",\n            defaultValue: null\n        },\n        {\n            converter: n.nullableConverter(n.converters.boolean),\n            key: \"httpOnly\",\n            defaultValue: null\n        },\n        {\n            converter: n.converters.USVString,\n            key: \"sameSite\",\n            allowedValues: [\n                \"Strict\",\n                \"Lax\",\n                \"None\"\n            ]\n        },\n        {\n            converter: n.sequenceConverter(n.converters.DOMString),\n            key: \"unparsed\",\n            defaultValue: []\n        }\n    ]), cookies = {\n        getCookies: s,\n        deleteCookie: i,\n        getSetCookies: E,\n        setCookie: Q\n    }, cookies;\n}\no(requireCookies, \"requireCookies\");\nvar events, hasRequiredEvents;\nfunction requireEvents() {\n    var E, C, a;\n    if (hasRequiredEvents) return events;\n    hasRequiredEvents = 1;\n    const { webidl: e } = requireWebidl(), { kEnumerableProperty: A } = util$m, { MessagePort: t } = require$$2__default, Q = class Q extends Event {\n        constructor(c, l = {}){\n            e.argumentLengthCheck(arguments, 1, {\n                header: \"MessageEvent constructor\"\n            }), c = e.converters.DOMString(c), l = e.converters.MessageEventInit(l);\n            super(c, l);\n            CA(this, E, void 0);\n            EA(this, E, l);\n        }\n        get data() {\n            return e.brandCheck(this, Q), p(this, E).data;\n        }\n        get origin() {\n            return e.brandCheck(this, Q), p(this, E).origin;\n        }\n        get lastEventId() {\n            return e.brandCheck(this, Q), p(this, E).lastEventId;\n        }\n        get source() {\n            return e.brandCheck(this, Q), p(this, E).source;\n        }\n        get ports() {\n            return e.brandCheck(this, Q), Object.isFrozen(p(this, E).ports) || Object.freeze(p(this, E).ports), p(this, E).ports;\n        }\n        initMessageEvent(c, l = !1, S = !1, k = null, w = \"\", U = \"\", M = null, B = []) {\n            return e.brandCheck(this, Q), e.argumentLengthCheck(arguments, 1, {\n                header: \"MessageEvent.initMessageEvent\"\n            }), new Q(c, {\n                bubbles: l,\n                cancelable: S,\n                data: k,\n                origin: w,\n                lastEventId: U,\n                source: M,\n                ports: B\n            });\n        }\n    };\n    E = new WeakMap, o(Q, \"MessageEvent\");\n    let n = Q;\n    const I = class I extends Event {\n        constructor(c, l = {}){\n            e.argumentLengthCheck(arguments, 1, {\n                header: \"CloseEvent constructor\"\n            }), c = e.converters.DOMString(c), l = e.converters.CloseEventInit(l);\n            super(c, l);\n            CA(this, C, void 0);\n            EA(this, C, l);\n        }\n        get wasClean() {\n            return e.brandCheck(this, I), p(this, C).wasClean;\n        }\n        get code() {\n            return e.brandCheck(this, I), p(this, C).code;\n        }\n        get reason() {\n            return e.brandCheck(this, I), p(this, C).reason;\n        }\n    };\n    C = new WeakMap, o(I, \"CloseEvent\");\n    let r = I;\n    const f = class f extends Event {\n        constructor(c, l){\n            e.argumentLengthCheck(arguments, 1, {\n                header: \"ErrorEvent constructor\"\n            });\n            super(c, l);\n            CA(this, a, void 0);\n            c = e.converters.DOMString(c), l = e.converters.ErrorEventInit(l ?? {}), EA(this, a, l);\n        }\n        get message() {\n            return e.brandCheck(this, f), p(this, a).message;\n        }\n        get filename() {\n            return e.brandCheck(this, f), p(this, a).filename;\n        }\n        get lineno() {\n            return e.brandCheck(this, f), p(this, a).lineno;\n        }\n        get colno() {\n            return e.brandCheck(this, f), p(this, a).colno;\n        }\n        get error() {\n            return e.brandCheck(this, f), p(this, a).error;\n        }\n    };\n    a = new WeakMap, o(f, \"ErrorEvent\");\n    let s = f;\n    Object.defineProperties(n.prototype, {\n        [Symbol.toStringTag]: {\n            value: \"MessageEvent\",\n            configurable: !0\n        },\n        data: A,\n        origin: A,\n        lastEventId: A,\n        source: A,\n        ports: A,\n        initMessageEvent: A\n    }), Object.defineProperties(r.prototype, {\n        [Symbol.toStringTag]: {\n            value: \"CloseEvent\",\n            configurable: !0\n        },\n        reason: A,\n        code: A,\n        wasClean: A\n    }), Object.defineProperties(s.prototype, {\n        [Symbol.toStringTag]: {\n            value: \"ErrorEvent\",\n            configurable: !0\n        },\n        message: A,\n        filename: A,\n        lineno: A,\n        colno: A,\n        error: A\n    }), e.converters.MessagePort = e.interfaceConverter(t), e.converters[\"sequence<MessagePort>\"] = e.sequenceConverter(e.converters.MessagePort);\n    const i = [\n        {\n            key: \"bubbles\",\n            converter: e.converters.boolean,\n            defaultValue: !1\n        },\n        {\n            key: \"cancelable\",\n            converter: e.converters.boolean,\n            defaultValue: !1\n        },\n        {\n            key: \"composed\",\n            converter: e.converters.boolean,\n            defaultValue: !1\n        }\n    ];\n    return e.converters.MessageEventInit = e.dictionaryConverter([\n        ...i,\n        {\n            key: \"data\",\n            converter: e.converters.any,\n            defaultValue: null\n        },\n        {\n            key: \"origin\",\n            converter: e.converters.USVString,\n            defaultValue: \"\"\n        },\n        {\n            key: \"lastEventId\",\n            converter: e.converters.DOMString,\n            defaultValue: \"\"\n        },\n        {\n            key: \"source\",\n            converter: e.nullableConverter(e.converters.MessagePort),\n            defaultValue: null\n        },\n        {\n            key: \"ports\",\n            converter: e.converters[\"sequence<MessagePort>\"],\n            get defaultValue () {\n                return [];\n            }\n        }\n    ]), e.converters.CloseEventInit = e.dictionaryConverter([\n        ...i,\n        {\n            key: \"wasClean\",\n            converter: e.converters.boolean,\n            defaultValue: !1\n        },\n        {\n            key: \"code\",\n            converter: e.converters[\"unsigned short\"],\n            defaultValue: 0\n        },\n        {\n            key: \"reason\",\n            converter: e.converters.USVString,\n            defaultValue: \"\"\n        }\n    ]), e.converters.ErrorEventInit = e.dictionaryConverter([\n        ...i,\n        {\n            key: \"message\",\n            converter: e.converters.DOMString,\n            defaultValue: \"\"\n        },\n        {\n            key: \"filename\",\n            converter: e.converters.USVString,\n            defaultValue: \"\"\n        },\n        {\n            key: \"lineno\",\n            converter: e.converters[\"unsigned long\"],\n            defaultValue: 0\n        },\n        {\n            key: \"colno\",\n            converter: e.converters[\"unsigned long\"],\n            defaultValue: 0\n        },\n        {\n            key: \"error\",\n            converter: e.converters.any\n        }\n    ]), events = {\n        MessageEvent: n,\n        CloseEvent: r,\n        ErrorEvent: s\n    }, events;\n}\no(requireEvents, \"requireEvents\");\nvar constants, hasRequiredConstants;\nfunction requireConstants() {\n    if (hasRequiredConstants) return constants;\n    hasRequiredConstants = 1;\n    const e = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\", A = {\n        enumerable: !0,\n        writable: !1,\n        configurable: !1\n    }, t = {\n        CONNECTING: 0,\n        OPEN: 1,\n        CLOSING: 2,\n        CLOSED: 3\n    }, n = {\n        NOT_SENT: 0,\n        PROCESSING: 1,\n        SENT: 2\n    }, r = {\n        CONTINUATION: 0,\n        TEXT: 1,\n        BINARY: 2,\n        CLOSE: 8,\n        PING: 9,\n        PONG: 10\n    }, s = 2 ** 16 - 1, i = {\n        INFO: 0,\n        PAYLOADLENGTH_16: 2,\n        PAYLOADLENGTH_64: 3,\n        READ_DATA: 4\n    }, E = Buffer.allocUnsafe(0);\n    return constants = {\n        uid: e,\n        sentCloseFrameState: n,\n        staticPropertyDescriptors: A,\n        states: t,\n        opcodes: r,\n        maxUnsigned16Bit: s,\n        parserStates: i,\n        emptyBuffer: E\n    }, constants;\n}\no(requireConstants, \"requireConstants\");\nvar symbols, hasRequiredSymbols;\nfunction requireSymbols() {\n    return hasRequiredSymbols || (hasRequiredSymbols = 1, symbols = {\n        kWebSocketURL: Symbol(\"url\"),\n        kReadyState: Symbol(\"ready state\"),\n        kController: Symbol(\"controller\"),\n        kResponse: Symbol(\"response\"),\n        kBinaryType: Symbol(\"binary type\"),\n        kSentClose: Symbol(\"sent close\"),\n        kReceivedClose: Symbol(\"received close\"),\n        kByteParser: Symbol(\"byte parser\")\n    }), symbols;\n}\no(requireSymbols, \"requireSymbols\");\nvar util$2, hasRequiredUtil$1;\nfunction requireUtil$1() {\n    if (hasRequiredUtil$1) return util$2;\n    hasRequiredUtil$1 = 1;\n    const { kReadyState: e, kController: A, kResponse: t, kBinaryType: n, kWebSocketURL: r } = requireSymbols(), { states: s, opcodes: i } = requireConstants(), { MessageEvent: E, ErrorEvent: Q } = requireEvents(), { isUtf8: C } = require$$6__default;\n    function I(B) {\n        return B[e] === s.CONNECTING;\n    }\n    o(I, \"isConnecting\");\n    function a(B) {\n        return B[e] === s.OPEN;\n    }\n    o(a, \"isEstablished\");\n    function f(B) {\n        return B[e] === s.CLOSING;\n    }\n    o(f, \"isClosing\");\n    function h(B) {\n        return B[e] === s.CLOSED;\n    }\n    o(h, \"isClosed\");\n    function L(B, D, G = Event, g = {}) {\n        const d = new G(B, g);\n        D.dispatchEvent(d);\n    }\n    o(L, \"fireEvent\");\n    function c(B, D, G) {\n        if (B[e] !== s.OPEN) return;\n        let g;\n        if (D === i.TEXT) try {\n            g = M(G);\n        } catch  {\n            k(B, \"Received invalid UTF-8 in text frame.\");\n            return;\n        }\n        else D === i.BINARY && (B[n] === \"blob\" ? g = new Blob([\n            G\n        ]) : g = new Uint8Array(G).buffer);\n        L(\"message\", B, E, {\n            origin: B[r].origin,\n            data: g\n        });\n    }\n    o(c, \"websocketMessageReceived\");\n    function l(B) {\n        if (B.length === 0) return !1;\n        for(let D = 0; D < B.length; ++D){\n            const G = B.charCodeAt(D);\n            if (G < 33 || G > 126 || G === 34 || G === 40 || G === 41 || G === 44 || G === 47 || G === 58 || G === 59 || G === 60 || G === 61 || G === 62 || G === 63 || G === 64 || G === 91 || G === 92 || G === 93 || G === 123 || G === 125) return !1;\n        }\n        return !0;\n    }\n    o(l, \"isValidSubprotocol\");\n    function S(B) {\n        return B >= 1e3 && B < 1015 ? B !== 1004 && B !== 1005 && B !== 1006 : B >= 3e3 && B <= 4999;\n    }\n    o(S, \"isValidStatusCode\");\n    function k(B, D) {\n        const { [A]: G, [t]: g } = B;\n        G.abort(), g?.socket && !g.socket.destroyed && g.socket.destroy(), D && L(\"error\", B, Q, {\n            error: new Error(D)\n        });\n    }\n    o(k, \"failWebsocketConnection\");\n    const w = typeof process.versions.icu == \"string\", U = w ? new TextDecoder(\"utf-8\", {\n        fatal: !0\n    }) : void 0;\n    function M(B) {\n        if (w) return U.decode(B);\n        if (!C?.(B)) throw C || process.emitWarning(\"ICU is not supported and no fallback exists. Please upgrade to at least Node v18.14.0.\", {\n            code: \"UNDICI-WS-NO-ICU\"\n        }), new TypeError(\"Invalid utf-8 received.\");\n        return B.toString(\"utf-8\");\n    }\n    return o(M, \"utf8Decode\"), util$2 = {\n        isConnecting: I,\n        isEstablished: a,\n        isClosing: f,\n        isClosed: h,\n        fireEvent: L,\n        isValidSubprotocol: l,\n        isValidStatusCode: S,\n        failWebsocketConnection: k,\n        websocketMessageReceived: c,\n        utf8Decode: M\n    }, util$2;\n}\no(requireUtil$1, \"requireUtil$1\");\nvar connection, hasRequiredConnection;\nfunction requireConnection() {\n    if (hasRequiredConnection) return connection;\n    hasRequiredConnection = 1;\n    const { uid: e, states: A, sentCloseFrameState: t } = requireConstants(), { kReadyState: n, kSentClose: r, kByteParser: s, kReceivedClose: i } = requireSymbols(), { fireEvent: E, failWebsocketConnection: Q } = requireUtil$1(), { channels: C } = diagnostics, { CloseEvent: I } = requireEvents(), { makeRequest: a } = requireRequest(), { fetching: f } = requireFetch(), { Headers: h } = requireHeaders(), { getDecodeSplit: L } = requireUtil$5(), { kHeadersList: c } = symbols$4;\n    let l;\n    try {\n        l = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n    } catch  {}\n    function S(M, B, D, G, g) {\n        const d = M;\n        d.protocol = M.protocol === \"ws:\" ? \"http:\" : \"https:\";\n        const F = a({\n            urlList: [\n                d\n            ],\n            serviceWorkers: \"none\",\n            referrer: \"no-referrer\",\n            mode: \"websocket\",\n            credentials: \"include\",\n            cache: \"no-store\",\n            redirect: \"error\"\n        });\n        if (g.headers) {\n            const m = new h(g.headers)[c];\n            F.headersList = m;\n        }\n        const N = l.randomBytes(16).toString(\"base64\");\n        F.headersList.append(\"sec-websocket-key\", N), F.headersList.append(\"sec-websocket-version\", \"13\");\n        for (const m of B)F.headersList.append(\"sec-websocket-protocol\", m);\n        const u = \"\";\n        return f({\n            request: F,\n            useParallelQueue: !0,\n            dispatcher: g.dispatcher,\n            processResponse (m) {\n                if (m.type === \"error\" || m.status !== 101) {\n                    Q(D, \"Received network error or non-101 status code.\");\n                    return;\n                }\n                if (B.length !== 0 && !m.headersList.get(\"Sec-WebSocket-Protocol\")) {\n                    Q(D, \"Server did not respond with sent protocols.\");\n                    return;\n                }\n                if (m.headersList.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\n                    Q(D, 'Server did not set Upgrade header to \"websocket\".');\n                    return;\n                }\n                if (m.headersList.get(\"Connection\")?.toLowerCase() !== \"upgrade\") {\n                    Q(D, 'Server did not set Connection header to \"upgrade\".');\n                    return;\n                }\n                const T = m.headersList.get(\"Sec-WebSocket-Accept\"), v = l.createHash(\"sha1\").update(N + e).digest(\"base64\");\n                if (T !== v) {\n                    Q(D, \"Incorrect hash received in Sec-WebSocket-Accept header.\");\n                    return;\n                }\n                const Z = m.headersList.get(\"Sec-WebSocket-Extensions\");\n                if (Z !== null && Z !== u) {\n                    Q(D, \"Received different permessage-deflate than the one set.\");\n                    return;\n                }\n                const P = m.headersList.get(\"Sec-WebSocket-Protocol\");\n                if (P !== null && !L(\"sec-websocket-protocol\", F.headersList).includes(P)) {\n                    Q(D, \"Protocol was not set in the opening handshake.\");\n                    return;\n                }\n                m.socket.on(\"data\", k), m.socket.on(\"close\", w), m.socket.on(\"error\", U), C.open.hasSubscribers && C.open.publish({\n                    address: m.socket.address(),\n                    protocol: P,\n                    extensions: Z\n                }), G(m);\n            }\n        });\n    }\n    o(S, \"establishWebSocketConnection\");\n    function k(M) {\n        this.ws[s].write(M) || this.pause();\n    }\n    o(k, \"onSocketData\");\n    function w() {\n        const { ws: M } = this, B = M[r] === t.SENT && M[i];\n        let D = 1005, G = \"\";\n        const g = M[s].closingInfo;\n        g ? (D = g.code ?? 1005, G = g.reason) : M[r] !== t.SENT && (D = 1006), M[n] = A.CLOSED, E(\"close\", M, I, {\n            wasClean: B,\n            code: D,\n            reason: G\n        }), C.close.hasSubscribers && C.close.publish({\n            websocket: M,\n            code: D,\n            reason: G\n        });\n    }\n    o(w, \"onSocketClose\");\n    function U(M) {\n        const { ws: B } = this;\n        B[n] = A.CLOSING, C.socketError.hasSubscribers && C.socketError.publish(M), this.destroy();\n    }\n    return o(U, \"onSocketError\"), connection = {\n        establishWebSocketConnection: S\n    }, connection;\n}\no(requireConnection, \"requireConnection\");\nvar frame, hasRequiredFrame;\nfunction requireFrame() {\n    if (hasRequiredFrame) return frame;\n    hasRequiredFrame = 1;\n    const { maxUnsigned16Bit: e } = requireConstants();\n    let A;\n    try {\n        A = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n    } catch  {}\n    const n = class n {\n        constructor(s){\n            this.frameData = s, this.maskKey = A.randomBytes(4);\n        }\n        createFrame(s) {\n            const i = this.frameData?.byteLength ?? 0;\n            let E = i, Q = 6;\n            i > e ? (Q += 8, E = 127) : i > 125 && (Q += 2, E = 126);\n            const C = Buffer.allocUnsafe(i + Q);\n            C[0] = C[1] = 0, C[0] |= 128, C[0] = (C[0] & 240) + s; /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */ \n            C[Q - 4] = this.maskKey[0], C[Q - 3] = this.maskKey[1], C[Q - 2] = this.maskKey[2], C[Q - 1] = this.maskKey[3], C[1] = E, E === 126 ? C.writeUInt16BE(i, 2) : E === 127 && (C[2] = C[3] = 0, C.writeUIntBE(i, 4, 6)), C[1] |= 128;\n            for(let I = 0; I < i; I++)C[Q + I] = this.frameData[I] ^ this.maskKey[I % 4];\n            return C;\n        }\n    };\n    o(n, \"WebsocketFrameSend\");\n    let t = n;\n    return frame = {\n        WebsocketFrameSend: t\n    }, frame;\n}\no(requireFrame, \"requireFrame\");\nvar receiver, hasRequiredReceiver;\nfunction requireReceiver() {\n    var S, k, w, U, M;\n    if (hasRequiredReceiver) return receiver;\n    hasRequiredReceiver = 1;\n    const { Writable: e } = Stream__default, { parserStates: A, opcodes: t, states: n, emptyBuffer: r, sentCloseFrameState: s } = requireConstants(), { kReadyState: i, kSentClose: E, kResponse: Q, kReceivedClose: C } = requireSymbols(), { channels: I } = diagnostics, { isValidStatusCode: a, failWebsocketConnection: f, websocketMessageReceived: h, utf8Decode: L } = requireUtil$1(), { WebsocketFrameSend: c } = requireFrame(), B = class B extends e {\n        constructor(g){\n            super();\n            CA(this, S, []);\n            CA(this, k, 0);\n            CA(this, w, A.INFO);\n            CA(this, U, {});\n            CA(this, M, []);\n            this.ws = g;\n        }\n        _write(g, d, F) {\n            p(this, S).push(g), EA(this, k, p(this, k) + g.length), this.run(F);\n        }\n        run(g) {\n            var d;\n            for(;;){\n                if (p(this, w) === A.INFO) {\n                    if (p(this, k) < 2) return g();\n                    const F = this.consume(2);\n                    if (p(this, U).fin = (F[0] & 128) !== 0, p(this, U).opcode = F[0] & 15, (d = p(this, U)).originalOpcode ?? (d.originalOpcode = p(this, U).opcode), p(this, U).fragmented = !p(this, U).fin && p(this, U).opcode !== t.CONTINUATION, p(this, U).fragmented && p(this, U).opcode !== t.BINARY && p(this, U).opcode !== t.TEXT) {\n                        f(this.ws, \"Invalid frame type was fragmented.\");\n                        return;\n                    }\n                    const N = F[1] & 127;\n                    if (N <= 125 ? (p(this, U).payloadLength = N, EA(this, w, A.READ_DATA)) : N === 126 ? EA(this, w, A.PAYLOADLENGTH_16) : N === 127 && EA(this, w, A.PAYLOADLENGTH_64), p(this, U).fragmented && N > 125) {\n                        f(this.ws, \"Fragmented frame exceeded 125 bytes.\");\n                        return;\n                    } else if ((p(this, U).opcode === t.PING || p(this, U).opcode === t.PONG || p(this, U).opcode === t.CLOSE) && N > 125) {\n                        f(this.ws, \"Payload length for control frame exceeded 125 bytes.\");\n                        return;\n                    } else if (p(this, U).opcode === t.CLOSE) {\n                        if (N === 1) {\n                            f(this.ws, \"Received close frame with a 1-byte body.\");\n                            return;\n                        }\n                        const u = this.consume(N);\n                        if (p(this, U).closeInfo = this.parseCloseBody(u), this.ws[E] !== s.SENT) {\n                            let b = r;\n                            p(this, U).closeInfo.code && (b = Buffer.allocUnsafe(2), b.writeUInt16BE(p(this, U).closeInfo.code, 0));\n                            const m = new c(b);\n                            this.ws[Q].socket.write(m.createFrame(t.CLOSE), (T)=>{\n                                T || (this.ws[E] = s.SENT);\n                            });\n                        }\n                        this.ws[i] = n.CLOSING, this.ws[C] = !0, this.end();\n                        return;\n                    } else if (p(this, U).opcode === t.PING) {\n                        const u = this.consume(N);\n                        if (!this.ws[C]) {\n                            const b = new c(u);\n                            this.ws[Q].socket.write(b.createFrame(t.PONG)), I.ping.hasSubscribers && I.ping.publish({\n                                payload: u\n                            });\n                        }\n                        if (EA(this, w, A.INFO), p(this, k) > 0) continue;\n                        g();\n                        return;\n                    } else if (p(this, U).opcode === t.PONG) {\n                        const u = this.consume(N);\n                        if (I.pong.hasSubscribers && I.pong.publish({\n                            payload: u\n                        }), p(this, k) > 0) continue;\n                        g();\n                        return;\n                    }\n                } else if (p(this, w) === A.PAYLOADLENGTH_16) {\n                    if (p(this, k) < 2) return g();\n                    const F = this.consume(2);\n                    p(this, U).payloadLength = F.readUInt16BE(0), EA(this, w, A.READ_DATA);\n                } else if (p(this, w) === A.PAYLOADLENGTH_64) {\n                    if (p(this, k) < 8) return g();\n                    const F = this.consume(8), N = F.readUInt32BE(0);\n                    if (N > 2 ** 31 - 1) {\n                        f(this.ws, \"Received payload length > 2^31 bytes.\");\n                        return;\n                    }\n                    const u = F.readUInt32BE(4);\n                    p(this, U).payloadLength = (N << 8) + u, EA(this, w, A.READ_DATA);\n                } else if (p(this, w) === A.READ_DATA) {\n                    if (p(this, k) < p(this, U).payloadLength) return g();\n                    if (p(this, k) >= p(this, U).payloadLength) {\n                        const F = this.consume(p(this, U).payloadLength);\n                        if (p(this, M).push(F), !p(this, U).fragmented || p(this, U).fin && p(this, U).opcode === t.CONTINUATION) {\n                            const N = Buffer.concat(p(this, M));\n                            h(this.ws, p(this, U).originalOpcode, N), EA(this, U, {}), p(this, M).length = 0;\n                        }\n                        EA(this, w, A.INFO);\n                    }\n                }\n                if (p(this, k) === 0) {\n                    g();\n                    break;\n                }\n            }\n        }\n        consume(g) {\n            if (g > p(this, k)) return null;\n            if (g === 0) return r;\n            if (p(this, S)[0].length === g) return EA(this, k, p(this, k) - p(this, S)[0].length), p(this, S).shift();\n            const d = Buffer.allocUnsafe(g);\n            let F = 0;\n            for(; F !== g;){\n                const N = p(this, S)[0], { length: u } = N;\n                if (u + F === g) {\n                    d.set(p(this, S).shift(), F);\n                    break;\n                } else if (u + F > g) {\n                    d.set(N.subarray(0, g - F), F), p(this, S)[0] = N.subarray(g - F);\n                    break;\n                } else d.set(p(this, S).shift(), F), F += N.length;\n            }\n            return EA(this, k, p(this, k) - g), d;\n        }\n        parseCloseBody(g) {\n            let d;\n            g.length >= 2 && (d = g.readUInt16BE(0));\n            let F = g.subarray(2);\n            if (F[0] === 239 && F[1] === 187 && F[2] === 191 && (F = F.subarray(3)), d !== void 0 && !a(d)) return null;\n            try {\n                F = L(F);\n            } catch  {\n                return null;\n            }\n            return {\n                code: d,\n                reason: F\n            };\n        }\n        get closingInfo() {\n            return p(this, U).closeInfo;\n        }\n    };\n    S = new WeakMap, k = new WeakMap, w = new WeakMap, U = new WeakMap, M = new WeakMap, o(B, \"ByteParser\");\n    let l = B;\n    return receiver = {\n        ByteParser: l\n    }, receiver;\n}\no(requireReceiver, \"requireReceiver\");\nvar websocket, hasRequiredWebsocket;\nfunction requireWebsocket() {\n    var m, T, v, Z, P, kt;\n    if (hasRequiredWebsocket) return websocket;\n    hasRequiredWebsocket = 1;\n    const { webidl: e } = requireWebidl(), { URLSerializer: A } = requireDataUrl(), { getGlobalOrigin: t } = requireGlobal(), { staticPropertyDescriptors: n, states: r, sentCloseFrameState: s, opcodes: i, emptyBuffer: E } = requireConstants(), { kWebSocketURL: Q, kReadyState: C, kController: I, kBinaryType: a, kResponse: f, kSentClose: h, kByteParser: L } = requireSymbols(), { isConnecting: c, isEstablished: l, isClosed: S, isClosing: k, isValidSubprotocol: w, failWebsocketConnection: U, fireEvent: M } = requireUtil$1(), { establishWebSocketConnection: B } = requireConnection(), { WebsocketFrameSend: D } = requireFrame(), { ByteParser: G } = requireReceiver(), { kEnumerableProperty: g, isBlobLike: d } = util$m, { getGlobalDispatcher: F } = global, { types: N } = require$$0__default$1;\n    let u = !1;\n    const K = class K extends EventTarget {\n        constructor(X, $ = []){\n            super();\n            CA(this, P);\n            CA(this, m, {\n                open: null,\n                error: null,\n                close: null,\n                message: null\n            });\n            CA(this, T, 0);\n            CA(this, v, \"\");\n            CA(this, Z, \"\");\n            e.argumentLengthCheck(arguments, 1, {\n                header: \"WebSocket constructor\"\n            }), u || (u = !0, process.emitWarning(\"WebSockets are experimental, expect them to change at any time.\", {\n                code: \"UNDICI-WS\"\n            }));\n            const V = e.converters[\"DOMString or sequence<DOMString> or WebSocketInit\"]($);\n            X = e.converters.USVString(X), $ = V.protocols;\n            const q = t();\n            let z;\n            try {\n                z = new URL(X, q);\n            } catch (rA) {\n                throw new DOMException(rA, \"SyntaxError\");\n            }\n            if (z.protocol === \"http:\" ? z.protocol = \"ws:\" : z.protocol === \"https:\" && (z.protocol = \"wss:\"), z.protocol !== \"ws:\" && z.protocol !== \"wss:\") throw new DOMException(`Expected a ws: or wss: protocol, got ${z.protocol}`, \"SyntaxError\");\n            if (z.hash || z.href.endsWith(\"#\")) throw new DOMException(\"Got fragment\", \"SyntaxError\");\n            if (typeof $ == \"string\" && ($ = [\n                $\n            ]), $.length !== new Set($.map((rA)=>rA.toLowerCase())).size) throw new DOMException(\"Invalid Sec-WebSocket-Protocol value\", \"SyntaxError\");\n            if ($.length > 0 && !$.every((rA)=>w(rA))) throw new DOMException(\"Invalid Sec-WebSocket-Protocol value\", \"SyntaxError\");\n            this[Q] = new URL(z.href), this[I] = B(z, $, this, (rA)=>kA(this, P, kt).call(this, rA), V), this[C] = K.CONNECTING, this[h] = s.NOT_SENT, this[a] = \"blob\";\n        }\n        close(X = void 0, $ = void 0) {\n            if (e.brandCheck(this, K), X !== void 0 && (X = e.converters[\"unsigned short\"](X, {\n                clamp: !0\n            })), $ !== void 0 && ($ = e.converters.USVString($)), X !== void 0 && X !== 1e3 && (X < 3e3 || X > 4999)) throw new DOMException(\"invalid code\", \"InvalidAccessError\");\n            let V = 0;\n            if ($ !== void 0 && (V = Buffer.byteLength($), V > 123)) throw new DOMException(`Reason must be less than 123 bytes; received ${V}`, \"SyntaxError\");\n            if (!(k(this) || S(this))) if (!l(this)) U(this, \"Connection was closed before it was established.\"), this[C] = K.CLOSING;\n            else if (this[h] === s.NOT_SENT) {\n                this[h] = s.PROCESSING;\n                const q = new D;\n                X !== void 0 && $ === void 0 ? (q.frameData = Buffer.allocUnsafe(2), q.frameData.writeUInt16BE(X, 0)) : X !== void 0 && $ !== void 0 ? (q.frameData = Buffer.allocUnsafe(2 + V), q.frameData.writeUInt16BE(X, 0), q.frameData.write($, 2, \"utf-8\")) : q.frameData = E, this[f].socket.write(q.createFrame(i.CLOSE), (rA)=>{\n                    rA || (this[h] = s.SENT);\n                }), this[C] = r.CLOSING;\n            } else this[C] = K.CLOSING;\n        }\n        send(X) {\n            if (e.brandCheck(this, K), e.argumentLengthCheck(arguments, 1, {\n                header: \"WebSocket.send\"\n            }), X = e.converters.WebSocketSendData(X), c(this)) throw new DOMException(\"Sent before connected.\", \"InvalidStateError\");\n            if (!l(this) || k(this)) return;\n            const $ = this[f].socket;\n            if (typeof X == \"string\") {\n                const V = Buffer.from(X), z = new D(V).createFrame(i.TEXT);\n                EA(this, T, p(this, T) + V.byteLength), $.write(z, ()=>{\n                    EA(this, T, p(this, T) - V.byteLength);\n                });\n            } else if (N.isArrayBuffer(X)) {\n                const V = Buffer.from(X), z = new D(V).createFrame(i.BINARY);\n                EA(this, T, p(this, T) + V.byteLength), $.write(z, ()=>{\n                    EA(this, T, p(this, T) - V.byteLength);\n                });\n            } else if (ArrayBuffer.isView(X)) {\n                const V = Buffer.from(X, X.byteOffset, X.byteLength), z = new D(V).createFrame(i.BINARY);\n                EA(this, T, p(this, T) + V.byteLength), $.write(z, ()=>{\n                    EA(this, T, p(this, T) - V.byteLength);\n                });\n            } else if (d(X)) {\n                const V = new D;\n                X.arrayBuffer().then((q)=>{\n                    const z = Buffer.from(q);\n                    V.frameData = z;\n                    const rA = V.createFrame(i.BINARY);\n                    EA(this, T, p(this, T) + z.byteLength), $.write(rA, ()=>{\n                        EA(this, T, p(this, T) - z.byteLength);\n                    });\n                });\n            }\n        }\n        get readyState() {\n            return e.brandCheck(this, K), this[C];\n        }\n        get bufferedAmount() {\n            return e.brandCheck(this, K), p(this, T);\n        }\n        get url() {\n            return e.brandCheck(this, K), A(this[Q]);\n        }\n        get extensions() {\n            return e.brandCheck(this, K), p(this, Z);\n        }\n        get protocol() {\n            return e.brandCheck(this, K), p(this, v);\n        }\n        get onopen() {\n            return e.brandCheck(this, K), p(this, m).open;\n        }\n        set onopen(X) {\n            e.brandCheck(this, K), p(this, m).open && this.removeEventListener(\"open\", p(this, m).open), typeof X == \"function\" ? (p(this, m).open = X, this.addEventListener(\"open\", X)) : p(this, m).open = null;\n        }\n        get onerror() {\n            return e.brandCheck(this, K), p(this, m).error;\n        }\n        set onerror(X) {\n            e.brandCheck(this, K), p(this, m).error && this.removeEventListener(\"error\", p(this, m).error), typeof X == \"function\" ? (p(this, m).error = X, this.addEventListener(\"error\", X)) : p(this, m).error = null;\n        }\n        get onclose() {\n            return e.brandCheck(this, K), p(this, m).close;\n        }\n        set onclose(X) {\n            e.brandCheck(this, K), p(this, m).close && this.removeEventListener(\"close\", p(this, m).close), typeof X == \"function\" ? (p(this, m).close = X, this.addEventListener(\"close\", X)) : p(this, m).close = null;\n        }\n        get onmessage() {\n            return e.brandCheck(this, K), p(this, m).message;\n        }\n        set onmessage(X) {\n            e.brandCheck(this, K), p(this, m).message && this.removeEventListener(\"message\", p(this, m).message), typeof X == \"function\" ? (p(this, m).message = X, this.addEventListener(\"message\", X)) : p(this, m).message = null;\n        }\n        get binaryType() {\n            return e.brandCheck(this, K), this[a];\n        }\n        set binaryType(X) {\n            e.brandCheck(this, K), X !== \"blob\" && X !== \"arraybuffer\" ? this[a] = \"blob\" : this[a] = X;\n        }\n    };\n    m = new WeakMap, T = new WeakMap, v = new WeakMap, Z = new WeakMap, P = new WeakSet, kt = o(function(X) {\n        this[f] = X;\n        const $ = new G(this);\n        $.on(\"drain\", o(function() {\n            this.ws[f].socket.resume();\n        }, \"onParserDrain\")), X.socket.ws = this, this[L] = $, this[C] = r.OPEN;\n        const V = X.headersList.get(\"sec-websocket-extensions\");\n        V !== null && EA(this, Z, V);\n        const q = X.headersList.get(\"sec-websocket-protocol\");\n        q !== null && EA(this, v, q), M(\"open\", this);\n    }, \"#onConnectionEstablished\"), o(K, \"WebSocket\");\n    let b = K;\n    return b.CONNECTING = b.prototype.CONNECTING = r.CONNECTING, b.OPEN = b.prototype.OPEN = r.OPEN, b.CLOSING = b.prototype.CLOSING = r.CLOSING, b.CLOSED = b.prototype.CLOSED = r.CLOSED, Object.defineProperties(b.prototype, {\n        CONNECTING: n,\n        OPEN: n,\n        CLOSING: n,\n        CLOSED: n,\n        url: g,\n        readyState: g,\n        bufferedAmount: g,\n        onopen: g,\n        onerror: g,\n        onclose: g,\n        close: g,\n        onmessage: g,\n        binaryType: g,\n        send: g,\n        extensions: g,\n        protocol: g,\n        [Symbol.toStringTag]: {\n            value: \"WebSocket\",\n            writable: !1,\n            enumerable: !1,\n            configurable: !0\n        }\n    }), Object.defineProperties(b, {\n        CONNECTING: n,\n        OPEN: n,\n        CLOSING: n,\n        CLOSED: n\n    }), e.converters[\"sequence<DOMString>\"] = e.sequenceConverter(e.converters.DOMString), e.converters[\"DOMString or sequence<DOMString>\"] = function(tA) {\n        return e.util.Type(tA) === \"Object\" && Symbol.iterator in tA ? e.converters[\"sequence<DOMString>\"](tA) : e.converters.DOMString(tA);\n    }, e.converters.WebSocketInit = e.dictionaryConverter([\n        {\n            key: \"protocols\",\n            converter: e.converters[\"DOMString or sequence<DOMString>\"],\n            get defaultValue () {\n                return [];\n            }\n        },\n        {\n            key: \"dispatcher\",\n            converter: (tA)=>tA,\n            get defaultValue () {\n                return F();\n            }\n        },\n        {\n            key: \"headers\",\n            converter: e.nullableConverter(e.converters.HeadersInit)\n        }\n    ]), e.converters[\"DOMString or sequence<DOMString> or WebSocketInit\"] = function(tA) {\n        return e.util.Type(tA) === \"Object\" && !(Symbol.iterator in tA) ? e.converters.WebSocketInit(tA) : {\n            protocols: e.converters[\"DOMString or sequence<DOMString>\"](tA)\n        };\n    }, e.converters.WebSocketSendData = function(tA) {\n        if (e.util.Type(tA) === \"Object\") {\n            if (d(tA)) return e.converters.Blob(tA, {\n                strict: !1\n            });\n            if (ArrayBuffer.isView(tA) || N.isArrayBuffer(tA)) return e.converters.BufferSource(tA);\n        }\n        return e.converters.USVString(tA);\n    }, websocket = {\n        WebSocket: b\n    }, websocket;\n}\no(requireWebsocket, \"requireWebsocket\");\nvar util$1, hasRequiredUtil;\nfunction requireUtil() {\n    if (hasRequiredUtil) return util$1;\n    hasRequiredUtil = 1;\n    function e(n) {\n        return n.indexOf(\"\\x00\") === -1;\n    }\n    o(e, \"isValidLastEventId\");\n    function A(n) {\n        if (n.length === 0) return !1;\n        for(let r = 0; r < n.length; r++)if (n.charCodeAt(r) < 48 || n.charCodeAt(r) > 57) return !1;\n        return !0;\n    }\n    o(A, \"isASCIINumber\");\n    function t(n) {\n        return new Promise((r)=>{\n            setTimeout(r, n).unref();\n        });\n    }\n    return o(t, \"delay\"), util$1 = {\n        isValidLastEventId: e,\n        isASCIINumber: A,\n        delay: t\n    }, util$1;\n}\no(requireUtil, \"requireUtil\");\nvar eventsourceStream, hasRequiredEventsourceStream;\nfunction requireEventsourceStream() {\n    if (hasRequiredEventsourceStream) return eventsourceStream;\n    hasRequiredEventsourceStream = 1;\n    const { Transform: e } = Stream__default, { isASCIINumber: A, isValidLastEventId: t } = requireUtil(), n = [\n        239,\n        187,\n        191\n    ], r = 10, s = 13, i = 58, E = 32, C = class C extends e {\n        constructor(f = {}){\n            f.readableObjectMode = !0;\n            super(f);\n            NA(this, \"state\", null);\n            NA(this, \"checkBOM\", !0);\n            NA(this, \"crlfCheck\", !1);\n            NA(this, \"eventEndCheck\", !1);\n            NA(this, \"buffer\", null);\n            NA(this, \"pos\", 0);\n            NA(this, \"event\", {\n                data: void 0,\n                event: void 0,\n                id: void 0,\n                retry: void 0\n            });\n            this.state = f.eventSourceSettings || {}, f.push && (this.push = f.push);\n        }\n        _transform(f, h, L) {\n            if (f.length === 0) {\n                L();\n                return;\n            }\n            if (this.buffer ? this.buffer = Buffer.concat([\n                this.buffer,\n                f\n            ]) : this.buffer = f, this.checkBOM) switch(this.buffer.length){\n                case 1:\n                    if (this.buffer[0] === n[0]) {\n                        L();\n                        return;\n                    }\n                    this.checkBOM = !1, L();\n                    return;\n                case 2:\n                    if (this.buffer[0] === n[0] && this.buffer[1] === n[1]) {\n                        L();\n                        return;\n                    }\n                    this.checkBOM = !1;\n                    break;\n                case 3:\n                    if (this.buffer[0] === n[0] && this.buffer[1] === n[1] && this.buffer[2] === n[2]) {\n                        this.buffer = Buffer.alloc(0), this.checkBOM = !1, L();\n                        return;\n                    }\n                    this.checkBOM = !1;\n                    break;\n                default:\n                    this.buffer[0] === n[0] && this.buffer[1] === n[1] && this.buffer[2] === n[2] && (this.buffer = this.buffer.subarray(3)), this.checkBOM = !1;\n                    break;\n            }\n            for(; this.pos < this.buffer.length;){\n                if (this.eventEndCheck) {\n                    if (this.crlfCheck) {\n                        if (this.buffer[this.pos] === r) {\n                            this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.crlfCheck = !1;\n                            continue;\n                        }\n                        this.crlfCheck = !1;\n                    }\n                    if (this.buffer[this.pos] === r || this.buffer[this.pos] === s) {\n                        this.buffer[this.pos] === s && (this.crlfCheck = !0), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) && this.processEvent(this.event), this.clearEvent();\n                        continue;\n                    }\n                    this.eventEndCheck = !1;\n                    continue;\n                }\n                if (this.buffer[this.pos] === r || this.buffer[this.pos] === s) {\n                    this.buffer[this.pos] === s && (this.crlfCheck = !0), this.parseLine(this.buffer.subarray(0, this.pos), this.event), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.eventEndCheck = !0;\n                    continue;\n                }\n                this.pos++;\n            }\n            L();\n        }\n        parseLine(f, h) {\n            if (f.length === 0) return;\n            const L = f.indexOf(i);\n            if (L === 0) return;\n            let c = \"\", l = \"\";\n            if (L !== -1) {\n                c = f.subarray(0, L).toString(\"utf8\");\n                let S = L + 1;\n                f[S] === E && ++S, l = f.subarray(S).toString(\"utf8\");\n            } else c = f.toString(\"utf8\"), l = \"\";\n            switch(c){\n                case \"data\":\n                    h[c] === void 0 ? h[c] = l : h[c] += `\n${l}`;\n                    break;\n                case \"retry\":\n                    A(l) && (h[c] = l);\n                    break;\n                case \"id\":\n                    t(l) && (h[c] = l);\n                    break;\n                case \"event\":\n                    l.length > 0 && (h[c] = l);\n                    break;\n            }\n        }\n        processEvent(f) {\n            f.retry && A(f.retry) && (this.state.reconnectionTime = parseInt(f.retry, 10)), f.id && t(f.id) && (this.state.lastEventId = f.id), f.data !== void 0 && this.push({\n                type: f.event || \"message\",\n                options: {\n                    data: f.data,\n                    lastEventId: this.state.lastEventId,\n                    origin: this.state.origin\n                }\n            });\n        }\n        clearEvent() {\n            this.event = {\n                data: void 0,\n                event: void 0,\n                id: void 0,\n                retry: void 0\n            };\n        }\n    };\n    o(C, \"EventSourceStream\");\n    let Q = C;\n    return eventsourceStream = {\n        EventSourceStream: Q\n    }, eventsourceStream;\n}\no(requireEventsourceStream, \"requireEventsourceStream\");\nvar eventsource, hasRequiredEventsource;\nfunction requireEventsource() {\n    var U, M, B, D, G, g, d, F, $e, u, _e;\n    if (hasRequiredEventsource) return eventsource;\n    hasRequiredEventsource = 1;\n    const { pipeline: e } = Stream__default, { fetching: A } = requireFetch(), { makeRequest: t } = requireRequest(), { getGlobalOrigin: n } = requireGlobal(), { webidl: r } = requireWebidl(), { EventSourceStream: s } = requireEventsourceStream(), { parseMIMEType: i } = requireDataUrl(), { MessageEvent: E } = requireEvents(), { isNetworkError: Q } = requireResponse(), { delay: C } = requireUtil(), { kEnumerableProperty: I } = util$m;\n    let a = !1;\n    const f = 3e3, h = 0, L = 1, c = 2, l = \"anonymous\", S = \"use-credentials\", m = class m extends EventTarget {\n        constructor(Z, P = {}){\n            super();\n            CA(this, F);\n            CA(this, u);\n            CA(this, U, {\n                open: null,\n                error: null,\n                message: null\n            });\n            CA(this, M, null);\n            CA(this, B, !1);\n            CA(this, D, h);\n            CA(this, G, null);\n            CA(this, g, null);\n            CA(this, d, null);\n            r.argumentLengthCheck(arguments, 1, {\n                header: \"EventSource constructor\"\n            }), a || (a = !0, process.emitWarning(\"EventSource is experimental, expect them to change at any time.\", {\n                code: \"UNDICI-ES\"\n            })), Z = r.converters.USVString(Z), P = r.converters.EventSourceInitDict(P), EA(this, d, {\n                origin: n(),\n                policyContainer: {\n                    referrerPolicy: \"no-referrer\"\n                },\n                lastEventId: \"\",\n                reconnectionTime: f\n            });\n            let AA;\n            try {\n                AA = new URL(Z, p(this, d).origin), p(this, d).origin = AA.origin;\n            } catch (aA) {\n                throw new DOMException(aA, \"SyntaxError\");\n            }\n            EA(this, M, AA.href);\n            let K = l;\n            P.withCredentials && (K = S, EA(this, B, !0));\n            const tA = {\n                redirect: \"follow\",\n                keepalive: !0,\n                mode: \"cors\",\n                credentials: K === \"anonymous\" ? \"same-origin\" : \"omit\",\n                referrer: \"no-referrer\"\n            };\n            tA.client = p(this, d), tA.headersList = [\n                [\n                    \"accept\",\n                    {\n                        name: \"accept\",\n                        value: \"text/event-stream\"\n                    }\n                ]\n            ], tA.cache = \"no-store\", tA.initiator = \"other\", tA.urlList = [\n                new URL(p(this, M))\n            ], EA(this, G, t(tA)), kA(this, F, $e).call(this);\n        }\n        get readyState() {\n            return p(this, D);\n        }\n        get url() {\n            return p(this, M);\n        }\n        get withCredentials() {\n            return p(this, B);\n        }\n        close() {\n            r.brandCheck(this, m), p(this, D) !== c && (EA(this, D, c), clearTimeout(p(this, d).reconnectionTimer), p(this, g).abort(), p(this, G) && EA(this, G, null));\n        }\n        get onopen() {\n            return p(this, U).open;\n        }\n        set onopen(Z) {\n            p(this, U).open && this.removeEventListener(\"open\", p(this, U).open), typeof Z == \"function\" ? (p(this, U).open = Z, this.addEventListener(\"open\", Z)) : p(this, U).open = null;\n        }\n        get onmessage() {\n            return p(this, U).message;\n        }\n        set onmessage(Z) {\n            p(this, U).message && this.removeEventListener(\"message\", p(this, U).message), typeof Z == \"function\" ? (p(this, U).message = Z, this.addEventListener(\"message\", Z)) : p(this, U).message = null;\n        }\n        get onerror() {\n            return p(this, U).error;\n        }\n        set onerror(Z) {\n            p(this, U).error && this.removeEventListener(\"error\", p(this, U).error), typeof Z == \"function\" ? (p(this, U).error = Z, this.addEventListener(\"error\", Z)) : p(this, U).error = null;\n        }\n    };\n    U = new WeakMap, M = new WeakMap, B = new WeakMap, D = new WeakMap, G = new WeakMap, g = new WeakMap, d = new WeakMap, F = new WeakSet, $e = o(function() {\n        if (p(this, D) === c) return;\n        EA(this, D, h);\n        const Z = {\n            request: p(this, G)\n        }, P = o((AA)=>{\n            Q(AA) && (this.dispatchEvent(new Event(\"error\")), this.close()), kA(this, u, _e).call(this);\n        }, \"processEventSourceEndOfBody\");\n        Z.processResponseEndOfBody = P, Z.processResponse = (AA)=>{\n            if (Q(AA)) if (AA.aborted) {\n                this.close(), this.dispatchEvent(new Event(\"error\"));\n                return;\n            } else {\n                kA(this, u, _e).call(this);\n                return;\n            }\n            const K = AA.headersList.get(\"content-type\", !0), tA = K !== null ? i(K) : \"failure\", aA = tA !== \"failure\" && tA.essence === \"text/event-stream\";\n            if (AA.status !== 200 || aA === !1) {\n                this.close(), this.dispatchEvent(new Event(\"error\"));\n                return;\n            }\n            EA(this, D, L), this.dispatchEvent(new Event(\"open\")), p(this, d).origin = AA.urlList[AA.urlList.length - 1].origin;\n            const X = new s({\n                eventSourceSettings: p(this, d),\n                push: ($)=>{\n                    this.dispatchEvent(new E($.type, $.options));\n                }\n            });\n            e(AA.body.stream, X, ($)=>{\n                $?.aborted === !1 && (this.close(), this.dispatchEvent(new Event(\"error\")));\n            });\n        }, EA(this, g, A(Z));\n    }, \"#connect\"), u = new WeakSet, _e = o(async function() {\n        p(this, D) !== c && (EA(this, D, h), this.dispatchEvent(new Event(\"error\")), await C(p(this, d).reconnectionTime), p(this, D) === h && (p(this, d).lastEventId !== \"\" && p(this, G).headersList.set(\"last-event-id\", p(this, d).lastEventId, !0), kA(this, F, $e).call(this)));\n    }, \"#reconnect\"), o(m, \"EventSource\");\n    let k = m;\n    const w = {\n        CONNECTING: {\n            __proto__: null,\n            configurable: !1,\n            enumerable: !0,\n            value: h,\n            writable: !1\n        },\n        OPEN: {\n            __proto__: null,\n            configurable: !1,\n            enumerable: !0,\n            value: L,\n            writable: !1\n        },\n        CLOSED: {\n            __proto__: null,\n            configurable: !1,\n            enumerable: !0,\n            value: c,\n            writable: !1\n        }\n    };\n    return Object.defineProperties(k, w), Object.defineProperties(k.prototype, w), Object.defineProperties(k.prototype, {\n        close: I,\n        onerror: I,\n        onmessage: I,\n        onopen: I,\n        readyState: I,\n        url: I,\n        withCredentials: I\n    }), r.converters.EventSourceInitDict = r.dictionaryConverter([\n        {\n            key: \"withCredentials\",\n            converter: r.converters.boolean,\n            defaultValue: !1\n        }\n    ]), eventsource = {\n        EventSource: k,\n        defaultReconnectionTime: f\n    }, eventsource;\n}\no(requireEventsource, \"requireEventsource\");\nconst Dispatcher = dispatcher, Agent = agent, ProxyAgent = proxyAgent, errors = errors$1, util = util$m, { InvalidArgumentError } = errors, api = api$1, { getGlobalDispatcher, setGlobalDispatcher } = global;\nObject.assign(Dispatcher.prototype, api);\nvar Agent_1 = Agent, ProxyAgent_1 = ProxyAgent;\nutil.parseHeaders, util.headerNameToString;\nfunction makeDispatcher(e) {\n    return (A, t, n)=>{\n        if (typeof t == \"function\" && (n = t, t = null), !A || typeof A != \"string\" && typeof A != \"object\" && !(A instanceof URL)) throw new InvalidArgumentError(\"invalid url\");\n        if (t != null && typeof t != \"object\") throw new InvalidArgumentError(\"invalid opts\");\n        if (t && t.path != null) {\n            if (typeof t.path != \"string\") throw new InvalidArgumentError(\"invalid opts.path\");\n            let i = t.path;\n            t.path.startsWith(\"/\") || (i = `/${i}`), A = new URL(util.parseOrigin(A).origin + i);\n        } else t || (t = typeof A == \"object\" ? A : {}), A = util.parseURL(A);\n        const { agent: r, dispatcher: s = getGlobalDispatcher() } = t;\n        if (r) throw new InvalidArgumentError(\"unsupported opts.agent. Did you mean opts.client?\");\n        return e.call(s, {\n            ...t,\n            origin: A.origin,\n            path: A.search ? `${A.pathname}${A.search}` : A.pathname,\n            method: t.method || (t.body ? \"PUT\" : \"GET\")\n        }, n);\n    };\n}\no(makeDispatcher, \"makeDispatcher\"), requireFetch().fetch, requireHeaders().Headers, requireResponse().Response, requireRequest().Request, requireFormdata().FormData, requireFile().File, requireFilereader().FileReader, requireGlobal();\nconst { CacheStorage } = requireCachestorage(), { kConstruct } = requireSymbols$1();\nnew CacheStorage(kConstruct), requireCookies(), requireDataUrl(), requireEvents(), requireWebsocket().WebSocket, makeDispatcher(api.request), makeDispatcher(api.stream), makeDispatcher(api.pipeline), makeDispatcher(api.connect), makeDispatcher(api.upgrade), requireEventsource(), exports.Agent_1 = Agent_1, exports.ProxyAgent_1 = ProxyAgent_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudC9kaXN0L3NoYXJlZC9ub2RlLWZldGNoLW5hdGl2ZS13aXRoLWFnZW50LmRmN2U2YmQ2LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUFBLElBQUlBLEtBQUdDLE9BQU9DLGNBQWM7QUFBQyxJQUFJQyxLQUFHLENBQUNDLEdBQUVDLEdBQUVDLElBQUlELEtBQUtELElBQUVKLEdBQUdJLEdBQUVDLEdBQUU7UUFBQ0UsWUFBVyxDQUFDO1FBQUVDLGNBQWEsQ0FBQztRQUFFQyxVQUFTLENBQUM7UUFBRUMsT0FBTUo7SUFBQyxLQUFHRixDQUFDLENBQUNDLEVBQUUsR0FBQ0M7QUFBRSxJQUFJSyxJQUFFLENBQUNQLEdBQUVDLElBQUlMLEdBQUdJLEdBQUUsUUFBTztRQUFDTSxPQUFNTDtRQUFFRyxjQUFhLENBQUM7SUFBQztBQUFHLElBQUlJLEtBQUcsQ0FBQ1IsR0FBRUMsR0FBRUMsSUFBS0gsQ0FBQUEsR0FBR0MsR0FBRSxPQUFPQyxLQUFHLFdBQVNBLElBQUUsS0FBR0EsR0FBRUMsSUFBR0EsQ0FBQUEsR0FBR08sS0FBRyxDQUFDVCxHQUFFQyxHQUFFQztJQUFLLElBQUcsQ0FBQ0QsRUFBRVMsR0FBRyxDQUFDVixJQUFHLE1BQU1XLFVBQVUsWUFBVVQ7QUFBRSxHQUFFVSxLQUFHLENBQUNaLEdBQUVDO0lBQUssSUFBR0osT0FBT0ksT0FBS0EsR0FBRSxNQUFNVSxVQUFVO0lBQThDLE9BQU9YLEVBQUVVLEdBQUcsQ0FBQ1Q7QUFBRSxHQUFFWSxJQUFFLENBQUNiLEdBQUVDLEdBQUVDLElBQUtPLENBQUFBLEdBQUdULEdBQUVDLEdBQUUsNEJBQTJCQyxJQUFFQSxFQUFFWSxJQUFJLENBQUNkLEtBQUdDLEVBQUVjLEdBQUcsQ0FBQ2YsRUFBQyxHQUFHZ0IsS0FBRyxDQUFDaEIsR0FBRUMsR0FBRUM7SUFBSyxJQUFHRCxFQUFFUyxHQUFHLENBQUNWLElBQUcsTUFBTVcsVUFBVTtJQUFx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LENBQUMsQ0FBQ0EsRUFBRXVlLEdBQUcsR0FBQyxFQUFFLEdBQUMsT0FBTXZlLENBQUMsQ0FBQ0EsRUFBRXdlLElBQUksR0FBQyxFQUFFLEdBQUMsUUFBT3hlLENBQUMsQ0FBQ0EsRUFBRXllLElBQUksR0FBQyxFQUFFLEdBQUMsUUFBT3plLENBQUMsQ0FBQ0EsRUFBRTBlLEdBQUcsR0FBQyxFQUFFLEdBQUMsT0FBTTFlLENBQUMsQ0FBQ0EsRUFBRTJlLE9BQU8sR0FBQyxFQUFFLEdBQUMsV0FBVTNlLENBQUMsQ0FBQ0EsRUFBRTRlLE9BQU8sR0FBQyxFQUFFLEdBQUMsV0FBVTVlLENBQUMsQ0FBQ0EsRUFBRTZlLEtBQUssR0FBQyxFQUFFLEdBQUMsU0FBUTdlLENBQUMsQ0FBQ0EsRUFBRThlLElBQUksR0FBQyxFQUFFLEdBQUMsUUFBTzllLENBQUMsQ0FBQ0EsRUFBRStlLElBQUksR0FBQyxFQUFFLEdBQUMsUUFBTy9lLENBQUMsQ0FBQ0EsRUFBRWdmLEtBQUssR0FBQyxHQUFHLEdBQUMsU0FBUWhmLENBQUMsQ0FBQ0EsRUFBRWlmLElBQUksR0FBQyxHQUFHLEdBQUMsUUFBT2pmLENBQUMsQ0FBQ0EsRUFBRWtmLFFBQVEsR0FBQyxHQUFHLEdBQUMsWUFBV2xmLENBQUMsQ0FBQ0EsRUFBRW1mLFNBQVMsR0FBQyxHQUFHLEdBQUMsYUFBWW5mLENBQUMsQ0FBQ0EsRUFBRW9mLE1BQU0sR0FBQyxHQUFHLEdBQUMsVUFBU3BmLENBQUMsQ0FBQ0EsRUFBRXFmLE1BQU0sR0FBQyxHQUFHLEdBQUMsVUFBU3JmLENBQUMsQ0FBQ0EsRUFBRXNmLElBQUksR0FBQyxHQUFHLEdBQUMsUUFBT3RmLENBQUMsQ0FBQ0EsRUFBRXVmLE1BQU0sR0FBQyxHQUFHLEdBQUMsVUFBU3ZmLENBQUMsQ0FBQ0EsRUFBRXdmLE1BQU0sR0FBQyxHQUFHLEdBQUMsVUFBU3hmLENBQUMsQ0FBQ0EsRUFBRXlmLEdBQUcsR0FBQyxHQUFHLEdBQUMsT0FBTXpmLENBQUMsQ0FBQ0EsRUFBRTBmLE1BQU0sR0FBQyxHQUFHLEdBQUMsVUFBUzFm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QUk7WUFBa0IsS0FBSTtZQUFLLEtBQUk7Z0JBQVMsT0FBTTtZQUFhLEtBQUk7WUFBcUIsS0FBSTtZQUFXLEtBQUk7WUFBYSxLQUFJO1lBQWEsS0FBSTtZQUFZLEtBQUk7WUFBVyxLQUFJO1lBQWEsS0FBSTtnQkFBa0IsT0FBTTtZQUFhLEtBQUk7WUFBUyxLQUFJO1lBQVcsS0FBSTtZQUFjLEtBQUk7WUFBYyxLQUFJO1lBQW1CLEtBQUk7WUFBVyxLQUFJO1lBQWEsS0FBSTtZQUFlLEtBQUk7WUFBZSxLQUFJO1lBQWEsS0FBSTtZQUFZLEtBQUk7WUFBVyxLQUFJO1lBQWEsS0FBSTtnQkFBa0IsT0FBTTtZQUFhLEtBQUk7WUFBa0IsS0FBSTtZQUFXLEtBQUk7WUFBVyxLQUFJO1lBQVEsS0FBSTtZQUFTLEtBQUk7WUFBYSxLQUFJO1lBQWEsS0FBSTtZQUFZLEtBQUk7WUFBVyxLQUFJO1lBQWEsS0FBSTtZQUFrQixLQUFJO2dCQUFlLE9BQU07WUFBYSxLQUFJO1lBQWMsS0FBSTtZQUFtQixLQUFJO1lBQVMsS0FBSTtZQUFhLEtBQUk7WUFBZSxLQUFJO1lBQWEsS0FBSTtZQUFZLEtBQUk7WUFBVyxLQUFJO1lBQWEsS0FBSTtZQUFrQixLQUFJO2dCQUFTLE9BQU07WUFBYSxLQUFJO1lBQWMsS0FBSTtZQUFlLEtBQUk7Z0JBQVUsT0FBTTtZQUFlLEtBQUk7WUFBYyxLQUFJO1lBQWMsS0FBSTtZQUFhLEtBQUk7WUFBYSxLQUFJO1lBQVksS0FBSTtZQUFLLEtBQUk7Z0JBQVMsT0FBTTtZQUFjLEtBQUk7WUFBYyxLQUFJO1lBQWEsS0FBSTtnQkFBWSxPQUFNO1lBQWMsS0FBSTtZQUFjLEtBQUk7WUFBYSxLQUFJO2dCQUFZLE9BQU07WUFBYyxLQUFJO1lBQWMsS0FBSTtZQUFjLEtBQUk7WUFBYSxLQUFJO1lBQVksS0FBSTtZQUFjLEtBQUk7Z0JBQUssT0FBTTtZQUFjLEtBQUk7Z0JBQWMsT0FBTTtZQUFjLEtBQUk7WUFBVSxLQUFJO1lBQU0sS0FBSTtZQUFPLEtBQUk7WUFBUyxLQUFJO2dCQUFTLE9BQU07WUFBUyxLQUFJO1lBQVUsS0FBSTtnQkFBUyxPQUFNO1lBQVMsS0FBSTtZQUFjLEtBQUk7WUFBTSxLQUFJO1lBQVksS0FBSTtnQkFBYyxPQUFNO1lBQVksS0FBSTtZQUFjLEtBQUk7WUFBYSxLQUFJO1lBQVksS0FBSTtZQUFVLEtBQUk7Z0JBQWMsT0FBTTtZQUFjLEtBQUk7WUFBUyxLQUFJO1lBQWUsS0FBSTtnQkFBVyxPQUFNO1lBQWUsS0FBSTtZQUFTLEtBQUk7WUFBZSxLQUFJO2dCQUFXLE9BQU07WUFBZSxLQUFJO1lBQWlCLEtBQUk7WUFBUSxLQUFJO1lBQVMsS0FBSTtZQUFRLEtBQUk7WUFBYyxLQUFJO1lBQVMsS0FBSTtZQUFhLEtBQUk7WUFBYSxLQUFJO1lBQVksS0FBSTtZQUFXLEtBQUk7WUFBYSxLQUFJO1lBQWtCLEtBQUk7WUFBSyxLQUFJO1lBQVMsS0FBSTtZQUFXLEtBQUk7WUFBZSxLQUFJO2dCQUFXLE9BQU07WUFBZSxLQUFJO1lBQVMsS0FBSTtZQUFlLEtBQUk7Z0JBQVcsT0FBTTtZQUFlLEtBQUk7WUFBUyxLQUFJO1lBQWMsS0FBSTtZQUFhLEtBQUk7WUFBYSxLQUFJO1lBQVksS0FBSTtZQUFXLEtBQUk7WUFBYSxLQUFJO1lBQWtCLEtBQUk7WUFBSyxLQUFJO1lBQVMsS0FBSTtZQUFlLEtBQUk7Z0JBQVcsT0FBTTtZQUFlLEtBQUk7WUFBUyxLQUFJO1lBQWUsS0FBSTtnQkFBVyxPQUFNO1lBQWUsS0FBSTtZQUFTLEtBQUk7WUFBZSxLQUFJO2dCQUFXLE9BQU07WUFBZSxLQUFJO1lBQVMsS0FBSTtZQUFlLEtBQUk7Z0JBQVcsT0FBTTtZQUFlLEtBQUk7WUFBUyxLQUFJO1lBQWUsS0FBSTtnQkFBVyxPQUFNO1lBQWUsS0FBSTtZQUFpQixLQUFJO2dCQUFrQixPQUFNO1lBQWlCLEtBQUk7WUFBVSxLQUFJO1lBQVcsS0FBSTtZQUFrQixLQUFJO1lBQVMsS0FBSTtZQUFVLEtBQUk7WUFBYSxLQUFJO1lBQU0sS0FBSTtZQUFZLEtBQUk7Z0JBQVEsT0FBTTtZQUFNLEtBQUk7Z0JBQVUsT0FBTTtZQUFV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QUFHNU8sQ0FBQztZQUFDMFIsUUFBTzNSLEVBQUUyUixNQUFNO1lBQUNLLE1BQUtoUyxFQUFFaVAsTUFBTSxHQUFDLENBQUMsRUFBRWpQLEVBQUVpUyxRQUFRLENBQUMsRUFBRWpTLEVBQUVpUCxNQUFNLENBQUMsQ0FBQyxHQUFDalAsRUFBRWlTLFFBQVE7WUFBQzRKLFFBQU81YixFQUFFNGIsTUFBTSxJQUFHNWIsQ0FBQUEsRUFBRWlMLElBQUksR0FBQyxRQUFNLEtBQUk7UUFBRSxHQUFFOUo7SUFBRTtBQUFDO0FBQUNkLEVBQUUwaUUsZ0JBQWUsbUJBQWtCcFUsZUFBZWdELEtBQUssRUFBQ3pJLGlCQUFpQlEsT0FBTyxFQUFDRyxrQkFBa0J1QixRQUFRLEVBQUNTLGlCQUFpQjVhLE9BQU8sRUFBQzdPLGtCQUFrQlEsUUFBUSxFQUFDdEIsY0FBY0UsSUFBSSxFQUFDdXlCLG9CQUFvQnFCLFVBQVUsRUFBQ2ptQztBQUFnQixNQUFLLEVBQUM0bkMsWUFBWSxFQUFDLEdBQUNGLHVCQUFzQixFQUFDNXNELFVBQVUsRUFBQyxHQUFDc3JEO0FBQW1CLElBQUl3QixhQUFhOXNELGFBQVlndkQsa0JBQWlCeHBDLGtCQUFpQmlxQyxpQkFBZ0JzRyxtQkFBbUJZLFNBQVMsRUFBQ21DLGVBQWVILElBQUlqbkQsT0FBTyxHQUFFb25ELGVBQWVILElBQUl6eEQsTUFBTSxHQUFFNHhELGVBQWVILElBQUl4MkIsUUFBUSxHQUFFMjJCLGVBQWVILElBQUlwZ0QsT0FBTyxHQUFFdWdELGVBQWVILElBQUk3bEQsT0FBTyxHQUFFb2xELHNCQUFxQm41QixlQUFlLEdBQUM2NUIsU0FBUTc1QixvQkFBb0IsR0FBQzg1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVvLWVkaXRvci1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudC9kaXN0L3NoYXJlZC9ub2RlLWZldGNoLW5hdGl2ZS13aXRoLWFnZW50LmRmN2U2YmQ2LmNqcz80ODlkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO3ZhciBEdD1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIEZ0PShlLEEsdCk9PkEgaW4gZT9EdChlLEEse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KTplW0FdPXQ7dmFyIG89KGUsQSk9PkR0KGUsXCJuYW1lXCIse3ZhbHVlOkEsY29uZmlndXJhYmxlOiEwfSk7dmFyIE5BPShlLEEsdCk9PihGdChlLHR5cGVvZiBBIT1cInN5bWJvbFwiP0ErXCJcIjpBLHQpLHQpLHplPShlLEEsdCk9PntpZighQS5oYXMoZSkpdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiK3QpfSx5dD0oZSxBKT0+e2lmKE9iamVjdChBKSE9PUEpdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgdXNlIHRoZSBcImluXCIgb3BlcmF0b3Igb24gdGhpcyB2YWx1ZScpO3JldHVybiBlLmhhcyhBKX0scD0oZSxBLHQpPT4oemUoZSxBLFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksdD90LmNhbGwoZSk6QS5nZXQoZSkpLENBPShlLEEsdCk9PntpZihBLmhhcyhlKSl0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO0EgaW5zdGFuY2VvZiBXZWFrU2V0P0EuYWRkKGUpOkEuc2V0KGUsdCl9LEVBPShlLEEsdCxuKT0+KHplKGUsQSxcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksbj9uLmNhbGwoZSx0KTpBLnNldChlLHQpLHQpO3ZhciBrQT0oZSxBLHQpPT4oemUoZSxBLFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpLHQpO3ZhciBuZSxzZSxvZSxpZSxRZSxFZSxnZSxCZSxDZSxJZSxhZSxjZSxoZSxsZSx1ZSxkZSxmZSxEZSx5ZSxSZSx3ZSxrZSxfQSxOZSxGZSxwZSxTZSxVZSxiZSxtZSxMZSxNZSxZZSxKZSxPZSxSdCxHZSxBZSxUZTtjb25zdCByZXF1aXJlJCQwPXJlcXVpcmUoXCJub2RlOmFzc2VydFwiKSxyZXF1aXJlJCQ0PXJlcXVpcmUoXCJub2RlOm5ldFwiKSxodHRwJDE9cmVxdWlyZShcIm5vZGU6aHR0cFwiKSxTdHJlYW09cmVxdWlyZShcIm5vZGU6c3RyZWFtXCIpLHJlcXVpcmUkJDY9cmVxdWlyZShcIm5vZGU6YnVmZmVyXCIpLHJlcXVpcmUkJDAkMT1yZXF1aXJlKFwibm9kZTp1dGlsXCIpLHJlcXVpcmUkJDg9cmVxdWlyZShcIm5vZGU6cXVlcnlzdHJpbmdcIikscmVxdWlyZSQkMCQyPXJlcXVpcmUoXCJub2RlOmRpYWdub3N0aWNzX2NoYW5uZWxcIikscmVxdWlyZSQkMCQzPXJlcXVpcmUoXCJub2RlOmV2ZW50c1wiKSxfY29tbW9uanNIZWxwZXJzPXJlcXVpcmUoXCIuL25vZGUtZmV0Y2gtbmF0aXZlLXdpdGgtYWdlbnQuNjE3NThkMTEuY2pzXCIpLHJlcXVpcmUkJDQkMT1yZXF1aXJlKFwibm9kZTp0bHNcIiksemxpYj1yZXF1aXJlKFwibm9kZTp6bGliXCIpLHJlcXVpcmUkJDU9cmVxdWlyZShcIm5vZGU6cGVyZl9ob29rc1wiKSxyZXF1aXJlJCQ4JDE9cmVxdWlyZShcIm5vZGU6dXRpbC90eXBlc1wiKSxyZXF1aXJlJCQwJDQ9cmVxdWlyZShcIm5vZGU6b3NcIikscmVxdWlyZSQkMT1yZXF1aXJlKFwibm9kZTp1cmxcIikscmVxdWlyZSQkNSQxPXJlcXVpcmUoXCJub2RlOmFzeW5jX2hvb2tzXCIpO3JlcXVpcmUoXCJub2RlOmNvbnNvbGVcIik7Y29uc3QgcmVxdWlyZSQkNSQyPXJlcXVpcmUoXCJzdHJpbmdfZGVjb2RlclwiKSxyZXF1aXJlJCQyPXJlcXVpcmUoXCJub2RlOndvcmtlcl90aHJlYWRzXCIpO2Z1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdENvbXBhdChlKXtyZXR1cm4gZSYmdHlwZW9mIGU9PVwib2JqZWN0XCImJlwiZGVmYXVsdFwiaW4gZT9lLmRlZmF1bHQ6ZX1vKF9pbnRlcm9wRGVmYXVsdENvbXBhdCxcIl9pbnRlcm9wRGVmYXVsdENvbXBhdFwiKTtjb25zdCByZXF1aXJlJCQwX19kZWZhdWx0PV9pbnRlcm9wRGVmYXVsdENvbXBhdChyZXF1aXJlJCQwKSxyZXF1aXJlJCQ0X19kZWZhdWx0PV9pbnRlcm9wRGVmYXVsdENvbXBhdChyZXF1aXJlJCQ0KSxodHRwX19kZWZhdWx0PV9pbnRlcm9wRGVmYXVsdENvbXBhdChodHRwJDEpLFN0cmVhbV9fZGVmYXVsdD1faW50ZXJvcERlZmF1bHRDb21wYXQoU3RyZWFtKSxyZXF1aXJlJCQ2X19kZWZhdWx0PV9pbnRlcm9wRGVmYXVsdENvbXBhdChyZXF1aXJlJCQ2KSxyZXF1aXJlJCQwX19kZWZhdWx0JDE9X2ludGVyb3BEZWZhdWx0Q29tcGF0KHJlcXVpcmUkJDAkMSkscmVxdWlyZSQkOF9fZGVmYXVsdD1faW50ZXJvcERlZmF1bHRDb21wYXQocmVxdWlyZSQkOCkscmVxdWlyZSQkMF9fZGVmYXVsdCQyPV9pbnRlcm9wRGVmYXVsdENvbXBhdChyZXF1aXJlJCQwJDIpLHJlcXVpcmUkJDBfX2RlZmF1bHQkMz1faW50ZXJvcERlZmF1bHRDb21wYXQocmVxdWlyZSQkMCQzKSxyZXF1aXJlJCQ0X19kZWZhdWx0JDE9X2ludGVyb3BEZWZhdWx0Q29tcGF0KHJlcXVpcmUkJDQkMSksemxpYl9fZGVmYXVsdD1faW50ZXJvcERlZmF1bHRDb21wYXQoemxpYikscmVxdWlyZSQkNV9fZGVmYXVsdD1faW50ZXJvcERlZmF1bHRDb21wYXQocmVxdWlyZSQkNSkscmVxdWlyZSQkOF9fZGVmYXVsdCQxPV9pbnRlcm9wRGVmYXVsdENvbXBhdChyZXF1aXJlJCQ4JDEpLHJlcXVpcmUkJDBfX2RlZmF1bHQkND1faW50ZXJvcERlZmF1bHRDb21wYXQocmVxdWlyZSQkMCQ0KSxyZXF1aXJlJCQxX19kZWZhdWx0PV9pbnRlcm9wRGVmYXVsdENvbXBhdChyZXF1aXJlJCQxKSxyZXF1aXJlJCQ1X19kZWZhdWx0JDE9X2ludGVyb3BEZWZhdWx0Q29tcGF0KHJlcXVpcmUkJDUkMSkscmVxdWlyZSQkNV9fZGVmYXVsdCQyPV9pbnRlcm9wRGVmYXVsdENvbXBhdChyZXF1aXJlJCQ1JDIpLHJlcXVpcmUkJDJfX2RlZmF1bHQ9X2ludGVyb3BEZWZhdWx0Q29tcGF0KHJlcXVpcmUkJDIpO3ZhciBzeW1ib2xzJDQ9e2tDbG9zZTpTeW1ib2woXCJjbG9zZVwiKSxrRGVzdHJveTpTeW1ib2woXCJkZXN0cm95XCIpLGtEaXNwYXRjaDpTeW1ib2woXCJkaXNwYXRjaFwiKSxrVXJsOlN5bWJvbChcInVybFwiKSxrV3JpdGluZzpTeW1ib2woXCJ3cml0aW5nXCIpLGtSZXN1bWluZzpTeW1ib2woXCJyZXN1bWluZ1wiKSxrUXVldWU6U3ltYm9sKFwicXVldWVcIiksa0Nvbm5lY3Q6U3ltYm9sKFwiY29ubmVjdFwiKSxrQ29ubmVjdGluZzpTeW1ib2woXCJjb25uZWN0aW5nXCIpLGtIZWFkZXJzTGlzdDpTeW1ib2woXCJoZWFkZXJzIGxpc3RcIiksa0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0OlN5bWJvbChcImRlZmF1bHQga2VlcCBhbGl2ZSB0aW1lb3V0XCIpLGtLZWVwQWxpdmVNYXhUaW1lb3V0OlN5bWJvbChcIm1heCBrZWVwIGFsaXZlIHRpbWVvdXRcIiksa0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQ6U3ltYm9sKFwia2VlcCBhbGl2ZSB0aW1lb3V0IHRocmVzaG9sZFwiKSxrS2VlcEFsaXZlVGltZW91dFZhbHVlOlN5bWJvbChcImtlZXAgYWxpdmUgdGltZW91dFwiKSxrS2VlcEFsaXZlOlN5bWJvbChcImtlZXAgYWxpdmVcIiksa0hlYWRlcnNUaW1lb3V0OlN5bWJvbChcImhlYWRlcnMgdGltZW91dFwiKSxrQm9keVRpbWVvdXQ6U3ltYm9sKFwiYm9keSB0aW1lb3V0XCIpLGtTZXJ2ZXJOYW1lOlN5bWJvbChcInNlcnZlciBuYW1lXCIpLGtMb2NhbEFkZHJlc3M6U3ltYm9sKFwibG9jYWwgYWRkcmVzc1wiKSxrSG9zdDpTeW1ib2woXCJob3N0XCIpLGtOb1JlZjpTeW1ib2woXCJubyByZWZcIiksa0JvZHlVc2VkOlN5bWJvbChcInVzZWRcIiksa1J1bm5pbmc6U3ltYm9sKFwicnVubmluZ1wiKSxrQmxvY2tpbmc6U3ltYm9sKFwiYmxvY2tpbmdcIiksa1BlbmRpbmc6U3ltYm9sKFwicGVuZGluZ1wiKSxrU2l6ZTpTeW1ib2woXCJzaXplXCIpLGtCdXN5OlN5bWJvbChcImJ1c3lcIiksa1F1ZXVlZDpTeW1ib2woXCJxdWV1ZWRcIiksa0ZyZWU6U3ltYm9sKFwiZnJlZVwiKSxrQ29ubmVjdGVkOlN5bWJvbChcImNvbm5lY3RlZFwiKSxrQ2xvc2VkOlN5bWJvbChcImNsb3NlZFwiKSxrTmVlZERyYWluOlN5bWJvbChcIm5lZWQgZHJhaW5cIiksa1Jlc2V0OlN5bWJvbChcInJlc2V0XCIpLGtEZXN0cm95ZWQ6U3ltYm9sLmZvcihcIm5vZGVqcy5zdHJlYW0uZGVzdHJveWVkXCIpLGtSZXN1bWU6U3ltYm9sKFwicmVzdW1lXCIpLGtPbkVycm9yOlN5bWJvbChcIm9uIGVycm9yXCIpLGtNYXhIZWFkZXJzU2l6ZTpTeW1ib2woXCJtYXggaGVhZGVycyBzaXplXCIpLGtSdW5uaW5nSWR4OlN5bWJvbChcInJ1bm5pbmcgaW5kZXhcIiksa1BlbmRpbmdJZHg6U3ltYm9sKFwicGVuZGluZyBpbmRleFwiKSxrRXJyb3I6U3ltYm9sKFwiZXJyb3JcIiksa0NsaWVudHM6U3ltYm9sKFwiY2xpZW50c1wiKSxrQ2xpZW50OlN5bWJvbChcImNsaWVudFwiKSxrUGFyc2VyOlN5bWJvbChcInBhcnNlclwiKSxrT25EZXN0cm95ZWQ6U3ltYm9sKFwiZGVzdHJveSBjYWxsYmFja3NcIiksa1BpcGVsaW5pbmc6U3ltYm9sKFwicGlwZWxpbmluZ1wiKSxrU29ja2V0OlN5bWJvbChcInNvY2tldFwiKSxrSG9zdEhlYWRlcjpTeW1ib2woXCJob3N0IGhlYWRlclwiKSxrQ29ubmVjdG9yOlN5bWJvbChcImNvbm5lY3RvclwiKSxrU3RyaWN0Q29udGVudExlbmd0aDpTeW1ib2woXCJzdHJpY3QgY29udGVudCBsZW5ndGhcIiksa01heFJlZGlyZWN0aW9uczpTeW1ib2woXCJtYXhSZWRpcmVjdGlvbnNcIiksa01heFJlcXVlc3RzOlN5bWJvbChcIm1heFJlcXVlc3RzUGVyQ2xpZW50XCIpLGtQcm94eTpTeW1ib2woXCJwcm94eSBhZ2VudCBvcHRpb25zXCIpLGtDb3VudGVyOlN5bWJvbChcInNvY2tldCByZXF1ZXN0IGNvdW50ZXJcIiksa0ludGVyY2VwdG9yczpTeW1ib2woXCJkaXNwYXRjaCBpbnRlcmNlcHRvcnNcIiksa01heFJlc3BvbnNlU2l6ZTpTeW1ib2woXCJtYXggcmVzcG9uc2Ugc2l6ZVwiKSxrSFRUUDJTZXNzaW9uOlN5bWJvbChcImh0dHAyU2Vzc2lvblwiKSxrSFRUUDJTZXNzaW9uU3RhdGU6U3ltYm9sKFwiaHR0cDJTZXNzaW9uIHN0YXRlXCIpLGtSZXRyeUhhbmRsZXJEZWZhdWx0UmV0cnk6U3ltYm9sKFwicmV0cnkgYWdlbnQgZGVmYXVsdCByZXRyeVwiKSxrQ29uc3RydWN0OlN5bWJvbChcImNvbnN0cnVjdGFibGVcIiksa0xpc3RlbmVyczpTeW1ib2woXCJsaXN0ZW5lcnNcIiksa0hUVFBDb250ZXh0OlN5bWJvbChcImh0dHAgY29udGV4dFwiKSxrTWF4Q29uY3VycmVudFN0cmVhbXM6U3ltYm9sKFwibWF4IGNvbmN1cnJlbnQgc3RyZWFtc1wiKX07bGV0IFVuZGljaUVycm9yJDE9KG5lPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoQSl7c3VwZXIoQSksdGhpcy5uYW1lPVwiVW5kaWNpRXJyb3JcIix0aGlzLmNvZGU9XCJVTkRfRVJSXCJ9fSxvKG5lLFwiVW5kaWNpRXJyb3JcIiksbmUpLENvbm5lY3RUaW1lb3V0RXJyb3IkMT0oc2U9Y2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciQxe2NvbnN0cnVjdG9yKEEpe3N1cGVyKEEpLHRoaXMubmFtZT1cIkNvbm5lY3RUaW1lb3V0RXJyb3JcIix0aGlzLm1lc3NhZ2U9QXx8XCJDb25uZWN0IFRpbWVvdXQgRXJyb3JcIix0aGlzLmNvZGU9XCJVTkRfRVJSX0NPTk5FQ1RfVElNRU9VVFwifX0sbyhzZSxcIkNvbm5lY3RUaW1lb3V0RXJyb3JcIiksc2UpLEhlYWRlcnNUaW1lb3V0RXJyb3IkMT0ob2U9Y2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciQxe2NvbnN0cnVjdG9yKEEpe3N1cGVyKEEpLHRoaXMubmFtZT1cIkhlYWRlcnNUaW1lb3V0RXJyb3JcIix0aGlzLm1lc3NhZ2U9QXx8XCJIZWFkZXJzIFRpbWVvdXQgRXJyb3JcIix0aGlzLmNvZGU9XCJVTkRfRVJSX0hFQURFUlNfVElNRU9VVFwifX0sbyhvZSxcIkhlYWRlcnNUaW1lb3V0RXJyb3JcIiksb2UpLEhlYWRlcnNPdmVyZmxvd0Vycm9yJDE9KGllPWNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3IkMXtjb25zdHJ1Y3RvcihBKXtzdXBlcihBKSx0aGlzLm5hbWU9XCJIZWFkZXJzT3ZlcmZsb3dFcnJvclwiLHRoaXMubWVzc2FnZT1BfHxcIkhlYWRlcnMgT3ZlcmZsb3cgRXJyb3JcIix0aGlzLmNvZGU9XCJVTkRfRVJSX0hFQURFUlNfT1ZFUkZMT1dcIn19LG8oaWUsXCJIZWFkZXJzT3ZlcmZsb3dFcnJvclwiKSxpZSksQm9keVRpbWVvdXRFcnJvciQxPShRZT1jbGFzcyBleHRlbmRzIFVuZGljaUVycm9yJDF7Y29uc3RydWN0b3IoQSl7c3VwZXIoQSksdGhpcy5uYW1lPVwiQm9keVRpbWVvdXRFcnJvclwiLHRoaXMubWVzc2FnZT1BfHxcIkJvZHkgVGltZW91dCBFcnJvclwiLHRoaXMuY29kZT1cIlVORF9FUlJfQk9EWV9USU1FT1VUXCJ9fSxvKFFlLFwiQm9keVRpbWVvdXRFcnJvclwiKSxRZSksUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IkMT0oRWU9Y2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciQxe2NvbnN0cnVjdG9yKEEsdCxuLHIpe3N1cGVyKEEpLHRoaXMubmFtZT1cIlJlc3BvbnNlU3RhdHVzQ29kZUVycm9yXCIsdGhpcy5tZXNzYWdlPUF8fFwiUmVzcG9uc2UgU3RhdHVzIENvZGUgRXJyb3JcIix0aGlzLmNvZGU9XCJVTkRfRVJSX1JFU1BPTlNFX1NUQVRVU19DT0RFXCIsdGhpcy5ib2R5PXIsdGhpcy5zdGF0dXM9dCx0aGlzLnN0YXR1c0NvZGU9dCx0aGlzLmhlYWRlcnM9bn19LG8oRWUsXCJSZXNwb25zZVN0YXR1c0NvZGVFcnJvclwiKSxFZSksSW52YWxpZEFyZ3VtZW50RXJyb3Ikaz0oZ2U9Y2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciQxe2NvbnN0cnVjdG9yKEEpe3N1cGVyKEEpLHRoaXMubmFtZT1cIkludmFsaWRBcmd1bWVudEVycm9yXCIsdGhpcy5tZXNzYWdlPUF8fFwiSW52YWxpZCBBcmd1bWVudCBFcnJvclwiLHRoaXMuY29kZT1cIlVORF9FUlJfSU5WQUxJRF9BUkdcIn19LG8oZ2UsXCJJbnZhbGlkQXJndW1lbnRFcnJvclwiKSxnZSksSW52YWxpZFJldHVyblZhbHVlRXJyb3IkMj0oQmU9Y2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciQxe2NvbnN0cnVjdG9yKEEpe3N1cGVyKEEpLHRoaXMubmFtZT1cIkludmFsaWRSZXR1cm5WYWx1ZUVycm9yXCIsdGhpcy5tZXNzYWdlPUF8fFwiSW52YWxpZCBSZXR1cm4gVmFsdWUgRXJyb3JcIix0aGlzLmNvZGU9XCJVTkRfRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFXCJ9fSxvKEJlLFwiSW52YWxpZFJldHVyblZhbHVlRXJyb3JcIiksQmUpLEFib3J0RXJyb3IkMT0oQ2U9Y2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciQxe2NvbnN0cnVjdG9yKEEpe3N1cGVyKEEpLHRoaXMubmFtZT1cIkFib3J0RXJyb3JcIix0aGlzLm1lc3NhZ2U9QXx8XCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkXCJ9fSxvKENlLFwiQWJvcnRFcnJvclwiKSxDZSksUmVxdWVzdEFib3J0ZWRFcnJvciQ2PShJZT1jbGFzcyBleHRlbmRzIEFib3J0RXJyb3IkMXtjb25zdHJ1Y3RvcihBKXtzdXBlcihBKSx0aGlzLm5hbWU9XCJBYm9ydEVycm9yXCIsdGhpcy5tZXNzYWdlPUF8fFwiUmVxdWVzdCBhYm9ydGVkXCIsdGhpcy5jb2RlPVwiVU5EX0VSUl9BQk9SVEVEXCJ9fSxvKEllLFwiUmVxdWVzdEFib3J0ZWRFcnJvclwiKSxJZSksSW5mb3JtYXRpb25hbEVycm9yJDM9KGFlPWNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3IkMXtjb25zdHJ1Y3RvcihBKXtzdXBlcihBKSx0aGlzLm5hbWU9XCJJbmZvcm1hdGlvbmFsRXJyb3JcIix0aGlzLm1lc3NhZ2U9QXx8XCJSZXF1ZXN0IGluZm9ybWF0aW9uXCIsdGhpcy5jb2RlPVwiVU5EX0VSUl9JTkZPXCJ9fSxvKGFlLFwiSW5mb3JtYXRpb25hbEVycm9yXCIpLGFlKSxSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IkMj0oY2U9Y2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciQxe2NvbnN0cnVjdG9yKEEpe3N1cGVyKEEpLHRoaXMubmFtZT1cIlJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvclwiLHRoaXMubWVzc2FnZT1BfHxcIlJlcXVlc3QgYm9keSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggY29udGVudC1sZW5ndGggaGVhZGVyXCIsdGhpcy5jb2RlPVwiVU5EX0VSUl9SRVFfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0hcIn19LG8oY2UsXCJSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3JcIiksY2UpLFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IkMT0oaGU9Y2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciQxe2NvbnN0cnVjdG9yKEEpe3N1cGVyKEEpLHRoaXMubmFtZT1cIlJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3JcIix0aGlzLm1lc3NhZ2U9QXx8XCJSZXNwb25zZSBib2R5IGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBjb250ZW50LWxlbmd0aCBoZWFkZXJcIix0aGlzLmNvZGU9XCJVTkRfRVJSX1JFU19DT05URU5UX0xFTkdUSF9NSVNNQVRDSFwifX0sbyhoZSxcIlJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3JcIiksaGUpLENsaWVudERlc3Ryb3llZEVycm9yJDI9KGxlPWNsYXNzIGV4dGVuZHMgVW5kaWNpRXJyb3IkMXtjb25zdHJ1Y3RvcihBKXtzdXBlcihBKSx0aGlzLm5hbWU9XCJDbGllbnREZXN0cm95ZWRFcnJvclwiLHRoaXMubWVzc2FnZT1BfHxcIlRoZSBjbGllbnQgaXMgZGVzdHJveWVkXCIsdGhpcy5jb2RlPVwiVU5EX0VSUl9ERVNUUk9ZRURcIn19LG8obGUsXCJDbGllbnREZXN0cm95ZWRFcnJvclwiKSxsZSksQ2xpZW50Q2xvc2VkRXJyb3IkMT0odWU9Y2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciQxe2NvbnN0cnVjdG9yKEEpe3N1cGVyKEEpLHRoaXMubmFtZT1cIkNsaWVudENsb3NlZEVycm9yXCIsdGhpcy5tZXNzYWdlPUF8fFwiVGhlIGNsaWVudCBpcyBjbG9zZWRcIix0aGlzLmNvZGU9XCJVTkRfRVJSX0NMT1NFRFwifX0sbyh1ZSxcIkNsaWVudENsb3NlZEVycm9yXCIpLHVlKSxTb2NrZXRFcnJvciQ0PShkZT1jbGFzcyBleHRlbmRzIFVuZGljaUVycm9yJDF7Y29uc3RydWN0b3IoQSx0KXtzdXBlcihBKSx0aGlzLm5hbWU9XCJTb2NrZXRFcnJvclwiLHRoaXMubWVzc2FnZT1BfHxcIlNvY2tldCBlcnJvclwiLHRoaXMuY29kZT1cIlVORF9FUlJfU09DS0VUXCIsdGhpcy5zb2NrZXQ9dH19LG8oZGUsXCJTb2NrZXRFcnJvclwiKSxkZSksTm90U3VwcG9ydGVkRXJyb3IkMj0oZmU9Y2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciQxe2NvbnN0cnVjdG9yKEEpe3N1cGVyKEEpLHRoaXMubmFtZT1cIk5vdFN1cHBvcnRlZEVycm9yXCIsdGhpcy5tZXNzYWdlPUF8fFwiTm90IHN1cHBvcnRlZCBlcnJvclwiLHRoaXMuY29kZT1cIlVORF9FUlJfTk9UX1NVUFBPUlRFRFwifX0sbyhmZSxcIk5vdFN1cHBvcnRlZEVycm9yXCIpLGZlKTtjb25zdCBBdD1jbGFzcyBBdCBleHRlbmRzIFVuZGljaUVycm9yJDF7Y29uc3RydWN0b3IoQSl7c3VwZXIoQSksdGhpcy5uYW1lPVwiTWlzc2luZ1Vwc3RyZWFtRXJyb3JcIix0aGlzLm1lc3NhZ2U9QXx8XCJObyB1cHN0cmVhbSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgQmFsYW5jZWRQb29sXCIsdGhpcy5jb2RlPVwiVU5EX0VSUl9CUExfTUlTU0lOR19VUFNUUkVBTVwifX07byhBdCxcIkJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yXCIpO2xldCBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvcj1BdCxIVFRQUGFyc2VyRXJyb3IkMT0oRGU9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihBLHQsbil7c3VwZXIoQSksdGhpcy5uYW1lPVwiSFRUUFBhcnNlckVycm9yXCIsdGhpcy5jb2RlPXQ/YEhQRV8ke3R9YDp2b2lkIDAsdGhpcy5kYXRhPW4/bi50b1N0cmluZygpOnZvaWQgMH19LG8oRGUsXCJIVFRQUGFyc2VyRXJyb3JcIiksRGUpLFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IkMT0oeWU9Y2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciQxe2NvbnN0cnVjdG9yKEEpe3N1cGVyKEEpLHRoaXMubmFtZT1cIlJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3JcIix0aGlzLm1lc3NhZ2U9QXx8XCJSZXNwb25zZSBjb250ZW50IGV4Y2VlZGVkIG1heCBzaXplXCIsdGhpcy5jb2RlPVwiVU5EX0VSUl9SRVNfRVhDRUVERURfTUFYX1NJWkVcIn19LG8oeWUsXCJSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yXCIpLHllKTtjb25zdCBldD1jbGFzcyBldCBleHRlbmRzIFVuZGljaUVycm9yJDF7Y29uc3RydWN0b3IoQSx0LHtoZWFkZXJzOm4sZGF0YTpyfSl7c3VwZXIoQSksdGhpcy5uYW1lPVwiUmVxdWVzdFJldHJ5RXJyb3JcIix0aGlzLm1lc3NhZ2U9QXx8XCJSZXF1ZXN0IHJldHJ5IGVycm9yXCIsdGhpcy5jb2RlPVwiVU5EX0VSUl9SRVFfUkVUUllcIix0aGlzLnN0YXR1c0NvZGU9dCx0aGlzLmRhdGE9cix0aGlzLmhlYWRlcnM9bn19O28oZXQsXCJSZXF1ZXN0UmV0cnlFcnJvclwiKTtsZXQgUmVxdWVzdFJldHJ5RXJyb3I9ZXQsU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3IkMT0oUmU9Y2xhc3MgZXh0ZW5kcyBVbmRpY2lFcnJvciQxe2NvbnN0cnVjdG9yKEEsdCxuKXtzdXBlcih0LHtjYXVzZTpBLC4uLm4/P3t9fSksdGhpcy5uYW1lPVwiU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3JcIix0aGlzLm1lc3NhZ2U9dHx8XCJTZWN1cmUgUHJveHkgQ29ubmVjdGlvbiBmYWlsZWRcIix0aGlzLmNvZGU9XCJVTkRfRVJSX1BSWF9UTFNcIix0aGlzLmNhdXNlPUF9fSxvKFJlLFwiU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3JcIiksUmUpO3ZhciBlcnJvcnMkMT17QWJvcnRFcnJvcjpBYm9ydEVycm9yJDEsSFRUUFBhcnNlckVycm9yOkhUVFBQYXJzZXJFcnJvciQxLFVuZGljaUVycm9yOlVuZGljaUVycm9yJDEsSGVhZGVyc1RpbWVvdXRFcnJvcjpIZWFkZXJzVGltZW91dEVycm9yJDEsSGVhZGVyc092ZXJmbG93RXJyb3I6SGVhZGVyc092ZXJmbG93RXJyb3IkMSxCb2R5VGltZW91dEVycm9yOkJvZHlUaW1lb3V0RXJyb3IkMSxSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3I6UmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJDIsQ29ubmVjdFRpbWVvdXRFcnJvcjpDb25uZWN0VGltZW91dEVycm9yJDEsUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3I6UmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IkMSxJbnZhbGlkQXJndW1lbnRFcnJvcjpJbnZhbGlkQXJndW1lbnRFcnJvciRrLEludmFsaWRSZXR1cm5WYWx1ZUVycm9yOkludmFsaWRSZXR1cm5WYWx1ZUVycm9yJDIsUmVxdWVzdEFib3J0ZWRFcnJvcjpSZXF1ZXN0QWJvcnRlZEVycm9yJDYsQ2xpZW50RGVzdHJveWVkRXJyb3I6Q2xpZW50RGVzdHJveWVkRXJyb3IkMixDbGllbnRDbG9zZWRFcnJvcjpDbGllbnRDbG9zZWRFcnJvciQxLEluZm9ybWF0aW9uYWxFcnJvcjpJbmZvcm1hdGlvbmFsRXJyb3IkMyxTb2NrZXRFcnJvcjpTb2NrZXRFcnJvciQ0LE5vdFN1cHBvcnRlZEVycm9yOk5vdFN1cHBvcnRlZEVycm9yJDIsUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcjpSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJDEsQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcjpSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yJDEsUmVxdWVzdFJldHJ5RXJyb3IsU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3I6U2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3IkMX07Y29uc3QgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQkMz17fSx3ZWxsa25vd25IZWFkZXJOYW1lcyQxPVtcIkFjY2VwdFwiLFwiQWNjZXB0LUVuY29kaW5nXCIsXCJBY2NlcHQtTGFuZ3VhZ2VcIixcIkFjY2VwdC1SYW5nZXNcIixcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCIsXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzXCIsXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzXCIsXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIixcIkFjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzXCIsXCJBY2Nlc3MtQ29udHJvbC1NYXgtQWdlXCIsXCJBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnNcIixcIkFjY2Vzcy1Db250cm9sLVJlcXVlc3QtTWV0aG9kXCIsXCJBZ2VcIixcIkFsbG93XCIsXCJBbHQtU3ZjXCIsXCJBbHQtVXNlZFwiLFwiQXV0aG9yaXphdGlvblwiLFwiQ2FjaGUtQ29udHJvbFwiLFwiQ2xlYXItU2l0ZS1EYXRhXCIsXCJDb25uZWN0aW9uXCIsXCJDb250ZW50LURpc3Bvc2l0aW9uXCIsXCJDb250ZW50LUVuY29kaW5nXCIsXCJDb250ZW50LUxhbmd1YWdlXCIsXCJDb250ZW50LUxlbmd0aFwiLFwiQ29udGVudC1Mb2NhdGlvblwiLFwiQ29udGVudC1SYW5nZVwiLFwiQ29udGVudC1TZWN1cml0eS1Qb2xpY3lcIixcIkNvbnRlbnQtU2VjdXJpdHktUG9saWN5LVJlcG9ydC1Pbmx5XCIsXCJDb250ZW50LVR5cGVcIixcIkNvb2tpZVwiLFwiQ3Jvc3MtT3JpZ2luLUVtYmVkZGVyLVBvbGljeVwiLFwiQ3Jvc3MtT3JpZ2luLU9wZW5lci1Qb2xpY3lcIixcIkNyb3NzLU9yaWdpbi1SZXNvdXJjZS1Qb2xpY3lcIixcIkRhdGVcIixcIkRldmljZS1NZW1vcnlcIixcIkRvd25saW5rXCIsXCJFQ1RcIixcIkVUYWdcIixcIkV4cGVjdFwiLFwiRXhwZWN0LUNUXCIsXCJFeHBpcmVzXCIsXCJGb3J3YXJkZWRcIixcIkZyb21cIixcIkhvc3RcIixcIklmLU1hdGNoXCIsXCJJZi1Nb2RpZmllZC1TaW5jZVwiLFwiSWYtTm9uZS1NYXRjaFwiLFwiSWYtUmFuZ2VcIixcIklmLVVubW9kaWZpZWQtU2luY2VcIixcIktlZXAtQWxpdmVcIixcIkxhc3QtTW9kaWZpZWRcIixcIkxpbmtcIixcIkxvY2F0aW9uXCIsXCJNYXgtRm9yd2FyZHNcIixcIk9yaWdpblwiLFwiUGVybWlzc2lvbnMtUG9saWN5XCIsXCJQcmFnbWFcIixcIlByb3h5LUF1dGhlbnRpY2F0ZVwiLFwiUHJveHktQXV0aG9yaXphdGlvblwiLFwiUlRUXCIsXCJSYW5nZVwiLFwiUmVmZXJlclwiLFwiUmVmZXJyZXItUG9saWN5XCIsXCJSZWZyZXNoXCIsXCJSZXRyeS1BZnRlclwiLFwiU2VjLVdlYlNvY2tldC1BY2NlcHRcIixcIlNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc1wiLFwiU2VjLVdlYlNvY2tldC1LZXlcIixcIlNlYy1XZWJTb2NrZXQtUHJvdG9jb2xcIixcIlNlYy1XZWJTb2NrZXQtVmVyc2lvblwiLFwiU2VydmVyXCIsXCJTZXJ2ZXItVGltaW5nXCIsXCJTZXJ2aWNlLVdvcmtlci1BbGxvd2VkXCIsXCJTZXJ2aWNlLVdvcmtlci1OYXZpZ2F0aW9uLVByZWxvYWRcIixcIlNldC1Db29raWVcIixcIlNvdXJjZU1hcFwiLFwiU3RyaWN0LVRyYW5zcG9ydC1TZWN1cml0eVwiLFwiU3VwcG9ydHMtTG9hZGluZy1Nb2RlXCIsXCJURVwiLFwiVGltaW5nLUFsbG93LU9yaWdpblwiLFwiVHJhaWxlclwiLFwiVHJhbnNmZXItRW5jb2RpbmdcIixcIlVwZ3JhZGVcIixcIlVwZ3JhZGUtSW5zZWN1cmUtUmVxdWVzdHNcIixcIlVzZXItQWdlbnRcIixcIlZhcnlcIixcIlZpYVwiLFwiV1dXLUF1dGhlbnRpY2F0ZVwiLFwiWC1Db250ZW50LVR5cGUtT3B0aW9uc1wiLFwiWC1ETlMtUHJlZmV0Y2gtQ29udHJvbFwiLFwiWC1GcmFtZS1PcHRpb25zXCIsXCJYLVBlcm1pdHRlZC1Dcm9zcy1Eb21haW4tUG9saWNpZXNcIixcIlgtUG93ZXJlZC1CeVwiLFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLFwiWC1YU1MtUHJvdGVjdGlvblwiXTtmb3IobGV0IGU9MDtlPHdlbGxrbm93bkhlYWRlck5hbWVzJDEubGVuZ3RoOysrZSl7Y29uc3QgQT13ZWxsa25vd25IZWFkZXJOYW1lcyQxW2VdLHQ9QS50b0xvd2VyQ2FzZSgpO2hlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkJDNbQV09aGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQkM1t0XT10fU9iamVjdC5zZXRQcm90b3R5cGVPZihoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCQzLG51bGwpO3ZhciBjb25zdGFudHMkNT17d2VsbGtub3duSGVhZGVyTmFtZXM6d2VsbGtub3duSGVhZGVyTmFtZXMkMSxoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZDpoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCQzfTtjb25zdHt3ZWxsa25vd25IZWFkZXJOYW1lcyxoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZDpoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCQyfT1jb25zdGFudHMkNSx4QT1jbGFzcyB4QXtjb25zdHJ1Y3RvcihBLHQsbil7TkEodGhpcyxcInZhbHVlXCIsbnVsbCk7TkEodGhpcyxcImxlZnRcIixudWxsKTtOQSh0aGlzLFwibWlkZGxlXCIsbnVsbCk7TkEodGhpcyxcInJpZ2h0XCIsbnVsbCk7TkEodGhpcyxcImNvZGVcIik7aWYobj09PXZvaWQgMHx8bj49QS5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVucmVhY2hhYmxlXCIpO2lmKCh0aGlzLmNvZGU9QS5jaGFyQ29kZUF0KG4pKT4xMjcpdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleSBtdXN0IGJlIGFzY2lpIHN0cmluZ1wiKTtBLmxlbmd0aCE9PSsrbj90aGlzLm1pZGRsZT1uZXcgeEEoQSx0LG4pOnRoaXMudmFsdWU9dH1hZGQoQSx0KXtjb25zdCBuPUEubGVuZ3RoO2lmKG49PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtsZXQgcj0wLHM9dGhpcztmb3IoOzspe2NvbnN0IGk9QS5jaGFyQ29kZUF0KHIpO2lmKGk+MTI3KXRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXkgbXVzdCBiZSBhc2NpaSBzdHJpbmdcIik7aWYocy5jb2RlPT09aSlpZihuPT09KytyKXtzLnZhbHVlPXQ7YnJlYWt9ZWxzZSBpZihzLm1pZGRsZSE9PW51bGwpcz1zLm1pZGRsZTtlbHNle3MubWlkZGxlPW5ldyB4QShBLHQscik7YnJlYWt9ZWxzZSBpZihzLmNvZGU8aSlpZihzLmxlZnQhPT1udWxsKXM9cy5sZWZ0O2Vsc2V7cy5sZWZ0PW5ldyB4QShBLHQscik7YnJlYWt9ZWxzZSBpZihzLnJpZ2h0IT09bnVsbClzPXMucmlnaHQ7ZWxzZXtzLnJpZ2h0PW5ldyB4QShBLHQscik7YnJlYWt9fX1zZWFyY2goQSl7Y29uc3QgdD1BLmxlbmd0aDtsZXQgbj0wLHI9dGhpcztmb3IoO3IhPT1udWxsJiZuPHQ7KXtsZXQgcz1BW25dO2ZvcihzPD05MCYmcz49NjUmJihzfD0zMik7ciE9PW51bGw7KXtpZihzPT09ci5jb2RlKXtpZih0PT09KytuKXJldHVybiByO3I9ci5taWRkbGU7YnJlYWt9cj1yLmNvZGU8cz9yLmxlZnQ6ci5yaWdodH19cmV0dXJuIG51bGx9fTtvKHhBLFwiVHN0Tm9kZVwiKTtsZXQgVHN0Tm9kZT14QTtjb25zdCB0dD1jbGFzcyB0dHtjb25zdHJ1Y3Rvcigpe05BKHRoaXMsXCJub2RlXCIsbnVsbCl9aW5zZXJ0KEEsdCl7dGhpcy5ub2RlPT09bnVsbD90aGlzLm5vZGU9bmV3IFRzdE5vZGUoQSx0LDApOnRoaXMubm9kZS5hZGQoQSx0KX1sb29rdXAoQSl7cmV0dXJuIHRoaXMubm9kZT8uc2VhcmNoKEEpPy52YWx1ZT8/bnVsbH19O28odHQsXCJUZXJuYXJ5U2VhcmNoVHJlZVwiKTtsZXQgVGVybmFyeVNlYXJjaFRyZWU9dHQ7Y29uc3QgdHJlZSQxPW5ldyBUZXJuYXJ5U2VhcmNoVHJlZTtmb3IobGV0IGU9MDtlPHdlbGxrbm93bkhlYWRlck5hbWVzLmxlbmd0aDsrK2Upe2NvbnN0IEE9aGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQkMlt3ZWxsa25vd25IZWFkZXJOYW1lc1tlXV07dHJlZSQxLmluc2VydChBLEEpfXZhciB0cmVlXzE9e1Rlcm5hcnlTZWFyY2hUcmVlLHRyZWU6dHJlZSQxfTtjb25zdCBhc3NlcnQkZD1yZXF1aXJlJCQwX19kZWZhdWx0LHtrRGVzdHJveWVkOmtEZXN0cm95ZWQkMSxrQm9keVVzZWQ6a0JvZHlVc2VkJDEsa0xpc3RlbmVyc309c3ltYm9scyQ0LHtJbmNvbWluZ01lc3NhZ2V9PWh0dHBfX2RlZmF1bHQsc3RyZWFtJDE9U3RyZWFtX19kZWZhdWx0LG5ldCQyPXJlcXVpcmUkJDRfX2RlZmF1bHQse0ludmFsaWRBcmd1bWVudEVycm9yOkludmFsaWRBcmd1bWVudEVycm9yJGp9PWVycm9ycyQxLHtCbG9iOkJsb2IkMX09cmVxdWlyZSQkNl9fZGVmYXVsdCxub2RlVXRpbD1yZXF1aXJlJCQwX19kZWZhdWx0JDEse3N0cmluZ2lmeX09cmVxdWlyZSQkOF9fZGVmYXVsdCx7aGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQ6aGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQkMX09Y29uc3RhbnRzJDUse3RyZWV9PXRyZWVfMSxbbm9kZU1ham9yLG5vZGVNaW5vcl09cHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KFwiLlwiKS5tYXAoZT0+TnVtYmVyKGUpKTtmdW5jdGlvbiBub3AoKXt9byhub3AsXCJub3BcIik7ZnVuY3Rpb24gaXNTdHJlYW0kMShlKXtyZXR1cm4gZSYmdHlwZW9mIGU9PVwib2JqZWN0XCImJnR5cGVvZiBlLnBpcGU9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGUub249PVwiZnVuY3Rpb25cIn1vKGlzU3RyZWFtJDEsXCJpc1N0cmVhbSQxXCIpO2Z1bmN0aW9uIGlzQmxvYkxpa2UkMShlKXtpZihlPT09bnVsbClyZXR1cm4hMTtpZihlIGluc3RhbmNlb2YgQmxvYiQxKXJldHVybiEwO2lmKHR5cGVvZiBlIT1cIm9iamVjdFwiKXJldHVybiExO3tjb25zdCBBPWVbU3ltYm9sLnRvU3RyaW5nVGFnXTtyZXR1cm4oQT09PVwiQmxvYlwifHxBPT09XCJGaWxlXCIpJiYoXCJzdHJlYW1cImluIGUmJnR5cGVvZiBlLnN0cmVhbT09XCJmdW5jdGlvblwifHxcImFycmF5QnVmZmVyXCJpbiBlJiZ0eXBlb2YgZS5hcnJheUJ1ZmZlcj09XCJmdW5jdGlvblwiKX19byhpc0Jsb2JMaWtlJDEsXCJpc0Jsb2JMaWtlJDFcIik7ZnVuY3Rpb24gYnVpbGRVUkwkMyhlLEEpe2lmKGUuaW5jbHVkZXMoXCI/XCIpfHxlLmluY2x1ZGVzKFwiI1wiKSl0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5IHBhcmFtcyBjYW5ub3QgYmUgcGFzc2VkIHdoZW4gdXJsIGFscmVhZHkgY29udGFpbnMgXCI/XCIgb3IgXCIjXCIuJyk7Y29uc3QgdD1zdHJpbmdpZnkoQSk7cmV0dXJuIHQmJihlKz1cIj9cIit0KSxlfW8oYnVpbGRVUkwkMyxcImJ1aWxkVVJMJDNcIik7ZnVuY3Rpb24gcGFyc2VVUkwoZSl7aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpe2lmKGU9bmV3IFVSTChlKSwhL15odHRwcz86Ly50ZXN0KGUub3JpZ2lufHxlLnByb3RvY29sKSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaihcIkludmFsaWQgVVJMIHByb3RvY29sOiB0aGUgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLlwiKTtyZXR1cm4gZX1pZighZXx8dHlwZW9mIGUhPVwib2JqZWN0XCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGooXCJJbnZhbGlkIFVSTDogVGhlIFVSTCBhcmd1bWVudCBtdXN0IGJlIGEgbm9uLW51bGwgb2JqZWN0LlwiKTtpZighL15odHRwcz86Ly50ZXN0KGUub3JpZ2lufHxlLnByb3RvY29sKSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaihcIkludmFsaWQgVVJMIHByb3RvY29sOiB0aGUgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLlwiKTtpZighKGUgaW5zdGFuY2VvZiBVUkwpKXtpZihlLnBvcnQhPW51bGwmJmUucG9ydCE9PVwiXCImJiFOdW1iZXIuaXNGaW5pdGUocGFyc2VJbnQoZS5wb3J0KSkpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGooXCJJbnZhbGlkIFVSTDogcG9ydCBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciBvciBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlwiKTtpZihlLnBhdGghPW51bGwmJnR5cGVvZiBlLnBhdGghPVwic3RyaW5nXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGooXCJJbnZhbGlkIFVSTCBwYXRoOiB0aGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwvdW5kZWZpbmVkLlwiKTtpZihlLnBhdGhuYW1lIT1udWxsJiZ0eXBlb2YgZS5wYXRobmFtZSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaihcIkludmFsaWQgVVJMIHBhdGhuYW1lOiB0aGUgcGF0aG5hbWUgbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC5cIik7aWYoZS5ob3N0bmFtZSE9bnVsbCYmdHlwZW9mIGUuaG9zdG5hbWUhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGooXCJJbnZhbGlkIFVSTCBob3N0bmFtZTogdGhlIGhvc3RuYW1lIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuXCIpO2lmKGUub3JpZ2luIT1udWxsJiZ0eXBlb2YgZS5vcmlnaW4hPVwic3RyaW5nXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGooXCJJbnZhbGlkIFVSTCBvcmlnaW46IHRoZSBvcmlnaW4gbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC5cIik7Y29uc3QgQT1lLnBvcnQhPW51bGw/ZS5wb3J0OmUucHJvdG9jb2w9PT1cImh0dHBzOlwiPzQ0Mzo4MDtsZXQgdD1lLm9yaWdpbiE9bnVsbD9lLm9yaWdpbjpgJHtlLnByb3RvY29sfS8vJHtlLmhvc3RuYW1lfToke0F9YCxuPWUucGF0aCE9bnVsbD9lLnBhdGg6YCR7ZS5wYXRobmFtZXx8XCJcIn0ke2Uuc2VhcmNofHxcIlwifWA7dC5lbmRzV2l0aChcIi9cIikmJih0PXQuc3Vic3RyaW5nKDAsdC5sZW5ndGgtMSkpLG4mJiFuLnN0YXJ0c1dpdGgoXCIvXCIpJiYobj1gLyR7bn1gKSxlPW5ldyBVUkwodCtuKX1yZXR1cm4gZX1vKHBhcnNlVVJMLFwicGFyc2VVUkxcIik7ZnVuY3Rpb24gcGFyc2VPcmlnaW4oZSl7aWYoZT1wYXJzZVVSTChlKSxlLnBhdGhuYW1lIT09XCIvXCJ8fGUuc2VhcmNofHxlLmhhc2gpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGooXCJpbnZhbGlkIHVybFwiKTtyZXR1cm4gZX1vKHBhcnNlT3JpZ2luLFwicGFyc2VPcmlnaW5cIik7ZnVuY3Rpb24gZ2V0SG9zdG5hbWUoZSl7aWYoZVswXT09PVwiW1wiKXtjb25zdCB0PWUuaW5kZXhPZihcIl1cIik7cmV0dXJuIGFzc2VydCRkKHQhPT0tMSksZS5zdWJzdHJpbmcoMSx0KX1jb25zdCBBPWUuaW5kZXhPZihcIjpcIik7cmV0dXJuIEE9PT0tMT9lOmUuc3Vic3RyaW5nKDAsQSl9byhnZXRIb3N0bmFtZSxcImdldEhvc3RuYW1lXCIpO2Z1bmN0aW9uIGdldFNlcnZlck5hbWUkMShlKXtpZighZSlyZXR1cm4gbnVsbDthc3NlcnQkZC5zdHJpY3RFcXVhbCh0eXBlb2YgZSxcInN0cmluZ1wiKTtjb25zdCBBPWdldEhvc3RuYW1lKGUpO3JldHVybiBuZXQkMi5pc0lQKEEpP1wiXCI6QX1vKGdldFNlcnZlck5hbWUkMSxcImdldFNlcnZlck5hbWUkMVwiKTtmdW5jdGlvbiBkZWVwQ2xvbmUoZSl7cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZSkpfW8oZGVlcENsb25lLFwiZGVlcENsb25lXCIpO2Z1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZShlKXtyZXR1cm4gZSE9bnVsbCYmdHlwZW9mIGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPT1cImZ1bmN0aW9uXCJ9byhpc0FzeW5jSXRlcmFibGUsXCJpc0FzeW5jSXRlcmFibGVcIik7ZnVuY3Rpb24gaXNJdGVyYWJsZSQxKGUpe3JldHVybiBlIT1udWxsJiYodHlwZW9mIGVbU3ltYm9sLml0ZXJhdG9yXT09XCJmdW5jdGlvblwifHx0eXBlb2YgZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl09PVwiZnVuY3Rpb25cIil9byhpc0l0ZXJhYmxlJDEsXCJpc0l0ZXJhYmxlJDFcIik7ZnVuY3Rpb24gYm9keUxlbmd0aChlKXtpZihlPT1udWxsKXJldHVybiAwO2lmKGlzU3RyZWFtJDEoZSkpe2NvbnN0IEE9ZS5fcmVhZGFibGVTdGF0ZTtyZXR1cm4gQSYmQS5vYmplY3RNb2RlPT09ITEmJkEuZW5kZWQ9PT0hMCYmTnVtYmVyLmlzRmluaXRlKEEubGVuZ3RoKT9BLmxlbmd0aDpudWxsfWVsc2V7aWYoaXNCbG9iTGlrZSQxKGUpKXJldHVybiBlLnNpemUhPW51bGw/ZS5zaXplOm51bGw7aWYoaXNCdWZmZXIkMShlKSlyZXR1cm4gZS5ieXRlTGVuZ3RofXJldHVybiBudWxsfW8oYm9keUxlbmd0aCxcImJvZHlMZW5ndGhcIik7ZnVuY3Rpb24gaXNEZXN0cm95ZWQoZSl7cmV0dXJuIGUmJiEhKGUuZGVzdHJveWVkfHxlW2tEZXN0cm95ZWQkMV18fHN0cmVhbSQxLmlzRGVzdHJveWVkPy4oZSkpfW8oaXNEZXN0cm95ZWQsXCJpc0Rlc3Ryb3llZFwiKTtmdW5jdGlvbiBpc1JlYWRhYmxlQWJvcnRlZChlKXtjb25zdCBBPWU/Ll9yZWFkYWJsZVN0YXRlO3JldHVybiBpc0Rlc3Ryb3llZChlKSYmQSYmIUEuZW5kRW1pdHRlZH1vKGlzUmVhZGFibGVBYm9ydGVkLFwiaXNSZWFkYWJsZUFib3J0ZWRcIik7ZnVuY3Rpb24gZGVzdHJveSQxKGUsQSl7ZT09bnVsbHx8IWlzU3RyZWFtJDEoZSl8fGlzRGVzdHJveWVkKGUpfHwodHlwZW9mIGUuZGVzdHJveT09XCJmdW5jdGlvblwiPyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkuY29uc3RydWN0b3I9PT1JbmNvbWluZ01lc3NhZ2UmJihlLnNvY2tldD1udWxsKSxlLmRlc3Ryb3koQSkpOkEmJnF1ZXVlTWljcm90YXNrKCgpPT57ZS5lbWl0KFwiZXJyb3JcIixBKX0pLGUuZGVzdHJveWVkIT09ITAmJihlW2tEZXN0cm95ZWQkMV09ITApKX1vKGRlc3Ryb3kkMSxcImRlc3Ryb3kkMVwiKTtjb25zdCBLRUVQQUxJVkVfVElNRU9VVF9FWFBSPS90aW1lb3V0PShcXGQrKS87ZnVuY3Rpb24gcGFyc2VLZWVwQWxpdmVUaW1lb3V0KGUpe2NvbnN0IEE9ZS50b1N0cmluZygpLm1hdGNoKEtFRVBBTElWRV9USU1FT1VUX0VYUFIpO3JldHVybiBBP3BhcnNlSW50KEFbMV0sMTApKjFlMzpudWxsfW8ocGFyc2VLZWVwQWxpdmVUaW1lb3V0LFwicGFyc2VLZWVwQWxpdmVUaW1lb3V0XCIpO2Z1bmN0aW9uIGhlYWRlck5hbWVUb1N0cmluZyhlKXtyZXR1cm4gdHlwZW9mIGU9PVwic3RyaW5nXCI/aGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQkMVtlXT8/ZS50b0xvd2VyQ2FzZSgpOnRyZWUubG9va3VwKGUpPz9lLnRvU3RyaW5nKFwibGF0aW4xXCIpLnRvTG93ZXJDYXNlKCl9byhoZWFkZXJOYW1lVG9TdHJpbmcsXCJoZWFkZXJOYW1lVG9TdHJpbmdcIik7ZnVuY3Rpb24gYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShlKXtyZXR1cm4gdHJlZS5sb29rdXAoZSk/P2UudG9TdHJpbmcoXCJsYXRpbjFcIikudG9Mb3dlckNhc2UoKX1vKGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUsXCJidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lXCIpO2Z1bmN0aW9uIHBhcnNlSGVhZGVycyhlLEEpe0E9PT12b2lkIDAmJihBPXt9KTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrPTIpe2NvbnN0IG49aGVhZGVyTmFtZVRvU3RyaW5nKGVbdF0pO2xldCByPUFbbl07aWYocil0eXBlb2Ygcj09XCJzdHJpbmdcIiYmKHI9W3JdLEFbbl09ciksci5wdXNoKGVbdCsxXS50b1N0cmluZyhcInV0ZjhcIikpO2Vsc2V7Y29uc3Qgcz1lW3QrMV07dHlwZW9mIHM9PVwic3RyaW5nXCI/QVtuXT1zOkFbbl09QXJyYXkuaXNBcnJheShzKT9zLm1hcChpPT5pLnRvU3RyaW5nKFwidXRmOFwiKSk6cy50b1N0cmluZyhcInV0ZjhcIil9fXJldHVyblwiY29udGVudC1sZW5ndGhcImluIEEmJlwiY29udGVudC1kaXNwb3NpdGlvblwiaW4gQSYmKEFbXCJjb250ZW50LWRpc3Bvc2l0aW9uXCJdPUJ1ZmZlci5mcm9tKEFbXCJjb250ZW50LWRpc3Bvc2l0aW9uXCJdKS50b1N0cmluZyhcImxhdGluMVwiKSksQX1vKHBhcnNlSGVhZGVycyxcInBhcnNlSGVhZGVyc1wiKTtmdW5jdGlvbiBwYXJzZVJhd0hlYWRlcnMoZSl7Y29uc3QgQT1lLmxlbmd0aCx0PW5ldyBBcnJheShBKTtsZXQgbj0hMSxyPS0xLHMsaSxFPTA7Zm9yKGxldCBRPTA7UTxlLmxlbmd0aDtRKz0yKXM9ZVtRXSxpPWVbUSsxXSx0eXBlb2YgcyE9XCJzdHJpbmdcIiYmKHM9cy50b1N0cmluZygpKSx0eXBlb2YgaSE9XCJzdHJpbmdcIiYmKGk9aS50b1N0cmluZyhcInV0ZjhcIikpLEU9cy5sZW5ndGgsRT09PTE0JiZzWzddPT09XCItXCImJihzPT09XCJjb250ZW50LWxlbmd0aFwifHxzLnRvTG93ZXJDYXNlKCk9PT1cImNvbnRlbnQtbGVuZ3RoXCIpP249ITA6RT09PTE5JiZzWzddPT09XCItXCImJihzPT09XCJjb250ZW50LWRpc3Bvc2l0aW9uXCJ8fHMudG9Mb3dlckNhc2UoKT09PVwiY29udGVudC1kaXNwb3NpdGlvblwiKSYmKHI9USsxKSx0W1FdPXMsdFtRKzFdPWk7cmV0dXJuIG4mJnIhPT0tMSYmKHRbcl09QnVmZmVyLmZyb20odFtyXSkudG9TdHJpbmcoXCJsYXRpbjFcIikpLHR9byhwYXJzZVJhd0hlYWRlcnMsXCJwYXJzZVJhd0hlYWRlcnNcIik7ZnVuY3Rpb24gaXNCdWZmZXIkMShlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fEJ1ZmZlci5pc0J1ZmZlcihlKX1vKGlzQnVmZmVyJDEsXCJpc0J1ZmZlciQxXCIpO2Z1bmN0aW9uIHZhbGlkYXRlSGFuZGxlciQxKGUsQSx0KXtpZighZXx8dHlwZW9mIGUhPVwib2JqZWN0XCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGooXCJoYW5kbGVyIG11c3QgYmUgYW4gb2JqZWN0XCIpO2lmKHR5cGVvZiBlLm9uQ29ubmVjdCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRqKFwiaW52YWxpZCBvbkNvbm5lY3QgbWV0aG9kXCIpO2lmKHR5cGVvZiBlLm9uRXJyb3IhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaihcImludmFsaWQgb25FcnJvciBtZXRob2RcIik7aWYodHlwZW9mIGUub25Cb2R5U2VudCE9XCJmdW5jdGlvblwiJiZlLm9uQm9keVNlbnQhPT12b2lkIDApdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGooXCJpbnZhbGlkIG9uQm9keVNlbnQgbWV0aG9kXCIpO2lmKHR8fEE9PT1cIkNPTk5FQ1RcIil7aWYodHlwZW9mIGUub25VcGdyYWRlIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGooXCJpbnZhbGlkIG9uVXBncmFkZSBtZXRob2RcIil9ZWxzZXtpZih0eXBlb2YgZS5vbkhlYWRlcnMhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaihcImludmFsaWQgb25IZWFkZXJzIG1ldGhvZFwiKTtpZih0eXBlb2YgZS5vbkRhdGEhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaihcImludmFsaWQgb25EYXRhIG1ldGhvZFwiKTtpZih0eXBlb2YgZS5vbkNvbXBsZXRlIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGooXCJpbnZhbGlkIG9uQ29tcGxldGUgbWV0aG9kXCIpfX1vKHZhbGlkYXRlSGFuZGxlciQxLFwidmFsaWRhdGVIYW5kbGVyJDFcIik7ZnVuY3Rpb24gaXNEaXN0dXJiZWQoZSl7cmV0dXJuISEoZSYmKHN0cmVhbSQxLmlzRGlzdHVyYmVkKGUpfHxlW2tCb2R5VXNlZCQxXSkpfW8oaXNEaXN0dXJiZWQsXCJpc0Rpc3R1cmJlZFwiKTtmdW5jdGlvbiBpc0Vycm9yZWQoZSl7cmV0dXJuISEoZSYmc3RyZWFtJDEuaXNFcnJvcmVkKGUpKX1vKGlzRXJyb3JlZCxcImlzRXJyb3JlZFwiKTtmdW5jdGlvbiBpc1JlYWRhYmxlKGUpe3JldHVybiEhKGUmJnN0cmVhbSQxLmlzUmVhZGFibGUoZSkpfW8oaXNSZWFkYWJsZSxcImlzUmVhZGFibGVcIik7ZnVuY3Rpb24gZ2V0U29ja2V0SW5mbyhlKXtyZXR1cm57bG9jYWxBZGRyZXNzOmUubG9jYWxBZGRyZXNzLGxvY2FsUG9ydDplLmxvY2FsUG9ydCxyZW1vdGVBZGRyZXNzOmUucmVtb3RlQWRkcmVzcyxyZW1vdGVQb3J0OmUucmVtb3RlUG9ydCxyZW1vdGVGYW1pbHk6ZS5yZW1vdGVGYW1pbHksdGltZW91dDplLnRpbWVvdXQsYnl0ZXNXcml0dGVuOmUuYnl0ZXNXcml0dGVuLGJ5dGVzUmVhZDplLmJ5dGVzUmVhZH19byhnZXRTb2NrZXRJbmZvLFwiZ2V0U29ja2V0SW5mb1wiKTtmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZyb20kMShlKXtsZXQgQTtyZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHthc3luYyBzdGFydCgpe0E9ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKX0sYXN5bmMgcHVsbCh0KXtjb25zdHtkb25lOm4sdmFsdWU6cn09YXdhaXQgQS5uZXh0KCk7aWYobilxdWV1ZU1pY3JvdGFzaygoKT0+e3QuY2xvc2UoKSx0LmJ5b2JSZXF1ZXN0Py5yZXNwb25kKDApfSk7ZWxzZXtjb25zdCBzPUJ1ZmZlci5pc0J1ZmZlcihyKT9yOkJ1ZmZlci5mcm9tKHIpO3MuYnl0ZUxlbmd0aCYmdC5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHMpKX1yZXR1cm4gdC5kZXNpcmVkU2l6ZT4wfSxhc3luYyBjYW5jZWwodCl7YXdhaXQgQS5yZXR1cm4oKX0sdHlwZTpcImJ5dGVzXCJ9KX1vKFJlYWRhYmxlU3RyZWFtRnJvbSQxLFwiUmVhZGFibGVTdHJlYW1Gcm9tJDFcIik7ZnVuY3Rpb24gaXNGb3JtRGF0YUxpa2UkMShlKXtyZXR1cm4gZSYmdHlwZW9mIGU9PVwib2JqZWN0XCImJnR5cGVvZiBlLmFwcGVuZD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgZS5kZWxldGU9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGUuZ2V0PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBlLmdldEFsbD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgZS5oYXM9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGUuc2V0PT1cImZ1bmN0aW9uXCImJmVbU3ltYm9sLnRvU3RyaW5nVGFnXT09PVwiRm9ybURhdGFcIn1vKGlzRm9ybURhdGFMaWtlJDEsXCJpc0Zvcm1EYXRhTGlrZSQxXCIpO2Z1bmN0aW9uIGFkZEFib3J0TGlzdGVuZXIkMShlLEEpe3JldHVyblwiYWRkRXZlbnRMaXN0ZW5lclwiaW4gZT8oZS5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIixBLHtvbmNlOiEwfSksKCk9PmUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsQSkpOihlLmFkZExpc3RlbmVyKFwiYWJvcnRcIixBKSwoKT0+ZS5yZW1vdmVMaXN0ZW5lcihcImFib3J0XCIsQSkpfW8oYWRkQWJvcnRMaXN0ZW5lciQxLFwiYWRkQWJvcnRMaXN0ZW5lciQxXCIpO2NvbnN0IGhhc1RvV2VsbEZvcm1lZD10eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50b1dlbGxGb3JtZWQ9PVwiZnVuY3Rpb25cIixoYXNJc1dlbGxGb3JtZWQ9dHlwZW9mIFN0cmluZy5wcm90b3R5cGUuaXNXZWxsRm9ybWVkPT1cImZ1bmN0aW9uXCI7ZnVuY3Rpb24gdG9VU1ZTdHJpbmcoZSl7cmV0dXJuIGhhc1RvV2VsbEZvcm1lZD9gJHtlfWAudG9XZWxsRm9ybWVkKCk6bm9kZVV0aWwudG9VU1ZTdHJpbmcoZSl9byh0b1VTVlN0cmluZyxcInRvVVNWU3RyaW5nXCIpO2Z1bmN0aW9uIGlzVVNWU3RyaW5nKGUpe3JldHVybiBoYXNJc1dlbGxGb3JtZWQ/YCR7ZX1gLmlzV2VsbEZvcm1lZCgpOnRvVVNWU3RyaW5nKGUpPT09YCR7ZX1gfW8oaXNVU1ZTdHJpbmcsXCJpc1VTVlN0cmluZ1wiKTtmdW5jdGlvbiBpc1Rva2VuQ2hhckNvZGUoZSl7c3dpdGNoKGUpe2Nhc2UgMzQ6Y2FzZSA0MDpjYXNlIDQxOmNhc2UgNDQ6Y2FzZSA0NzpjYXNlIDU4OmNhc2UgNTk6Y2FzZSA2MDpjYXNlIDYxOmNhc2UgNjI6Y2FzZSA2MzpjYXNlIDY0OmNhc2UgOTE6Y2FzZSA5MjpjYXNlIDkzOmNhc2UgMTIzOmNhc2UgMTI1OnJldHVybiExO2RlZmF1bHQ6cmV0dXJuIGU+PTMzJiZlPD0xMjZ9fW8oaXNUb2tlbkNoYXJDb2RlLFwiaXNUb2tlbkNoYXJDb2RlXCIpO2Z1bmN0aW9uIGlzVmFsaWRIVFRQVG9rZW4kMShlKXtpZihlLmxlbmd0aD09PTApcmV0dXJuITE7Zm9yKGxldCBBPTA7QTxlLmxlbmd0aDsrK0EpaWYoIWlzVG9rZW5DaGFyQ29kZShlLmNoYXJDb2RlQXQoQSkpKXJldHVybiExO3JldHVybiEwfW8oaXNWYWxpZEhUVFBUb2tlbiQxLFwiaXNWYWxpZEhUVFBUb2tlbiQxXCIpO2NvbnN0IGhlYWRlckNoYXJSZWdleD0vW15cXHRcXHgyMC1cXHg3ZVxceDgwLVxceGZmXS87ZnVuY3Rpb24gaXNWYWxpZEhlYWRlckNoYXIkMShlKXtyZXR1cm4haGVhZGVyQ2hhclJlZ2V4LnRlc3QoZSl9byhpc1ZhbGlkSGVhZGVyQ2hhciQxLFwiaXNWYWxpZEhlYWRlckNoYXIkMVwiKTtmdW5jdGlvbiBwYXJzZVJhbmdlSGVhZGVyKGUpe2lmKGU9PW51bGx8fGU9PT1cIlwiKXJldHVybntzdGFydDowLGVuZDpudWxsLHNpemU6bnVsbH07Y29uc3QgQT1lP2UubWF0Y2goL15ieXRlcyAoXFxkKyktKFxcZCspXFwvKFxcZCspPyQvKTpudWxsO3JldHVybiBBP3tzdGFydDpwYXJzZUludChBWzFdKSxlbmQ6QVsyXT9wYXJzZUludChBWzJdKTpudWxsLHNpemU6QVszXT9wYXJzZUludChBWzNdKTpudWxsfTpudWxsfW8ocGFyc2VSYW5nZUhlYWRlcixcInBhcnNlUmFuZ2VIZWFkZXJcIik7ZnVuY3Rpb24gYWRkTGlzdGVuZXIkMShlLEEsdCl7cmV0dXJuKGVba0xpc3RlbmVyc10/PyhlW2tMaXN0ZW5lcnNdPVtdKSkucHVzaChbQSx0XSksZS5vbihBLHQpLGV9byhhZGRMaXN0ZW5lciQxLFwiYWRkTGlzdGVuZXIkMVwiKTtmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMkMShlKXtmb3IoY29uc3RbQSx0XW9mIGVba0xpc3RlbmVyc10/P1tdKWUucmVtb3ZlTGlzdGVuZXIoQSx0KTtlW2tMaXN0ZW5lcnNdPW51bGx9byhyZW1vdmVBbGxMaXN0ZW5lcnMkMSxcInJlbW92ZUFsbExpc3RlbmVycyQxXCIpO2Z1bmN0aW9uIGVycm9yUmVxdWVzdChlLEEsdCl7dHJ5e0Eub25FcnJvcih0KSxhc3NlcnQkZChBLmFib3J0ZWQpfWNhdGNoKG4pe2UuZW1pdChcImVycm9yXCIsbil9fW8oZXJyb3JSZXF1ZXN0LFwiZXJyb3JSZXF1ZXN0XCIpO2NvbnN0IGtFbnVtZXJhYmxlUHJvcGVydHk9T2JqZWN0LmNyZWF0ZShudWxsKTtrRW51bWVyYWJsZVByb3BlcnR5LmVudW1lcmFibGU9ITA7dmFyIHV0aWwkbT17a0VudW1lcmFibGVQcm9wZXJ0eSxub3AsaXNEaXN0dXJiZWQsaXNFcnJvcmVkLGlzUmVhZGFibGUsdG9VU1ZTdHJpbmcsaXNVU1ZTdHJpbmcsaXNSZWFkYWJsZUFib3J0ZWQsaXNCbG9iTGlrZTppc0Jsb2JMaWtlJDEscGFyc2VPcmlnaW4scGFyc2VVUkwsZ2V0U2VydmVyTmFtZTpnZXRTZXJ2ZXJOYW1lJDEsaXNTdHJlYW06aXNTdHJlYW0kMSxpc0l0ZXJhYmxlOmlzSXRlcmFibGUkMSxpc0FzeW5jSXRlcmFibGUsaXNEZXN0cm95ZWQsaGVhZGVyTmFtZVRvU3RyaW5nLGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUsYWRkTGlzdGVuZXI6YWRkTGlzdGVuZXIkMSxyZW1vdmVBbGxMaXN0ZW5lcnM6cmVtb3ZlQWxsTGlzdGVuZXJzJDEsZXJyb3JSZXF1ZXN0LHBhcnNlUmF3SGVhZGVycyxwYXJzZUhlYWRlcnMscGFyc2VLZWVwQWxpdmVUaW1lb3V0LGRlc3Ryb3k6ZGVzdHJveSQxLGJvZHlMZW5ndGgsZGVlcENsb25lLFJlYWRhYmxlU3RyZWFtRnJvbTpSZWFkYWJsZVN0cmVhbUZyb20kMSxpc0J1ZmZlcjppc0J1ZmZlciQxLHZhbGlkYXRlSGFuZGxlcjp2YWxpZGF0ZUhhbmRsZXIkMSxnZXRTb2NrZXRJbmZvLGlzRm9ybURhdGFMaWtlOmlzRm9ybURhdGFMaWtlJDEsYnVpbGRVUkw6YnVpbGRVUkwkMyxhZGRBYm9ydExpc3RlbmVyOmFkZEFib3J0TGlzdGVuZXIkMSxpc1ZhbGlkSFRUUFRva2VuOmlzVmFsaWRIVFRQVG9rZW4kMSxpc1ZhbGlkSGVhZGVyQ2hhcjppc1ZhbGlkSGVhZGVyQ2hhciQxLGlzVG9rZW5DaGFyQ29kZSxwYXJzZVJhbmdlSGVhZGVyLG5vZGVNYWpvcixub2RlTWlub3Isbm9kZUhhc0F1dG9TZWxlY3RGYW1pbHk6bm9kZU1ham9yPjE4fHxub2RlTWFqb3I9PT0xOCYmbm9kZU1pbm9yPj0xMyxzYWZlSFRUUE1ldGhvZHM6W1wiR0VUXCIsXCJIRUFEXCIsXCJPUFRJT05TXCIsXCJUUkFDRVwiXX07Y29uc3QgZGlhZ25vc3RpY3NDaGFubmVsPXJlcXVpcmUkJDBfX2RlZmF1bHQkMix1dGlsJGw9cmVxdWlyZSQkMF9fZGVmYXVsdCQxLHVuZGljaURlYnVnTG9nPXV0aWwkbC5kZWJ1Z2xvZyhcInVuZGljaVwiKSxmZXRjaERlYnVnbG9nPXV0aWwkbC5kZWJ1Z2xvZyhcImZldGNoXCIpLHdlYnNvY2tldERlYnVnbG9nPXV0aWwkbC5kZWJ1Z2xvZyhcIndlYnNvY2tldFwiKTtsZXQgaXNDbGllbnRTZXQ9ITE7Y29uc3QgY2hhbm5lbHMkMz17YmVmb3JlQ29ubmVjdDpkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTpjbGllbnQ6YmVmb3JlQ29ubmVjdFwiKSxjb25uZWN0ZWQ6ZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6Y2xpZW50OmNvbm5lY3RlZFwiKSxjb25uZWN0RXJyb3I6ZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6Y2xpZW50OmNvbm5lY3RFcnJvclwiKSxzZW5kSGVhZGVyczpkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTpjbGllbnQ6c2VuZEhlYWRlcnNcIiksY3JlYXRlOmRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOnJlcXVlc3Q6Y3JlYXRlXCIpLGJvZHlTZW50OmRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOnJlcXVlc3Q6Ym9keVNlbnRcIiksaGVhZGVyczpkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTpyZXF1ZXN0OmhlYWRlcnNcIiksdHJhaWxlcnM6ZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6cmVxdWVzdDp0cmFpbGVyc1wiKSxlcnJvcjpkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTpyZXF1ZXN0OmVycm9yXCIpLG9wZW46ZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6d2Vic29ja2V0Om9wZW5cIiksY2xvc2U6ZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6d2Vic29ja2V0OmNsb3NlXCIpLHNvY2tldEVycm9yOmRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOndlYnNvY2tldDpzb2NrZXRfZXJyb3JcIikscGluZzpkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTp3ZWJzb2NrZXQ6cGluZ1wiKSxwb25nOmRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOndlYnNvY2tldDpwb25nXCIpfTtpZih1bmRpY2lEZWJ1Z0xvZy5lbmFibGVkfHxmZXRjaERlYnVnbG9nLmVuYWJsZWQpe2NvbnN0IGU9ZmV0Y2hEZWJ1Z2xvZy5lbmFibGVkP2ZldGNoRGVidWdsb2c6dW5kaWNpRGVidWdMb2c7ZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6Y2xpZW50OmJlZm9yZUNvbm5lY3RcIikuc3Vic2NyaWJlKEE9Pntjb25zdHtjb25uZWN0UGFyYW1zOnt2ZXJzaW9uOnQscHJvdG9jb2w6bixwb3J0OnIsaG9zdDpzfX09QTtlKFwiY29ubmVjdGluZyB0byAlcyB1c2luZyAlcyVzXCIsYCR7c30ke3I/YDoke3J9YDpcIlwifWAsbix0KX0pLGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOmNsaWVudDpjb25uZWN0ZWRcIikuc3Vic2NyaWJlKEE9Pntjb25zdHtjb25uZWN0UGFyYW1zOnt2ZXJzaW9uOnQscHJvdG9jb2w6bixwb3J0OnIsaG9zdDpzfX09QTtlKFwiY29ubmVjdGVkIHRvICVzIHVzaW5nICVzJXNcIixgJHtzfSR7cj9gOiR7cn1gOlwiXCJ9YCxuLHQpfSksZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6Y2xpZW50OmNvbm5lY3RFcnJvclwiKS5zdWJzY3JpYmUoQT0+e2NvbnN0e2Nvbm5lY3RQYXJhbXM6e3ZlcnNpb246dCxwcm90b2NvbDpuLHBvcnQ6cixob3N0OnN9LGVycm9yOml9PUE7ZShcImNvbm5lY3Rpb24gdG8gJXMgdXNpbmcgJXMlcyBlcnJvcmVkIC0gJXNcIixgJHtzfSR7cj9gOiR7cn1gOlwiXCJ9YCxuLHQsaS5tZXNzYWdlKX0pLGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOmNsaWVudDpzZW5kSGVhZGVyc1wiKS5zdWJzY3JpYmUoQT0+e2NvbnN0e3JlcXVlc3Q6e21ldGhvZDp0LHBhdGg6bixvcmlnaW46cn19PUE7ZShcInNlbmRpbmcgcmVxdWVzdCB0byAlcyAlcy8lc1wiLHQscixuKX0pLGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOnJlcXVlc3Q6aGVhZGVyc1wiKS5zdWJzY3JpYmUoQT0+e2NvbnN0e3JlcXVlc3Q6e21ldGhvZDp0LHBhdGg6bixvcmlnaW46cn0scmVzcG9uc2U6e3N0YXR1c0NvZGU6c319PUE7ZShcInJlY2VpdmVkIHJlc3BvbnNlIHRvICVzICVzLyVzIC0gSFRUUCAlZFwiLHQscixuLHMpfSksZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6cmVxdWVzdDp0cmFpbGVyc1wiKS5zdWJzY3JpYmUoQT0+e2NvbnN0e3JlcXVlc3Q6e21ldGhvZDp0LHBhdGg6bixvcmlnaW46cn19PUE7ZShcInRyYWlsZXJzIHJlY2VpdmVkIGZyb20gJXMgJXMvJXNcIix0LHIsbil9KSxkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTpyZXF1ZXN0OmVycm9yXCIpLnN1YnNjcmliZShBPT57Y29uc3R7cmVxdWVzdDp7bWV0aG9kOnQscGF0aDpuLG9yaWdpbjpyfSxlcnJvcjpzfT1BO2UoXCJyZXF1ZXN0IHRvICVzICVzLyVzIGVycm9yZWQgLSAlc1wiLHQscixuLHMubWVzc2FnZSl9KSxpc0NsaWVudFNldD0hMH1pZih3ZWJzb2NrZXREZWJ1Z2xvZy5lbmFibGVkKXtpZighaXNDbGllbnRTZXQpe2NvbnN0IGU9dW5kaWNpRGVidWdMb2cuZW5hYmxlZD91bmRpY2lEZWJ1Z0xvZzp3ZWJzb2NrZXREZWJ1Z2xvZztkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTpjbGllbnQ6YmVmb3JlQ29ubmVjdFwiKS5zdWJzY3JpYmUoQT0+e2NvbnN0e2Nvbm5lY3RQYXJhbXM6e3ZlcnNpb246dCxwcm90b2NvbDpuLHBvcnQ6cixob3N0OnN9fT1BO2UoXCJjb25uZWN0aW5nIHRvICVzJXMgdXNpbmcgJXMlc1wiLHMscj9gOiR7cn1gOlwiXCIsbix0KX0pLGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOmNsaWVudDpjb25uZWN0ZWRcIikuc3Vic2NyaWJlKEE9Pntjb25zdHtjb25uZWN0UGFyYW1zOnt2ZXJzaW9uOnQscHJvdG9jb2w6bixwb3J0OnIsaG9zdDpzfX09QTtlKFwiY29ubmVjdGVkIHRvICVzJXMgdXNpbmcgJXMlc1wiLHMscj9gOiR7cn1gOlwiXCIsbix0KX0pLGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOmNsaWVudDpjb25uZWN0RXJyb3JcIikuc3Vic2NyaWJlKEE9Pntjb25zdHtjb25uZWN0UGFyYW1zOnt2ZXJzaW9uOnQscHJvdG9jb2w6bixwb3J0OnIsaG9zdDpzfSxlcnJvcjppfT1BO2UoXCJjb25uZWN0aW9uIHRvICVzJXMgdXNpbmcgJXMlcyBlcnJvcmVkIC0gJXNcIixzLHI/YDoke3J9YDpcIlwiLG4sdCxpLm1lc3NhZ2UpfSksZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6Y2xpZW50OnNlbmRIZWFkZXJzXCIpLnN1YnNjcmliZShBPT57Y29uc3R7cmVxdWVzdDp7bWV0aG9kOnQscGF0aDpuLG9yaWdpbjpyfX09QTtlKFwic2VuZGluZyByZXF1ZXN0IHRvICVzICVzLyVzXCIsdCxyLG4pfSl9ZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6d2Vic29ja2V0Om9wZW5cIikuc3Vic2NyaWJlKGU9Pntjb25zdHthZGRyZXNzOnthZGRyZXNzOkEscG9ydDp0fX09ZTt3ZWJzb2NrZXREZWJ1Z2xvZyhcImNvbm5lY3Rpb24gb3BlbmVkICVzJXNcIixBLHQ/YDoke3R9YDpcIlwiKX0pLGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKFwidW5kaWNpOndlYnNvY2tldDpjbG9zZVwiKS5zdWJzY3JpYmUoZT0+e2NvbnN0e3dlYnNvY2tldDpBLGNvZGU6dCxyZWFzb246bn09ZTt3ZWJzb2NrZXREZWJ1Z2xvZyhcImNsb3NlZCBjb25uZWN0aW9uIHRvICVzIC0gJXMgJXNcIixBLnVybCx0LG4pfSksZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6d2Vic29ja2V0OnNvY2tldF9lcnJvclwiKS5zdWJzY3JpYmUoZT0+e3dlYnNvY2tldERlYnVnbG9nKFwiY29ubmVjdGlvbiBlcnJvcmVkIC0gJXNcIixlLm1lc3NhZ2UpfSksZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoXCJ1bmRpY2k6d2Vic29ja2V0OnBpbmdcIikuc3Vic2NyaWJlKGU9Pnt3ZWJzb2NrZXREZWJ1Z2xvZyhcInBpbmcgcmVjZWl2ZWRcIil9KSxkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbChcInVuZGljaTp3ZWJzb2NrZXQ6cG9uZ1wiKS5zdWJzY3JpYmUoZT0+e3dlYnNvY2tldERlYnVnbG9nKFwicG9uZyByZWNlaXZlZFwiKX0pfXZhciBkaWFnbm9zdGljcz17Y2hhbm5lbHM6Y2hhbm5lbHMkM307Y29uc3R7SW52YWxpZEFyZ3VtZW50RXJyb3I6SW52YWxpZEFyZ3VtZW50RXJyb3IkaSxOb3RTdXBwb3J0ZWRFcnJvcjpOb3RTdXBwb3J0ZWRFcnJvciQxfT1lcnJvcnMkMSxhc3NlcnQkYz1yZXF1aXJlJCQwX19kZWZhdWx0LHtpc1ZhbGlkSFRUUFRva2VuLGlzVmFsaWRIZWFkZXJDaGFyLGlzU3RyZWFtLGRlc3Ryb3ksaXNCdWZmZXIsaXNGb3JtRGF0YUxpa2UsaXNJdGVyYWJsZSxpc0Jsb2JMaWtlLGJ1aWxkVVJMOmJ1aWxkVVJMJDIsdmFsaWRhdGVIYW5kbGVyLGdldFNlcnZlck5hbWV9PXV0aWwkbSx7Y2hhbm5lbHM6Y2hhbm5lbHMkMn09ZGlhZ25vc3RpY3Mse2hlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkfT1jb25zdGFudHMkNSxpbnZhbGlkUGF0aFJlZ2V4PS9bXlxcdTAwMjEtXFx1MDBmZl0vLGtIYW5kbGVyPVN5bWJvbChcImhhbmRsZXJcIik7bGV0IFJlcXVlc3QkMT0od2U9Y2xhc3N7Y29uc3RydWN0b3IoQSx7cGF0aDp0LG1ldGhvZDpuLGJvZHk6cixoZWFkZXJzOnMscXVlcnk6aSxpZGVtcG90ZW50OkUsYmxvY2tpbmc6USx1cGdyYWRlOkMsaGVhZGVyc1RpbWVvdXQ6SSxib2R5VGltZW91dDphLHJlc2V0OmYsdGhyb3dPbkVycm9yOmgsZXhwZWN0Q29udGludWU6TCxzZXJ2ZXJuYW1lOmN9LGwpe2lmKHR5cGVvZiB0IT1cInN0cmluZ1wiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRpKFwicGF0aCBtdXN0IGJlIGEgc3RyaW5nXCIpO2lmKHRbMF0hPT1cIi9cIiYmISh0LnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpfHx0LnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkmJm4hPT1cIkNPTk5FQ1RcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaShcInBhdGggbXVzdCBiZSBhbiBhYnNvbHV0ZSBVUkwgb3Igc3RhcnQgd2l0aCBhIHNsYXNoXCIpO2lmKGludmFsaWRQYXRoUmVnZXguZXhlYyh0KSE9PW51bGwpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGkoXCJpbnZhbGlkIHJlcXVlc3QgcGF0aFwiKTtpZih0eXBlb2YgbiE9XCJzdHJpbmdcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaShcIm1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nXCIpO2lmKCFpc1ZhbGlkSFRUUFRva2VuKG4pKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRpKFwiaW52YWxpZCByZXF1ZXN0IG1ldGhvZFwiKTtpZihDJiZ0eXBlb2YgQyE9XCJzdHJpbmdcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaShcInVwZ3JhZGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZihJIT1udWxsJiYoIU51bWJlci5pc0Zpbml0ZShJKXx8STwwKSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaShcImludmFsaWQgaGVhZGVyc1RpbWVvdXRcIik7aWYoYSE9bnVsbCYmKCFOdW1iZXIuaXNGaW5pdGUoYSl8fGE8MCkpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGkoXCJpbnZhbGlkIGJvZHlUaW1lb3V0XCIpO2lmKGYhPW51bGwmJnR5cGVvZiBmIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaShcImludmFsaWQgcmVzZXRcIik7aWYoTCE9bnVsbCYmdHlwZW9mIEwhPVwiYm9vbGVhblwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRpKFwiaW52YWxpZCBleHBlY3RDb250aW51ZVwiKTtpZih0aGlzLmhlYWRlcnNUaW1lb3V0PUksdGhpcy5ib2R5VGltZW91dD1hLHRoaXMudGhyb3dPbkVycm9yPWg9PT0hMCx0aGlzLm1ldGhvZD1uLHRoaXMuYWJvcnQ9bnVsbCxyPT1udWxsKXRoaXMuYm9keT1udWxsO2Vsc2UgaWYoaXNTdHJlYW0ocikpe3RoaXMuYm9keT1yO2NvbnN0IFM9dGhpcy5ib2R5Ll9yZWFkYWJsZVN0YXRlOyghU3x8IVMuYXV0b0Rlc3Ryb3kpJiYodGhpcy5lbmRIYW5kbGVyPW8oZnVuY3Rpb24oKXtkZXN0cm95KHRoaXMpfSxcImF1dG9EZXN0cm95XCIpLHRoaXMuYm9keS5vbihcImVuZFwiLHRoaXMuZW5kSGFuZGxlcikpLHRoaXMuZXJyb3JIYW5kbGVyPWs9Pnt0aGlzLmFib3J0P3RoaXMuYWJvcnQoayk6dGhpcy5lcnJvcj1rfSx0aGlzLmJvZHkub24oXCJlcnJvclwiLHRoaXMuZXJyb3JIYW5kbGVyKX1lbHNlIGlmKGlzQnVmZmVyKHIpKXRoaXMuYm9keT1yLmJ5dGVMZW5ndGg/cjpudWxsO2Vsc2UgaWYoQXJyYXlCdWZmZXIuaXNWaWV3KHIpKXRoaXMuYm9keT1yLmJ1ZmZlci5ieXRlTGVuZ3RoP0J1ZmZlci5mcm9tKHIuYnVmZmVyLHIuYnl0ZU9mZnNldCxyLmJ5dGVMZW5ndGgpOm51bGw7ZWxzZSBpZihyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhpcy5ib2R5PXIuYnl0ZUxlbmd0aD9CdWZmZXIuZnJvbShyKTpudWxsO2Vsc2UgaWYodHlwZW9mIHI9PVwic3RyaW5nXCIpdGhpcy5ib2R5PXIubGVuZ3RoP0J1ZmZlci5mcm9tKHIpOm51bGw7ZWxzZSBpZihpc0Zvcm1EYXRhTGlrZShyKXx8aXNJdGVyYWJsZShyKXx8aXNCbG9iTGlrZShyKSl0aGlzLmJvZHk9cjtlbHNlIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRpKFwiYm9keSBtdXN0IGJlIGEgc3RyaW5nLCBhIEJ1ZmZlciwgYSBSZWFkYWJsZSBzdHJlYW0sIGFuIGl0ZXJhYmxlLCBvciBhbiBhc3luYyBpdGVyYWJsZVwiKTtpZih0aGlzLmNvbXBsZXRlZD0hMSx0aGlzLmFib3J0ZWQ9ITEsdGhpcy51cGdyYWRlPUN8fG51bGwsdGhpcy5wYXRoPWk/YnVpbGRVUkwkMih0LGkpOnQsdGhpcy5vcmlnaW49QSx0aGlzLmlkZW1wb3RlbnQ9RT8/KG49PT1cIkhFQURcInx8bj09PVwiR0VUXCIpLHRoaXMuYmxvY2tpbmc9UT8/ITEsdGhpcy5yZXNldD1mPz9udWxsLHRoaXMuaG9zdD1udWxsLHRoaXMuY29udGVudExlbmd0aD1udWxsLHRoaXMuY29udGVudFR5cGU9bnVsbCx0aGlzLmhlYWRlcnM9W10sdGhpcy5leHBlY3RDb250aW51ZT1MPz8hMSxBcnJheS5pc0FycmF5KHMpKXtpZihzLmxlbmd0aCUyIT09MCl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaShcImhlYWRlcnMgYXJyYXkgbXVzdCBiZSBldmVuXCIpO2ZvcihsZXQgUz0wO1M8cy5sZW5ndGg7Uys9Milwcm9jZXNzSGVhZGVyKHRoaXMsc1tTXSxzW1MrMV0pfWVsc2UgaWYocyYmdHlwZW9mIHM9PVwib2JqZWN0XCIpaWYoc1tTeW1ib2wuaXRlcmF0b3JdKWZvcihjb25zdCBTIG9mIHMpe2lmKCFBcnJheS5pc0FycmF5KFMpfHxTLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGkoXCJoZWFkZXJzIG11c3QgYmUgaW4ga2V5LXZhbHVlIHBhaXIgZm9ybWF0XCIpO3Byb2Nlc3NIZWFkZXIodGhpcyxTWzBdLFNbMV0pfWVsc2V7Y29uc3QgUz1PYmplY3Qua2V5cyhzKTtmb3IobGV0IGs9MDtrPFMubGVuZ3RoOysraylwcm9jZXNzSGVhZGVyKHRoaXMsU1trXSxzW1Nba11dKX1lbHNlIGlmKHMhPW51bGwpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGkoXCJoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5XCIpO3ZhbGlkYXRlSGFuZGxlcihsLG4sQyksdGhpcy5zZXJ2ZXJuYW1lPWN8fGdldFNlcnZlck5hbWUodGhpcy5ob3N0KSx0aGlzW2tIYW5kbGVyXT1sLGNoYW5uZWxzJDIuY3JlYXRlLmhhc1N1YnNjcmliZXJzJiZjaGFubmVscyQyLmNyZWF0ZS5wdWJsaXNoKHtyZXF1ZXN0OnRoaXN9KX1vbkJvZHlTZW50KEEpe2lmKHRoaXNba0hhbmRsZXJdLm9uQm9keVNlbnQpdHJ5e3JldHVybiB0aGlzW2tIYW5kbGVyXS5vbkJvZHlTZW50KEEpfWNhdGNoKHQpe3RoaXMuYWJvcnQodCl9fW9uUmVxdWVzdFNlbnQoKXtpZihjaGFubmVscyQyLmJvZHlTZW50Lmhhc1N1YnNjcmliZXJzJiZjaGFubmVscyQyLmJvZHlTZW50LnB1Ymxpc2goe3JlcXVlc3Q6dGhpc30pLHRoaXNba0hhbmRsZXJdLm9uUmVxdWVzdFNlbnQpdHJ5e3JldHVybiB0aGlzW2tIYW5kbGVyXS5vblJlcXVlc3RTZW50KCl9Y2F0Y2goQSl7dGhpcy5hYm9ydChBKX19b25Db25uZWN0KEEpe2lmKGFzc2VydCRjKCF0aGlzLmFib3J0ZWQpLGFzc2VydCRjKCF0aGlzLmNvbXBsZXRlZCksdGhpcy5lcnJvcilBKHRoaXMuZXJyb3IpO2Vsc2UgcmV0dXJuIHRoaXMuYWJvcnQ9QSx0aGlzW2tIYW5kbGVyXS5vbkNvbm5lY3QoQSl9b25SZXNwb25zZVN0YXJ0ZWQoKXtyZXR1cm4gdGhpc1trSGFuZGxlcl0ub25SZXNwb25zZVN0YXJ0ZWQ/LigpfW9uSGVhZGVycyhBLHQsbixyKXthc3NlcnQkYyghdGhpcy5hYm9ydGVkKSxhc3NlcnQkYyghdGhpcy5jb21wbGV0ZWQpLGNoYW5uZWxzJDIuaGVhZGVycy5oYXNTdWJzY3JpYmVycyYmY2hhbm5lbHMkMi5oZWFkZXJzLnB1Ymxpc2goe3JlcXVlc3Q6dGhpcyxyZXNwb25zZTp7c3RhdHVzQ29kZTpBLGhlYWRlcnM6dCxzdGF0dXNUZXh0OnJ9fSk7dHJ5e3JldHVybiB0aGlzW2tIYW5kbGVyXS5vbkhlYWRlcnMoQSx0LG4scil9Y2F0Y2gocyl7dGhpcy5hYm9ydChzKX19b25EYXRhKEEpe2Fzc2VydCRjKCF0aGlzLmFib3J0ZWQpLGFzc2VydCRjKCF0aGlzLmNvbXBsZXRlZCk7dHJ5e3JldHVybiB0aGlzW2tIYW5kbGVyXS5vbkRhdGEoQSl9Y2F0Y2godCl7cmV0dXJuIHRoaXMuYWJvcnQodCksITF9fW9uVXBncmFkZShBLHQsbil7cmV0dXJuIGFzc2VydCRjKCF0aGlzLmFib3J0ZWQpLGFzc2VydCRjKCF0aGlzLmNvbXBsZXRlZCksdGhpc1trSGFuZGxlcl0ub25VcGdyYWRlKEEsdCxuKX1vbkNvbXBsZXRlKEEpe3RoaXMub25GaW5hbGx5KCksYXNzZXJ0JGMoIXRoaXMuYWJvcnRlZCksdGhpcy5jb21wbGV0ZWQ9ITAsY2hhbm5lbHMkMi50cmFpbGVycy5oYXNTdWJzY3JpYmVycyYmY2hhbm5lbHMkMi50cmFpbGVycy5wdWJsaXNoKHtyZXF1ZXN0OnRoaXMsdHJhaWxlcnM6QX0pO3RyeXtyZXR1cm4gdGhpc1trSGFuZGxlcl0ub25Db21wbGV0ZShBKX1jYXRjaCh0KXt0aGlzLm9uRXJyb3IodCl9fW9uRXJyb3IoQSl7aWYodGhpcy5vbkZpbmFsbHkoKSxjaGFubmVscyQyLmVycm9yLmhhc1N1YnNjcmliZXJzJiZjaGFubmVscyQyLmVycm9yLnB1Ymxpc2goe3JlcXVlc3Q6dGhpcyxlcnJvcjpBfSksIXRoaXMuYWJvcnRlZClyZXR1cm4gdGhpcy5hYm9ydGVkPSEwLHRoaXNba0hhbmRsZXJdLm9uRXJyb3IoQSl9b25GaW5hbGx5KCl7dGhpcy5lcnJvckhhbmRsZXImJih0aGlzLmJvZHkub2ZmKFwiZXJyb3JcIix0aGlzLmVycm9ySGFuZGxlciksdGhpcy5lcnJvckhhbmRsZXI9bnVsbCksdGhpcy5lbmRIYW5kbGVyJiYodGhpcy5ib2R5Lm9mZihcImVuZFwiLHRoaXMuZW5kSGFuZGxlciksdGhpcy5lbmRIYW5kbGVyPW51bGwpfWFkZEhlYWRlcihBLHQpe3JldHVybiBwcm9jZXNzSGVhZGVyKHRoaXMsQSx0KSx0aGlzfX0sbyh3ZSxcIlJlcXVlc3RcIiksd2UpO2Z1bmN0aW9uIHByb2Nlc3NIZWFkZXIoZSxBLHQpe2lmKHQmJnR5cGVvZiB0PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaShgaW52YWxpZCAke0F9IGhlYWRlcmApO2lmKHQ9PT12b2lkIDApcmV0dXJuO2xldCBuPWhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW0FdO2lmKG49PT12b2lkIDAmJihuPUEudG9Mb3dlckNhc2UoKSxoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFtuXT09PXZvaWQgMCYmIWlzVmFsaWRIVFRQVG9rZW4obikpKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRpKFwiaW52YWxpZCBoZWFkZXIga2V5XCIpO2lmKEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IHI9W107Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspaWYodHlwZW9mIHRbc109PVwic3RyaW5nXCIpe2lmKCFpc1ZhbGlkSGVhZGVyQ2hhcih0W3NdKSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaShgaW52YWxpZCAke0F9IGhlYWRlcmApO3IucHVzaCh0W3NdKX1lbHNlIGlmKHRbc109PT1udWxsKXIucHVzaChcIlwiKTtlbHNle2lmKHR5cGVvZiB0W3NdPT1cIm9iamVjdFwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRpKGBpbnZhbGlkICR7QX0gaGVhZGVyYCk7ci5wdXNoKGAke3Rbc119YCl9dD1yfWVsc2UgaWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpe2lmKCFpc1ZhbGlkSGVhZGVyQ2hhcih0KSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaShgaW52YWxpZCAke0F9IGhlYWRlcmApfWVsc2UgaWYodD09PW51bGwpdD1cIlwiO2Vsc2V7aWYodHlwZW9mIHQ9PVwib2JqZWN0XCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGkoYGludmFsaWQgJHtBfSBoZWFkZXJgKTt0PWAke3R9YH1pZihlLmhvc3Q9PT1udWxsJiZuPT09XCJob3N0XCIpe2lmKHR5cGVvZiB0IT1cInN0cmluZ1wiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRpKFwiaW52YWxpZCBob3N0IGhlYWRlclwiKTtlLmhvc3Q9dH1lbHNlIGlmKGUuY29udGVudExlbmd0aD09PW51bGwmJm49PT1cImNvbnRlbnQtbGVuZ3RoXCIpe2lmKGUuY29udGVudExlbmd0aD1wYXJzZUludCh0LDEwKSwhTnVtYmVyLmlzRmluaXRlKGUuY29udGVudExlbmd0aCkpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGkoXCJpbnZhbGlkIGNvbnRlbnQtbGVuZ3RoIGhlYWRlclwiKX1lbHNlIGlmKGUuY29udGVudFR5cGU9PT1udWxsJiZuPT09XCJjb250ZW50LXR5cGVcIillLmNvbnRlbnRUeXBlPXQsZS5oZWFkZXJzLnB1c2goQSx0KTtlbHNle2lmKG49PT1cInRyYW5zZmVyLWVuY29kaW5nXCJ8fG49PT1cImtlZXAtYWxpdmVcInx8bj09PVwidXBncmFkZVwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRpKGBpbnZhbGlkICR7bn0gaGVhZGVyYCk7aWYobj09PVwiY29ubmVjdGlvblwiKXtjb25zdCByPXR5cGVvZiB0PT1cInN0cmluZ1wiP3QudG9Mb3dlckNhc2UoKTpudWxsO2lmKHIhPT1cImNsb3NlXCImJnIhPT1cImtlZXAtYWxpdmVcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaShcImludmFsaWQgY29ubmVjdGlvbiBoZWFkZXJcIik7cj09PVwiY2xvc2VcIiYmKGUucmVzZXQ9ITApfWVsc2V7aWYobj09PVwiZXhwZWN0XCIpdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yJDEoXCJleHBlY3QgaGVhZGVyIG5vdCBzdXBwb3J0ZWRcIik7ZS5oZWFkZXJzLnB1c2goQSx0KX19fW8ocHJvY2Vzc0hlYWRlcixcInByb2Nlc3NIZWFkZXJcIik7dmFyIHJlcXVlc3QkMj1SZXF1ZXN0JDE7Y29uc3QgRXZlbnRFbWl0dGVyPXJlcXVpcmUkJDBfX2RlZmF1bHQkMztsZXQgRGlzcGF0Y2hlciQyPShrZT1jbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcntkaXNwYXRjaCgpe3Rocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKX1jbG9zZSgpe3Rocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKX1kZXN0cm95KCl7dGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpfWNvbXBvc2UoLi4uQSl7Y29uc3QgdD1BcnJheS5pc0FycmF5KEFbMF0pP0FbMF06QTtsZXQgbj10aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7Zm9yKGNvbnN0IHIgb2YgdClpZihyIT1udWxsKXtpZih0eXBlb2YgciE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgaW50ZXJjZXB0b3IsIGV4cGVjdGVkIGZ1bmN0aW9uIHJlY2VpdmVkICR7dHlwZW9mIHJ9YCk7aWYobj1yKG4pLG49PW51bGx8fHR5cGVvZiBuIT1cImZ1bmN0aW9uXCJ8fG4ubGVuZ3RoIT09Mil0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBpbnRlcmNlcHRvclwiKX1yZXR1cm4gbmV3IENvbXBvc2VkRGlzcGF0Y2hlcih0aGlzLG4pfX0sbyhrZSxcIkRpc3BhdGNoZXJcIiksa2UpO2NvbnN0IHJ0PWNsYXNzIHJ0IGV4dGVuZHMgRGlzcGF0Y2hlciQye2NvbnN0cnVjdG9yKHQsbil7c3VwZXIoKTtDQSh0aGlzLF9BLG51bGwpO0NBKHRoaXMsTmUsbnVsbCk7RUEodGhpcyxfQSx0KSxFQSh0aGlzLE5lLG4pfWRpc3BhdGNoKC4uLnQpe3AodGhpcyxOZSkuY2FsbCh0aGlzLC4uLnQpfWNsb3NlKC4uLnQpe3JldHVybiBwKHRoaXMsX0EpLmNsb3NlKC4uLnQpfWRlc3Ryb3koLi4udCl7cmV0dXJuIHAodGhpcyxfQSkuZGVzdHJveSguLi50KX19O19BPW5ldyBXZWFrTWFwLE5lPW5ldyBXZWFrTWFwLG8ocnQsXCJDb21wb3NlZERpc3BhdGNoZXJcIik7bGV0IENvbXBvc2VkRGlzcGF0Y2hlcj1ydDt2YXIgZGlzcGF0Y2hlcj1EaXNwYXRjaGVyJDI7Y29uc3QgRGlzcGF0Y2hlciQxPWRpc3BhdGNoZXIse0NsaWVudERlc3Ryb3llZEVycm9yOkNsaWVudERlc3Ryb3llZEVycm9yJDEsQ2xpZW50Q2xvc2VkRXJyb3IsSW52YWxpZEFyZ3VtZW50RXJyb3I6SW52YWxpZEFyZ3VtZW50RXJyb3IkaH09ZXJyb3JzJDEse2tEZXN0cm95OmtEZXN0cm95JDQsa0Nsb3NlOmtDbG9zZSQ2LGtEaXNwYXRjaDprRGlzcGF0Y2gkMyxrSW50ZXJjZXB0b3JzOmtJbnRlcmNlcHRvcnMkNH09c3ltYm9scyQ0LGtEZXN0cm95ZWQ9U3ltYm9sKFwiZGVzdHJveWVkXCIpLGtDbG9zZWQ9U3ltYm9sKFwiY2xvc2VkXCIpLGtPbkRlc3Ryb3llZD1TeW1ib2woXCJvbkRlc3Ryb3llZFwiKSxrT25DbG9zZWQ9U3ltYm9sKFwib25DbG9zZWRcIiksa0ludGVyY2VwdGVkRGlzcGF0Y2g9U3ltYm9sKFwiSW50ZXJjZXB0ZWQgRGlzcGF0Y2hcIik7bGV0IERpc3BhdGNoZXJCYXNlJDQ9KEZlPWNsYXNzIGV4dGVuZHMgRGlzcGF0Y2hlciQxe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzW2tEZXN0cm95ZWRdPSExLHRoaXNba09uRGVzdHJveWVkXT1udWxsLHRoaXNba0Nsb3NlZF09ITEsdGhpc1trT25DbG9zZWRdPVtdfWdldCBkZXN0cm95ZWQoKXtyZXR1cm4gdGhpc1trRGVzdHJveWVkXX1nZXQgY2xvc2VkKCl7cmV0dXJuIHRoaXNba0Nsb3NlZF19Z2V0IGludGVyY2VwdG9ycygpe3JldHVybiB0aGlzW2tJbnRlcmNlcHRvcnMkNF19c2V0IGludGVyY2VwdG9ycyhBKXtpZihBKXtmb3IobGV0IHQ9QS5sZW5ndGgtMTt0Pj0wO3QtLSlpZih0eXBlb2YgdGhpc1trSW50ZXJjZXB0b3JzJDRdW3RdIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGgoXCJpbnRlcmNlcHRvciBtdXN0IGJlIGFuIGZ1bmN0aW9uXCIpfXRoaXNba0ludGVyY2VwdG9ycyQ0XT1BfWNsb3NlKEEpe2lmKEE9PT12b2lkIDApcmV0dXJuIG5ldyBQcm9taXNlKChuLHIpPT57dGhpcy5jbG9zZSgocyxpKT0+cz9yKHMpOm4oaSkpfSk7aWYodHlwZW9mIEEhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaChcImludmFsaWQgY2FsbGJhY2tcIik7aWYodGhpc1trRGVzdHJveWVkXSl7cXVldWVNaWNyb3Rhc2soKCk9PkEobmV3IENsaWVudERlc3Ryb3llZEVycm9yJDEsbnVsbCkpO3JldHVybn1pZih0aGlzW2tDbG9zZWRdKXt0aGlzW2tPbkNsb3NlZF0/dGhpc1trT25DbG9zZWRdLnB1c2goQSk6cXVldWVNaWNyb3Rhc2soKCk9PkEobnVsbCxudWxsKSk7cmV0dXJufXRoaXNba0Nsb3NlZF09ITAsdGhpc1trT25DbG9zZWRdLnB1c2goQSk7Y29uc3QgdD1vKCgpPT57Y29uc3Qgbj10aGlzW2tPbkNsb3NlZF07dGhpc1trT25DbG9zZWRdPW51bGw7Zm9yKGxldCByPTA7cjxuLmxlbmd0aDtyKyspbltyXShudWxsLG51bGwpfSxcIm9uQ2xvc2VkXCIpO3RoaXNba0Nsb3NlJDZdKCkudGhlbigoKT0+dGhpcy5kZXN0cm95KCkpLnRoZW4oKCk9PntxdWV1ZU1pY3JvdGFzayh0KX0pfWRlc3Ryb3koQSx0KXtpZih0eXBlb2YgQT09XCJmdW5jdGlvblwiJiYodD1BLEE9bnVsbCksdD09PXZvaWQgMClyZXR1cm4gbmV3IFByb21pc2UoKHIscyk9Pnt0aGlzLmRlc3Ryb3koQSwoaSxFKT0+aT9zKGkpOnIoRSkpfSk7aWYodHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaChcImludmFsaWQgY2FsbGJhY2tcIik7aWYodGhpc1trRGVzdHJveWVkXSl7dGhpc1trT25EZXN0cm95ZWRdP3RoaXNba09uRGVzdHJveWVkXS5wdXNoKHQpOnF1ZXVlTWljcm90YXNrKCgpPT50KG51bGwsbnVsbCkpO3JldHVybn1BfHwoQT1uZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IkMSksdGhpc1trRGVzdHJveWVkXT0hMCx0aGlzW2tPbkRlc3Ryb3llZF09dGhpc1trT25EZXN0cm95ZWRdfHxbXSx0aGlzW2tPbkRlc3Ryb3llZF0ucHVzaCh0KTtjb25zdCBuPW8oKCk9Pntjb25zdCByPXRoaXNba09uRGVzdHJveWVkXTt0aGlzW2tPbkRlc3Ryb3llZF09bnVsbDtmb3IobGV0IHM9MDtzPHIubGVuZ3RoO3MrKylyW3NdKG51bGwsbnVsbCl9LFwib25EZXN0cm95ZWRcIik7dGhpc1trRGVzdHJveSQ0XShBKS50aGVuKCgpPT57cXVldWVNaWNyb3Rhc2sobil9KX1ba0ludGVyY2VwdGVkRGlzcGF0Y2hdKEEsdCl7aWYoIXRoaXNba0ludGVyY2VwdG9ycyQ0XXx8dGhpc1trSW50ZXJjZXB0b3JzJDRdLmxlbmd0aD09PTApcmV0dXJuIHRoaXNba0ludGVyY2VwdGVkRGlzcGF0Y2hdPXRoaXNba0Rpc3BhdGNoJDNdLHRoaXNba0Rpc3BhdGNoJDNdKEEsdCk7bGV0IG49dGhpc1trRGlzcGF0Y2gkM10uYmluZCh0aGlzKTtmb3IobGV0IHI9dGhpc1trSW50ZXJjZXB0b3JzJDRdLmxlbmd0aC0xO3I+PTA7ci0tKW49dGhpc1trSW50ZXJjZXB0b3JzJDRdW3JdKG4pO3JldHVybiB0aGlzW2tJbnRlcmNlcHRlZERpc3BhdGNoXT1uLG4oQSx0KX1kaXNwYXRjaChBLHQpe2lmKCF0fHx0eXBlb2YgdCE9XCJvYmplY3RcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaChcImhhbmRsZXIgbXVzdCBiZSBhbiBvYmplY3RcIik7dHJ5e2lmKCFBfHx0eXBlb2YgQSE9XCJvYmplY3RcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkaChcIm9wdHMgbXVzdCBiZSBhbiBvYmplY3QuXCIpO2lmKHRoaXNba0Rlc3Ryb3llZF18fHRoaXNba09uRGVzdHJveWVkXSl0aHJvdyBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IkMTtpZih0aGlzW2tDbG9zZWRdKXRocm93IG5ldyBDbGllbnRDbG9zZWRFcnJvcjtyZXR1cm4gdGhpc1trSW50ZXJjZXB0ZWREaXNwYXRjaF0oQSx0KX1jYXRjaChuKXtpZih0eXBlb2YgdC5vbkVycm9yIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGgoXCJpbnZhbGlkIG9uRXJyb3IgbWV0aG9kXCIpO3JldHVybiB0Lm9uRXJyb3IobiksITF9fX0sbyhGZSxcIkRpc3BhdGNoZXJCYXNlXCIpLEZlKTt2YXIgZGlzcGF0Y2hlckJhc2U9RGlzcGF0Y2hlckJhc2UkNDtjb25zdCBuZXQkMT1yZXF1aXJlJCQ0X19kZWZhdWx0LGFzc2VydCRiPXJlcXVpcmUkJDBfX2RlZmF1bHQsdXRpbCRrPXV0aWwkbSx7SW52YWxpZEFyZ3VtZW50RXJyb3I6SW52YWxpZEFyZ3VtZW50RXJyb3IkZyxDb25uZWN0VGltZW91dEVycm9yfT1lcnJvcnMkMTtsZXQgdGxzLFNlc3Npb25DYWNoZTtfY29tbW9uanNIZWxwZXJzLmNvbW1vbmpzR2xvYmFsLkZpbmFsaXphdGlvblJlZ2lzdHJ5JiYhKHByb2Nlc3MuZW52Lk5PREVfVjhfQ09WRVJBR0V8fHByb2Nlc3MuZW52LlVORElDSV9OT19GRyk/U2Vzc2lvbkNhY2hlPShwZT1jbGFzc3tjb25zdHJ1Y3RvcihBKXt0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucz1BLHRoaXMuX3Nlc3Npb25DYWNoZT1uZXcgTWFwLHRoaXMuX3Nlc3Npb25SZWdpc3RyeT1uZXcgX2NvbW1vbmpzSGVscGVycy5jb21tb25qc0dsb2JhbC5GaW5hbGl6YXRpb25SZWdpc3RyeSh0PT57aWYodGhpcy5fc2Vzc2lvbkNhY2hlLnNpemU8dGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMpcmV0dXJuO2NvbnN0IG49dGhpcy5fc2Vzc2lvbkNhY2hlLmdldCh0KTtuIT09dm9pZCAwJiZuLmRlcmVmKCk9PT12b2lkIDAmJnRoaXMuX3Nlc3Npb25DYWNoZS5kZWxldGUodCl9KX1nZXQoQSl7Y29uc3QgdD10aGlzLl9zZXNzaW9uQ2FjaGUuZ2V0KEEpO3JldHVybiB0P3QuZGVyZWYoKTpudWxsfXNldChBLHQpe3RoaXMuX21heENhY2hlZFNlc3Npb25zIT09MCYmKHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoQSxuZXcgV2Vha1JlZih0KSksdGhpcy5fc2Vzc2lvblJlZ2lzdHJ5LnJlZ2lzdGVyKHQsQSkpfX0sbyhwZSxcIldlYWtTZXNzaW9uQ2FjaGVcIikscGUpOlNlc3Npb25DYWNoZT0oU2U9Y2xhc3N7Y29uc3RydWN0b3IoQSl7dGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnM9QSx0aGlzLl9zZXNzaW9uQ2FjaGU9bmV3IE1hcH1nZXQoQSl7cmV0dXJuIHRoaXMuX3Nlc3Npb25DYWNoZS5nZXQoQSl9c2V0KEEsdCl7aWYodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMhPT0wKXtpZih0aGlzLl9zZXNzaW9uQ2FjaGUuc2l6ZT49dGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMpe2NvbnN0e3ZhbHVlOm59PXRoaXMuX3Nlc3Npb25DYWNoZS5rZXlzKCkubmV4dCgpO3RoaXMuX3Nlc3Npb25DYWNoZS5kZWxldGUobil9dGhpcy5fc2Vzc2lvbkNhY2hlLnNldChBLHQpfX19LG8oU2UsXCJTaW1wbGVTZXNzaW9uQ2FjaGVcIiksU2UpO2Z1bmN0aW9uIGJ1aWxkQ29ubmVjdG9yJDMoe2FsbG93SDI6ZSxtYXhDYWNoZWRTZXNzaW9uczpBLHNvY2tldFBhdGg6dCx0aW1lb3V0Om4sLi4ucn0pe2lmKEEhPW51bGwmJighTnVtYmVyLmlzSW50ZWdlcihBKXx8QTwwKSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkZyhcIm1heENhY2hlZFNlc3Npb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm9cIik7Y29uc3Qgcz17cGF0aDp0LC4uLnJ9LGk9bmV3IFNlc3Npb25DYWNoZShBPz8xMDApO3JldHVybiBuPW4/PzFlNCxlPWU/PyExLG8oZnVuY3Rpb24oe2hvc3RuYW1lOlEsaG9zdDpDLHByb3RvY29sOkkscG9ydDphLHNlcnZlcm5hbWU6Zixsb2NhbEFkZHJlc3M6aCxodHRwU29ja2V0Okx9LGMpe2xldCBsO2lmKEk9PT1cImh0dHBzOlwiKXt0bHN8fCh0bHM9cmVxdWlyZSQkNF9fZGVmYXVsdCQxKSxmPWZ8fHMuc2VydmVybmFtZXx8dXRpbCRrLmdldFNlcnZlck5hbWUoQyl8fG51bGw7Y29uc3Qgaz1mfHxRLHc9aS5nZXQoayl8fG51bGw7YXNzZXJ0JGIoayksbD10bHMuY29ubmVjdCh7aGlnaFdhdGVyTWFyazoxNjM4NCwuLi5zLHNlcnZlcm5hbWU6ZixzZXNzaW9uOncsbG9jYWxBZGRyZXNzOmgsQUxQTlByb3RvY29sczplP1tcImh0dHAvMS4xXCIsXCJoMlwiXTpbXCJodHRwLzEuMVwiXSxzb2NrZXQ6TCxwb3J0OmF8fDQ0Myxob3N0OlF9KSxsLm9uKFwic2Vzc2lvblwiLGZ1bmN0aW9uKFUpe2kuc2V0KGssVSl9KX1lbHNlIGFzc2VydCRiKCFMLFwiaHR0cFNvY2tldCBjYW4gb25seSBiZSBzZW50IG9uIFRMUyB1cGRhdGVcIiksbD1uZXQkMS5jb25uZWN0KHtoaWdoV2F0ZXJNYXJrOjY0KjEwMjQsLi4ucyxsb2NhbEFkZHJlc3M6aCxwb3J0OmF8fDgwLGhvc3Q6UX0pO2lmKHMua2VlcEFsaXZlPT1udWxsfHxzLmtlZXBBbGl2ZSl7Y29uc3Qgaz1zLmtlZXBBbGl2ZUluaXRpYWxEZWxheT09PXZvaWQgMD82ZTQ6cy5rZWVwQWxpdmVJbml0aWFsRGVsYXk7bC5zZXRLZWVwQWxpdmUoITAsayl9Y29uc3QgUz1zZXR1cFRpbWVvdXQoKCk9Pm9uQ29ubmVjdFRpbWVvdXQobCksbik7cmV0dXJuIGwuc2V0Tm9EZWxheSghMCkub25jZShJPT09XCJodHRwczpcIj9cInNlY3VyZUNvbm5lY3RcIjpcImNvbm5lY3RcIixmdW5jdGlvbigpe2lmKFMoKSxjKXtjb25zdCBrPWM7Yz1udWxsLGsobnVsbCx0aGlzKX19KS5vbihcImVycm9yXCIsZnVuY3Rpb24oayl7aWYoUygpLGMpe2NvbnN0IHc9YztjPW51bGwsdyhrKX19KSxsfSxcImNvbm5lY3RcIil9byhidWlsZENvbm5lY3RvciQzLFwiYnVpbGRDb25uZWN0b3IkM1wiKTtmdW5jdGlvbiBzZXR1cFRpbWVvdXQoZSxBKXtpZighQSlyZXR1cm4oKT0+e307bGV0IHQ9bnVsbCxuPW51bGw7Y29uc3Qgcj1zZXRUaW1lb3V0KCgpPT57dD1zZXRJbW1lZGlhdGUoKCk9Pntwcm9jZXNzLnBsYXRmb3JtPT09XCJ3aW4zMlwiP249c2V0SW1tZWRpYXRlKCgpPT5lKCkpOmUoKX0pfSxBKTtyZXR1cm4oKT0+e2NsZWFyVGltZW91dChyKSxjbGVhckltbWVkaWF0ZSh0KSxjbGVhckltbWVkaWF0ZShuKX19byhzZXR1cFRpbWVvdXQsXCJzZXR1cFRpbWVvdXRcIik7ZnVuY3Rpb24gb25Db25uZWN0VGltZW91dChlKXtsZXQgQT1cIkNvbm5lY3QgVGltZW91dCBFcnJvclwiO0FycmF5LmlzQXJyYXkoZS5hdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdGVkQWRkcmVzc2VzKSYmKEErPWAgKGF0dGVtcHRlZCBhZGRyZXNzZXM6ICR7ZS5hdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdGVkQWRkcmVzc2VzLmpvaW4oXCIsIFwiKX0pYCksdXRpbCRrLmRlc3Ryb3koZSxuZXcgQ29ubmVjdFRpbWVvdXRFcnJvcihBKSl9byhvbkNvbm5lY3RUaW1lb3V0LFwib25Db25uZWN0VGltZW91dFwiKTt2YXIgY29ubmVjdCQyPWJ1aWxkQ29ubmVjdG9yJDM7bGV0IGZhc3ROb3c9RGF0ZS5ub3coKSxmYXN0Tm93VGltZW91dDtjb25zdCBmYXN0VGltZXJzPVtdO2Z1bmN0aW9uIG9uVGltZW91dCgpe2Zhc3ROb3c9RGF0ZS5ub3coKTtsZXQgZT1mYXN0VGltZXJzLmxlbmd0aCxBPTA7Zm9yKDtBPGU7KXtjb25zdCB0PWZhc3RUaW1lcnNbQV07dC5zdGF0ZT09PTA/dC5zdGF0ZT1mYXN0Tm93K3QuZGVsYXk6dC5zdGF0ZT4wJiZmYXN0Tm93Pj10LnN0YXRlJiYodC5zdGF0ZT0tMSx0LmNhbGxiYWNrKHQub3BhcXVlKSksdC5zdGF0ZT09PS0xPyh0LnN0YXRlPS0yLEEhPT1lLTE/ZmFzdFRpbWVyc1tBXT1mYXN0VGltZXJzLnBvcCgpOmZhc3RUaW1lcnMucG9wKCksZS09MSk6QSs9MX1mYXN0VGltZXJzLmxlbmd0aD4wJiZyZWZyZXNoVGltZW91dCgpfW8ob25UaW1lb3V0LFwib25UaW1lb3V0XCIpO2Z1bmN0aW9uIHJlZnJlc2hUaW1lb3V0KCl7ZmFzdE5vd1RpbWVvdXQ/LnJlZnJlc2g/ZmFzdE5vd1RpbWVvdXQucmVmcmVzaCgpOihjbGVhclRpbWVvdXQoZmFzdE5vd1RpbWVvdXQpLGZhc3ROb3dUaW1lb3V0PXNldFRpbWVvdXQob25UaW1lb3V0LDFlMyksZmFzdE5vd1RpbWVvdXQudW5yZWYmJmZhc3ROb3dUaW1lb3V0LnVucmVmKCkpfW8ocmVmcmVzaFRpbWVvdXQsXCJyZWZyZXNoVGltZW91dFwiKTtjb25zdCBudD1jbGFzcyBudHtjb25zdHJ1Y3RvcihBLHQsbil7dGhpcy5jYWxsYmFjaz1BLHRoaXMuZGVsYXk9dCx0aGlzLm9wYXF1ZT1uLHRoaXMuc3RhdGU9LTIsdGhpcy5yZWZyZXNoKCl9cmVmcmVzaCgpe3RoaXMuc3RhdGU9PT0tMiYmKGZhc3RUaW1lcnMucHVzaCh0aGlzKSwoIWZhc3ROb3dUaW1lb3V0fHxmYXN0VGltZXJzLmxlbmd0aD09PTEpJiZyZWZyZXNoVGltZW91dCgpKSx0aGlzLnN0YXRlPTB9Y2xlYXIoKXt0aGlzLnN0YXRlPS0xfX07byhudCxcIlRpbWVvdXRcIik7bGV0IFRpbWVvdXQ9bnQ7dmFyIHRpbWVycyQxPXtzZXRUaW1lb3V0KGUsQSx0KXtyZXR1cm4gQTwxZTM/c2V0VGltZW91dChlLEEsdCk6bmV3IFRpbWVvdXQoZSxBLHQpfSxjbGVhclRpbWVvdXQoZSl7ZSBpbnN0YW5jZW9mIFRpbWVvdXQ/ZS5jbGVhcigpOmNsZWFyVGltZW91dChlKX19LGNvbnN0YW50cyQ0PXt9LHV0aWxzPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1dGlscyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx1dGlscy5lbnVtVG9NYXA9dm9pZCAwO2Z1bmN0aW9uIGVudW1Ub01hcChlKXtjb25zdCBBPXt9O3JldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKHQ9Pntjb25zdCBuPWVbdF07dHlwZW9mIG49PVwibnVtYmVyXCImJihBW3RdPW4pfSksQX1vKGVudW1Ub01hcCxcImVudW1Ub01hcFwiKSx1dGlscy5lbnVtVG9NYXA9ZW51bVRvTWFwLGZ1bmN0aW9uKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuU1BFQ0lBTF9IRUFERVJTPWUuSEVBREVSX1NUQVRFPWUuTUlOT1I9ZS5NQUpPUj1lLkNPTk5FQ1RJT05fVE9LRU5fQ0hBUlM9ZS5IRUFERVJfQ0hBUlM9ZS5UT0tFTj1lLlNUUklDVF9UT0tFTj1lLkhFWD1lLlVSTF9DSEFSPWUuU1RSSUNUX1VSTF9DSEFSPWUuVVNFUklORk9fQ0hBUlM9ZS5NQVJLPWUuQUxQSEFOVU09ZS5OVU09ZS5IRVhfTUFQPWUuTlVNX01BUD1lLkFMUEhBPWUuRklOSVNIPWUuSF9NRVRIT0RfTUFQPWUuTUVUSE9EX01BUD1lLk1FVEhPRFNfUlRTUD1lLk1FVEhPRFNfSUNFPWUuTUVUSE9EU19IVFRQPWUuTUVUSE9EUz1lLkxFTklFTlRfRkxBR1M9ZS5GTEFHUz1lLlRZUEU9ZS5FUlJPUj12b2lkIDA7Y29uc3QgQT11dGlsczsoZnVuY3Rpb24ocil7cltyLk9LPTBdPVwiT0tcIixyW3IuSU5URVJOQUw9MV09XCJJTlRFUk5BTFwiLHJbci5TVFJJQ1Q9Ml09XCJTVFJJQ1RcIixyW3IuTEZfRVhQRUNURUQ9M109XCJMRl9FWFBFQ1RFRFwiLHJbci5VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIPTRdPVwiVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSFwiLHJbci5DTE9TRURfQ09OTkVDVElPTj01XT1cIkNMT1NFRF9DT05ORUNUSU9OXCIscltyLklOVkFMSURfTUVUSE9EPTZdPVwiSU5WQUxJRF9NRVRIT0RcIixyW3IuSU5WQUxJRF9VUkw9N109XCJJTlZBTElEX1VSTFwiLHJbci5JTlZBTElEX0NPTlNUQU5UPThdPVwiSU5WQUxJRF9DT05TVEFOVFwiLHJbci5JTlZBTElEX1ZFUlNJT049OV09XCJJTlZBTElEX1ZFUlNJT05cIixyW3IuSU5WQUxJRF9IRUFERVJfVE9LRU49MTBdPVwiSU5WQUxJRF9IRUFERVJfVE9LRU5cIixyW3IuSU5WQUxJRF9DT05URU5UX0xFTkdUSD0xMV09XCJJTlZBTElEX0NPTlRFTlRfTEVOR1RIXCIscltyLklOVkFMSURfQ0hVTktfU0laRT0xMl09XCJJTlZBTElEX0NIVU5LX1NJWkVcIixyW3IuSU5WQUxJRF9TVEFUVVM9MTNdPVwiSU5WQUxJRF9TVEFUVVNcIixyW3IuSU5WQUxJRF9FT0ZfU1RBVEU9MTRdPVwiSU5WQUxJRF9FT0ZfU1RBVEVcIixyW3IuSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORz0xNV09XCJJTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HXCIscltyLkNCX01FU1NBR0VfQkVHSU49MTZdPVwiQ0JfTUVTU0FHRV9CRUdJTlwiLHJbci5DQl9IRUFERVJTX0NPTVBMRVRFPTE3XT1cIkNCX0hFQURFUlNfQ09NUExFVEVcIixyW3IuQ0JfTUVTU0FHRV9DT01QTEVURT0xOF09XCJDQl9NRVNTQUdFX0NPTVBMRVRFXCIscltyLkNCX0NIVU5LX0hFQURFUj0xOV09XCJDQl9DSFVOS19IRUFERVJcIixyW3IuQ0JfQ0hVTktfQ09NUExFVEU9MjBdPVwiQ0JfQ0hVTktfQ09NUExFVEVcIixyW3IuUEFVU0VEPTIxXT1cIlBBVVNFRFwiLHJbci5QQVVTRURfVVBHUkFERT0yMl09XCJQQVVTRURfVVBHUkFERVwiLHJbci5QQVVTRURfSDJfVVBHUkFERT0yM109XCJQQVVTRURfSDJfVVBHUkFERVwiLHJbci5VU0VSPTI0XT1cIlVTRVJcIn0pKGUuRVJST1J8fChlLkVSUk9SPXt9KSksZnVuY3Rpb24ocil7cltyLkJPVEg9MF09XCJCT1RIXCIscltyLlJFUVVFU1Q9MV09XCJSRVFVRVNUXCIscltyLlJFU1BPTlNFPTJdPVwiUkVTUE9OU0VcIn0oZS5UWVBFfHwoZS5UWVBFPXt9KSksZnVuY3Rpb24ocil7cltyLkNPTk5FQ1RJT05fS0VFUF9BTElWRT0xXT1cIkNPTk5FQ1RJT05fS0VFUF9BTElWRVwiLHJbci5DT05ORUNUSU9OX0NMT1NFPTJdPVwiQ09OTkVDVElPTl9DTE9TRVwiLHJbci5DT05ORUNUSU9OX1VQR1JBREU9NF09XCJDT05ORUNUSU9OX1VQR1JBREVcIixyW3IuQ0hVTktFRD04XT1cIkNIVU5LRURcIixyW3IuVVBHUkFERT0xNl09XCJVUEdSQURFXCIscltyLkNPTlRFTlRfTEVOR1RIPTMyXT1cIkNPTlRFTlRfTEVOR1RIXCIscltyLlNLSVBCT0RZPTY0XT1cIlNLSVBCT0RZXCIscltyLlRSQUlMSU5HPTEyOF09XCJUUkFJTElOR1wiLHJbci5UUkFOU0ZFUl9FTkNPRElORz01MTJdPVwiVFJBTlNGRVJfRU5DT0RJTkdcIn0oZS5GTEFHU3x8KGUuRkxBR1M9e30pKSxmdW5jdGlvbihyKXtyW3IuSEVBREVSUz0xXT1cIkhFQURFUlNcIixyW3IuQ0hVTktFRF9MRU5HVEg9Ml09XCJDSFVOS0VEX0xFTkdUSFwiLHJbci5LRUVQX0FMSVZFPTRdPVwiS0VFUF9BTElWRVwifShlLkxFTklFTlRfRkxBR1N8fChlLkxFTklFTlRfRkxBR1M9e30pKTt2YXIgdDsoZnVuY3Rpb24ocil7cltyLkRFTEVURT0wXT1cIkRFTEVURVwiLHJbci5HRVQ9MV09XCJHRVRcIixyW3IuSEVBRD0yXT1cIkhFQURcIixyW3IuUE9TVD0zXT1cIlBPU1RcIixyW3IuUFVUPTRdPVwiUFVUXCIscltyLkNPTk5FQ1Q9NV09XCJDT05ORUNUXCIscltyLk9QVElPTlM9Nl09XCJPUFRJT05TXCIscltyLlRSQUNFPTddPVwiVFJBQ0VcIixyW3IuQ09QWT04XT1cIkNPUFlcIixyW3IuTE9DSz05XT1cIkxPQ0tcIixyW3IuTUtDT0w9MTBdPVwiTUtDT0xcIixyW3IuTU9WRT0xMV09XCJNT1ZFXCIscltyLlBST1BGSU5EPTEyXT1cIlBST1BGSU5EXCIscltyLlBST1BQQVRDSD0xM109XCJQUk9QUEFUQ0hcIixyW3IuU0VBUkNIPTE0XT1cIlNFQVJDSFwiLHJbci5VTkxPQ0s9MTVdPVwiVU5MT0NLXCIscltyLkJJTkQ9MTZdPVwiQklORFwiLHJbci5SRUJJTkQ9MTddPVwiUkVCSU5EXCIscltyLlVOQklORD0xOF09XCJVTkJJTkRcIixyW3IuQUNMPTE5XT1cIkFDTFwiLHJbci5SRVBPUlQ9MjBdPVwiUkVQT1JUXCIscltyLk1LQUNUSVZJVFk9MjFdPVwiTUtBQ1RJVklUWVwiLHJbci5DSEVDS09VVD0yMl09XCJDSEVDS09VVFwiLHJbci5NRVJHRT0yM109XCJNRVJHRVwiLHJbcltcIk0tU0VBUkNIXCJdPTI0XT1cIk0tU0VBUkNIXCIscltyLk5PVElGWT0yNV09XCJOT1RJRllcIixyW3IuU1VCU0NSSUJFPTI2XT1cIlNVQlNDUklCRVwiLHJbci5VTlNVQlNDUklCRT0yN109XCJVTlNVQlNDUklCRVwiLHJbci5QQVRDSD0yOF09XCJQQVRDSFwiLHJbci5QVVJHRT0yOV09XCJQVVJHRVwiLHJbci5NS0NBTEVOREFSPTMwXT1cIk1LQ0FMRU5EQVJcIixyW3IuTElOSz0zMV09XCJMSU5LXCIscltyLlVOTElOSz0zMl09XCJVTkxJTktcIixyW3IuU09VUkNFPTMzXT1cIlNPVVJDRVwiLHJbci5QUkk9MzRdPVwiUFJJXCIscltyLkRFU0NSSUJFPTM1XT1cIkRFU0NSSUJFXCIscltyLkFOTk9VTkNFPTM2XT1cIkFOTk9VTkNFXCIscltyLlNFVFVQPTM3XT1cIlNFVFVQXCIscltyLlBMQVk9MzhdPVwiUExBWVwiLHJbci5QQVVTRT0zOV09XCJQQVVTRVwiLHJbci5URUFSRE9XTj00MF09XCJURUFSRE9XTlwiLHJbci5HRVRfUEFSQU1FVEVSPTQxXT1cIkdFVF9QQVJBTUVURVJcIixyW3IuU0VUX1BBUkFNRVRFUj00Ml09XCJTRVRfUEFSQU1FVEVSXCIscltyLlJFRElSRUNUPTQzXT1cIlJFRElSRUNUXCIscltyLlJFQ09SRD00NF09XCJSRUNPUkRcIixyW3IuRkxVU0g9NDVdPVwiRkxVU0hcIn0pKHQ9ZS5NRVRIT0RTfHwoZS5NRVRIT0RTPXt9KSksZS5NRVRIT0RTX0hUVFA9W3QuREVMRVRFLHQuR0VULHQuSEVBRCx0LlBPU1QsdC5QVVQsdC5DT05ORUNULHQuT1BUSU9OUyx0LlRSQUNFLHQuQ09QWSx0LkxPQ0ssdC5NS0NPTCx0Lk1PVkUsdC5QUk9QRklORCx0LlBST1BQQVRDSCx0LlNFQVJDSCx0LlVOTE9DSyx0LkJJTkQsdC5SRUJJTkQsdC5VTkJJTkQsdC5BQ0wsdC5SRVBPUlQsdC5NS0FDVElWSVRZLHQuQ0hFQ0tPVVQsdC5NRVJHRSx0W1wiTS1TRUFSQ0hcIl0sdC5OT1RJRlksdC5TVUJTQ1JJQkUsdC5VTlNVQlNDUklCRSx0LlBBVENILHQuUFVSR0UsdC5NS0NBTEVOREFSLHQuTElOSyx0LlVOTElOSyx0LlBSSSx0LlNPVVJDRV0sZS5NRVRIT0RTX0lDRT1bdC5TT1VSQ0VdLGUuTUVUSE9EU19SVFNQPVt0Lk9QVElPTlMsdC5ERVNDUklCRSx0LkFOTk9VTkNFLHQuU0VUVVAsdC5QTEFZLHQuUEFVU0UsdC5URUFSRE9XTix0LkdFVF9QQVJBTUVURVIsdC5TRVRfUEFSQU1FVEVSLHQuUkVESVJFQ1QsdC5SRUNPUkQsdC5GTFVTSCx0LkdFVCx0LlBPU1RdLGUuTUVUSE9EX01BUD1BLmVudW1Ub01hcCh0KSxlLkhfTUVUSE9EX01BUD17fSxPYmplY3Qua2V5cyhlLk1FVEhPRF9NQVApLmZvckVhY2gocj0+ey9eSC8udGVzdChyKSYmKGUuSF9NRVRIT0RfTUFQW3JdPWUuTUVUSE9EX01BUFtyXSl9KSxmdW5jdGlvbihyKXtyW3IuU0FGRT0wXT1cIlNBRkVcIixyW3IuU0FGRV9XSVRIX0NCPTFdPVwiU0FGRV9XSVRIX0NCXCIscltyLlVOU0FGRT0yXT1cIlVOU0FGRVwifShlLkZJTklTSHx8KGUuRklOSVNIPXt9KSksZS5BTFBIQT1bXTtmb3IobGV0IHI9NjU7cjw9OTA7cisrKWUuQUxQSEEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHIpKSxlLkFMUEhBLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShyKzMyKSk7ZS5OVU1fTUFQPXswOjAsMToxLDI6MiwzOjMsNDo0LDU6NSw2OjYsNzo3LDg6OCw5Ojl9LGUuSEVYX01BUD17MDowLDE6MSwyOjIsMzozLDQ6NCw1OjUsNjo2LDc6Nyw4OjgsOTo5LEE6MTAsQjoxMSxDOjEyLEQ6MTMsRToxNCxGOjE1LGE6MTAsYjoxMSxjOjEyLGQ6MTMsZToxNCxmOjE1fSxlLk5VTT1bXCIwXCIsXCIxXCIsXCIyXCIsXCIzXCIsXCI0XCIsXCI1XCIsXCI2XCIsXCI3XCIsXCI4XCIsXCI5XCJdLGUuQUxQSEFOVU09ZS5BTFBIQS5jb25jYXQoZS5OVU0pLGUuTUFSSz1bXCItXCIsXCJfXCIsXCIuXCIsXCIhXCIsXCJ+XCIsXCIqXCIsXCInXCIsXCIoXCIsXCIpXCJdLGUuVVNFUklORk9fQ0hBUlM9ZS5BTFBIQU5VTS5jb25jYXQoZS5NQVJLKS5jb25jYXQoW1wiJVwiLFwiO1wiLFwiOlwiLFwiJlwiLFwiPVwiLFwiK1wiLFwiJFwiLFwiLFwiXSksZS5TVFJJQ1RfVVJMX0NIQVI9W1wiIVwiLCdcIicsXCIkXCIsXCIlXCIsXCImXCIsXCInXCIsXCIoXCIsXCIpXCIsXCIqXCIsXCIrXCIsXCIsXCIsXCItXCIsXCIuXCIsXCIvXCIsXCI6XCIsXCI7XCIsXCI8XCIsXCI9XCIsXCI+XCIsXCJAXCIsXCJbXCIsXCJcXFxcXCIsXCJdXCIsXCJeXCIsXCJfXCIsXCJgXCIsXCJ7XCIsXCJ8XCIsXCJ9XCIsXCJ+XCJdLmNvbmNhdChlLkFMUEhBTlVNKSxlLlVSTF9DSEFSPWUuU1RSSUNUX1VSTF9DSEFSLmNvbmNhdChbXCJcdFwiLFwiXFxmXCJdKTtmb3IobGV0IHI9MTI4O3I8PTI1NTtyKyspZS5VUkxfQ0hBUi5wdXNoKHIpO2UuSEVYPWUuTlVNLmNvbmNhdChbXCJhXCIsXCJiXCIsXCJjXCIsXCJkXCIsXCJlXCIsXCJmXCIsXCJBXCIsXCJCXCIsXCJDXCIsXCJEXCIsXCJFXCIsXCJGXCJdKSxlLlNUUklDVF9UT0tFTj1bXCIhXCIsXCIjXCIsXCIkXCIsXCIlXCIsXCImXCIsXCInXCIsXCIqXCIsXCIrXCIsXCItXCIsXCIuXCIsXCJeXCIsXCJfXCIsXCJgXCIsXCJ8XCIsXCJ+XCJdLmNvbmNhdChlLkFMUEhBTlVNKSxlLlRPS0VOPWUuU1RSSUNUX1RPS0VOLmNvbmNhdChbXCIgXCJdKSxlLkhFQURFUl9DSEFSUz1bXCJcdFwiXTtmb3IobGV0IHI9MzI7cjw9MjU1O3IrKylyIT09MTI3JiZlLkhFQURFUl9DSEFSUy5wdXNoKHIpO2UuQ09OTkVDVElPTl9UT0tFTl9DSEFSUz1lLkhFQURFUl9DSEFSUy5maWx0ZXIocj0+ciE9PTQ0KSxlLk1BSk9SPWUuTlVNX01BUCxlLk1JTk9SPWUuTUFKT1I7dmFyIG47KGZ1bmN0aW9uKHIpe3Jbci5HRU5FUkFMPTBdPVwiR0VORVJBTFwiLHJbci5DT05ORUNUSU9OPTFdPVwiQ09OTkVDVElPTlwiLHJbci5DT05URU5UX0xFTkdUSD0yXT1cIkNPTlRFTlRfTEVOR1RIXCIscltyLlRSQU5TRkVSX0VOQ09ESU5HPTNdPVwiVFJBTlNGRVJfRU5DT0RJTkdcIixyW3IuVVBHUkFERT00XT1cIlVQR1JBREVcIixyW3IuQ09OTkVDVElPTl9LRUVQX0FMSVZFPTVdPVwiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCIscltyLkNPTk5FQ1RJT05fQ0xPU0U9Nl09XCJDT05ORUNUSU9OX0NMT1NFXCIscltyLkNPTk5FQ1RJT05fVVBHUkFERT03XT1cIkNPTk5FQ1RJT05fVVBHUkFERVwiLHJbci5UUkFOU0ZFUl9FTkNPRElOR19DSFVOS0VEPThdPVwiVFJBTlNGRVJfRU5DT0RJTkdfQ0hVTktFRFwifSkobj1lLkhFQURFUl9TVEFURXx8KGUuSEVBREVSX1NUQVRFPXt9KSksZS5TUEVDSUFMX0hFQURFUlM9e2Nvbm5lY3Rpb246bi5DT05ORUNUSU9OLFwiY29udGVudC1sZW5ndGhcIjpuLkNPTlRFTlRfTEVOR1RILFwicHJveHktY29ubmVjdGlvblwiOm4uQ09OTkVDVElPTixcInRyYW5zZmVyLWVuY29kaW5nXCI6bi5UUkFOU0ZFUl9FTkNPRElORyx1cGdyYWRlOm4uVVBHUkFERX19KGNvbnN0YW50cyQ0KTt2YXIgbGxodHRwV2FzbSxoYXNSZXF1aXJlZExsaHR0cFdhc207ZnVuY3Rpb24gcmVxdWlyZUxsaHR0cFdhc20oKXtpZihoYXNSZXF1aXJlZExsaHR0cFdhc20pcmV0dXJuIGxsaHR0cFdhc207aGFzUmVxdWlyZWRMbGh0dHBXYXNtPTE7Y29uc3R7QnVmZmVyOmV9PXJlcXVpcmUkJDZfX2RlZmF1bHQ7cmV0dXJuIGxsaHR0cFdhc209ZS5mcm9tKFwiQUdGemJRRUFBQUFCTUFoZ0FYOEJmMkFEZjM5L0FYOWdCSDkvZjM4QmYyQUFBR0FEZjM5L0FHQUJmd0JnQW45L0FHQUdmMzkvZjM5L0FBTExBUWdEWlc1MkdIZGhjMjFmYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFBQ0EyVnVkaFYzWVhOdFgyOXVYMjFsYzNOaFoyVmZZbVZuYVc0QUFBTmxibllMZDJGemJWOXZibDkxY213QUFRTmxibllPZDJGemJWOXZibDl6ZEdGMGRYTUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmWm1sbGJHUUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFBUU5sYm5ZTWQyRnpiVjl2Ymw5aWIyUjVBQUVEWlc1MkdIZGhjMjFmYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlFBQUEwWkZBd01FQUFBRkFBQUFBQUFBQlFFRkFBVUZCUUFBQmdBQUFBQUdCZ1lHQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQUFBQkFRY0FBQVVGQXdBQkJBVUJjQUVTRWdVREFRQUNCZ2dCZndGQmdOUUVDd2ZSQlNJR2JXVnRiM0o1QWdBTFgybHVhWFJwWVd4cGVtVUFDUmxmWDJsdVpHbHlaV04wWDJaMWJtTjBhVzl1WDNSaFlteGxBUUFMYkd4b2RIUndYMmx1YVhRQUNoaHNiR2gwZEhCZmMyaHZkV3hrWDJ0bFpYQmZZV3hwZG1VQVFReHNiR2gwZEhCZllXeHNiMk1BREFadFlXeHNiMk1BUmd0c2JHaDBkSEJmWm5KbFpRQU5CR1p5WldVQVNBOXNiR2gwZEhCZloyVjBYM1I1Y0dVQURoVnNiR2gwZEhCZloyVjBYMmgwZEhCZmJXRnFiM0lBRHhWc2JHaDBkSEJmWjJWMFgyaDBkSEJmYldsdWIzSUFFQkZzYkdoMGRIQmZaMlYwWDIxbGRHaHZaQUFSRm14c2FIUjBjRjluWlhSZmMzUmhkSFZ6WDJOdlpHVUFFaEpzYkdoMGRIQmZaMlYwWDNWd1ozSmhaR1VBRXd4c2JHaDBkSEJmY21WelpYUUFGQTVzYkdoMGRIQmZaWGhsWTNWMFpRQVZGR3hzYUhSMGNGOXpaWFIwYVc1bmMxOXBibWwwQUJZTmJHeG9kSFJ3WDJacGJtbHphQUFYREd4c2FIUjBjRjl3WVhWelpRQVlEV3hzYUhSMGNGOXlaWE4xYldVQUdSdHNiR2gwZEhCZmNtVnpkVzFsWDJGbWRHVnlYM1Z3WjNKaFpHVUFHaEJzYkdoMGRIQmZaMlYwWDJWeWNtNXZBQnNYYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl5WldGemIyNEFIQmRzYkdoMGRIQmZjMlYwWDJWeWNtOXlYM0psWVhOdmJnQWRGR3hzYUhSMGNGOW5aWFJmWlhKeWIzSmZjRzl6QUI0UmJHeG9kSFJ3WDJWeWNtNXZYMjVoYldVQUh4SnNiR2gwZEhCZmJXVjBhRzlrWDI1aGJXVUFJQkpzYkdoMGRIQmZjM1JoZEhWelgyNWhiV1VBSVJwc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmFHVmhaR1Z5Y3dBaUlXeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOWphSFZ1YTJWa1gyeGxibWQwYUFBakhXeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOXJaV1Z3WDJGc2FYWmxBQ1FrYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDNSeVlXNXpabVZ5WDJWdVkyOWthVzVuQUNVWWJHeG9kSFJ3WDIxbGMzTmhaMlZmYm1WbFpITmZaVzltQUQ4SkZ3RUFRUUVMRVFFQ0F3UUZDd1lITlRrM01TOHRKeXNwQ3NMZ0FrVUNBQXNJQUJDSWdJQ0FBQXNaQUNBQUVNS0FnSUFBR2lBQUlBSTJBamdnQUNBQk9nQW9DeHdBSUFBZ0FDOEJNaUFBTFFBdUlBQVF3WUNBZ0FBUWdJQ0FnQUFMS2dFQmYwSEFBQkRHZ0lDQUFDSUJFTUtBZ0lBQUdpQUJRWUNJZ0lBQU5nSTRJQUVnQURvQUtDQUJDd29BSUFBUXlJQ0FnQUFMQndBZ0FDMEFLQXNIQUNBQUxRQXFDd2NBSUFBdEFDc0xCd0FnQUMwQUtRc0hBQ0FBTHdFeUN3Y0FJQUF0QUM0TFJRRUVmeUFBS0FJWUlRRWdBQzBBTFNFQ0lBQXRBQ2doQXlBQUtBSTRJUVFnQUJEQ2dJQ0FBQm9nQUNBRU5nSTRJQUFnQXpvQUtDQUFJQUk2QUMwZ0FDQUJOZ0lZQ3hFQUlBQWdBU0FCSUFKcUVNT0FnSUFBQ3hBQUlBQkJBRUhjQUJETWdJQ0FBQm9MWndFQmYwRUFJUUVDUUNBQUtBSU1EUUFDUUFKQUFrQUNRQ0FBTFFBdkRnTUJBQU1DQ3lBQUtBSTRJZ0ZGRFFBZ0FTZ0NMQ0lCUlEwQUlBQWdBUkdBZ0lDQUFBQWlBUTBEQzBFQUR3c1F5b0NBZ0FBQUN5QUFRY09XZ0lBQU5nSVFRUTRoQVFzZ0FRc2VBQUpBSUFBb0Fnd05BQ0FBUWRHYmdJQUFOZ0lRSUFCQkZUWUNEQXNMRmdBQ1FDQUFLQUlNUVJWSERRQWdBRUVBTmdJTUN3c1dBQUpBSUFBb0FneEJGa2NOQUNBQVFRQTJBZ3dMQ3djQUlBQW9BZ3dMQndBZ0FDZ0NFQXNKQUNBQUlBRTJBaEFMQndBZ0FDZ0NGQXNpQUFKQUlBQkJKRWtOQUJES2dJQ0FBQUFMSUFCQkFuUkJvTE9BZ0FCcUtBSUFDeUlBQWtBZ0FFRXVTUTBBRU1xQWdJQUFBQXNnQUVFQ2RFR3d0SUNBQUdvb0FnQUw3Z3NCQVg5QjY2aUFnQUFoQVFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkJuSDlxRHZRRFkySUFBV0ZoWVdGaFlRSURCQVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEJnY0lDUW9MREEwT0QyRmhZV0ZoRUdGaFlXRmhZV0ZoWVdGaEVXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlSSVRGQlVXRnhnWkdodGhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhIQjBlSHlBaElpTWtKU1luS0NrcUt5d3RMaTh3TVRJek5EVTJZVGM0T1RwaFlXRmhZV0ZoWVR0aFlXRThZV0ZoWVQwK1AyRmhZV0ZoWVdGaFFHRmhRV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVVKRFJFVkdSMGhKU2t0TVRVNVBVRkZTVTJGaFlXRmhZV0ZoVkZWV1YxaFpXbHRoWEYxaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmVZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhYMkJoQzBIaHA0Q0FBQThMUWFTaGdJQUFEd3RCeTZ5QWdBQVBDMEgrc1lDQUFBOExRY0NrZ0lBQUR3dEJxNlNBZ0FBUEMwR05xSUNBQUE4TFFlS21nSUFBRHd0QmdMQ0FnQUFQQzBHNXI0Q0FBQThMUWRla2dJQUFEd3RCNzUrQWdBQVBDMEhobjRDQUFBOExRZnFmZ0lBQUR3dEI4cUNBZ0FBUEMwR29yNENBQUE4TFFhNnlnSUFBRHd0QmlMQ0FnQUFQQzBIc3A0Q0FBQThMUVlLaWdJQUFEd3RCanAyQWdBQVBDMEhRcm9DQUFBOExRY3FqZ0lBQUR3dEJ4YktBZ0FBUEMwSGZuSUNBQUE4TFFkS2NnSUFBRHd0QnhLQ0FnQUFQQzBIWG9JQ0FBQThMUWFLZmdJQUFEd3RCN2E2QWdBQVBDMEdyc0lDQUFBOExRZFNsZ0lBQUR3dEJ6SzZBZ0FBUEMwSDZyb0NBQUE4TFFmeXJnSUFBRHd0QjByQ0FnQUFQQzBIeG5ZQ0FBQThMUWJ1Z2dJQUFEd3RCOTZ1QWdBQVBDMEdRc1lDQUFBOExRZGV4Z0lBQUR3dEJvcTJBZ0FBUEMwSFVwNENBQUE4TFFlQ3JnSUFBRHd0Qm42eUFnQUFQQzBIcnNZQ0FBQThMUWRXZmdJQUFEd3RCeXJHQWdBQVBDMEhlcFlDQUFBOExRZFNlZ0lBQUR3dEI5SnlBZ0FBUEMwR25zb0NBQUE4TFFiR2RnSUFBRHd0Qm9KMkFnQUFQQzBHNXNZQ0FBQThMUWJ5d2dJQUFEd3RCa3FHQWdBQVBDMEd6cG9DQUFBOExRZW1zZ0lBQUR3dEJySjZBZ0FBUEMwSFVxNENBQUE4TFFmZW1nSUFBRHd0QmdLYUFnQUFQQzBHd29ZQ0FBQThMUWY2ZWdJQUFEd3RCamFPQWdBQVBDMEdKcllDQUFBOExRZmVpZ0lBQUR3dEJvTEdBZ0FBUEMwR3VuNENBQUE4TFFjYWxnSUFBRHd0QjZKNkFnQUFQQzBHVG9vQ0FBQThMUWNLdmdJQUFEd3RCdzUyQWdBQVBDMEdMcklDQUFBOExRZUdkZ0lBQUR3dEJqYStBZ0FBUEMwSHFvWUNBQUE4TFFiU3RnSUFBRHd0QjBxK0FnQUFQQzBIZnNvQ0FBQThMUWRLeWdJQUFEd3RCOExDQWdBQVBDMEdwb29DQUFBOExRZm1qZ0lBQUR3dEJtWjZBZ0FBUEMwRzFySUNBQUE4TFFadXdnSUFBRHd0QmtyS0FnQUFQQzBHMnE0Q0FBQThMUWNLaWdJQUFEd3RCK0xLQWdBQVBDMEdlcFlDQUFBOExRZENpZ0lBQUR3dEJ1cDZBZ0FBUEMwR0Jub0NBQUE4TEVNcUFnSUFBQUF0QjFxR0FnQUFoQVFzZ0FRc1dBQ0FBSUFBdEFDMUIvZ0Z4SUFGQkFFZHlPZ0F0Q3hrQUlBQWdBQzBBTFVIOUFYRWdBVUVBUjBFQmRISTZBQzBMR1FBZ0FDQUFMUUF0UWZzQmNTQUJRUUJIUVFKMGNqb0FMUXNaQUNBQUlBQXRBQzFCOXdGeElBRkJBRWRCQTNSeU9nQXRDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FnQWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NCQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFjYVJnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUl3SWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwa0JBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWdnaUJFVU5BQ0FBSUFFZ0FpQUJheUFFRVlHQWdJQUFBQ0lEUVg5SERRQWdBRUgyaW9DQUFEWUNFRUVZSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ05DSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSU1JZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQjdacUFnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BamdpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDRUNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRWldRZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJOElnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMGtCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FoUWlCRVVOQUNBQUlBRWdBaUFCYXlBRUVZR0FnSUFBQUNJRFFYOUhEUUFnQUVHcW00Q0FBRFlDRUVFWUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NRQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0SkFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUlZSWdSRkRRQWdBQ0FCSUFJZ0FXc2dCQkdCZ0lDQUFBQWlBMEYvUncwQUlBQkI3Wk9BZ0FBMkFoQkJHQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWtRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ0pDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSXNJZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQzBrQkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BaWdpQkVVTkFDQUFJQUVnQWlBQmF5QUVFWUdBZ0lBQUFDSURRWDlIRFFBZ0FFSDJpSUNBQURZQ0VFRVlJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDVUNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEpBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJY0lnUkZEUUFnQUNBQklBSWdBV3NnQkJHQmdJQ0FBQUFpQTBGL1J3MEFJQUJCd3BtQWdBQTJBaEJCR0NFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FrZ2lCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NJQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFaU1VnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUpNSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWxRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ1dDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RGQVFGL0FrQUNRQ0FBTHdFd1FSUnhRUlJIRFFCQkFTRURJQUF0QUNoQkFVWU5BU0FBTHdFeVFlVUFSaUVEREFFTElBQXRBQ2xCQlVZaEF3c2dBQ0FET2dBdVFRQUwvZ0VCQTM5QkFTRURBa0FnQUM4Qk1DSUVRUWh4RFFBZ0FDa0RJRUlBVWlFREN3SkFBa0FnQUMwQUxrVU5BRUVCSVFVZ0FDMEFLVUVGUmcwQlFRRWhCU0FFUWNBQWNVVWdBM0ZCQVVjTkFRdEJBQ0VGSUFSQndBQnhEUUJCQWlFRklBUkIvLzhEY1NJRFFRaHhEUUFDUUNBRFFZQUVjVVVOQUFKQUlBQXRBQ2hCQVVjTkFDQUFMUUF0UVFweERRQkJCUThMUVFRUEN3SkFJQU5CSUhFTkFBSkFJQUF0QUNoQkFVWU5BQ0FBTHdFeVFmLy9BM0VpQUVHY2YycEI1QUJKRFFBZ0FFSE1BVVlOQUNBQVFiQUNSZzBBUVFRaEJTQUVRU2h4UlEwQ0lBTkJpQVJ4UVlBRVJnMENDMEVBRHd0QkFFRURJQUFwQXlCUUd5RUZDeUFGQzJJQkFuOUJBQ0VCQWtBZ0FDMEFLRUVCUmcwQUlBQXZBVEpCLy84RGNTSUNRWngvYWtIa0FFa05BQ0FDUWN3QlJnMEFJQUpCc0FKR0RRQWdBQzhCTUNJQVFjQUFjUTBBUVFFaEFTQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUJDeUFCQzZjQkFRTi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUVFQUlRTWdBQzhCTUNJRVFRSnhSUTBCREFJTFFRQWhBeUFBTHdFd0lnUkJBWEZGRFFFTFFRRWhBeUFBTFFBb1FRRkdEUUFnQUM4Qk1rSC8vd054SWdWQm5IOXFRZVFBU1EwQUlBVkJ6QUZHRFFBZ0JVR3dBa1lOQUNBRVFjQUFjUTBBUVFBaEF5QUVRWWdFY1VHQUJFWU5BQ0FFUVNoeFFRQkhJUU1MSUFCQkFEc0JNQ0FBUVFBNkFDOGdBd3VaQVFFQ2Z3SkFBa0FDUUNBQUxRQXFSUTBBSUFBdEFDdEZEUUJCQUNFQklBQXZBVEFpQWtFQ2NVVU5BUXdDQzBFQUlRRWdBQzhCTUNJQ1FRRnhSUTBCQzBFQklRRWdBQzBBS0VFQlJnMEFJQUF2QVRKQi8vOERjU0lBUVp4L2FrSGtBRWtOQUNBQVFjd0JSZzBBSUFCQnNBSkdEUUFnQWtIQUFIRU5BRUVBSVFFZ0FrR0lCSEZCZ0FSR0RRQWdBa0VvY1VFQVJ5RUJDeUFCQzFrQUlBQkJHR3BDQURjREFDQUFRZ0EzQXdBZ0FFRTRha0lBTndNQUlBQkJNR3BDQURjREFDQUFRU2hxUWdBM0F3QWdBRUVnYWtJQU53TUFJQUJCRUdwQ0FEY0RBQ0FBUVFocVFnQTNBd0FnQUVIZEFUWUNIRUVBQzNzQkFYOENRQ0FBS0FJTUlnTU5BQUpBSUFBb0FnUkZEUUFnQUNBQk5nSUVDd0pBSUFBZ0FTQUNFTVNBZ0lBQUlnTU5BQ0FBS0FJTUR3c2dBQ0FETmdJY1FRQWhBeUFBS0FJRUlnRkZEUUFnQUNBQklBSWdBQ2dDQ0JHQmdJQ0FBQUFpQVVVTkFDQUFJQUkyQWhRZ0FDQUJOZ0lNSUFFaEF3c2dBd3ZrOHdFRERuOERmZ1IvSTRDQWdJQUFRUkJySWdNa2dJQ0FnQUFnQVNFRUlBRWhCU0FCSVFZZ0FTRUhJQUVoQ0NBQklRa2dBU0VLSUFFaEN5QUJJUXdnQVNFTklBRWhEaUFCSVE4Q1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FDZ0NIQ0lRUVg5cUR0MEIyZ0VCMlFFQ0F3UUZCZ2NJQ1FvTERBME8yQUVQRU5jQkVSTFdBUk1VRlJZWEdCa2FHK0FCM3dFY0hSN1ZBUjhnSVNJakpDWFVBU1luS0NrcUt5elRBZElCTFM3UkFkQUJMekF4TWpNME5UWTNPRGs2T3p3OVBqOUFRVUpEUkVWRzJ3RkhTRWxLendIT0FVdk5BVXpNQVUxT1QxQlJVbE5VVlZaWFdGbGFXMXhkWGw5Z1lXSmpaR1ZtWjJocGFtdHNiVzV2Y0hGeWMzUjFkbmQ0ZVhwN2ZIMStmNEFCZ1FHQ0FZTUJoQUdGQVlZQmh3R0lBWWtCaWdHTEFZd0JqUUdPQVk4QmtBR1JBWklCa3dHVUFaVUJsZ0dYQVpnQm1RR2FBWnNCbkFHZEFaNEJud0dnQWFFQm9nR2pBYVFCcFFHbUFhY0JxQUdwQWFvQnF3R3NBYTBCcmdHdkFiQUJzUUd5QWJNQnRBRzFBYllCdHdITEFjb0J1QUhKQWJrQnlBRzZBYnNCdkFHOUFiNEJ2d0hBQWNFQndnSERBY1FCeFFIR0FRRGNBUXRCQUNFUURNWUJDMEVPSVJBTXhRRUxRUTBoRUF6RUFRdEJEeUVRRE1NQkMwRVFJUkFNd2dFTFFSTWhFQXpCQVF0QkZDRVFETUFCQzBFVklSQU12d0VMUVJZaEVBeStBUXRCRnlFUURMMEJDMEVZSVJBTXZBRUxRUmtoRUF5N0FRdEJHaUVRRExvQkMwRWJJUkFNdVFFTFFSd2hFQXk0QVF0QkNDRVFETGNCQzBFZElSQU10Z0VMUVNBaEVBeTFBUXRCSHlFUURMUUJDMEVISVJBTXN3RUxRU0VoRUF5eUFRdEJJaUVRRExFQkMwRWVJUkFNc0FFTFFTTWhFQXl2QVF0QkVpRVFESzRCQzBFUklSQU1yUUVMUVNRaEVBeXNBUXRCSlNFUURLc0JDMEVtSVJBTXFnRUxRU2NoRUF5cEFRdEJ3d0VoRUF5b0FRdEJLU0VRREtjQkMwRXJJUkFNcGdFTFFTd2hFQXlsQVF0QkxTRVFES1FCQzBFdUlSQU1vd0VMUVM4aEVBeWlBUXRCeEFFaEVBeWhBUXRCTUNFUURLQUJDMEUwSVJBTW53RUxRUXdoRUF5ZUFRdEJNU0VRREowQkMwRXlJUkFNbkFFTFFUTWhFQXliQVF0Qk9TRVFESm9CQzBFMUlSQU1tUUVMUWNVQklSQU1tQUVMUVFzaEVBeVhBUXRCT2lFUURKWUJDMEUySVJBTWxRRUxRUW9oRUF5VUFRdEJOeUVRREpNQkMwRTRJUkFNa2dFTFFUd2hFQXlSQVF0Qk95RVFESkFCQzBFOUlSQU1qd0VMUVFraEVBeU9BUXRCS0NFUURJMEJDMEUrSVJBTWpBRUxRVDhoRUF5TEFRdEJ3QUFoRUF5S0FRdEJ3UUFoRUF5SkFRdEJ3Z0FoRUF5SUFRdEJ3d0FoRUF5SEFRdEJ4QUFoRUF5R0FRdEJ4UUFoRUF5RkFRdEJ4Z0FoRUF5RUFRdEJLaUVRRElNQkMwSEhBQ0VRRElJQkMwSElBQ0VRRElFQkMwSEpBQ0VRRElBQkMwSEtBQ0VRREg4TFFjc0FJUkFNZmd0QnpRQWhFQXg5QzBITUFDRVFESHdMUWM0QUlSQU1ld3RCendBaEVBeDZDMEhRQUNFUURIa0xRZEVBSVJBTWVBdEIwZ0FoRUF4M0MwSFRBQ0VRREhZTFFkUUFJUkFNZFF0QjFnQWhFQXgwQzBIVkFDRVFESE1MUVFZaEVBeHlDMEhYQUNFUURIRUxRUVVoRUF4d0MwSFlBQ0VRREc4TFFRUWhFQXh1QzBIWkFDRVFERzBMUWRvQUlSQU1iQXRCMndBaEVBeHJDMEhjQUNFUURHb0xRUU1oRUF4cEMwSGRBQ0VRREdnTFFkNEFJUkFNWnd0QjN3QWhFQXhtQzBIaEFDRVFER1VMUWVBQUlSQU1aQXRCNGdBaEVBeGpDMEhqQUNFUURHSUxRUUloRUF4aEMwSGtBQ0VRREdBTFFlVUFJUkFNWHd0QjVnQWhFQXhlQzBIbkFDRVFERjBMUWVnQUlSQU1YQXRCNlFBaEVBeGJDMEhxQUNFUURGb0xRZXNBSVJBTVdRdEI3QUFoRUF4WUMwSHRBQ0VRREZjTFFlNEFJUkFNVmd0Qjd3QWhFQXhWQzBId0FDRVFERlFMUWZFQUlSQU1Vd3RCOGdBaEVBeFNDMEh6QUNFUURGRUxRZlFBSVJBTVVBdEI5UUFoRUF4UEMwSDJBQ0VRREU0TFFmY0FJUkFNVFF0QitBQWhFQXhNQzBINUFDRVFERXNMUWZvQUlSQU1TZ3RCK3dBaEVBeEpDMEg4QUNFUURFZ0xRZjBBSVJBTVJ3dEIvZ0FoRUF4R0MwSC9BQ0VRREVVTFFZQUJJUkFNUkF0QmdRRWhFQXhEQzBHQ0FTRVFERUlMUVlNQklSQU1RUXRCaEFFaEVBeEFDMEdGQVNFUUREOExRWVlCSVJBTVBndEJod0VoRUF3OUMwR0lBU0VRRER3TFFZa0JJUkFNT3d0QmlnRWhFQXc2QzBHTEFTRVFERGtMUVl3QklSQU1PQXRCalFFaEVBdzNDMEdPQVNFUUREWUxRWThCSVJBTU5RdEJrQUVoRUF3MEMwR1JBU0VRRERNTFFaSUJJUkFNTWd0Qmt3RWhFQXd4QzBHVUFTRVFEREFMUVpVQklSQU1Md3RCbGdFaEVBd3VDMEdYQVNFUURDMExRWmdCSVJBTUxBdEJtUUVoRUF3ckMwR2FBU0VRRENvTFFac0JJUkFNS1F0Qm5BRWhFQXdvQzBHZEFTRVFEQ2NMUVo0QklSQU1KZ3RCbndFaEVBd2xDMEdnQVNFUURDUUxRYUVCSVJBTUl3dEJvZ0VoRUF3aUMwR2pBU0VRRENFTFFhUUJJUkFNSUF0QnBRRWhFQXdmQzBHbUFTRVFEQjRMUWFjQklSQU1IUXRCcUFFaEVBd2NDMEdwQVNFUURCc0xRYW9CSVJBTUdndEJxd0VoRUF3WkMwR3NBU0VRREJnTFFhMEJJUkFNRnd0QnJnRWhFQXdXQzBFQklSQU1GUXRCcndFaEVBd1VDMEd3QVNFUURCTUxRYkVCSVJBTUVndEJzd0VoRUF3UkMwR3lBU0VRREJBTFFiUUJJUkFNRHd0QnRRRWhFQXdPQzBHMkFTRVFEQTBMUWJjQklSQU1EQXRCdUFFaEVBd0xDMEc1QVNFUURBb0xRYm9CSVJBTUNRdEJ1d0VoRUF3SUMwSEdBU0VRREFjTFFid0JJUkFNQmd0QnZRRWhFQXdGQzBHK0FTRVFEQVFMUWI4QklSQU1Bd3RCd0FFaEVBd0NDMEhDQVNFUURBRUxRY0VCSVJBTEEwQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FRRHNjQkFBRUNBd1FGQmdjSUNRb0xEQTBPRHhBUkVoTVVGUllYR0JrYUd4d2VIeUFoSXlVb1AwQkJSRVZHUjBoSlNrdE1UVTlRVVZKVDNnTlhXVnRjWFdCaVpXWm5hR2xxYTJ4dGIzQnhjbk4wZFhaM2VIbDZlM3g5Zm9BQmdnR0ZBWVlCaHdHSkFZc0JqQUdOQVk0Qmp3R1FBWkVCbEFHVkFaWUJsd0dZQVprQm1nR2JBWndCblFHZUFaOEJvQUdoQWFJQm93R2tBYVVCcGdHbkFhZ0JxUUdxQWFzQnJBR3RBYTRCcndHd0FiRUJzZ0d6QWJRQnRRRzJBYmNCdUFHNUFib0J1d0c4QWIwQnZnRy9BY0FCd1FIQ0FjTUJ4QUhGQWNZQnh3SElBY2tCeWdITEFjd0J6UUhPQWM4QjBBSFJBZElCMHdIVUFkVUIxZ0hYQWRnQjJRSGFBZHNCM0FIZEFkNEI0QUhoQWVJQjR3SGtBZVVCNWdIbkFlZ0I2UUhxQWVzQjdBSHRBZTRCN3dId0FmRUI4Z0h6QVprQ3BBS3dBdjRDL2dJTElBRWlCQ0FDUnczekFVSGRBU0VRRFA4REN5QUJJaEFnQWtjTjNRRkJ3d0VoRUF6K0F3c2dBU0lCSUFKSERaQUJRZmNBSVJBTS9RTUxJQUVpQVNBQ1J3MkdBVUh2QUNFUURQd0RDeUFCSWdFZ0FrY05mMEhxQUNFUURQc0RDeUFCSWdFZ0FrY05lMEhvQUNFUURQb0RDeUFCSWdFZ0FrY05lRUhtQUNFUURQa0RDeUFCSWdFZ0FrY05Ha0VZSVJBTStBTUxJQUVpQVNBQ1J3MFVRUkloRUF6M0F3c2dBU0lCSUFKSERWbEJ4UUFoRUF6MkF3c2dBU0lCSUFKSERVcEJQeUVRRFBVREN5QUJJZ0VnQWtjTlNFRThJUkFNOUFNTElBRWlBU0FDUncxQlFURWhFQXp6QXdzZ0FDMEFMa0VCUmczckF3eUhBZ3NnQUNBQklnRWdBaERBZ0lDQUFFRUJSdzNtQVNBQVFnQTNBeUFNNXdFTElBQWdBU0lCSUFJUXRJQ0FnQUFpRUEzbkFTQUJJUUVNOVFJTEFrQWdBU0lCSUFKSERRQkJCaUVRRFBBREN5QUFJQUZCQVdvaUFTQUNFTHVBZ0lBQUloQU42QUVnQVNFQkRERUxJQUJDQURjRElFRVNJUkFNMVFNTElBRWlFQ0FDUncwclFSMGhFQXp0QXdzQ1FDQUJJZ0VnQWtZTkFDQUJRUUZxSVFGQkVDRVFETlFEQzBFSElSQU03QU1MSUFCQ0FDQUFLUU1nSWhFZ0FpQUJJaEJyclNJU2ZTSVRJQk1nRVZZYk53TWdJQkVnRWxZaUZFVU41UUZCQ0NFUURPc0RDd0pBSUFFaUFTQUNSZzBBSUFCQmlZQ0FnQUEyQWdnZ0FDQUJOZ0lFSUFFaEFVRVVJUkFNMGdNTFFRa2hFQXpxQXdzZ0FTRUJJQUFwQXlCUURlUUJJQUVoQVF6eUFnc0NRQ0FCSWdFZ0FrY05BRUVMSVJBTTZRTUxJQUFnQVVFQmFpSUJJQUlRdG9DQWdBQWlFQTNsQVNBQklRRU04Z0lMSUFBZ0FTSUJJQUlRdUlDQWdBQWlFQTNsQVNBQklRRU04Z0lMSUFBZ0FTSUJJQUlRdUlDQWdBQWlFQTNtQVNBQklRRU1EUXNnQUNBQklnRWdBaEM2Z0lDQUFDSVFEZWNCSUFFaEFRendBZ3NDUUNBQklnRWdBa2NOQUVFUElSQU01UU1MSUFFdEFBQWlFRUU3UmcwSUlCQkJEVWNONkFFZ0FVRUJhaUVCRE84Q0N5QUFJQUVpQVNBQ0VMcUFnSUFBSWhBTjZBRWdBU0VCRFBJQ0N3TkFBa0FnQVMwQUFFSHd0WUNBQUdvdEFBQWlFRUVCUmcwQUlCQkJBa2NONndFZ0FDZ0NCQ0VRSUFCQkFEWUNCQ0FBSUJBZ0FVRUJhaUlCRUxtQWdJQUFJaEFONmdFZ0FTRUJEUFFDQ3lBQlFRRnFJZ0VnQWtjTkFBdEJFaUVRRE9JREN5QUFJQUVpQVNBQ0VMcUFnSUFBSWhBTjZRRWdBU0VCREFvTElBRWlBU0FDUncwR1FSc2hFQXpnQXdzQ1FDQUJJZ0VnQWtjTkFFRVdJUkFNNEFNTElBQkJpb0NBZ0FBMkFnZ2dBQ0FCTmdJRUlBQWdBU0FDRUxpQWdJQUFJaEFONmdFZ0FTRUJRU0FoRUF6R0F3c0NRQ0FCSWdFZ0FrWU5BQU5BQWtBZ0FTMEFBRUh3dDRDQUFHb3RBQUFpRUVFQ1JnMEFBa0FnRUVGL2FnNEU1UUhzQVFEckFld0JDeUFCUVFGcUlRRkJDQ0VRRE1nREN5QUJRUUZxSWdFZ0FrY05BQXRCRlNFUUROOERDMEVWSVJBTTNnTUxBMEFDUUNBQkxRQUFRZkM1Z0lBQWFpMEFBQ0lRUVFKR0RRQWdFRUYvYWc0RTNnSHNBZUFCNndIc0FRc2dBVUVCYWlJQklBSkhEUUFMUVJnaEVBemRBd3NDUUNBQklnRWdBa1lOQUNBQVFZdUFnSUFBTmdJSUlBQWdBVFlDQkNBQklRRkJCeUVRRE1RREMwRVpJUkFNM0FNTElBRkJBV29oQVF3Q0N3SkFJQUVpRkNBQ1J3MEFRUm9oRUF6YkF3c2dGQ0VCQWtBZ0ZDMEFBRUZ6YWc0VTNRTHVBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnSUE3Z0lMUVFBaEVDQUFRUUEyQWh3Z0FFR3ZpNENBQURZQ0VDQUFRUUkyQWd3Z0FDQVVRUUZxTmdJVUROb0RDd0pBSUFFdEFBQWlFRUU3UmcwQUlCQkJEVWNONkFFZ0FVRUJhaUVCRE9VQ0N5QUJRUUZxSVFFTFFTSWhFQXkvQXdzQ1FDQUJJaEFnQWtjTkFFRWNJUkFNMkFNTFFnQWhFU0FRSVFFZ0VDMEFBRUZRYWc0MzV3SG1BUUVDQXdRRkJnY0lBQUFBQUFBQUFBa0tDd3dORGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRHhBUkVoTVVBQXRCSGlFUURMMERDMElDSVJFTTVRRUxRZ01oRVF6a0FRdENCQ0VSRE9NQkMwSUZJUkVNNGdFTFFnWWhFUXpoQVF0Q0J5RVJET0FCQzBJSUlSRU0zd0VMUWdraEVRemVBUXRDQ2lFUkROMEJDMElMSVJFTTNBRUxRZ3doRVF6YkFRdENEU0VSRE5vQkMwSU9JUkVNMlFFTFFnOGhFUXpZQVF0Q0NpRVJETmNCQzBJTElSRU0xZ0VMUWd3aEVRelZBUXRDRFNFUkROUUJDMElPSVJFTTB3RUxRZzhoRVF6U0FRdENBQ0VSQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQVFMUUFBUVZCcURqZmxBZVFCQUFFQ0F3UUZCZ2ZtQWVZQjVnSG1BZVlCNWdIbUFRZ0pDZ3NNRGVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0VPRHhBUkVoUG1BUXRDQWlFUkRPUUJDMElESVJFTTR3RUxRZ1FoRVF6aUFRdENCU0VSRE9FQkMwSUdJUkVNNEFFTFFnY2hFUXpmQVF0Q0NDRVJETjRCQzBJSklSRU0zUUVMUWdvaEVRemNBUXRDQ3lFUkROc0JDMElNSVJFTTJnRUxRZzBoRVF6WkFRdENEaUVSRE5nQkMwSVBJUkVNMXdFTFFnb2hFUXpXQVF0Q0N5RVJETlVCQzBJTUlSRU0xQUVMUWcwaEVRelRBUXRDRGlFUkROSUJDMElQSVJFTTBRRUxJQUJDQUNBQUtRTWdJaEVnQWlBQkloQnJyU0lTZlNJVElCTWdFVlliTndNZ0lCRWdFbFlpRkVVTjBnRkJIeUVRRE1BREN3SkFJQUVpQVNBQ1JnMEFJQUJCaVlDQWdBQTJBZ2dnQUNBQk5nSUVJQUVoQVVFa0lSQU1wd01MUVNBaEVBeS9Bd3NnQUNBQkloQWdBaEMrZ0lDQUFFRi9hZzRGdGdFQXhRSUIwUUhTQVF0QkVTRVFES1FEQ3lBQVFRRTZBQzhnRUNFQkRMc0RDeUFCSWdFZ0FrY04wZ0ZCSkNFUURMc0RDeUFCSWcwZ0FrY05Ia0hHQUNFUURMb0RDeUFBSUFFaUFTQUNFTEtBZ0lBQUloQU4xQUVnQVNFQkRMVUJDeUFCSWhBZ0FrY05Ka0hRQUNFUURMZ0RDd0pBSUFFaUFTQUNSdzBBUVNnaEVBeTRBd3NnQUVFQU5nSUVJQUJCaklDQWdBQTJBZ2dnQUNBQklBRVFzWUNBZ0FBaUVBM1RBU0FCSVFFTTJBRUxBa0FnQVNJUUlBSkhEUUJCS1NFUURMY0RDeUFRTFFBQUlnRkJJRVlORkNBQlFRbEhEZE1CSUJCQkFXb2hBUXdWQ3dKQUlBRWlBU0FDUmcwQUlBRkJBV29oQVF3WEMwRXFJUkFNdFFNTEFrQWdBU0lRSUFKSERRQkJLeUVRRExVREN3SkFJQkF0QUFBaUFVRUpSZzBBSUFGQklFY04xUUVMSUFBdEFDeEJDRVlOMHdFZ0VDRUJESkVEQ3dKQUlBRWlBU0FDUncwQVFTd2hFQXkwQXdzZ0FTMEFBRUVLUnczVkFTQUJRUUZxSVFFTXlRSUxJQUVpRGlBQ1J3M1ZBVUV2SVJBTXNnTUxBMEFDUUNBQkxRQUFJaEJCSUVZTkFBSkFJQkJCZG1vT0JBRGNBZHdCQU5vQkN5QUJJUUVNNEFFTElBRkJBV29pQVNBQ1J3MEFDMEV4SVJBTXNRTUxRVEloRUNBQkloUWdBa1lOc0FNZ0FpQVVheUFBS0FJQUlnRnFJUlVnRkNBQmEwRURhaUVXQWtBRFFDQVVMUUFBSWhkQklISWdGeUFYUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUWZDN2dJQUFhaTBBQUVjTkFRSkFJQUZCQTBjTkFFRUdJUUVNbGdNTElBRkJBV29oQVNBVVFRRnFJaFFnQWtjTkFBc2dBQ0FWTmdJQURMRURDeUFBUVFBMkFnQWdGQ0VCRE5rQkMwRXpJUkFnQVNJVUlBSkdEYThESUFJZ0ZHc2dBQ2dDQUNJQmFpRVZJQlFnQVd0QkNHb2hGZ0pBQTBBZ0ZDMEFBQ0lYUVNCeUlCY2dGMEcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUgwdTRDQUFHb3RBQUJIRFFFQ1FDQUJRUWhIRFFCQkJTRUJESlVEQ3lBQlFRRnFJUUVnRkVFQmFpSVVJQUpIRFFBTElBQWdGVFlDQUF5d0F3c2dBRUVBTmdJQUlCUWhBUXpZQVF0Qk5DRVFJQUVpRkNBQ1JnMnVBeUFDSUJScklBQW9BZ0FpQVdvaEZTQVVJQUZyUVFWcUlSWUNRQU5BSUJRdEFBQWlGMEVnY2lBWElCZEJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkIwTUtBZ0FCcUxRQUFSdzBCQWtBZ0FVRUZSdzBBUVFjaEFReVVBd3NnQVVFQmFpRUJJQlJCQVdvaUZDQUNSdzBBQ3lBQUlCVTJBZ0FNcndNTElBQkJBRFlDQUNBVUlRRU0xd0VMQWtBZ0FTSUJJQUpHRFFBRFFBSkFJQUV0QUFCQmdMNkFnQUJxTFFBQUloQkJBVVlOQUNBUVFRSkdEUW9nQVNFQkROMEJDeUFCUVFGcUlnRWdBa2NOQUF0Qk1DRVFESzREQzBFd0lSQU1yUU1MQWtBZ0FTSUJJQUpHRFFBRFFBSkFJQUV0QUFBaUVFRWdSZzBBSUJCQmRtb09CTmtCMmdIYUFka0IyZ0VMSUFGQkFXb2lBU0FDUncwQUMwRTRJUkFNclFNTFFUZ2hFQXlzQXdzRFFBSkFJQUV0QUFBaUVFRWdSZzBBSUJCQkNVY05Bd3NnQVVFQmFpSUJJQUpIRFFBTFFUd2hFQXlyQXdzRFFBSkFJQUV0QUFBaUVFRWdSZzBBQWtBQ1FDQVFRWFpxRGdUYUFRRUIyZ0VBQ3lBUVFTeEdEZHNCQ3lBQklRRU1CQXNnQVVFQmFpSUJJQUpIRFFBTFFUOGhFQXlxQXdzZ0FTRUJETnNCQzBIQUFDRVFJQUVpRkNBQ1JnMm9BeUFDSUJScklBQW9BZ0FpQVdvaEZpQVVJQUZyUVFacUlSY0NRQU5BSUJRdEFBQkJJSElnQVVHQXdJQ0FBR290QUFCSERRRWdBVUVHUmcyT0F5QUJRUUZxSVFFZ0ZFRUJhaUlVSUFKSERRQUxJQUFnRmpZQ0FBeXBBd3NnQUVFQU5nSUFJQlFoQVF0Qk5pRVFESTREQ3dKQUlBRWlEeUFDUncwQVFjRUFJUkFNcHdNTElBQkJqSUNBZ0FBMkFnZ2dBQ0FQTmdJRUlBOGhBU0FBTFFBc1FYOXFEZ1ROQWRVQjF3SFpBWWNEQ3lBQlFRRnFJUUVNekFFTEFrQWdBU0lCSUFKR0RRQURRQUpBSUFFdEFBQWlFRUVnY2lBUUlCQkJ2MzlxUWY4QmNVRWFTUnRCL3dGeEloQkJDVVlOQUNBUVFTQkdEUUFDUUFKQUFrQUNRQ0FRUVoxL2FnNFRBQU1EQXdNREF3TUJBd01EQXdNREF3TURBZ01MSUFGQkFXb2hBVUV4SVJBTWtRTUxJQUZCQVdvaEFVRXlJUkFNa0FNTElBRkJBV29oQVVFeklSQU1qd01MSUFFaEFRelFBUXNnQVVFQmFpSUJJQUpIRFFBTFFUVWhFQXlsQXd0Qk5TRVFES1FEQ3dKQUlBRWlBU0FDUmcwQUEwQUNRQ0FCTFFBQVFZQzhnSUFBYWkwQUFFRUJSZzBBSUFFaEFRelRBUXNnQVVFQmFpSUJJQUpIRFFBTFFUMGhFQXlrQXd0QlBTRVFES01EQ3lBQUlBRWlBU0FDRUxDQWdJQUFJaEFOMWdFZ0FTRUJEQUVMSUJCQkFXb2hBUXRCUENFUURJY0RDd0pBSUFFaUFTQUNSdzBBUWNJQUlSQU1vQU1MQWtBRFFBSkFJQUV0QUFCQmQyb09HQUFDL2dMK0FvUUQvZ0wrQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDL2dMK0F2NENBUDRDQ3lBQlFRRnFJZ0VnQWtjTkFBdEJ3Z0FoRUF5Z0F3c2dBVUVCYWlFQklBQXRBQzFCQVhGRkRiMEJJQUVoQVF0QkxDRVFESVVEQ3lBQklnRWdBa2NOMHdGQnhBQWhFQXlkQXdzRFFBSkFJQUV0QUFCQmtNQ0FnQUJxTFFBQVFRRkdEUUFnQVNFQkRMY0NDeUFCUVFGcUlnRWdBa2NOQUF0QnhRQWhFQXljQXdzZ0RTMEFBQ0lRUVNCR0RiTUJJQkJCT2tjTmdRTWdBQ2dDQkNFQklBQkJBRFlDQkNBQUlBRWdEUkN2Z0lDQUFDSUJEZEFCSUExQkFXb2hBUXl6QWd0Qnh3QWhFQ0FCSWcwZ0FrWU5tZ01nQWlBTmF5QUFLQUlBSWdGcUlSWWdEU0FCYTBFRmFpRVhBMEFnRFMwQUFDSVVRU0J5SUJRZ0ZFRy9mMnBCL3dGeFFScEpHMEgvQVhFZ0FVR1F3b0NBQUdvdEFBQkhEWUFESUFGQkJVWU45QUlnQVVFQmFpRUJJQTFCQVdvaURTQUNSdzBBQ3lBQUlCWTJBZ0FNbWdNTFFjZ0FJUkFnQVNJTklBSkdEWmtESUFJZ0RXc2dBQ2dDQUNJQmFpRVdJQTBnQVd0QkNXb2hGd05BSUEwdEFBQWlGRUVnY2lBVUlCUkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkJsc0tBZ0FCcUxRQUFSdzMvQWdKQUlBRkJDVWNOQUVFQ0lRRU05UUlMSUFGQkFXb2hBU0FOUVFGcUlnMGdBa2NOQUFzZ0FDQVdOZ0lBREprREN3SkFJQUVpRFNBQ1J3MEFRY2tBSVJBTW1RTUxBa0FDUUNBTkxRQUFJZ0ZCSUhJZ0FTQUJRYjkvYWtIL0FYRkJHa2tiUWY4QmNVR1NmMm9PQndDQUE0QURnQU9BQTRBREFZQURDeUFOUVFGcUlRRkJQaUVRRElBREN5QU5RUUZxSVFGQlB5RVFEUDhDQzBIS0FDRVFJQUVpRFNBQ1JnMlhBeUFDSUExcklBQW9BZ0FpQVdvaEZpQU5JQUZyUVFGcUlSY0RRQ0FOTFFBQUloUkJJSElnRkNBVVFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFhRENnSUFBYWkwQUFFY04vUUlnQVVFQlJnM3dBaUFCUVFGcUlRRWdEVUVCYWlJTklBSkhEUUFMSUFBZ0ZqWUNBQXlYQXd0Qnl3QWhFQ0FCSWcwZ0FrWU5sZ01nQWlBTmF5QUFLQUlBSWdGcUlSWWdEU0FCYTBFT2FpRVhBMEFnRFMwQUFDSVVRU0J5SUJRZ0ZFRy9mMnBCL3dGeFFScEpHMEgvQVhFZ0FVR2l3b0NBQUdvdEFBQkhEZndDSUFGQkRrWU44QUlnQVVFQmFpRUJJQTFCQVdvaURTQUNSdzBBQ3lBQUlCWTJBZ0FNbGdNTFFjd0FJUkFnQVNJTklBSkdEWlVESUFJZ0RXc2dBQ2dDQUNJQmFpRVdJQTBnQVd0QkQyb2hGd05BSUEwdEFBQWlGRUVnY2lBVUlCUkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkJ3TUtBZ0FCcUxRQUFSdzM3QWdKQUlBRkJEMGNOQUVFRElRRU04UUlMSUFGQkFXb2hBU0FOUVFGcUlnMGdBa2NOQUFzZ0FDQVdOZ0lBREpVREMwSE5BQ0VRSUFFaURTQUNSZzJVQXlBQ0lBMXJJQUFvQWdBaUFXb2hGaUFOSUFGclFRVnFJUmNEUUNBTkxRQUFJaFJCSUhJZ0ZDQVVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRZERDZ0lBQWFpMEFBRWNOK2dJQ1FDQUJRUVZIRFFCQkJDRUJEUEFDQ3lBQlFRRnFJUUVnRFVFQmFpSU5JQUpIRFFBTElBQWdGallDQUF5VUF3c0NRQ0FCSWcwZ0FrY05BRUhPQUNFUURKUURDd0pBQWtBQ1FBSkFJQTB0QUFBaUFVRWdjaUFCSUFGQnYzOXFRZjhCY1VFYVNSdEIvd0Z4UVoxL2FnNFRBUDBDL1FMOUF2MEMvUUw5QXYwQy9RTDlBdjBDL1FMOUFnSDlBdjBDL1FJQ0EvMENDeUFOUVFGcUlRRkJ3UUFoRUF6OUFnc2dEVUVCYWlFQlFjSUFJUkFNL0FJTElBMUJBV29oQVVIREFDRVFEUHNDQ3lBTlFRRnFJUUZCeEFBaEVBejZBZ3NDUUNBQklnRWdBa1lOQUNBQVFZMkFnSUFBTmdJSUlBQWdBVFlDQkNBQklRRkJ4UUFoRUF6NkFndEJ6d0FoRUF5U0F3c2dFQ0VCQWtBQ1FDQVFMUUFBUVhacURnUUJxQUtvQWdDb0Fnc2dFRUVCYWlFQkMwRW5JUkFNK0FJTEFrQWdBU0lCSUFKSERRQkIwUUFoRUF5UkF3c0NRQ0FCTFFBQVFTQkdEUUFnQVNFQkRJMEJDeUFCUVFGcUlRRWdBQzBBTFVFQmNVVU54d0VnQVNFQkRJd0JDeUFCSWhjZ0FrY055QUZCMGdBaEVBeVBBd3RCMHdBaEVDQUJJaFFnQWtZTmpnTWdBaUFVYXlBQUtBSUFJZ0ZxSVJZZ0ZDQUJhMEVCYWlFWEEwQWdGQzBBQUNBQlFkYkNnSUFBYWkwQUFFY056QUVnQVVFQlJnM0hBU0FCUVFGcUlRRWdGRUVCYWlJVUlBSkhEUUFMSUFBZ0ZqWUNBQXlPQXdzQ1FDQUJJZ0VnQWtjTkFFSFZBQ0VRREk0REN5QUJMUUFBUVFwSERjd0JJQUZCQVdvaEFRekhBUXNDUUNBQklnRWdBa2NOQUVIV0FDRVFESTBEQ3dKQUFrQWdBUzBBQUVGMmFnNEVBTTBCelFFQnpRRUxJQUZCQVdvaEFRekhBUXNnQVVFQmFpRUJRY29BSVJBTTh3SUxJQUFnQVNJQklBSVFyb0NBZ0FBaUVBM0xBU0FCSVFGQnpRQWhFQXp5QWdzZ0FDMEFLVUVpUmcyRkF3eW1BZ3NDUUNBQklnRWdBa2NOQUVIYkFDRVFESW9EQzBFQUlSUkJBU0VYUVFFaEZrRUFJUkFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQVMwQUFFRlFhZzRLMUFIVEFRQUJBZ01FQlFZSTFRRUxRUUloRUF3R0MwRURJUkFNQlF0QkJDRVFEQVFMUVFVaEVBd0RDMEVHSVJBTUFndEJCeUVRREFFTFFRZ2hFQXRCQUNFWFFRQWhGa0VBSVJRTXpBRUxRUWtoRUVFQklSUkJBQ0VYUVFBaEZnekxBUXNDUUNBQklnRWdBa2NOQUVIZEFDRVFESWtEQ3lBQkxRQUFRUzVIRGN3QklBRkJBV29oQVF5bUFnc2dBU0lCSUFKSERjd0JRZDhBSVJBTWh3TUxBa0FnQVNJQklBSkdEUUFnQUVHT2dJQ0FBRFlDQ0NBQUlBRTJBZ1FnQVNFQlFkQUFJUkFNN2dJTFFlQUFJUkFNaGdNTFFlRUFJUkFnQVNJQklBSkdEWVVESUFJZ0FXc2dBQ2dDQUNJVWFpRVdJQUVnRkd0QkEyb2hGd05BSUFFdEFBQWdGRUhpd29DQUFHb3RBQUJIRGMwQklCUkJBMFlOekFFZ0ZFRUJhaUVVSUFGQkFXb2lBU0FDUncwQUN5QUFJQlkyQWdBTWhRTUxRZUlBSVJBZ0FTSUJJQUpHRFlRRElBSWdBV3NnQUNnQ0FDSVVhaUVXSUFFZ0ZHdEJBbW9oRndOQUlBRXRBQUFnRkVIbXdvQ0FBR290QUFCSERjd0JJQlJCQWtZTnpnRWdGRUVCYWlFVUlBRkJBV29pQVNBQ1J3MEFDeUFBSUJZMkFnQU1oQU1MUWVNQUlSQWdBU0lCSUFKR0RZTURJQUlnQVdzZ0FDZ0NBQ0lVYWlFV0lBRWdGR3RCQTJvaEZ3TkFJQUV0QUFBZ0ZFSHB3b0NBQUdvdEFBQkhEY3NCSUJSQkEwWU56Z0VnRkVFQmFpRVVJQUZCQVdvaUFTQUNSdzBBQ3lBQUlCWTJBZ0FNZ3dNTEFrQWdBU0lCSUFKSERRQkI1UUFoRUF5REF3c2dBQ0FCUVFGcUlnRWdBaENvZ0lDQUFDSVFEYzBCSUFFaEFVSFdBQ0VRRE9rQ0N3SkFJQUVpQVNBQ1JnMEFBMEFDUUNBQkxRQUFJaEJCSUVZTkFBSkFBa0FDUUNBUVFiaC9hZzRMQUFIUEFjOEJ6d0hQQWM4Qnp3SFBBYzhCQXM4QkN5QUJRUUZxSVFGQjBnQWhFQXp0QWdzZ0FVRUJhaUVCUWRNQUlSQU03QUlMSUFGQkFXb2hBVUhVQUNFUURPc0NDeUFCUVFGcUlnRWdBa2NOQUF0QjVBQWhFQXlDQXd0QjVBQWhFQXlCQXdzRFFBSkFJQUV0QUFCQjhNS0FnQUJxTFFBQUloQkJBVVlOQUNBUVFYNXFEZ1BQQWRBQjBRSFNBUXNnQVVFQmFpSUJJQUpIRFFBTFFlWUFJUkFNZ0FNTEFrQWdBU0lCSUFKR0RRQWdBVUVCYWlFQkRBTUxRZWNBSVJBTS93SUxBMEFDUUNBQkxRQUFRZkRFZ0lBQWFpMEFBQ0lRUVFGR0RRQUNRQ0FRUVg1cURnVFNBZE1CMUFFQTFRRUxJQUVoQVVIWEFDRVFET2NDQ3lBQlFRRnFJZ0VnQWtjTkFBdEI2QUFoRUF6K0Fnc0NRQ0FCSWdFZ0FrY05BRUhwQUNFUURQNENDd0pBSUFFdEFBQWlFRUYyYWc0YXVnSFZBZFVCdkFIVkFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIS0FkVUIxUUVBMHdFTElBRkJBV29oQVF0QkJpRVFET01DQ3dOQUFrQWdBUzBBQUVId3hvQ0FBR290QUFCQkFVWU5BQ0FCSVFFTW5nSUxJQUZCQVdvaUFTQUNSdzBBQzBIcUFDRVFEUHNDQ3dKQUlBRWlBU0FDUmcwQUlBRkJBV29oQVF3REMwSHJBQ0VRRFBvQ0N3SkFJQUVpQVNBQ1J3MEFRZXdBSVJBTStnSUxJQUZCQVdvaEFRd0JDd0pBSUFFaUFTQUNSdzBBUWUwQUlSQU0rUUlMSUFGQkFXb2hBUXRCQkNFUURONENDd0pBSUFFaUZDQUNSdzBBUWU0QUlSQU05d0lMSUJRaEFRSkFBa0FDUUNBVUxRQUFRZkRJZ0lBQWFpMEFBRUYvYWc0SDFBSFZBZFlCQUp3Q0FRTFhBUXNnRkVFQmFpRUJEQW9MSUJSQkFXb2hBUXpOQVF0QkFDRVFJQUJCQURZQ0hDQUFRWnVTZ0lBQU5nSVFJQUJCQnpZQ0RDQUFJQlJCQVdvMkFoUU05Z0lMQWtBRFFBSkFJQUV0QUFCQjhNaUFnQUJxTFFBQUloQkJCRVlOQUFKQUFrQWdFRUYvYWc0SDBnSFRBZFFCMlFFQUJBSFpBUXNnQVNFQlFkb0FJUkFNNEFJTElBRkJBV29oQVVIY0FDRVFETjhDQ3lBQlFRRnFJZ0VnQWtjTkFBdEI3d0FoRUF6MkFnc2dBVUVCYWlFQkRNc0JDd0pBSUFFaUZDQUNSdzBBUWZBQUlSQU05UUlMSUJRdEFBQkJMMGNOMUFFZ0ZFRUJhaUVCREFZTEFrQWdBU0lVSUFKSERRQkI4UUFoRUF6MEFnc0NRQ0FVTFFBQUlnRkJMMGNOQUNBVVFRRnFJUUZCM1FBaEVBemJBZ3NnQVVGMmFpSUVRUlpMRGRNQlFRRWdCSFJCaVlDQUFuRkZEZE1CRE1vQ0N3SkFJQUVpQVNBQ1JnMEFJQUZCQVdvaEFVSGVBQ0VRRE5vQ0MwSHlBQ0VRRFBJQ0N3SkFJQUVpRkNBQ1J3MEFRZlFBSVJBTThnSUxJQlFoQVFKQUlCUXRBQUJCOE15QWdBQnFMUUFBUVg5cURnUEpBcFFDQU5RQkMwSGhBQ0VRRE5nQ0N3SkFJQUVpRkNBQ1JnMEFBMEFDUUNBVUxRQUFRZkRLZ0lBQWFpMEFBQ0lCUVFOR0RRQUNRQ0FCUVg5cURnTExBZ0RWQVFzZ0ZDRUJRZDhBSVJBTTJnSUxJQlJCQVdvaUZDQUNSdzBBQzBIekFDRVFEUEVDQzBIekFDRVFEUEFDQ3dKQUlBRWlBU0FDUmcwQUlBQkJqNENBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUhnQUNFUUROY0NDMEgxQUNFUURPOENDd0pBSUFFaUFTQUNSdzBBUWZZQUlSQU03d0lMSUFCQmo0Q0FnQUEyQWdnZ0FDQUJOZ0lFSUFFaEFRdEJBeUVRRE5RQ0N3TkFJQUV0QUFCQklFY053d0lnQVVFQmFpSUJJQUpIRFFBTFFmY0FJUkFNN0FJTEFrQWdBU0lCSUFKSERRQkIrQUFoRUF6c0Fnc2dBUzBBQUVFZ1J3M09BU0FCUVFGcUlRRU03d0VMSUFBZ0FTSUJJQUlRcklDQWdBQWlFQTNPQVNBQklRRU1qZ0lMQWtBZ0FTSUVJQUpIRFFCQitnQWhFQXpxQWdzZ0JDMEFBRUhNQUVjTjBRRWdCRUVCYWlFQlFSTWhFQXpQQVFzQ1FDQUJJZ1FnQWtjTkFFSDdBQ0VRRE9rQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVZxSVJBRFFDQUVMUUFBSUFGQjhNNkFnQUJxTFFBQVJ3M1FBU0FCUVFWR0RjNEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZnNBSVJBTTZBSUxBa0FnQVNJRUlBSkhEUUJCL0FBaEVBem9BZ3NDUUFKQUlBUXRBQUJCdlg5cURnd0EwUUhSQWRFQjBRSFJBZEVCMFFIUkFkRUIwUUVCMFFFTElBUkJBV29oQVVIbUFDRVFETThDQ3lBRVFRRnFJUUZCNXdBaEVBek9BZ3NDUUNBQklnUWdBa2NOQUVIOUFDRVFET2NDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRSnFJUkFDUUFOQUlBUXRBQUFnQVVIdHo0Q0FBR290QUFCSERjOEJJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSDlBQ0VRRE9jQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJBaEVBek1BUXNDUUNBQklnUWdBa2NOQUVIK0FDRVFET1lDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRVnFJUkFDUUFOQUlBUXRBQUFnQVVIMnpvQ0FBR290QUFCSERjNEJJQUZCQlVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSCtBQ0VRRE9ZQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJZaEVBekxBUXNDUUNBQklnUWdBa2NOQUVIL0FDRVFET1VDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRTnFJUkFDUUFOQUlBUXRBQUFnQVVIOHpvQ0FBR290QUFCSERjMEJJQUZCQTBZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSC9BQ0VRRE9VQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVFVaEVBektBUXNDUUNBQklnUWdBa2NOQUVHQUFTRVFET1FDQ3lBRUxRQUFRZGtBUnczTEFTQUVRUUZxSVFGQkNDRVFETWtCQ3dKQUlBRWlCQ0FDUncwQVFZRUJJUkFNNHdJTEFrQUNRQ0FFTFFBQVFiSi9hZzREQU13QkFjd0JDeUFFUVFGcUlRRkI2d0FoRUF6S0Fnc2dCRUVCYWlFQlFld0FJUkFNeVFJTEFrQWdBU0lFSUFKSERRQkJnZ0VoRUF6aUFnc0NRQUpBSUFRdEFBQkJ1SDlxRGdnQXl3SExBY3NCeXdITEFjc0JBY3NCQ3lBRVFRRnFJUUZCNmdBaEVBekpBZ3NnQkVFQmFpRUJRZTBBSVJBTXlBSUxBa0FnQVNJRUlBSkhEUUJCZ3dFaEVBemhBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSQWdCQ0FCYTBFQ2FpRVVBa0FEUUNBRUxRQUFJQUZCZ00rQWdBQnFMUUFBUnczSkFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQkEyQWdCQmd3RWhFQXpoQWd0QkFDRVFJQUJCQURZQ0FDQVVRUUZxSVFFTXhnRUxBa0FnQVNJRUlBSkhEUUJCaEFFaEVBemdBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFRWFpRVFBa0FEUUNBRUxRQUFJQUZCZzgrQWdBQnFMUUFBUnczSUFTQUJRUVJHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQmhBRWhFQXpnQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVqSVJBTXhRRUxBa0FnQVNJRUlBSkhEUUJCaFFFaEVBemZBZ3NDUUFKQUlBUXRBQUJCdEg5cURnZ0F5QUhJQWNnQnlBSElBY2dCQWNnQkN5QUVRUUZxSVFGQjd3QWhFQXpHQWdzZ0JFRUJhaUVCUWZBQUlSQU14UUlMQWtBZ0FTSUVJQUpIRFFCQmhnRWhFQXplQWdzZ0JDMEFBRUhGQUVjTnhRRWdCRUVCYWlFQkRJTUNDd0pBSUFFaUJDQUNSdzBBUVljQklSQU0zUUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkEyb2hFQUpBQTBBZ0JDMEFBQ0FCUVlqUGdJQUFhaTBBQUVjTnhRRWdBVUVEUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZY0JJUkFNM1FJTElBQkJBRFlDQUNBUVFRRnFJUUZCTFNFUURNSUJDd0pBSUFFaUJDQUNSdzBBUVlnQklSQU0zQUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkNHb2hFQUpBQTBBZ0JDMEFBQ0FCUWREUGdJQUFhaTBBQUVjTnhBRWdBVUVJUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZZ0JJUkFNM0FJTElBQkJBRFlDQUNBUVFRRnFJUUZCS1NFUURNRUJDd0pBSUFFaUFTQUNSdzBBUVlrQklSQU0yd0lMUVFFaEVDQUJMUUFBUWQ4QVJ3M0FBU0FCUVFGcUlRRU1nUUlMQWtBZ0FTSUVJQUpIRFFCQmlnRWhFQXphQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUJhaUVRQTBBZ0JDMEFBQ0FCUVl6UGdJQUFhaTBBQUVjTndRRWdBVUVCUmcydkFpQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR0tBU0VRRE5rQ0N3SkFJQUVpQkNBQ1J3MEFRWXNCSVJBTTJRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQW1vaEVBSkFBMEFnQkMwQUFDQUJRWTdQZ0lBQWFpMEFBRWNOd1FFZ0FVRUNSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVlzQklSQU0yUUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJBaUVRREw0QkN3SkFJQUVpQkNBQ1J3MEFRWXdCSVJBTTJBSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRZkRQZ0lBQWFpMEFBRWNOd0FFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVl3QklSQU0yQUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJIeUVRREwwQkN3SkFJQUVpQkNBQ1J3MEFRWTBCSVJBTTF3SUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRZkxQZ0lBQWFpMEFBRWNOdndFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVkwQklSQU0xd0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJDU0VRREx3QkN3SkFJQUVpQkNBQ1J3MEFRWTRCSVJBTTFnSUxBa0FDUUNBRUxRQUFRYmQvYWc0SEFMOEJ2d0cvQWI4QnZ3RUJ2d0VMSUFSQkFXb2hBVUg0QUNFUURMMENDeUFFUVFGcUlRRkIrUUFoRUF5OEFnc0NRQ0FCSWdRZ0FrY05BRUdQQVNFUUROVUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFWcUlSQUNRQU5BSUFRdEFBQWdBVUdSejRDQUFHb3RBQUJIRGIwQklBRkJCVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHUEFTRVFETlVDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUmdoRUF5NkFRc0NRQ0FCSWdRZ0FrY05BRUdRQVNFUUROUUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUdYejRDQUFHb3RBQUJIRGJ3QklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHUUFTRVFETlFDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUmNoRUF5NUFRc0NRQ0FCSWdRZ0FrY05BRUdSQVNFUUROTUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFacUlSQUNRQU5BSUFRdEFBQWdBVUdhejRDQUFHb3RBQUJIRGJzQklBRkJCa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHUkFTRVFETk1DQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUlVoRUF5NEFRc0NRQ0FCSWdRZ0FrY05BRUdTQVNFUUROSUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFWcUlSQUNRQU5BSUFRdEFBQWdBVUdoejRDQUFHb3RBQUJIRGJvQklBRkJCVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHU0FTRVFETklDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUjRoRUF5M0FRc0NRQ0FCSWdRZ0FrY05BRUdUQVNFUURORUNDeUFFTFFBQVFjd0FSdzI0QVNBRVFRRnFJUUZCQ2lFUURMWUJDd0pBSUFRZ0FrY05BRUdVQVNFUUROQUNDd0pBQWtBZ0JDMEFBRUcvZjJvT0R3QzVBYmtCdVFHNUFia0J1UUc1QWJrQnVRRzVBYmtCdVFHNUFRRzVBUXNnQkVFQmFpRUJRZjRBSVJBTXR3SUxJQVJCQVdvaEFVSC9BQ0VRRExZQ0N3SkFJQVFnQWtjTkFFR1ZBU0VRRE04Q0N3SkFBa0FnQkMwQUFFRy9mMm9PQXdDNEFRRzRBUXNnQkVFQmFpRUJRZjBBSVJBTXRnSUxJQVJCQVdvaEJFR0FBU0VRRExVQ0N3SkFJQVFnQWtjTkFFR1dBU0VRRE00Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUZxSVJBQ1FBTkFJQVF0QUFBZ0FVR256NENBQUdvdEFBQkhEYllCSUFGQkFVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdXQVNFUURNNENDeUFBUVFBMkFnQWdFRUVCYWlFQlFRc2hFQXl6QVFzQ1FDQUVJQUpIRFFCQmx3RWhFQXpOQWdzQ1FBSkFBa0FDUUNBRUxRQUFRVk5xRGlNQXVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFRRzRBYmdCdUFHNEFiZ0JBcmdCdUFHNEFRTzRBUXNnQkVFQmFpRUJRZnNBSVJBTXRnSUxJQVJCQVdvaEFVSDhBQ0VRRExVQ0N5QUVRUUZxSVFSQmdRRWhFQXkwQWdzZ0JFRUJhaUVFUVlJQklSQU1zd0lMQWtBZ0JDQUNSdzBBUVpnQklSQU16QUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJHb2hFQUpBQTBBZ0JDMEFBQ0FCUWFuUGdJQUFhaTBBQUVjTnRBRWdBVUVFUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaZ0JJUkFNekFJTElBQkJBRFlDQUNBUVFRRnFJUUZCR1NFUURMRUJDd0pBSUFRZ0FrY05BRUdaQVNFUURNc0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFWcUlSQUNRQU5BSUFRdEFBQWdBVUd1ejRDQUFHb3RBQUJIRGJNQklBRkJCVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHWkFTRVFETXNDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUVloRUF5d0FRc0NRQ0FFSUFKSERRQkJtZ0VoRUF6S0Fnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVCYWlFUUFrQURRQ0FFTFFBQUlBRkJ0TStBZ0FCcUxRQUFSdzJ5QVNBQlFRRkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCbWdFaEVBektBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRWNJUkFNcndFTEFrQWdCQ0FDUncwQVFac0JJUkFNeVFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBV29oRUFKQUEwQWdCQzBBQUNBQlFiYlBnSUFBYWkwQUFFY05zUUVnQVVFQlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWnNCSVJBTXlRSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkp5RVFESzRCQ3dKQUlBUWdBa2NOQUVHY0FTRVFETWdDQ3dKQUFrQWdCQzBBQUVHc2Yyb09BZ0FCc1FFTElBUkJBV29oQkVHR0FTRVFESzhDQ3lBRVFRRnFJUVJCaHdFaEVBeXVBZ3NDUUNBRUlBSkhEUUJCblFFaEVBekhBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCdU0rQWdBQnFMUUFBUncydkFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQm5RRWhFQXpIQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVtSVJBTXJBRUxBa0FnQkNBQ1J3MEFRWjRCSVJBTXhnSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRYnJQZ0lBQWFpMEFBRWNOcmdFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVo0QklSQU14Z0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJBeUVRREtzQkN3SkFJQVFnQWtjTkFFR2ZBU0VRRE1VQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSHR6NENBQUdvdEFBQkhEYTBCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdmQVNFUURNVUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFRd2hFQXlxQVFzQ1FDQUVJQUpIRFFCQm9BRWhFQXpFQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRURhaUVRQWtBRFFDQUVMUUFBSUFGQnZNK0FnQUJxTFFBQVJ3MnNBU0FCUVFOR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJvQUVoRUF6RUFnc2dBRUVBTmdJQUlCQkJBV29oQVVFTklSQU1xUUVMQWtBZ0JDQUNSdzBBUWFFQklSQU13d0lMQWtBQ1FDQUVMUUFBUWJwL2FnNExBS3dCckFHc0Fhd0JyQUdzQWF3QnJBR3NBUUdzQVFzZ0JFRUJhaUVFUVlzQklSQU1xZ0lMSUFSQkFXb2hCRUdNQVNFUURLa0NDd0pBSUFRZ0FrY05BRUdpQVNFUURNSUNDeUFFTFFBQVFkQUFSdzJwQVNBRVFRRnFJUVFNNlFFTEFrQWdCQ0FDUncwQVFhTUJJUkFNd1FJTEFrQUNRQ0FFTFFBQVFiZC9hZzRIQWFvQnFnR3FBYW9CcWdFQXFnRUxJQVJCQVdvaEJFR09BU0VRREtnQ0N5QUVRUUZxSVFGQklpRVFES1lCQ3dKQUlBUWdBa2NOQUVHa0FTRVFETUFDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRRnFJUkFDUUFOQUlBUXRBQUFnQVVIQXo0Q0FBR290QUFCSERhZ0JJQUZCQVVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR2tBU0VRRE1BQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVIwaEVBeWxBUXNDUUNBRUlBSkhEUUJCcFFFaEVBeS9BZ3NDUUFKQUlBUXRBQUJCcm45cURnTUFxQUVCcUFFTElBUkJBV29oQkVHUUFTRVFES1lDQ3lBRVFRRnFJUUZCQkNFUURLUUJDd0pBSUFRZ0FrY05BRUdtQVNFUURMNENDd0pBQWtBQ1FBSkFBa0FnQkMwQUFFRy9mMm9PRlFDcUFhb0JxZ0dxQWFvQnFnR3FBYW9CcWdHcUFRR3FBYW9CQXFvQnFnRURxZ0dxQVFTcUFRc2dCRUVCYWlFRVFZZ0JJUkFNcUFJTElBUkJBV29oQkVHSkFTRVFES2NDQ3lBRVFRRnFJUVJCaWdFaEVBeW1BZ3NnQkVFQmFpRUVRWThCSVJBTXBRSUxJQVJCQVdvaEJFR1JBU0VRREtRQ0N3SkFJQVFnQWtjTkFFR25BU0VRREwwQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSHR6NENBQUdvdEFBQkhEYVVCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUduQVNFUURMMENDeUFBUVFBMkFnQWdFRUVCYWlFQlFSRWhFQXlpQVFzQ1FDQUVJQUpIRFFCQnFBRWhFQXk4QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUNhaUVRQWtBRFFDQUVMUUFBSUFGQndzK0FnQUJxTFFBQVJ3MmtBU0FCUVFKR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJxQUVoRUF5OEFnc2dBRUVBTmdJQUlCQkJBV29oQVVFc0lSQU1vUUVMQWtBZ0JDQUNSdzBBUWFrQklSQU11d0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJHb2hFQUpBQTBBZ0JDMEFBQ0FCUWNYUGdJQUFhaTBBQUVjTm93RWdBVUVFUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFha0JJUkFNdXdJTElBQkJBRFlDQUNBUVFRRnFJUUZCS3lFUURLQUJDd0pBSUFRZ0FrY05BRUdxQVNFUURMb0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUhLejRDQUFHb3RBQUJIRGFJQklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHcUFTRVFETG9DQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUlFoRUF5ZkFRc0NRQ0FFSUFKSERRQkJxd0VoRUF5NUFnc0NRQUpBQWtBQ1FDQUVMUUFBUWI1L2FnNFBBQUVDcEFHa0FhUUJwQUdrQWFRQnBBR2tBYVFCcEFHa0FRT2tBUXNnQkVFQmFpRUVRWk1CSVJBTW9nSUxJQVJCQVdvaEJFR1VBU0VRREtFQ0N5QUVRUUZxSVFSQmxRRWhFQXlnQWdzZ0JFRUJhaUVFUVpZQklSQU1ud0lMQWtBZ0JDQUNSdzBBUWF3QklSQU11QUlMSUFRdEFBQkJ4UUJIRFo4QklBUkJBV29oQkF6Z0FRc0NRQ0FFSUFKSERRQkJyUUVoRUF5M0Fnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVDYWlFUUFrQURRQ0FFTFFBQUlBRkJ6YytBZ0FCcUxRQUFSdzJmQVNBQlFRSkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCclFFaEVBeTNBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRU9JUkFNbkFFTEFrQWdCQ0FDUncwQVFhNEJJUkFNdGdJTElBUXRBQUJCMEFCSERaMEJJQVJCQVdvaEFVRWxJUkFNbXdFTEFrQWdCQ0FDUncwQVFhOEJJUkFNdFFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJDR29oRUFKQUEwQWdCQzBBQUNBQlFkRFBnSUFBYWkwQUFFY05uUUVnQVVFSVJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYThCSVJBTXRRSUxJQUJCQURZQ0FDQVFRUUZxSVFGQktpRVFESm9CQ3dKQUlBUWdBa2NOQUVHd0FTRVFETFFDQ3dKQUFrQWdCQzBBQUVHcmYyb09Dd0NkQVowQm5RR2RBWjBCblFHZEFaMEJuUUVCblFFTElBUkJBV29oQkVHYUFTRVFESnNDQ3lBRVFRRnFJUVJCbXdFaEVBeWFBZ3NDUUNBRUlBSkhEUUJCc1FFaEVBeXpBZ3NDUUFKQUlBUXRBQUJCdjM5cURoUUFuQUdjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUdjQVp3Qm5BR2NBWndCbkFHY0Fad0JBWndCQ3lBRVFRRnFJUVJCbVFFaEVBeWFBZ3NnQkVFQmFpRUVRWndCSVJBTW1RSUxBa0FnQkNBQ1J3MEFRYklCSVJBTXNnSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQTJvaEVBSkFBMEFnQkMwQUFDQUJRZG5QZ0lBQWFpMEFBRWNObWdFZ0FVRURSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWJJQklSQU1zZ0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJJU0VRREpjQkN3SkFJQVFnQWtjTkFFR3pBU0VRRExFQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVpxSVJBQ1FBTkFJQVF0QUFBZ0FVSGR6NENBQUdvdEFBQkhEWmtCSUFGQkJrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUd6QVNFUURMRUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFSb2hFQXlXQVFzQ1FDQUVJQUpIRFFCQnRBRWhFQXl3QWdzQ1FBSkFBa0FnQkMwQUFFRzdmMm9PRVFDYUFab0JtZ0dhQVpvQm1nR2FBWm9CbWdFQm1nR2FBWm9CbWdHYUFRS2FBUXNnQkVFQmFpRUVRWjBCSVJBTW1BSUxJQVJCQVdvaEJFR2VBU0VRREpjQ0N5QUVRUUZxSVFSQm53RWhFQXlXQWdzQ1FDQUVJQUpIRFFCQnRRRWhFQXl2QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUZhaUVRQWtBRFFDQUVMUUFBSUFGQjVNK0FnQUJxTFFBQVJ3MlhBU0FCUVFWR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJ0UUVoRUF5dkFnc2dBRUVBTmdJQUlCQkJBV29oQVVFb0lSQU1sQUVMQWtBZ0JDQUNSdzBBUWJZQklSQU1yZ0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUWVyUGdJQUFhaTBBQUVjTmxnRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFiWUJJUkFNcmdJTElBQkJBRFlDQUNBUVFRRnFJUUZCQnlFUURKTUJDd0pBSUFRZ0FrY05BRUczQVNFUURLMENDd0pBQWtBZ0JDMEFBRUc3ZjJvT0RnQ1dBWllCbGdHV0FaWUJsZ0dXQVpZQmxnR1dBWllCbGdFQmxnRUxJQVJCQVdvaEJFR2hBU0VRREpRQ0N5QUVRUUZxSVFSQm9nRWhFQXlUQWdzQ1FDQUVJQUpIRFFCQnVBRWhFQXlzQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUNhaUVRQWtBRFFDQUVMUUFBSUFGQjdjK0FnQUJxTFFBQVJ3MlVBU0FCUVFKR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJ1QUVoRUF5c0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFU0lSQU1rUUVMQWtBZ0JDQUNSdzBBUWJrQklSQU1xd0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWZEUGdJQUFhaTBBQUVjTmt3RWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFia0JJUkFNcXdJTElBQkJBRFlDQUNBUVFRRnFJUUZCSUNFUURKQUJDd0pBSUFRZ0FrY05BRUc2QVNFUURLb0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFGcUlSQUNRQU5BSUFRdEFBQWdBVUh5ejRDQUFHb3RBQUJIRFpJQklBRkJBVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHNkFTRVFES29DQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUThoRUF5UEFRc0NRQ0FFSUFKSERRQkJ1d0VoRUF5cEFnc0NRQUpBSUFRdEFBQkJ0MzlxRGdjQWtnR1NBWklCa2dHU0FRR1NBUXNnQkVFQmFpRUVRYVVCSVJBTWtBSUxJQVJCQVdvaEJFR21BU0VRREk4Q0N3SkFJQVFnQWtjTkFFRzhBU0VRREtnQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUWRxSVJBQ1FBTkFJQVF0QUFBZ0FVSDB6NENBQUdvdEFBQkhEWkFCSUFGQkIwWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUc4QVNFUURLZ0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFSc2hFQXlOQVFzQ1FDQUVJQUpIRFFCQnZRRWhFQXluQWdzQ1FBSkFBa0FnQkMwQUFFRytmMm9PRWdDUkFaRUJrUUdSQVpFQmtRR1JBWkVCa1FFQmtRR1JBWkVCa1FHUkFaRUJBcEVCQ3lBRVFRRnFJUVJCcEFFaEVBeVBBZ3NnQkVFQmFpRUVRYWNCSVJBTWpnSUxJQVJCQVdvaEJFR29BU0VRREkwQ0N3SkFJQVFnQWtjTkFFRytBU0VRREtZQ0N5QUVMUUFBUWM0QVJ3Mk5BU0FFUVFGcUlRUU16d0VMQWtBZ0JDQUNSdzBBUWI4QklSQU1wUUlMQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdCQzBBQUVHL2Yyb09GUUFCQWdPY0FRUUZCcHdCbkFHY0FRY0lDUW9MbkFFTURRNFBuQUVMSUFSQkFXb2hBVUhvQUNFUURKb0NDeUFFUVFGcUlRRkI2UUFoRUF5WkFnc2dCRUVCYWlFQlFlNEFJUkFNbUFJTElBUkJBV29oQVVIeUFDRVFESmNDQ3lBRVFRRnFJUUZCOHdBaEVBeVdBZ3NnQkVFQmFpRUJRZllBSVJBTWxRSUxJQVJCQVdvaEFVSDNBQ0VRREpRQ0N5QUVRUUZxSVFGQitnQWhFQXlUQWdzZ0JFRUJhaUVFUVlNQklSQU1rZ0lMSUFSQkFXb2hCRUdFQVNFUURKRUNDeUFFUVFGcUlRUkJoUUVoRUF5UUFnc2dCRUVCYWlFRVFaSUJJUkFNandJTElBUkJBV29oQkVHWUFTRVFESTRDQ3lBRVFRRnFJUVJCb0FFaEVBeU5BZ3NnQkVFQmFpRUVRYU1CSVJBTWpBSUxJQVJCQVdvaEJFR3FBU0VRRElzQ0N3SkFJQVFnQWtZTkFDQUFRWkNBZ0lBQU5nSUlJQUFnQkRZQ0JFR3JBU0VRRElzQ0MwSEFBU0VRREtNQ0N5QUFJQVVnQWhDcWdJQ0FBQ0lCRFlzQklBVWhBUXhjQ3dKQUlBWWdBa1lOQUNBR1FRRnFJUVVNalFFTFFjSUJJUkFNb1FJTEEwQUNRQ0FRTFFBQVFYWnFEZ1NNQVFBQWp3RUFDeUFRUVFGcUloQWdBa2NOQUF0Qnd3RWhFQXlnQWdzQ1FDQUhJQUpHRFFBZ0FFR1JnSUNBQURZQ0NDQUFJQWMyQWdRZ0J5RUJRUUVoRUF5SEFndEJ4QUVoRUF5ZkFnc0NRQ0FISUFKSERRQkJ4UUVoRUF5ZkFnc0NRQUpBSUFjdEFBQkJkbW9PQkFIT0FjNEJBTTRCQ3lBSFFRRnFJUVlNalFFTElBZEJBV29oQlF5SkFRc0NRQ0FISUFKSERRQkJ4Z0VoRUF5ZUFnc0NRQUpBSUFjdEFBQkJkbW9PRndHUEFZOEJBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBUUNQQVFzZ0IwRUJhaUVIQzBHd0FTRVFESVFDQ3dKQUlBZ2dBa2NOQUVISUFTRVFESjBDQ3lBSUxRQUFRU0JIRFkwQklBQkJBRHNCTWlBSVFRRnFJUUZCc3dFaEVBeURBZ3NnQVNFWEFrQURRQ0FYSWdjZ0FrWU5BU0FITFFBQVFWQnFRZjhCY1NJUVFRcFBEY3dCQWtBZ0FDOEJNaUlVUVprelN3MEFJQUFnRkVFS2JDSVVPd0V5SUJCQi8vOERjeUFVUWY3L0EzRkpEUUFnQjBFQmFpRVhJQUFnRkNBUWFpSVFPd0V5SUJCQi8vOERjVUhvQjBrTkFRc0xRUUFoRUNBQVFRQTJBaHdnQUVIQmlZQ0FBRFlDRUNBQVFRMDJBZ3dnQUNBSFFRRnFOZ0lVREp3Q0MwSEhBU0VRREpzQ0N5QUFJQWdnQWhDdWdJQ0FBQ0lRUlEzS0FTQVFRUlZIRFl3QklBQkJ5QUUyQWh3Z0FDQUlOZ0lVSUFCQnlaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeWFBZ3NDUUNBSklBSkhEUUJCekFFaEVBeWFBZ3RCQUNFVVFRRWhGMEVCSVJaQkFDRVFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQWt0QUFCQlVHb09DcFlCbFFFQUFRSURCQVVHQ0pjQkMwRUNJUkFNQmd0QkF5RVFEQVVMUVFRaEVBd0VDMEVGSVJBTUF3dEJCaUVRREFJTFFRY2hFQXdCQzBFSUlSQUxRUUFoRjBFQUlSWkJBQ0VVREk0QkMwRUpJUkJCQVNFVVFRQWhGMEVBSVJZTWpRRUxBa0FnQ2lBQ1J3MEFRYzRCSVJBTW1RSUxJQW90QUFCQkxrY05qZ0VnQ2tFQmFpRUpETW9CQ3lBTElBSkhEWTRCUWRBQklSQU1sd0lMQWtBZ0N5QUNSZzBBSUFCQmpvQ0FnQUEyQWdnZ0FDQUxOZ0lFUWJjQklSQU0vZ0VMUWRFQklSQU1sZ0lMQWtBZ0JDQUNSdzBBUWRJQklSQU1sZ0lMSUFJZ0JHc2dBQ2dDQUNJUWFpRVVJQVFnRUd0QkJHb2hDd05BSUFRdEFBQWdFRUg4ejRDQUFHb3RBQUJIRFk0QklCQkJCRVlONlFFZ0VFRUJhaUVRSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQjBnRWhFQXlWQWdzZ0FDQU1JQUlRcklDQWdBQWlBUTJOQVNBTUlRRU11QUVMQWtBZ0JDQUNSdzBBUWRRQklSQU1sQUlMSUFJZ0JHc2dBQ2dDQUNJUWFpRVVJQVFnRUd0QkFXb2hEQU5BSUFRdEFBQWdFRUdCMElDQUFHb3RBQUJIRFk4QklCQkJBVVlOamdFZ0VFRUJhaUVRSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQjFBRWhFQXlUQWdzQ1FDQUVJQUpIRFFCQjFnRWhFQXlUQWdzZ0FpQUVheUFBS0FJQUloQnFJUlFnQkNBUWEwRUNhaUVMQTBBZ0JDMEFBQ0FRUVlQUWdJQUFhaTBBQUVjTmpnRWdFRUVDUmcyUUFTQVFRUUZxSVJBZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSFdBU0VRREpJQ0N3SkFJQVFnQWtjTkFFSFhBU0VRREpJQ0N3SkFBa0FnQkMwQUFFRzdmMm9PRUFDUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4QkFZOEJDeUFFUVFGcUlRUkJ1d0VoRUF6NUFRc2dCRUVCYWlFRVFid0JJUkFNK0FFTEFrQWdCQ0FDUncwQVFkZ0JJUkFNa1FJTElBUXRBQUJCeUFCSERZd0JJQVJCQVdvaEJBekVBUXNDUUNBRUlBSkdEUUFnQUVHUWdJQ0FBRFlDQ0NBQUlBUTJBZ1JCdmdFaEVBejNBUXRCMlFFaEVBeVBBZ3NDUUNBRUlBSkhEUUJCMmdFaEVBeVBBZ3NnQkMwQUFFSElBRVlOd3dFZ0FFRUJPZ0FvRExrQkN5QUFRUUk2QUM4Z0FDQUVJQUlRcG9DQWdBQWlFQTJOQVVIQ0FTRVFEUFFCQ3lBQUxRQW9RWDlxRGdLM0Fia0J1QUVMQTBBQ1FDQUVMUUFBUVhacURnUUFqZ0dPQVFDT0FRc2dCRUVCYWlJRUlBSkhEUUFMUWQwQklSQU1pd0lMSUFCQkFEb0FMeUFBTFFBdFFRUnhSUTJFQWdzZ0FFRUFPZ0F2SUFCQkFUb0FOQ0FCSVFFTWpBRUxJQkJCRlVZTjJnRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFhZU9nSUFBTmdJUUlBQkJFallDREVFQUlSQU1pQUlMQWtBZ0FDQVFJQUlRdElDQWdBQWlCQTBBSUJBaEFReUJBZ3NDUUNBRVFSVkhEUUFnQUVFRE5nSWNJQUFnRURZQ0ZDQUFRYkNZZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNaUFJTElBQkJBRFlDSENBQUlCQTJBaFFnQUVHbmpvQ0FBRFlDRUNBQVFSSTJBZ3hCQUNFUURJY0NDeUFRUVJWR0RkWUJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSGFqWUNBQURZQ0VDQUFRUlEyQWd4QkFDRVFESVlDQ3lBQUtBSUVJUmNnQUVFQU5nSUVJQkFnRWFkcUloWWhBU0FBSUJjZ0VDQVdJQlFiSWhBUXRZQ0FnQUFpRkVVTmpRRWdBRUVITmdJY0lBQWdFRFlDRkNBQUlCUTJBZ3hCQUNFUURJVUNDeUFBSUFBdkFUQkJnQUZ5T3dFd0lBRWhBUXRCS2lFUURPb0JDeUFRUVJWR0RkRUJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR0RqSUNBQURZQ0VDQUFRUk0yQWd4QkFDRVFESUlDQ3lBUVFSVkdEYzhCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdhajRDQUFEWUNFQ0FBUVNJMkFneEJBQ0VRRElFQ0N5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRdDRDQWdBQWlFQTBBSUFGQkFXb2hBUXlOQVFzZ0FFRU1OZ0ljSUFBZ0VEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURJQUNDeUFRUVJWR0Rjd0JJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR2FqNENBQURZQ0VDQUFRU0kyQWd4QkFDRVFEUDhCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVF0NENBZ0FBaUVBMEFJQUZCQVdvaEFReU1BUXNnQUVFTk5nSWNJQUFnRURZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFA0QkN5QVFRUlZHRGNrQklBQkJBRFlDSENBQUlBRTJBaFFnQUVIR2pJQ0FBRFlDRUNBQVFTTTJBZ3hCQUNFUURQMEJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXVZQ0FnQUFpRUEwQUlBRkJBV29oQVF5TEFRc2dBRUVPTmdJY0lBQWdFRFlDRENBQUlBRkJBV28yQWhSQkFDRVFEUHdCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCd0pXQWdBQTJBaEFnQUVFQ05nSU1RUUFoRUF6N0FRc2dFRUVWUmczRkFTQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnhveUFnQUEyQWhBZ0FFRWpOZ0lNUVFBaEVBejZBUXNnQUVFUU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFEUGtCQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVF1WUNBZ0FBaUJBMEFJQUZCQVdvaEFRenhBUXNnQUVFUk5nSWNJQUFnQkRZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFBnQkN5QVFRUlZHRGNFQklBQkJBRFlDSENBQUlBRTJBaFFnQUVIR2pJQ0FBRFlDRUNBQVFTTTJBZ3hCQUNFUURQY0JDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXVZQ0FnQUFpRUEwQUlBRkJBV29oQVF5SUFRc2dBRUVUTmdJY0lBQWdFRFlDRENBQUlBRkJBV28yQWhSQkFDRVFEUFlCQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVF1WUNBZ0FBaUJBMEFJQUZCQVdvaEFRenRBUXNnQUVFVU5nSWNJQUFnQkRZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFBVQkN5QVFRUlZHRGIwQklBQkJBRFlDSENBQUlBRTJBaFFnQUVHYWo0Q0FBRFlDRUNBQVFTSTJBZ3hCQUNFUURQUUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXQ0Q0FnQUFpRUEwQUlBRkJBV29oQVF5R0FRc2dBRUVXTmdJY0lBQWdFRFlDRENBQUlBRkJBV28yQWhSQkFDRVFEUE1CQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVF0NENBZ0FBaUJBMEFJQUZCQVdvaEFRenBBUXNnQUVFWE5nSWNJQUFnQkRZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFBJQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnpaT0FnQUEyQWhBZ0FFRU1OZ0lNUVFBaEVBenhBUXRDQVNFUkN5QVFRUUZxSVFFQ1FDQUFLUU1nSWhKQy8vLy8vLy8vLy84UFZnMEFJQUFnRWtJRWhpQVJoRGNESUNBQklRRU1oQUVMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUd0aVlDQUFEWUNFQ0FBUVF3MkFneEJBQ0VRRE84QkN5QUFRUUEyQWh3Z0FDQVFOZ0lVSUFCQnpaT0FnQUEyQWhBZ0FFRU1OZ0lNUVFBaEVBenVBUXNnQUNnQ0JDRVhJQUJCQURZQ0JDQVFJQkduYWlJV0lRRWdBQ0FYSUJBZ0ZpQVVHeUlRRUxXQWdJQUFJaFJGRFhNZ0FFRUZOZ0ljSUFBZ0VEWUNGQ0FBSUJRMkFneEJBQ0VRRE8wQkN5QUFRUUEyQWh3Z0FDQVFOZ0lVSUFCQnFweUFnQUEyQWhBZ0FFRVBOZ0lNUVFBaEVBenNBUXNnQUNBUUlBSVF0SUNBZ0FBaUFRMEJJQkFoQVF0QkRpRVFETkVCQ3dKQUlBRkJGVWNOQUNBQVFRSTJBaHdnQUNBUU5nSVVJQUJCc0ppQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF6cUFRc2dBRUVBTmdJY0lBQWdFRFlDRkNBQVFhZU9nSUFBTmdJUUlBQkJFallDREVFQUlSQU02UUVMSUFGQkFXb2hFQUpBSUFBdkFUQWlBVUdBQVhGRkRRQUNRQ0FBSUJBZ0FoQzdnSUNBQUNJQkRRQWdFQ0VCREhBTElBRkJGVWNOdWdFZ0FFRUZOZ0ljSUFBZ0VEWUNGQ0FBUWZtWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTTZRRUxBa0FnQVVHZ0JIRkJvQVJIRFFBZ0FDMEFMVUVDY1EwQUlBQkJBRFlDSENBQUlCQTJBaFFnQUVHV2s0Q0FBRFlDRUNBQVFRUTJBZ3hCQUNFUURPa0JDeUFBSUJBZ0FoQzlnSUNBQUJvZ0VDRUJBa0FDUUFKQUFrQUNRQ0FBSUJBZ0FoQ3pnSUNBQUE0V0FnRUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBd1FMSUFCQkFUb0FMZ3NnQUNBQUx3RXdRY0FBY2pzQk1DQVFJUUVMUVNZaEVBelJBUXNnQUVFak5nSWNJQUFnRURZQ0ZDQUFRYVdXZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNNlFFTElBQkJBRFlDSENBQUlCQTJBaFFnQUVIVmk0Q0FBRFlDRUNBQVFSRTJBZ3hCQUNFUURPZ0JDeUFBTFFBdFFRRnhSUTBCUWNNQklSQU16Z0VMQWtBZ0RTQUNSZzBBQTBBQ1FDQU5MUUFBUVNCR0RRQWdEU0VCRE1RQkN5QU5RUUZxSWcwZ0FrY05BQXRCSlNFUURPY0JDMEVsSVJBTTVnRUxJQUFvQWdRaEJDQUFRUUEyQWdRZ0FDQUVJQTBRcjRDQWdBQWlCRVVOclFFZ0FFRW1OZ0ljSUFBZ0JEWUNEQ0FBSUExQkFXbzJBaFJCQUNFUURPVUJDeUFRUVJWR0Rhc0JJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSDlqWUNBQURZQ0VDQUFRUjAyQWd4QkFDRVFET1FCQ3lBQVFTYzJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNNHdFTElCQWhBVUVCSVJRQ1FBSkFBa0FDUUFKQUFrQUNRQ0FBTFFBc1FYNXFEZ2NHQlFVREFRSUFCUXNnQUNBQUx3RXdRUWh5T3dFd0RBTUxRUUloRkF3QkMwRUVJUlFMSUFCQkFUb0FMQ0FBSUFBdkFUQWdGSEk3QVRBTElCQWhBUXRCS3lFUURNb0JDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkJxNUtBZ0FBMkFoQWdBRUVMTmdJTVFRQWhFQXppQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWVHUGdJQUFOZ0lRSUFCQkNqWUNERUVBSVJBTTRRRUxJQUJCQURvQUxDQVFJUUVNdlFFTElCQWhBVUVCSVJRQ1FBSkFBa0FDUUFKQUlBQXRBQ3hCZTJvT0JBTUJBZ0FGQ3lBQUlBQXZBVEJCQ0hJN0FUQU1Bd3RCQWlFVURBRUxRUVFoRkFzZ0FFRUJPZ0FzSUFBZ0FDOEJNQ0FVY2pzQk1Bc2dFQ0VCQzBFcElSQU14UUVMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUh3bElDQUFEWUNFQ0FBUVFNMkFneEJBQ0VRRE4wQkN3SkFJQTR0QUFCQkRVY05BQ0FBS0FJRUlRRWdBRUVBTmdJRUFrQWdBQ0FCSUE0UXNZQ0FnQUFpQVEwQUlBNUJBV29oQVF4MUN5QUFRU3cyQWh3Z0FDQUJOZ0lNSUFBZ0RrRUJhallDRkVFQUlSQU0zUUVMSUFBdEFDMUJBWEZGRFFGQnhBRWhFQXpEQVFzQ1FDQU9JQUpIRFFCQkxTRVFETndCQ3dKQUFrQURRQUpBSUE0dEFBQkJkbW9PQkFJQUFBTUFDeUFPUVFGcUlnNGdBa2NOQUF0QkxTRVFETjBCQ3lBQUtBSUVJUUVnQUVFQU5nSUVBa0FnQUNBQklBNFFzWUNBZ0FBaUFRMEFJQTRoQVF4MEN5QUFRU3cyQWh3Z0FDQU9OZ0lVSUFBZ0FUWUNERUVBSVJBTTNBRUxJQUFvQWdRaEFTQUFRUUEyQWdRQ1FDQUFJQUVnRGhDeGdJQ0FBQ0lCRFFBZ0RrRUJhaUVCREhNTElBQkJMRFlDSENBQUlBRTJBZ3dnQUNBT1FRRnFOZ0lVUVFBaEVBemJBUXNnQUNnQ0JDRUVJQUJCQURZQ0JDQUFJQVFnRGhDeGdJQ0FBQ0lFRGFBQklBNGhBUXpPQVFzZ0VFRXNSdzBCSUFGQkFXb2hFRUVCSVFFQ1FBSkFBa0FDUUFKQUlBQXRBQ3hCZTJvT0JBTUJBZ1FBQ3lBUUlRRU1CQXRCQWlFQkRBRUxRUVFoQVFzZ0FFRUJPZ0FzSUFBZ0FDOEJNQ0FCY2pzQk1DQVFJUUVNQVFzZ0FDQUFMd0V3UVFoeU93RXdJQkFoQVF0Qk9TRVFETDhCQ3lBQVFRQTZBQ3dnQVNFQkMwRTBJUkFNdlFFTElBQWdBQzhCTUVFZ2Nqc0JNQ0FCSVFFTUFnc2dBQ2dDQkNFRUlBQkJBRFlDQkFKQUlBQWdCQ0FCRUxHQWdJQUFJZ1FOQUNBQklRRU14d0VMSUFCQk56WUNIQ0FBSUFFMkFoUWdBQ0FFTmdJTVFRQWhFQXpVQVFzZ0FFRUlPZ0FzSUFFaEFRdEJNQ0VRRExrQkN3SkFJQUF0QUNoQkFVWU5BQ0FCSVFFTUJBc2dBQzBBTFVFSWNVVU5rd0VnQVNFQkRBTUxJQUF0QURCQklIRU5sQUZCeFFFaEVBeTNBUXNDUUNBUElBSkdEUUFDUUFOQUFrQWdEeTBBQUVGUWFpSUJRZjhCY1VFS1NRMEFJQThoQVVFMUlSQU11Z0VMSUFBcEF5QWlFVUtacytiTW1iUG16QmxXRFFFZ0FDQVJRZ3ArSWhFM0F5QWdFU0FCclVML0FZTWlFa0ovaFZZTkFTQUFJQkVnRW53M0F5QWdEMEVCYWlJUElBSkhEUUFMUVRraEVBelJBUXNnQUNnQ0JDRUNJQUJCQURZQ0JDQUFJQUlnRDBFQmFpSUVFTEdBZ0lBQUlnSU5sUUVnQkNFQkRNTUJDMEU1SVJBTXp3RUxBa0FnQUM4Qk1DSUJRUWh4UlEwQUlBQXRBQ2hCQVVjTkFDQUFMUUF0UVFoeFJRMlFBUXNnQUNBQlFmZjdBM0ZCZ0FSeU93RXdJQThoQVF0Qk55RVFETFFCQ3lBQUlBQXZBVEJCRUhJN0FUQU1xd0VMSUJCQkZVWU5pd0VnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZkNPZ0lBQU5nSVFJQUJCSERZQ0RFRUFJUkFNeXdFTElBQkJ3d0EyQWh3Z0FDQUJOZ0lNSUFBZ0RVRUJhallDRkVFQUlSQU15Z0VMQWtBZ0FTMEFBRUU2UncwQUlBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkN2Z0lDQUFDSVFEUUFnQVVFQmFpRUJER01MSUFCQnd3QTJBaHdnQUNBUU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTXlnRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR3hrWUNBQURZQ0VDQUFRUW8yQWd4QkFDRVFETWtCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCb0ptQWdBQTJBaEFnQUVFZU5nSU1RUUFoRUF6SUFRc2dBRUVBTmdJQUN5QUFRWUFTT3dFcUlBQWdGMEVCYWlJQklBSVFxSUNBZ0FBaUVBMEJJQUVoQVF0Qnh3QWhFQXlzQVFzZ0VFRVZSdzJEQVNBQVFkRUFOZ0ljSUFBZ0FUWUNGQ0FBUWVPWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTXhBRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERjRMSUFCQjBnQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNd3dFTElBQkJBRFlDSENBQUlCUTJBaFFnQUVIQnFJQ0FBRFlDRUNBQVFRYzJBZ3dnQUVFQU5nSUFRUUFoRUF6Q0FRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUtlQWdJQUFJaEFOQUNBQklRRU1YUXNnQUVIVEFEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXpCQVF0QkFDRVFJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR0FrWUNBQURZQ0VDQUFRUWsyQWd3TXdBRUxJQkJCRlVZTmZTQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmxJMkFnQUEyQWhBZ0FFRWhOZ0lNUVFBaEVBeS9BUXRCQVNFV1FRQWhGMEVBSVJSQkFTRVFDeUFBSUJBNkFDc2dBVUVCYWlFQkFrQUNRQ0FBTFFBdFFSQnhEUUFDUUFKQUFrQWdBQzBBS2c0REFRQUNCQXNnRmtVTkF3d0NDeUFVRFFFTUFnc2dGMFVOQVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFSzJBZ0lBQUloQU5BQ0FCSVFFTVhBc2dBRUhZQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeStBUXNnQUNnQ0JDRUVJQUJCQURZQ0JBSkFJQUFnQkNBQkVLMkFnSUFBSWdRTkFDQUJJUUVNclFFTElBQkIyUUEyQWh3Z0FDQUJOZ0lVSUFBZ0JEWUNERUVBSVJBTXZRRUxJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDdGdJQ0FBQ0lFRFFBZ0FTRUJES3NCQ3lBQVFkb0FOZ0ljSUFBZ0FUWUNGQ0FBSUFRMkFneEJBQ0VRREx3QkN5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRcllDQWdBQWlCQTBBSUFFaEFReXBBUXNnQUVIY0FEWUNIQ0FBSUFFMkFoUWdBQ0FFTmdJTVFRQWhFQXk3QVFzQ1FDQUJMUUFBUVZCcUloQkIvd0Z4UVFwUERRQWdBQ0FRT2dBcUlBRkJBV29oQVVIUEFDRVFES0lCQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVFyWUNBZ0FBaUJBMEFJQUVoQVF5bkFRc2dBRUhlQURZQ0hDQUFJQUUyQWhRZ0FDQUVOZ0lNUVFBaEVBeTZBUXNnQUVFQU5nSUFJQmRCQVdvaEFRSkFJQUF0QUNsQkkwOE5BQ0FCSVFFTVdRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFkT0pnSUFBTmdJUUlBQkJDRFlDREVFQUlSQU11UUVMSUFCQkFEWUNBQXRCQUNFUUlBQkJBRFlDSENBQUlBRTJBaFFnQUVHUXM0Q0FBRFlDRUNBQVFRZzJBZ3dNdHdFTElBQkJBRFlDQUNBWFFRRnFJUUVDUUNBQUxRQXBRU0ZIRFFBZ0FTRUJERllMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdiaW9DQUFEWUNFQ0FBUVFnMkFneEJBQ0VRRExZQkN5QUFRUUEyQWdBZ0YwRUJhaUVCQWtBZ0FDMEFLU0lRUVYxcVFRdFBEUUFnQVNFQkRGVUxBa0FnRUVFR1N3MEFRUUVnRUhSQnlnQnhSUTBBSUFFaEFReFZDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZlSmdJQUFOZ0lRSUFCQkNEWUNEQXkxQVFzZ0VFRVZSZzF4SUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUc1allDQUFEWUNFQ0FBUVJvMkFneEJBQ0VRRExRQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcDRDQWdBQWlFQTBBSUFFaEFReFVDeUFBUWVVQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFETE1CQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVFwNENBZ0FBaUVBMEFJQUVoQVF4TkN5QUFRZElBTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURMSUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhOQ3lBQVFkTUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRExFQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcDRDQWdBQWlFQTBBSUFFaEFReFJDeUFBUWVVQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFETEFCQ3lBQVFRQTJBaHdnQUNBQk5nSVVJQUJCeG9xQWdBQTJBaEFnQUVFSE5nSU1RUUFoRUF5dkFRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUtlQWdJQUFJaEFOQUNBQklRRU1TUXNnQUVIU0FEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXl1QVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFS2VBZ0lBQUloQU5BQ0FCSVFFTVNRc2dBRUhUQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeXRBUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNVFFzZ0FFSGxBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF5c0FRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFkeUlnSUFBTmdJUUlBQkJCellDREVFQUlSQU1xd0VMSUJCQlAwY05BU0FCUVFGcUlRRUxRUVVoRUF5UUFRdEJBQ0VRSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUg5a29DQUFEWUNFQ0FBUVFjMkFnd01xQUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREVJTElBQkIwZ0EyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXB3RUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERUlMSUFCQjB3QTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNcGdFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkNuZ0lDQUFDSVFEUUFnQVNFQkRFWUxJQUJCNVFBMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU1wUUVMSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0ZCQ25nSUNBQUNJQkRRQWdGQ0VCREQ4TElBQkIwZ0EyQWh3Z0FDQVVOZ0lVSUFBZ0FUWUNERUVBSVJBTXBBRUxJQUFvQWdRaEFTQUFRUUEyQWdRQ1FDQUFJQUVnRkJDbmdJQ0FBQ0lCRFFBZ0ZDRUJERDhMSUFCQjB3QTJBaHdnQUNBVU5nSVVJQUFnQVRZQ0RFRUFJUkFNb3dFTElBQW9BZ1FoQVNBQVFRQTJBZ1FDUUNBQUlBRWdGQkNuZ0lDQUFDSUJEUUFnRkNFQkRFTUxJQUJCNVFBMkFod2dBQ0FVTmdJVUlBQWdBVFlDREVFQUlSQU1vZ0VMSUFCQkFEWUNIQ0FBSUJRMkFoUWdBRUhEajRDQUFEWUNFQ0FBUVFjMkFneEJBQ0VRREtFQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnc0K0FnQUEyQWhBZ0FFRUhOZ0lNUVFBaEVBeWdBUXRCQUNFUUlBQkJBRFlDSENBQUlCUTJBaFFnQUVHTW5JQ0FBRFlDRUNBQVFRYzJBZ3dNbndFTElBQkJBRFlDSENBQUlCUTJBaFFnQUVHTW5JQ0FBRFlDRUNBQVFRYzJBZ3hCQUNFUURKNEJDeUFBUVFBMkFod2dBQ0FVTmdJVUlBQkIvcEdBZ0FBMkFoQWdBRUVITmdJTVFRQWhFQXlkQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVk2YmdJQUFOZ0lRSUFCQkJqWUNERUVBSVJBTW5BRUxJQkJCRlVZTlZ5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnpJNkFnQUEyQWhBZ0FFRWdOZ0lNUVFBaEVBeWJBUXNnQUVFQU5nSUFJQkJCQVdvaEFVRWtJUkFMSUFBZ0VEb0FLU0FBS0FJRUlSQWdBRUVBTmdJRUlBQWdFQ0FCRUt1QWdJQUFJaEFOVkNBQklRRU1QZ3NnQUVFQU5nSUFDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0JEWUNGQ0FBUWZHYmdJQUFOZ0lRSUFCQkJqWUNEQXlYQVFzZ0FVRVZSZzFRSUFCQkFEWUNIQ0FBSUFVMkFoUWdBRUh3aklDQUFEWUNFQ0FBUVJzMkFneEJBQ0VRREpZQkN5QUFLQUlFSVFVZ0FFRUFOZ0lFSUFBZ0JTQVFFS21BZ0lBQUlnVU5BU0FRUVFGcUlRVUxRYTBCSVJBTWV3c2dBRUhCQVRZQ0hDQUFJQVUyQWd3Z0FDQVFRUUZxTmdJVVFRQWhFQXlUQVFzZ0FDZ0NCQ0VHSUFCQkFEWUNCQ0FBSUFZZ0VCQ3BnSUNBQUNJR0RRRWdFRUVCYWlFR0MwR3VBU0VRREhnTElBQkJ3Z0UyQWh3Z0FDQUdOZ0lNSUFBZ0VFRUJhallDRkVFQUlSQU1rQUVMSUFCQkFEWUNIQ0FBSUFjMkFoUWdBRUdYaTRDQUFEWUNFQ0FBUVEwMkFneEJBQ0VRREk4QkN5QUFRUUEyQWh3Z0FDQUlOZ0lVSUFCQjQ1Q0FnQUEyQWhBZ0FFRUpOZ0lNUVFBaEVBeU9BUXNnQUVFQU5nSWNJQUFnQ0RZQ0ZDQUFRWlNOZ0lBQU5nSVFJQUJCSVRZQ0RFRUFJUkFNalFFTFFRRWhGa0VBSVJkQkFDRVVRUUVoRUFzZ0FDQVFPZ0FySUFsQkFXb2hDQUpBQWtBZ0FDMEFMVUVRY1EwQUFrQUNRQUpBSUFBdEFDb09Bd0VBQWdRTElCWkZEUU1NQWdzZ0ZBMEJEQUlMSUJkRkRRRUxJQUFvQWdRaEVDQUFRUUEyQWdRZ0FDQVFJQWdRcllDQWdBQWlFRVVOUFNBQVFja0JOZ0ljSUFBZ0NEWUNGQ0FBSUJBMkFneEJBQ0VRREl3QkN5QUFLQUlFSVFRZ0FFRUFOZ0lFSUFBZ0JDQUlFSzJBZ0lBQUlnUkZEWFlnQUVIS0FUWUNIQ0FBSUFnMkFoUWdBQ0FFTmdJTVFRQWhFQXlMQVFzZ0FDZ0NCQ0VFSUFCQkFEWUNCQ0FBSUFRZ0NSQ3RnSUNBQUNJRVJRMTBJQUJCeXdFMkFod2dBQ0FKTmdJVUlBQWdCRFlDREVFQUlSQU1pZ0VMSUFBb0FnUWhCQ0FBUVFBMkFnUWdBQ0FFSUFvUXJZQ0FnQUFpQkVVTmNpQUFRYzBCTmdJY0lBQWdDallDRkNBQUlBUTJBZ3hCQUNFUURJa0JDd0pBSUFzdEFBQkJVR29pRUVIL0FYRkJDazhOQUNBQUlCQTZBQ29nQzBFQmFpRUtRYllCSVJBTWNBc2dBQ2dDQkNFRUlBQkJBRFlDQkNBQUlBUWdDeEN0Z0lDQUFDSUVSUTF3SUFCQnp3RTJBaHdnQUNBTE5nSVVJQUFnQkRZQ0RFRUFJUkFNaUFFTElBQkJBRFlDSENBQUlBUTJBaFFnQUVHUXM0Q0FBRFlDRUNBQVFRZzJBZ3dnQUVFQU5nSUFRUUFoRUF5SEFRc2dBVUVWUmcwL0lBQkJBRFlDSENBQUlBdzJBaFFnQUVITWpvQ0FBRFlDRUNBQVFTQTJBZ3hCQUNFUURJWUJDeUFBUVlFRU93RW9JQUFvQWdRaEVDQUFRZ0EzQXdBZ0FDQVFJQXhCQVdvaURCQ3JnSUNBQUNJUVJRMDRJQUJCMHdFMkFod2dBQ0FNTmdJVUlBQWdFRFlDREVFQUlSQU1oUUVMSUFCQkFEWUNBQXRCQUNFUUlBQkJBRFlDSENBQUlBUTJBaFFnQUVIWW00Q0FBRFlDRUNBQVFRZzJBZ3dNZ3dFTElBQW9BZ1FoRUNBQVFnQTNBd0FnQUNBUUlBdEJBV29pQ3hDcmdJQ0FBQ0lRRFFGQnhnRWhFQXhwQ3lBQVFRSTZBQ2dNVlFzZ0FFSFZBVFlDSENBQUlBczJBaFFnQUNBUU5nSU1RUUFoRUF5QUFRc2dFRUVWUmcwM0lBQkJBRFlDSENBQUlBUTJBaFFnQUVHa2pJQ0FBRFlDRUNBQVFSQTJBZ3hCQUNFUURIOExJQUF0QURSQkFVY05OQ0FBSUFRZ0FoQzhnSUNBQUNJUVJRMDBJQkJCRlVjTk5TQUFRZHdCTmdJY0lBQWdCRFlDRkNBQVFkV1dnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1mZ3RCQUNFUUlBQkJBRFlDSENBQVFhK0xnSUFBTmdJUUlBQkJBallDRENBQUlCUkJBV28yQWhRTWZRdEJBQ0VRREdNTFFRSWhFQXhpQzBFTklSQU1ZUXRCRHlFUURHQUxRU1VoRUF4ZkMwRVRJUkFNWGd0QkZTRVFERjBMUVJZaEVBeGNDMEVYSVJBTVd3dEJHQ0VRREZvTFFSa2hFQXhaQzBFYUlSQU1XQXRCR3lFUURGY0xRUndoRUF4V0MwRWRJUkFNVlF0Qkh5RVFERlFMUVNFaEVBeFRDMEVqSVJBTVVndEJ4Z0FoRUF4UkMwRXVJUkFNVUF0Qkx5RVFERThMUVRzaEVBeE9DMEU5SVJBTVRRdEJ5QUFoRUF4TUMwSEpBQ0VRREVzTFFjc0FJUkFNU2d0QnpBQWhFQXhKQzBIT0FDRVFERWdMUWRFQUlSQU1Sd3RCMVFBaEVBeEdDMEhZQUNFUURFVUxRZGtBSVJBTVJBdEIyd0FoRUF4REMwSGtBQ0VRREVJTFFlVUFJUkFNUVF0QjhRQWhFQXhBQzBIMEFDRVFERDhMUVkwQklSQU1QZ3RCbHdFaEVBdzlDMEdwQVNFUUREd0xRYXdCSVJBTU93dEJ3QUVoRUF3NkMwRzVBU0VRRERrTFFhOEJJUkFNT0F0QnNRRWhFQXczQzBHeUFTRVFERFlMUWJRQklSQU1OUXRCdFFFaEVBdzBDMEc2QVNFUURETUxRYjBCSVJBTU1ndEJ2d0VoRUF3eEMwSEJBU0VRRERBTElBQkJBRFlDSENBQUlBUTJBaFFnQUVIcGk0Q0FBRFlDRUNBQVFSODJBZ3hCQUNFUURFZ0xJQUJCMndFMkFod2dBQ0FFTmdJVUlBQkIrcGFBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXhIQ3lBQVFmZ0FOZ0ljSUFBZ0REWUNGQ0FBUWNxWWdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTVJnc2dBRUhSQURZQ0hDQUFJQVUyQWhRZ0FFR3dsNENBQURZQ0VDQUFRUlUyQWd4QkFDRVFERVVMSUFCQitRQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNUkFzZ0FFSDRBRFlDSENBQUlBRTJBaFFnQUVIS21JQ0FBRFlDRUNBQVFSVTJBZ3hCQUNFUURFTUxJQUJCNUFBMkFod2dBQ0FCTmdJVUlBQkI0NWVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXhDQ3lBQVFkY0FOZ0ljSUFBZ0FUWUNGQ0FBUWNtWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTVFRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFibU5nSUFBTmdJUUlBQkJHallDREVFQUlSQU1RQXNnQUVIQ0FEWUNIQ0FBSUFFMkFoUWdBRUhqbUlDQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREQ4TElBQkJBRFlDQkNBQUlBOGdEeEN4Z0lDQUFDSUVSUTBCSUFCQk9qWUNIQ0FBSUFRMkFnd2dBQ0FQUVFGcU5nSVVRUUFoRUF3K0N5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRc1lDQWdBQWlCRVVOQUNBQVFUczJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTVBnc2dBVUVCYWlFQkRDMExJQTlCQVdvaEFRd3RDeUFBUVFBMkFod2dBQ0FQTmdJVUlBQkI1SktBZ0FBMkFoQWdBRUVFTmdJTVFRQWhFQXc3Q3lBQVFUWTJBaHdnQUNBRU5nSVVJQUFnQWpZQ0RFRUFJUkFNT2dzZ0FFRXVOZ0ljSUFBZ0RqWUNGQ0FBSUFRMkFneEJBQ0VRRERrTElBQkIwQUEyQWh3Z0FDQUJOZ0lVSUFCQmtaaUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBdzRDeUFOUVFGcUlRRU1MQXNnQUVFVk5nSWNJQUFnQVRZQ0ZDQUFRWUtaZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTmdzZ0FFRWJOZ0ljSUFBZ0FUWUNGQ0FBUVpHWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTU5Rc2dBRUVQTmdJY0lBQWdBVFlDRkNBQVFaR1hnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1OQXNnQUVFTE5nSWNJQUFnQVRZQ0ZDQUFRWkdYZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTXdzZ0FFRWFOZ0ljSUFBZ0FUWUNGQ0FBUVlLWmdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTU1nc2dBRUVMTmdJY0lBQWdBVFlDRkNBQVFZS1pnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1NUXNnQUVFS05nSWNJQUFnQVRZQ0ZDQUFRZVNXZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTUFzZ0FFRWVOZ0ljSUFBZ0FUWUNGQ0FBUWZtWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTUx3c2dBRUVBTmdJY0lBQWdFRFlDRkNBQVFkcU5nSUFBTmdJUUlBQkJGRFlDREVFQUlSQU1MZ3NnQUVFRU5nSWNJQUFnQVRZQ0ZDQUFRYkNZZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTFFzZ0FFRUFOZ0lBSUF0QkFXb2hDd3RCdUFFaEVBd1NDeUFBUVFBMkFnQWdFRUVCYWlFQlFmVUFJUkFNRVFzZ0FTRUJBa0FnQUMwQUtVRUZSdzBBUWVNQUlSQU1FUXRCNGdBaEVBd1FDMEVBSVJBZ0FFRUFOZ0ljSUFCQjVKR0FnQUEyQWhBZ0FFRUhOZ0lNSUFBZ0ZFRUJhallDRkF3b0N5QUFRUUEyQWdBZ0YwRUJhaUVCUWNBQUlSQU1EZ3RCQVNFQkN5QUFJQUU2QUN3Z0FFRUFOZ0lBSUJkQkFXb2hBUXRCS0NFUURBc0xJQUVoQVF0Qk9DRVFEQWtMQWtBZ0FTSVBJQUpHRFFBRFFBSkFJQTh0QUFCQmdMNkFnQUJxTFFBQUlnRkJBVVlOQUNBQlFRSkhEUU1nRDBFQmFpRUJEQVFMSUE5QkFXb2lEeUFDUncwQUMwRStJUkFNSWd0QlBpRVFEQ0VMSUFCQkFEb0FMQ0FQSVFFTUFRdEJDeUVRREFZTFFUb2hFQXdGQ3lBQlFRRnFJUUZCTFNFUURBUUxJQUFnQVRvQUxDQUFRUUEyQWdBZ0ZrRUJhaUVCUVF3aEVBd0RDeUFBUVFBMkFnQWdGMEVCYWlFQlFRb2hFQXdDQ3lBQVFRQTJBZ0FMSUFCQkFEb0FMQ0FOSVFGQkNTRVFEQUFMQzBFQUlSQWdBRUVBTmdJY0lBQWdDellDRkNBQVFjMlFnSUFBTmdJUUlBQkJDVFlDREF3WEMwRUFJUkFnQUVFQU5nSWNJQUFnQ2pZQ0ZDQUFRZW1LZ0lBQU5nSVFJQUJCQ1RZQ0RBd1dDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0NUWUNGQ0FBUWJlUWdJQUFOZ0lRSUFCQkNUWUNEQXdWQzBFQUlSQWdBRUVBTmdJY0lBQWdDRFlDRkNBQVFaeVJnSUFBTmdJUUlBQkJDVFlDREF3VUMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYzJRZ0lBQU5nSVFJQUJCQ1RZQ0RBd1RDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWVtS2dJQUFOZ0lRSUFCQkNUWUNEQXdTQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFiZVFnSUFBTmdJUUlBQkJDVFlDREF3UkMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWnlSZ0lBQU5nSVFJQUJCQ1RZQ0RBd1FDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVplVmdJQUFOZ0lRSUFCQkR6WUNEQXdQQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFaZVZnSUFBTmdJUUlBQkJEellDREF3T0MwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRY0NTZ0lBQU5nSVFJQUJCQ3pZQ0RBd05DMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVpXSmdJQUFOZ0lRSUFCQkN6WUNEQXdNQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFlR1BnSUFBTmdJUUlBQkJDallDREF3TEMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZnVQZ0lBQU5nSVFJQUJCQ2pZQ0RBd0tDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZHWmdJQUFOZ0lRSUFCQkFqWUNEQXdKQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFjU1VnSUFBTmdJUUlBQkJBallDREF3SUMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZktWZ0lBQU5nSVFJQUJCQWpZQ0RBd0hDeUFBUVFJMkFod2dBQ0FCTmdJVUlBQkJuSnFBZ0FBMkFoQWdBRUVXTmdJTVFRQWhFQXdHQzBFQklSQU1CUXRCMUFBaEVDQUJJZ1FnQWtZTkJDQURRUWhxSUFBZ0JDQUNRZGpDZ0lBQVFRb1F4WUNBZ0FBZ0F5Z0NEQ0VFSUFNb0FnZ09Bd0VFQWdBTEVNcUFnSUFBQUFzZ0FFRUFOZ0ljSUFCQnRacUFnQUEyQWhBZ0FFRVhOZ0lNSUFBZ0JFRUJhallDRkVFQUlSQU1BZ3NnQUVFQU5nSWNJQUFnQkRZQ0ZDQUFRY3FhZ0lBQU5nSVFJQUJCQ1RZQ0RFRUFJUkFNQVFzQ1FDQUJJZ1FnQWtjTkFFRWlJUkFNQVFzZ0FFR0pnSUNBQURZQ0NDQUFJQVEyQWdSQklTRVFDeUFEUVJCcUpJQ0FnSUFBSUJBTHJ3RUJBbjhnQVNnQ0FDRUdBa0FDUUNBQ0lBTkdEUUFnQkNBR2FpRUVJQVlnQTJvZ0Ftc2hCeUFDSUFaQmYzTWdCV29pQm1vaEJRTkFBa0FnQWkwQUFDQUVMUUFBUmcwQVFRSWhCQXdEQ3dKQUlBWU5BRUVBSVFRZ0JTRUNEQU1MSUFaQmYyb2hCaUFFUVFGcUlRUWdBa0VCYWlJQ0lBTkhEUUFMSUFjaEJpQURJUUlMSUFCQkFUWUNBQ0FCSUFZMkFnQWdBQ0FDTmdJRUR3c2dBVUVBTmdJQUlBQWdCRFlDQUNBQUlBSTJBZ1FMQ2dBZ0FCREhnSUNBQUF2eU5nRUxmeU9BZ0lDQUFFRVFheUlCSklDQWdJQUFBa0JCQUNnQ29OQ0FnQUFOQUVFQUVNdUFnSUFBUVlEVWhJQUFheUlDUWRrQVNRMEFRUUFoQXdKQVFRQW9BdURUZ0lBQUlnUU5BRUVBUW44M0F1elRnSUFBUVFCQ2dJQ0VnSUNBd0FBM0F1VFRnSUFBUVFBZ0FVRUlha0Z3Y1VIWXF0V3FCWE1pQkRZQzROT0FnQUJCQUVFQU5nTDAwNENBQUVFQVFRQTJBc1RUZ0lBQUMwRUFJQUkyQXN6VGdJQUFRUUJCZ05TRWdBQTJBc2pUZ0lBQVFRQkJnTlNFZ0FBMkFwalFnSUFBUVFBZ0JEWUNyTkNBZ0FCQkFFRi9OZ0tvMElDQUFBTkFJQU5CeE5DQWdBQnFJQU5CdU5DQWdBQnFJZ1EyQWdBZ0JDQURRYkRRZ0lBQWFpSUZOZ0lBSUFOQnZOQ0FnQUJxSUFVMkFnQWdBMEhNMElDQUFHb2dBMEhBMElDQUFHb2lCVFlDQUNBRklBUTJBZ0FnQTBIVTBJQ0FBR29nQTBISTBJQ0FBR29pQkRZQ0FDQUVJQVUyQWdBZ0EwSFEwSUNBQUdvZ0JEWUNBQ0FEUVNCcUlnTkJnQUpIRFFBTFFZRFVoSUFBUVhoQmdOU0VnQUJyUVE5eFFRQkJnTlNFZ0FCQkNHcEJEM0ViSWdOcUlnUkJCR29nQWtGSWFpSUZJQU5ySWdOQkFYSTJBZ0JCQUVFQUtBTHcwNENBQURZQ3BOQ0FnQUJCQUNBRE5nS1UwSUNBQUVFQUlBUTJBcURRZ0lBQVFZRFVoSUFBSUFWcVFUZzJBZ1FMQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCN0FGTERRQUNRRUVBS0FLSTBJQ0FBQ0lHUVJBZ0FFRVRha0Z3Y1NBQVFRdEpHeUlDUVFOMklnUjJJZ05CQTNGRkRRQUNRQUpBSUFOQkFYRWdCSEpCQVhNaUJVRURkQ0lFUWJEUWdJQUFhaUlESUFSQnVOQ0FnQUJxS0FJQUlnUW9BZ2dpQWtjTkFFRUFJQVpCZmlBRmQzRTJBb2pRZ0lBQURBRUxJQU1nQWpZQ0NDQUNJQU0yQWd3TElBUkJDR29oQXlBRUlBVkJBM1FpQlVFRGNqWUNCQ0FFSUFWcUlnUWdCQ2dDQkVFQmNqWUNCQXdNQ3lBQ1FRQW9BcERRZ0lBQUlnZE5EUUVDUUNBRFJRMEFBa0FDUUNBRElBUjBRUUlnQkhRaUEwRUFJQU5yY25FaUEwRUFJQU5yY1VGL2FpSURJQU5CREhaQkVIRWlBM1lpQkVFRmRrRUljU0lGSUFOeUlBUWdCWFlpQTBFQ2RrRUVjU0lFY2lBRElBUjJJZ05CQVhaQkFuRWlCSElnQXlBRWRpSURRUUYyUVFGeElnUnlJQU1nQkhacUlnUkJBM1FpQTBHdzBJQ0FBR29pQlNBRFFialFnSUFBYWlnQ0FDSURLQUlJSWdCSERRQkJBQ0FHUVg0Z0JIZHhJZ1kyQW9qUWdJQUFEQUVMSUFVZ0FEWUNDQ0FBSUFVMkFnd0xJQU1nQWtFRGNqWUNCQ0FESUFSQkEzUWlCR29nQkNBQ2F5SUZOZ0lBSUFNZ0Ftb2lBQ0FGUVFGeU5nSUVBa0FnQjBVTkFDQUhRWGh4UWJEUWdJQUFhaUVDUVFBb0FwelFnSUFBSVFRQ1FBSkFJQVpCQVNBSFFRTjJkQ0lJY1EwQVFRQWdCaUFJY2pZQ2lOQ0FnQUFnQWlFSURBRUxJQUlvQWdnaENBc2dDQ0FFTmdJTUlBSWdCRFlDQ0NBRUlBSTJBZ3dnQkNBSU5nSUlDeUFEUVFocUlRTkJBQ0FBTmdLYzBJQ0FBRUVBSUFVMkFwRFFnSUFBREF3TFFRQW9Bb3pRZ0lBQUlnbEZEUUVnQ1VFQUlBbHJjVUYvYWlJRElBTkJESFpCRUhFaUEzWWlCRUVGZGtFSWNTSUZJQU55SUFRZ0JYWWlBMEVDZGtFRWNTSUVjaUFESUFSMklnTkJBWFpCQW5FaUJISWdBeUFFZGlJRFFRRjJRUUZ4SWdSeUlBTWdCSFpxUVFKMFFialNnSUFBYWlnQ0FDSUFLQUlFUVhoeElBSnJJUVFnQUNFRkFrQURRQUpBSUFVb0FoQWlBdzBBSUFWQkZHb29BZ0FpQTBVTkFnc2dBeWdDQkVGNGNTQUNheUlGSUFRZ0JTQUVTU0lGR3lFRUlBTWdBQ0FGR3lFQUlBTWhCUXdBQ3dzZ0FDZ0NHQ0VLQWtBZ0FDZ0NEQ0lJSUFCR0RRQWdBQ2dDQ0NJRFFRQW9BcGpRZ0lBQVNSb2dDQ0FETmdJSUlBTWdDRFlDREF3TEN3SkFJQUJCRkdvaUJTZ0NBQ0lERFFBZ0FDZ0NFQ0lEUlEwRElBQkJFR29oQlFzRFFDQUZJUXNnQXlJSVFSUnFJZ1VvQWdBaUF3MEFJQWhCRUdvaEJTQUlLQUlRSWdNTkFBc2dDMEVBTmdJQURBb0xRWDhoQWlBQVFiOS9TdzBBSUFCQkUyb2lBMEZ3Y1NFQ1FRQW9Bb3pRZ0lBQUlnZEZEUUJCQUNFTEFrQWdBa0dBQWtrTkFFRWZJUXNnQWtILy8vOEhTdzBBSUFOQkNIWWlBeUFEUVlEK1AycEJFSFpCQ0hFaUEzUWlCQ0FFUVlEZ0gycEJFSFpCQkhFaUJIUWlCU0FGUVlDQUQycEJFSFpCQW5FaUJYUkJEM1lnQXlBRWNpQUZjbXNpQTBFQmRDQUNJQU5CRldwMlFRRnhja0VjYWlFTEMwRUFJQUpySVFRQ1FBSkFBa0FDUUNBTFFRSjBRYmpTZ0lBQWFpZ0NBQ0lGRFFCQkFDRURRUUFoQ0F3QkMwRUFJUU1nQWtFQVFSa2dDMEVCZG1zZ0MwRWZSaHQwSVFCQkFDRUlBMEFDUUNBRktBSUVRWGh4SUFKcklnWWdCRThOQUNBR0lRUWdCU0VJSUFZTkFFRUFJUVFnQlNFSUlBVWhBd3dEQ3lBRElBVkJGR29vQWdBaUJpQUdJQVVnQUVFZGRrRUVjV3BCRUdvb0FnQWlCVVliSUFNZ0Joc2hBeUFBUVFGMElRQWdCUTBBQ3dzQ1FDQURJQWh5RFFCQkFDRUlRUUlnQzNRaUEwRUFJQU5yY2lBSGNTSURSUTBESUFOQkFDQURhM0ZCZjJvaUF5QURRUXgyUVJCeElnTjJJZ1ZCQlhaQkNIRWlBQ0FEY2lBRklBQjJJZ05CQW5aQkJIRWlCWElnQXlBRmRpSURRUUYyUVFKeElnVnlJQU1nQlhZaUEwRUJka0VCY1NJRmNpQURJQVYyYWtFQ2RFRzQwb0NBQUdvb0FnQWhBd3NnQTBVTkFRc0RRQ0FES0FJRVFYaHhJQUpySWdZZ0JFa2hBQUpBSUFNb0FoQWlCUTBBSUFOQkZHb29BZ0FoQlFzZ0JpQUVJQUFiSVFRZ0F5QUlJQUFiSVFnZ0JTRURJQVVOQUFzTElBaEZEUUFnQkVFQUtBS1EwSUNBQUNBQ2EwOE5BQ0FJS0FJWUlRc0NRQ0FJS0FJTUlnQWdDRVlOQUNBSUtBSUlJZ05CQUNnQ21OQ0FnQUJKR2lBQUlBTTJBZ2dnQXlBQU5nSU1EQWtMQWtBZ0NFRVVhaUlGS0FJQUlnTU5BQ0FJS0FJUUlnTkZEUU1nQ0VFUWFpRUZDd05BSUFVaEJpQURJZ0JCRkdvaUJTZ0NBQ0lERFFBZ0FFRVFhaUVGSUFBb0FoQWlBdzBBQ3lBR1FRQTJBZ0FNQ0FzQ1FFRUFLQUtRMElDQUFDSURJQUpKRFFCQkFDZ0NuTkNBZ0FBaEJBSkFBa0FnQXlBQ2F5SUZRUkJKRFFBZ0JDQUNhaUlBSUFWQkFYSTJBZ1JCQUNBRk5nS1EwSUNBQUVFQUlBQTJBcHpRZ0lBQUlBUWdBMm9nQlRZQ0FDQUVJQUpCQTNJMkFnUU1BUXNnQkNBRFFRTnlOZ0lFSUFRZ0Eyb2lBeUFES0FJRVFRRnlOZ0lFUVFCQkFEWUNuTkNBZ0FCQkFFRUFOZ0tRMElDQUFBc2dCRUVJYWlFRERBb0xBa0JCQUNnQ2xOQ0FnQUFpQUNBQ1RRMEFRUUFvQXFEUWdJQUFJZ01nQW1vaUJDQUFJQUpySWdWQkFYSTJBZ1JCQUNBRk5nS1UwSUNBQUVFQUlBUTJBcURRZ0lBQUlBTWdBa0VEY2pZQ0JDQURRUWhxSVFNTUNnc0NRQUpBUVFBb0F1RFRnSUFBUlEwQVFRQW9BdWpUZ0lBQUlRUU1BUXRCQUVKL053THMwNENBQUVFQVFvQ0FoSUNBZ01BQU53TGswNENBQUVFQUlBRkJER3BCY0hGQjJLclZxZ1Z6TmdMZzA0Q0FBRUVBUVFBMkF2VFRnSUFBUVFCQkFEWUN4Tk9BZ0FCQmdJQUVJUVFMUVFBaEF3SkFJQVFnQWtISEFHb2lCMm9pQmtFQUlBUnJJZ3R4SWdnZ0Frc05BRUVBUVRBMkF2alRnSUFBREFvTEFrQkJBQ2dDd05PQWdBQWlBMFVOQUFKQVFRQW9BcmpUZ0lBQUlnUWdDR29pQlNBRVRRMEFJQVVnQTAwTkFRdEJBQ0VEUVFCQk1EWUMrTk9BZ0FBTUNndEJBQzBBeE5PQWdBQkJCSEVOQkFKQUFrQUNRRUVBS0FLZzBJQ0FBQ0lFUlEwQVFjalRnSUFBSVFNRFFBSkFJQU1vQWdBaUJTQUVTdzBBSUFVZ0F5Z0NCR29nQkVzTkF3c2dBeWdDQ0NJRERRQUxDMEVBRU11QWdJQUFJZ0JCZjBZTkJTQUlJUVlDUUVFQUtBTGswNENBQUNJRFFYOXFJZ1FnQUhGRkRRQWdDQ0FBYXlBRUlBQnFRUUFnQTJ0eGFpRUdDeUFHSUFKTkRRVWdCa0grLy8vL0Iwc05CUUpBUVFBb0FzRFRnSUFBSWdORkRRQkJBQ2dDdU5PQWdBQWlCQ0FHYWlJRklBUk5EUVlnQlNBRFN3MEdDeUFHRU11QWdJQUFJZ01nQUVjTkFRd0hDeUFHSUFCcklBdHhJZ1pCL3YvLy93ZExEUVFnQmhETGdJQ0FBQ0lBSUFNb0FnQWdBeWdDQkdwR0RRTWdBQ0VEQ3dKQUlBTkJmMFlOQUNBQ1FjZ0FhaUFHVFEwQUFrQWdCeUFHYTBFQUtBTG8wNENBQUNJRWFrRUFJQVJyY1NJRVFmNy8vLzhIVFEwQUlBTWhBQXdIQ3dKQUlBUVF5NENBZ0FCQmYwWU5BQ0FFSUFacUlRWWdBeUVBREFjTFFRQWdCbXNReTRDQWdBQWFEQVFMSUFNaEFDQURRWDlIRFFVTUF3dEJBQ0VJREFjTFFRQWhBQXdGQ3lBQVFYOUhEUUlMUVFCQkFDZ0N4Tk9BZ0FCQkJISTJBc1RUZ0lBQUN5QUlRZjcvLy84SFN3MEJJQWdReTRDQWdBQWhBRUVBRU11QWdJQUFJUU1nQUVGL1JnMEJJQU5CZjBZTkFTQUFJQU5QRFFFZ0F5QUFheUlHSUFKQk9HcE5EUUVMUVFCQkFDZ0N1Tk9BZ0FBZ0Jtb2lBellDdU5PQWdBQUNRQ0FEUVFBb0FyelRnSUFBVFEwQVFRQWdBellDdk5PQWdBQUxBa0FDUUFKQUFrQkJBQ2dDb05DQWdBQWlCRVVOQUVISTA0Q0FBQ0VEQTBBZ0FDQURLQUlBSWdVZ0F5Z0NCQ0lJYWtZTkFpQURLQUlJSWdNTkFBd0RDd3NDUUFKQVFRQW9BcGpRZ0lBQUlnTkZEUUFnQUNBRFR3MEJDMEVBSUFBMkFwalFnSUFBQzBFQUlRTkJBQ0FHTmdMTTA0Q0FBRUVBSUFBMkFzalRnSUFBUVFCQmZ6WUNxTkNBZ0FCQkFFRUFLQUxnMDRDQUFEWUNyTkNBZ0FCQkFFRUFOZ0xVMDRDQUFBTkFJQU5CeE5DQWdBQnFJQU5CdU5DQWdBQnFJZ1EyQWdBZ0JDQURRYkRRZ0lBQWFpSUZOZ0lBSUFOQnZOQ0FnQUJxSUFVMkFnQWdBMEhNMElDQUFHb2dBMEhBMElDQUFHb2lCVFlDQUNBRklBUTJBZ0FnQTBIVTBJQ0FBR29nQTBISTBJQ0FBR29pQkRZQ0FDQUVJQVUyQWdBZ0EwSFEwSUNBQUdvZ0JEWUNBQ0FEUVNCcUlnTkJnQUpIRFFBTElBQkJlQ0FBYTBFUGNVRUFJQUJCQ0dwQkQzRWJJZ05xSWdRZ0JrRklhaUlGSUFOcklnTkJBWEkyQWdSQkFFRUFLQUx3MDRDQUFEWUNwTkNBZ0FCQkFDQUROZ0tVMElDQUFFRUFJQVEyQXFEUWdJQUFJQUFnQldwQk9EWUNCQXdDQ3lBRExRQU1RUWh4RFFBZ0JDQUZTUTBBSUFRZ0FFOE5BQ0FFUVhnZ0JHdEJEM0ZCQUNBRVFRaHFRUTl4R3lJRmFpSUFRUUFvQXBUUWdJQUFJQVpxSWdzZ0JXc2lCVUVCY2pZQ0JDQURJQWdnQm1vMkFnUkJBRUVBS0FMdzA0Q0FBRFlDcE5DQWdBQkJBQ0FGTmdLVTBJQ0FBRUVBSUFBMkFxRFFnSUFBSUFRZ0MycEJPRFlDQkF3QkN3SkFJQUJCQUNnQ21OQ0FnQUFpQ0U4TkFFRUFJQUEyQXBqUWdJQUFJQUFoQ0FzZ0FDQUdhaUVGUWNqVGdJQUFJUU1DUUFKQUFrQUNRQUpBQWtBQ1FBTkFJQU1vQWdBZ0JVWU5BU0FES0FJSUlnTU5BQXdDQ3dzZ0F5MEFERUVJY1VVTkFRdEJ5Tk9BZ0FBaEF3TkFBa0FnQXlnQ0FDSUZJQVJMRFFBZ0JTQURLQUlFYWlJRklBUkxEUU1MSUFNb0FnZ2hBd3dBQ3dzZ0F5QUFOZ0lBSUFNZ0F5Z0NCQ0FHYWpZQ0JDQUFRWGdnQUd0QkQzRkJBQ0FBUVFocVFROXhHMm9pQ3lBQ1FRTnlOZ0lFSUFWQmVDQUZhMEVQY1VFQUlBVkJDR3BCRDNFYmFpSUdJQXNnQW1vaUFtc2hBd0pBSUFZZ0JFY05BRUVBSUFJMkFxRFFnSUFBUVFCQkFDZ0NsTkNBZ0FBZ0Eyb2lBellDbE5DQWdBQWdBaUFEUVFGeU5nSUVEQU1MQWtBZ0JrRUFLQUtjMElDQUFFY05BRUVBSUFJMkFwelFnSUFBUVFCQkFDZ0NrTkNBZ0FBZ0Eyb2lBellDa05DQWdBQWdBaUFEUVFGeU5nSUVJQUlnQTJvZ0F6WUNBQXdEQ3dKQUlBWW9BZ1FpQkVFRGNVRUJSdzBBSUFSQmVIRWhCd0pBQWtBZ0JFSC9BVXNOQUNBR0tBSUlJZ1VnQkVFRGRpSUlRUU4wUWJEUWdJQUFhaUlBUmhvQ1FDQUdLQUlNSWdRZ0JVY05BRUVBUVFBb0FvalFnSUFBUVg0Z0NIZHhOZ0tJMElDQUFBd0NDeUFFSUFCR0dpQUVJQVUyQWdnZ0JTQUVOZ0lNREFFTElBWW9BaGdoQ1FKQUFrQWdCaWdDRENJQUlBWkdEUUFnQmlnQ0NDSUVJQWhKR2lBQUlBUTJBZ2dnQkNBQU5nSU1EQUVMQWtBZ0JrRVVhaUlFS0FJQUlnVU5BQ0FHUVJCcUlnUW9BZ0FpQlEwQVFRQWhBQXdCQ3dOQUlBUWhDQ0FGSWdCQkZHb2lCQ2dDQUNJRkRRQWdBRUVRYWlFRUlBQW9BaEFpQlEwQUN5QUlRUUEyQWdBTElBbEZEUUFDUUFKQUlBWWdCaWdDSENJRlFRSjBRYmpTZ0lBQWFpSUVLQUlBUncwQUlBUWdBRFlDQUNBQURRRkJBRUVBS0FLTTBJQ0FBRUYrSUFWM2NUWUNqTkNBZ0FBTUFnc2dDVUVRUVJRZ0NTZ0NFQ0FHUmh0cUlBQTJBZ0FnQUVVTkFRc2dBQ0FKTmdJWUFrQWdCaWdDRUNJRVJRMEFJQUFnQkRZQ0VDQUVJQUEyQWhnTElBWW9BaFFpQkVVTkFDQUFRUlJxSUFRMkFnQWdCQ0FBTmdJWUN5QUhJQU5xSVFNZ0JpQUhhaUlHS0FJRUlRUUxJQVlnQkVGK2NUWUNCQ0FDSUFOcUlBTTJBZ0FnQWlBRFFRRnlOZ0lFQWtBZ0EwSC9BVXNOQUNBRFFYaHhRYkRRZ0lBQWFpRUVBa0FDUUVFQUtBS0kwSUNBQUNJRlFRRWdBMEVEZG5RaUEzRU5BRUVBSUFVZ0EzSTJBb2pRZ0lBQUlBUWhBd3dCQ3lBRUtBSUlJUU1MSUFNZ0FqWUNEQ0FFSUFJMkFnZ2dBaUFFTmdJTUlBSWdBellDQ0F3REMwRWZJUVFDUUNBRFFmLy8vd2RMRFFBZ0EwRUlkaUlFSUFSQmdQNC9ha0VRZGtFSWNTSUVkQ0lGSUFWQmdPQWZha0VRZGtFRWNTSUZkQ0lBSUFCQmdJQVBha0VRZGtFQ2NTSUFkRUVQZGlBRUlBVnlJQUJ5YXlJRVFRRjBJQU1nQkVFVmFuWkJBWEZ5UVJ4cUlRUUxJQUlnQkRZQ0hDQUNRZ0EzQWhBZ0JFRUNkRUc0MG9DQUFHb2hCUUpBUVFBb0FvelFnSUFBSWdCQkFTQUVkQ0lJY1EwQUlBVWdBallDQUVFQUlBQWdDSEkyQW96UWdJQUFJQUlnQlRZQ0dDQUNJQUkyQWdnZ0FpQUNOZ0lNREFNTElBTkJBRUVaSUFSQkFYWnJJQVJCSDBZYmRDRUVJQVVvQWdBaEFBTkFJQUFpQlNnQ0JFRjRjU0FEUmcwQ0lBUkJIWFloQUNBRVFRRjBJUVFnQlNBQVFRUnhha0VRYWlJSUtBSUFJZ0FOQUFzZ0NDQUNOZ0lBSUFJZ0JUWUNHQ0FDSUFJMkFnd2dBaUFDTmdJSURBSUxJQUJCZUNBQWEwRVBjVUVBSUFCQkNHcEJEM0ViSWdOcUlnc2dCa0ZJYWlJSUlBTnJJZ05CQVhJMkFnUWdBQ0FJYWtFNE5nSUVJQVFnQlVFM0lBVnJRUTl4UVFBZ0JVRkpha0VQY1J0cVFVRnFJZ2dnQ0NBRVFSQnFTUnNpQ0VFak5nSUVRUUJCQUNnQzhOT0FnQUEyQXFUUWdJQUFRUUFnQXpZQ2xOQ0FnQUJCQUNBTE5nS2cwSUNBQUNBSVFSQnFRUUFwQXREVGdJQUFOd0lBSUFoQkFDa0N5Tk9BZ0FBM0FnaEJBQ0FJUVFocU5nTFEwNENBQUVFQUlBWTJBc3pUZ0lBQVFRQWdBRFlDeU5PQWdBQkJBRUVBTmdMVTA0Q0FBQ0FJUVNScUlRTURRQ0FEUVFjMkFnQWdBMEVFYWlJRElBVkpEUUFMSUFnZ0JFWU5BeUFJSUFnb0FnUkJmbkUyQWdRZ0NDQUlJQVJySWdBMkFnQWdCQ0FBUVFGeU5nSUVBa0FnQUVIL0FVc05BQ0FBUVhoeFFiRFFnSUFBYWlFREFrQUNRRUVBS0FLSTBJQ0FBQ0lGUVFFZ0FFRURkblFpQUhFTkFFRUFJQVVnQUhJMkFvalFnSUFBSUFNaEJRd0JDeUFES0FJSUlRVUxJQVVnQkRZQ0RDQURJQVEyQWdnZ0JDQUROZ0lNSUFRZ0JUWUNDQXdFQzBFZklRTUNRQ0FBUWYvLy93ZExEUUFnQUVFSWRpSURJQU5CZ1A0L2FrRVFka0VJY1NJRGRDSUZJQVZCZ09BZmFrRVFka0VFY1NJRmRDSUlJQWhCZ0lBUGFrRVFka0VDY1NJSWRFRVBkaUFESUFWeUlBaHlheUlEUVFGMElBQWdBMEVWYW5aQkFYRnlRUnhxSVFNTElBUWdBellDSENBRVFnQTNBaEFnQTBFQ2RFRzQwb0NBQUdvaEJRSkFRUUFvQW96UWdJQUFJZ2hCQVNBRGRDSUdjUTBBSUFVZ0JEWUNBRUVBSUFnZ0JuSTJBb3pRZ0lBQUlBUWdCVFlDR0NBRUlBUTJBZ2dnQkNBRU5nSU1EQVFMSUFCQkFFRVpJQU5CQVhacklBTkJIMFliZENFRElBVW9BZ0FoQ0FOQUlBZ2lCU2dDQkVGNGNTQUFSZzBESUFOQkhYWWhDQ0FEUVFGMElRTWdCU0FJUVFSeGFrRVFhaUlHS0FJQUlnZ05BQXNnQmlBRU5nSUFJQVFnQlRZQ0dDQUVJQVEyQWd3Z0JDQUVOZ0lJREFNTElBVW9BZ2dpQXlBQ05nSU1JQVVnQWpZQ0NDQUNRUUEyQWhnZ0FpQUZOZ0lNSUFJZ0F6WUNDQXNnQzBFSWFpRUREQVVMSUFVb0FnZ2lBeUFFTmdJTUlBVWdCRFlDQ0NBRVFRQTJBaGdnQkNBRk5nSU1JQVFnQXpZQ0NBdEJBQ2dDbE5DQWdBQWlBeUFDVFEwQVFRQW9BcURRZ0lBQUlnUWdBbW9pQlNBRElBSnJJZ05CQVhJMkFnUkJBQ0FETmdLVTBJQ0FBRUVBSUFVMkFxRFFnSUFBSUFRZ0FrRURjallDQkNBRVFRaHFJUU1NQXd0QkFDRURRUUJCTURZQytOT0FnQUFNQWdzQ1FDQUxSUTBBQWtBQ1FDQUlJQWdvQWh3aUJVRUNkRUc0MG9DQUFHb2lBeWdDQUVjTkFDQURJQUEyQWdBZ0FBMEJRUUFnQjBGK0lBVjNjU0lITmdLTTBJQ0FBQXdDQ3lBTFFSQkJGQ0FMS0FJUUlBaEdHMm9nQURZQ0FDQUFSUTBCQ3lBQUlBczJBaGdDUUNBSUtBSVFJZ05GRFFBZ0FDQUROZ0lRSUFNZ0FEWUNHQXNnQ0VFVWFpZ0NBQ0lEUlEwQUlBQkJGR29nQXpZQ0FDQURJQUEyQWhnTEFrQUNRQ0FFUVE5TERRQWdDQ0FFSUFKcUlnTkJBM0kyQWdRZ0NDQURhaUlESUFNb0FnUkJBWEkyQWdRTUFRc2dDQ0FDYWlJQUlBUkJBWEkyQWdRZ0NDQUNRUU55TmdJRUlBQWdCR29nQkRZQ0FBSkFJQVJCL3dGTERRQWdCRUY0Y1VHdzBJQ0FBR29oQXdKQUFrQkJBQ2dDaU5DQWdBQWlCVUVCSUFSQkEzWjBJZ1J4RFFCQkFDQUZJQVJ5TmdLSTBJQ0FBQ0FESVFRTUFRc2dBeWdDQ0NFRUN5QUVJQUEyQWd3Z0F5QUFOZ0lJSUFBZ0F6WUNEQ0FBSUFRMkFnZ01BUXRCSHlFREFrQWdCRUgvLy84SFN3MEFJQVJCQ0hZaUF5QURRWUQrUDJwQkVIWkJDSEVpQTNRaUJTQUZRWURnSDJwQkVIWkJCSEVpQlhRaUFpQUNRWUNBRDJwQkVIWkJBbkVpQW5SQkQzWWdBeUFGY2lBQ2Ntc2lBMEVCZENBRUlBTkJGV3AyUVFGeGNrRWNhaUVEQ3lBQUlBTTJBaHdnQUVJQU53SVFJQU5CQW5SQnVOS0FnQUJxSVFVQ1FDQUhRUUVnQTNRaUFuRU5BQ0FGSUFBMkFnQkJBQ0FISUFKeU5nS00wSUNBQUNBQUlBVTJBaGdnQUNBQU5nSUlJQUFnQURZQ0RBd0JDeUFFUVFCQkdTQURRUUYyYXlBRFFSOUdHM1FoQXlBRktBSUFJUUlDUUFOQUlBSWlCU2dDQkVGNGNTQUVSZzBCSUFOQkhYWWhBaUFEUVFGMElRTWdCU0FDUVFSeGFrRVFhaUlHS0FJQUlnSU5BQXNnQmlBQU5nSUFJQUFnQlRZQ0dDQUFJQUEyQWd3Z0FDQUFOZ0lJREFFTElBVW9BZ2dpQXlBQU5nSU1JQVVnQURZQ0NDQUFRUUEyQWhnZ0FDQUZOZ0lNSUFBZ0F6WUNDQXNnQ0VFSWFpRUREQUVMQWtBZ0NrVU5BQUpBQWtBZ0FDQUFLQUljSWdWQkFuUkJ1TktBZ0FCcUlnTW9BZ0JIRFFBZ0F5QUlOZ0lBSUFnTkFVRUFJQWxCZmlBRmQzRTJBb3pRZ0lBQURBSUxJQXBCRUVFVUlBb29BaEFnQUVZYmFpQUlOZ0lBSUFoRkRRRUxJQWdnQ2pZQ0dBSkFJQUFvQWhBaUEwVU5BQ0FJSUFNMkFoQWdBeUFJTmdJWUN5QUFRUlJxS0FJQUlnTkZEUUFnQ0VFVWFpQUROZ0lBSUFNZ0NEWUNHQXNDUUFKQUlBUkJEMHNOQUNBQUlBUWdBbW9pQTBFRGNqWUNCQ0FBSUFOcUlnTWdBeWdDQkVFQmNqWUNCQXdCQ3lBQUlBSnFJZ1VnQkVFQmNqWUNCQ0FBSUFKQkEzSTJBZ1FnQlNBRWFpQUVOZ0lBQWtBZ0IwVU5BQ0FIUVhoeFFiRFFnSUFBYWlFQ1FRQW9BcHpRZ0lBQUlRTUNRQUpBUVFFZ0IwRURkblFpQ0NBR2NRMEFRUUFnQ0NBR2NqWUNpTkNBZ0FBZ0FpRUlEQUVMSUFJb0FnZ2hDQXNnQ0NBRE5nSU1JQUlnQXpZQ0NDQURJQUkyQWd3Z0F5QUlOZ0lJQzBFQUlBVTJBcHpRZ0lBQVFRQWdCRFlDa05DQWdBQUxJQUJCQ0dvaEF3c2dBVUVRYWlTQWdJQ0FBQ0FEQ3dvQUlBQVF5WUNBZ0FBTDRnMEJCMzhDUUNBQVJRMEFJQUJCZUdvaUFTQUFRWHhxS0FJQUlnSkJlSEVpQUdvaEF3SkFJQUpCQVhFTkFDQUNRUU54UlEwQklBRWdBU2dDQUNJQ2F5SUJRUUFvQXBqUWdJQUFJZ1JKRFFFZ0FpQUFhaUVBQWtBZ0FVRUFLQUtjMElDQUFFWU5BQUpBSUFKQi93RkxEUUFnQVNnQ0NDSUVJQUpCQTNZaUJVRURkRUd3MElDQUFHb2lCa1lhQWtBZ0FTZ0NEQ0lDSUFSSERRQkJBRUVBS0FLSTBJQ0FBRUYrSUFWM2NUWUNpTkNBZ0FBTUF3c2dBaUFHUmhvZ0FpQUVOZ0lJSUFRZ0FqWUNEQXdDQ3lBQktBSVlJUWNDUUFKQUlBRW9BZ3dpQmlBQlJnMEFJQUVvQWdnaUFpQUVTUm9nQmlBQ05nSUlJQUlnQmpZQ0RBd0JDd0pBSUFGQkZHb2lBaWdDQUNJRURRQWdBVUVRYWlJQ0tBSUFJZ1FOQUVFQUlRWU1BUXNEUUNBQ0lRVWdCQ0lHUVJScUlnSW9BZ0FpQkEwQUlBWkJFR29oQWlBR0tBSVFJZ1FOQUFzZ0JVRUFOZ0lBQ3lBSFJRMEJBa0FDUUNBQklBRW9BaHdpQkVFQ2RFRzQwb0NBQUdvaUFpZ0NBRWNOQUNBQ0lBWTJBZ0FnQmcwQlFRQkJBQ2dDak5DQWdBQkJmaUFFZDNFMkFvelFnSUFBREFNTElBZEJFRUVVSUFjb0FoQWdBVVliYWlBR05nSUFJQVpGRFFJTElBWWdCellDR0FKQUlBRW9BaEFpQWtVTkFDQUdJQUkyQWhBZ0FpQUdOZ0lZQ3lBQktBSVVJZ0pGRFFFZ0JrRVVhaUFDTmdJQUlBSWdCallDR0F3QkN5QURLQUlFSWdKQkEzRkJBMGNOQUNBRElBSkJmbkUyQWdSQkFDQUFOZ0tRMElDQUFDQUJJQUJxSUFBMkFnQWdBU0FBUVFGeU5nSUVEd3NnQVNBRFR3MEFJQU1vQWdRaUFrRUJjVVVOQUFKQUFrQWdBa0VDY1EwQUFrQWdBMEVBS0FLZzBJQ0FBRWNOQUVFQUlBRTJBcURRZ0lBQVFRQkJBQ2dDbE5DQWdBQWdBR29pQURZQ2xOQ0FnQUFnQVNBQVFRRnlOZ0lFSUFGQkFDZ0NuTkNBZ0FCSERRTkJBRUVBTmdLUTBJQ0FBRUVBUVFBMkFwelFnSUFBRHdzQ1FDQURRUUFvQXB6UWdJQUFSdzBBUVFBZ0FUWUNuTkNBZ0FCQkFFRUFLQUtRMElDQUFDQUFhaUlBTmdLUTBJQ0FBQ0FCSUFCQkFYSTJBZ1FnQVNBQWFpQUFOZ0lBRHdzZ0FrRjRjU0FBYWlFQUFrQUNRQ0FDUWY4QlN3MEFJQU1vQWdnaUJDQUNRUU4ySWdWQkEzUkJzTkNBZ0FCcUlnWkdHZ0pBSUFNb0Fnd2lBaUFFUncwQVFRQkJBQ2dDaU5DQWdBQkJmaUFGZDNFMkFvalFnSUFBREFJTElBSWdCa1lhSUFJZ0JEWUNDQ0FFSUFJMkFnd01BUXNnQXlnQ0dDRUhBa0FDUUNBREtBSU1JZ1lnQTBZTkFDQURLQUlJSWdKQkFDZ0NtTkNBZ0FCSkdpQUdJQUkyQWdnZ0FpQUdOZ0lNREFFTEFrQWdBMEVVYWlJQ0tBSUFJZ1FOQUNBRFFSQnFJZ0lvQWdBaUJBMEFRUUFoQmd3QkN3TkFJQUloQlNBRUlnWkJGR29pQWlnQ0FDSUVEUUFnQmtFUWFpRUNJQVlvQWhBaUJBMEFDeUFGUVFBMkFnQUxJQWRGRFFBQ1FBSkFJQU1nQXlnQ0hDSUVRUUowUWJqU2dJQUFhaUlDS0FJQVJ3MEFJQUlnQmpZQ0FDQUdEUUZCQUVFQUtBS00wSUNBQUVGK0lBUjNjVFlDak5DQWdBQU1BZ3NnQjBFUVFSUWdCeWdDRUNBRFJodHFJQVkyQWdBZ0JrVU5BUXNnQmlBSE5nSVlBa0FnQXlnQ0VDSUNSUTBBSUFZZ0FqWUNFQ0FDSUFZMkFoZ0xJQU1vQWhRaUFrVU5BQ0FHUVJScUlBSTJBZ0FnQWlBR05nSVlDeUFCSUFCcUlBQTJBZ0FnQVNBQVFRRnlOZ0lFSUFGQkFDZ0NuTkNBZ0FCSERRRkJBQ0FBTmdLUTBJQ0FBQThMSUFNZ0FrRitjVFlDQkNBQklBQnFJQUEyQWdBZ0FTQUFRUUZ5TmdJRUN3SkFJQUJCL3dGTERRQWdBRUY0Y1VHdzBJQ0FBR29oQWdKQUFrQkJBQ2dDaU5DQWdBQWlCRUVCSUFCQkEzWjBJZ0J4RFFCQkFDQUVJQUJ5TmdLSTBJQ0FBQ0FDSVFBTUFRc2dBaWdDQ0NFQUN5QUFJQUUyQWd3Z0FpQUJOZ0lJSUFFZ0FqWUNEQ0FCSUFBMkFnZ1BDMEVmSVFJQ1FDQUFRZi8vL3dkTERRQWdBRUVJZGlJQ0lBSkJnUDQvYWtFUWRrRUljU0lDZENJRUlBUkJnT0FmYWtFUWRrRUVjU0lFZENJR0lBWkJnSUFQYWtFUWRrRUNjU0lHZEVFUGRpQUNJQVJ5SUFaeWF5SUNRUUYwSUFBZ0FrRVZhblpCQVhGeVFSeHFJUUlMSUFFZ0FqWUNIQ0FCUWdBM0FoQWdBa0VDZEVHNDBvQ0FBR29oQkFKQUFrQkJBQ2dDak5DQWdBQWlCa0VCSUFKMElnTnhEUUFnQkNBQk5nSUFRUUFnQmlBRGNqWUNqTkNBZ0FBZ0FTQUVOZ0lZSUFFZ0FUWUNDQ0FCSUFFMkFnd01BUXNnQUVFQVFSa2dBa0VCZG1zZ0FrRWZSaHQwSVFJZ0JDZ0NBQ0VHQWtBRFFDQUdJZ1FvQWdSQmVIRWdBRVlOQVNBQ1FSMTJJUVlnQWtFQmRDRUNJQVFnQmtFRWNXcEJFR29pQXlnQ0FDSUdEUUFMSUFNZ0FUWUNBQ0FCSUFRMkFoZ2dBU0FCTmdJTUlBRWdBVFlDQ0F3QkN5QUVLQUlJSWdBZ0FUWUNEQ0FFSUFFMkFnZ2dBVUVBTmdJWUlBRWdCRFlDRENBQklBQTJBZ2dMUVFCQkFDZ0NxTkNBZ0FCQmYyb2lBVUYvSUFFYk5nS28wSUNBQUFzTEJBQUFBQXRPQUFKQUlBQU5BRDhBUVJCMER3c0NRQ0FBUWYvL0EzRU5BQ0FBUVg5TURRQUNRQ0FBUVJCMlFBQWlBRUYvUncwQVFRQkJNRFlDK05PQWdBQkJmdzhMSUFCQkVIUVBDeERLZ0lDQUFBQUw4Z0lDQTM4QmZnSkFJQUpGRFFBZ0FDQUJPZ0FBSUFJZ0FHb2lBMEYvYWlBQk9nQUFJQUpCQTBrTkFDQUFJQUU2QUFJZ0FDQUJPZ0FCSUFOQmZXb2dBVG9BQUNBRFFYNXFJQUU2QUFBZ0FrRUhTUTBBSUFBZ0FUb0FBeUFEUVh4cUlBRTZBQUFnQWtFSlNRMEFJQUJCQUNBQWEwRURjU0lFYWlJRElBRkIvd0Z4UVlHQ2hBaHNJZ0UyQWdBZ0F5QUNJQVJyUVh4eElnUnFJZ0pCZkdvZ0FUWUNBQ0FFUVFsSkRRQWdBeUFCTmdJSUlBTWdBVFlDQkNBQ1FYaHFJQUUyQWdBZ0FrRjBhaUFCTmdJQUlBUkJHVWtOQUNBRElBRTJBaGdnQXlBQk5nSVVJQU1nQVRZQ0VDQURJQUUyQWd3Z0FrRndhaUFCTmdJQUlBSkJiR29nQVRZQ0FDQUNRV2hxSUFFMkFnQWdBa0ZrYWlBQk5nSUFJQVFnQTBFRWNVRVljaUlGYXlJQ1FTQkpEUUFnQWExQ2dZQ0FnQkIrSVFZZ0F5QUZhaUVCQTBBZ0FTQUdOd01ZSUFFZ0JqY0RFQ0FCSUFZM0F3Z2dBU0FHTndNQUlBRkJJR29oQVNBQ1FXQnFJZ0pCSDBzTkFBc0xJQUFMQzQ1SUFRQkJnQWdMaGtnQkFBQUFBZ0FBQUFNQUFBQUFBQUFBQUFBQUFBUUFBQUFGQUFBQUFBQUFBQUFBQUFBR0FBQUFCd0FBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFbHVkbUZzYVdRZ1kyaGhjaUJwYmlCMWNtd2djWFZsY25rQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5aWIyUjVBRU52Ym5SbGJuUXRUR1Z1WjNSb0lHOTJaWEptYkc5M0FFTm9kVzVySUhOcGVtVWdiM1psY21ac2IzY0FVbVZ6Y0c5dWMyVWdiM1psY21ac2IzY0FTVzUyWVd4cFpDQnRaWFJvYjJRZ1ptOXlJRWhVVkZBdmVDNTRJSEpsY1hWbGMzUUFTVzUyWVd4cFpDQnRaWFJvYjJRZ1ptOXlJRkpVVTFBdmVDNTRJSEpsY1hWbGMzUUFSWGh3WldOMFpXUWdVMDlWVWtORklHMWxkR2h2WkNCbWIzSWdTVU5GTDNndWVDQnlaWEYxWlhOMEFFbHVkbUZzYVdRZ1kyaGhjaUJwYmlCMWNtd2dabkpoWjIxbGJuUWdjM1JoY25RQVJYaHdaV04wWldRZ1pHOTBBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZjM1JoZEhWekFFbHVkbUZzYVdRZ2NtVnpjRzl1YzJVZ2MzUmhkSFZ6QUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NQVZYTmxjaUJqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmY21WelpYUmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlqYUhWdWExOW9aV0ZrWlhKZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXRaWE56WVdkbFgySmxaMmx1WUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDNaaGJIVmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYzNSaGRIVnpYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmZG1WeWMybHZibDlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDNWeWJGOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMk5vZFc1clgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZhR1ZoWkdWeVgzWmhiSFZsWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyMWxkR2h2WkY5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyaGxZV1JsY2w5bWFXVnNaRjlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDl1WVcxbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCVmJtVjRjR1ZqZEdWa0lHTm9ZWElnYVc0Z2RYSnNJSE5sY25abGNnQkpiblpoYkdsa0lHaGxZV1JsY2lCMllXeDFaU0JqYUdGeUFFbHVkbUZzYVdRZ2FHVmhaR1Z5SUdacFpXeGtJR05vWVhJQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5MlpYSnphVzl1QUVsdWRtRnNhV1FnYldsdWIzSWdkbVZ5YzJsdmJnQkpiblpoYkdsa0lHMWhhbTl5SUhabGNuTnBiMjRBUlhod1pXTjBaV1FnYzNCaFkyVWdZV1owWlhJZ2RtVnljMmx2YmdCRmVIQmxZM1JsWkNCRFVreEdJR0ZtZEdWeUlIWmxjbk5wYjI0QVNXNTJZV3hwWkNCSVZGUlFJSFpsY25OcGIyNEFTVzUyWVd4cFpDQm9aV0ZrWlhJZ2RHOXJaVzRBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDkxY213QVNXNTJZV3hwWkNCamFHRnlZV04wWlhKeklHbHVJSFZ5YkFCVmJtVjRjR1ZqZEdWa0lITjBZWEowSUdOb1lYSWdhVzRnZFhKc0FFUnZkV0pzWlNCQUlHbHVJSFZ5YkFCRmJYQjBlU0JEYjI1MFpXNTBMVXhsYm1kMGFBQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJEYjI1MFpXNTBMVXhsYm1kMGFBQkVkWEJzYVdOaGRHVWdRMjl1ZEdWdWRDMU1aVzVuZEdnQVNXNTJZV3hwWkNCamFHRnlJR2x1SUhWeWJDQndZWFJvQUVOdmJuUmxiblF0VEdWdVozUm9JR05oYmlkMElHSmxJSEJ5WlhObGJuUWdkMmwwYUNCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WndCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY2lCcGJpQmphSFZ1YXlCemFYcGxBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZhR1ZoWkdWeVgzWmhiSFZsQUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYM1poYkhWbEFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTWdkbUZzZFdVQVRXbHpjMmx1WnlCbGVIQmxZM1JsWkNCTVJpQmhablJsY2lCb1pXRmtaWElnZG1Gc2RXVUFTVzUyWVd4cFpDQmdWSEpoYm5ObVpYSXRSVzVqYjJScGJtZGdJR2hsWVdSbGNpQjJZV3gxWlFCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY2lCcGJpQmphSFZ1YXlCbGVIUmxibk5wYjI1eklIRjFiM1JsSUhaaGJIVmxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nY1hWdmRHVmtJSFpoYkhWbEFGQmhkWE5sWkNCaWVTQnZibDlvWldGa1pYSnpYMk52YlhCc1pYUmxBRWx1ZG1Gc2FXUWdSVTlHSUhOMFlYUmxBRzl1WDNKbGMyVjBJSEJoZFhObEFHOXVYMk5vZFc1clgyaGxZV1JsY2lCd1lYVnpaUUJ2Ymw5dFpYTnpZV2RsWDJKbFoybHVJSEJoZFhObEFHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOTJZV3gxWlNCd1lYVnpaUUJ2Ymw5emRHRjBkWE5mWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmZG1WeWMybHZibDlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDkxY214ZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZlkyaDFibXRmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmYUdWaFpHVnlYM1poYkhWbFgyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyMWxjM05oWjJWZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmJXVjBhRzlrWDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDJobFlXUmxjbDltYVdWc1pGOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmJtRnRaU0J3WVhWelpRQlZibVY0Y0dWamRHVmtJSE53WVdObElHRm1kR1Z5SUhOMFlYSjBJR3hwYm1VQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmYm1GdFpRQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJqYUhWdWF5QmxlSFJsYm5OcGIyNXpJRzVoYldVQVVHRjFjMlVnYjI0Z1EwOU9Ua1ZEVkM5VmNHZHlZV1JsQUZCaGRYTmxJRzl1SUZCU1NTOVZjR2R5WVdSbEFFVjRjR1ZqZEdWa0lFaFVWRkF2TWlCRGIyNXVaV04wYVc5dUlGQnlaV1poWTJVQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5dFpYUm9iMlFBUlhod1pXTjBaV1FnYzNCaFkyVWdZV1owWlhJZ2JXVjBhRzlrQUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmYUdWaFpHVnlYMlpwWld4a0FGQmhkWE5sWkFCSmJuWmhiR2xrSUhkdmNtUWdaVzVqYjNWdWRHVnlaV1FBU1c1MllXeHBaQ0J0WlhSb2IyUWdaVzVqYjNWdWRHVnlaV1FBVlc1bGVIQmxZM1JsWkNCamFHRnlJR2x1SUhWeWJDQnpZMmhsYldFQVVtVnhkV1Z6ZENCb1lYTWdhVzUyWVd4cFpDQmdWSEpoYm5ObVpYSXRSVzVqYjJScGJtZGdBRk5YU1ZSRFNGOVFVazlZV1FCVlUwVmZVRkpQV0ZrQVRVdEJRMVJKVmtsVVdRQlZUbEJTVDBORlUxTkJRa3hGWDBWT1ZFbFVXUUJEVDFCWkFFMVBWa1ZFWDFCRlVrMUJUa1ZPVkV4WkFGUlBUMTlGUVZKTVdRQk9UMVJKUmxrQVJrRkpURVZFWDBSRlVFVk9SRVZPUTFrQVFrRkVYMGRCVkVWWFFWa0FVRXhCV1FCUVZWUUFRMGhGUTB0UFZWUUFSMEZVUlZkQldWOVVTVTFGVDFWVUFGSkZVVlZGVTFSZlZFbE5SVTlWVkFCT1JWUlhUMUpMWDBOUFRrNUZRMVJmVkVsTlJVOVZWQUJEVDA1T1JVTlVTVTlPWDFSSlRVVlBWVlFBVEU5SFNVNWZWRWxOUlU5VlZBQk9SVlJYVDFKTFgxSkZRVVJmVkVsTlJVOVZWQUJRVDFOVUFFMUpVMFJKVWtWRFZFVkVYMUpGVVZWRlUxUUFRMHhKUlU1VVgwTk1UMU5GUkY5U1JWRlZSVk5VQUVOTVNVVk9WRjlEVEU5VFJVUmZURTlCUkY5Q1FVeEJUa05GUkY5U1JWRlZSVk5VQUVKQlJGOVNSVkZWUlZOVUFFaFVWRkJmVWtWUlZVVlRWRjlUUlU1VVgxUlBYMGhVVkZCVFgxQlBVbFFBVWtWUVQxSlVBRWxOWDBGZlZFVkJVRTlVQUZKRlUwVlVYME5QVGxSRlRsUUFUazlmUTA5T1ZFVk9WQUJRUVZKVVNVRk1YME5QVGxSRlRsUUFTRkJGWDBsT1ZrRk1TVVJmUTA5T1UxUkJUbFFBU0ZCRlgwTkNYMUpGVTBWVUFFZEZWQUJJVUVWZlUxUlNTVU5VQUVOUFRrWk1TVU5VQUZSRlRWQlBVa0ZTV1Y5U1JVUkpVa1ZEVkFCUVJWSk5RVTVGVGxSZlVrVkVTVkpGUTFRQVEwOU9Ua1ZEVkFCTlZVeFVTVjlUVkVGVVZWTUFTRkJGWDBsT1ZrRk1TVVJmVTFSQlZGVlRBRlJQVDE5TlFVNVpYMUpGVVZWRlUxUlRBRVZCVWt4WlgwaEpUbFJUQUZWT1FWWkJTVXhCUWt4RlgwWlBVbDlNUlVkQlRGOVNSVUZUVDA1VEFFOVFWRWxQVGxNQVUxZEpWRU5JU1U1SFgxQlNUMVJQUTA5TVV3QldRVkpKUVU1VVgwRk1VMDlmVGtWSFQxUkpRVlJGVXdCTlZVeFVTVkJNUlY5RFNFOUpRMFZUQUVsT1ZFVlNUa0ZNWDFORlVsWkZVbDlGVWxKUFVnQlhSVUpmVTBWU1ZrVlNYMVZPUzA1UFYwNWZSVkpTVDFJQVVrRkpURWRWVGw5RlVsSlBVZ0JKUkVWT1ZFbFVXVjlRVWs5V1NVUkZVbDlCVlZSSVJVNVVTVU5CVkVsUFRsOUZVbEpQVWdCVFUweGZRMFZTVkVsR1NVTkJWRVZmUlZKU1QxSUFTVTVXUVV4SlJGOVlYMFpQVWxkQlVrUkZSRjlHVDFJQVUwVlVYMUJCVWtGTlJWUkZVZ0JIUlZSZlVFRlNRVTFGVkVWU0FFaFFSVjlWVTBWU0FGTkZSVjlQVkVoRlVnQklVRVZmUTBKZlEwaFZUa3RmU0VWQlJFVlNBRTFMUTBGTVJVNUVRVklBVTBWVVZWQUFWMFZDWDFORlVsWkZVbDlKVTE5RVQxZE9BRlJGUVZKRVQxZE9BRWhRUlY5RFRFOVRSVVJmUTA5T1RrVkRWRWxQVGdCSVJWVlNTVk5VU1VOZlJWaFFTVkpCVkVsUFRnQkVTVk5EVDA1T1JVTlVSVVJmVDFCRlVrRlVTVTlPQUU1UFRsOUJWVlJJVDFKSlZFRlVTVlpGWDBsT1JrOVNUVUZVU1U5T0FFaFFSVjlKVGxaQlRFbEVYMVpGVWxOSlQwNEFTRkJGWDBOQ1gwMUZVMU5CUjBWZlFrVkhTVTRBVTBsVVJWOUpVMTlHVWs5YVJVNEFTRkJGWDBsT1ZrRk1TVVJmU0VWQlJFVlNYMVJQUzBWT0FFbE9Wa0ZNU1VSZlZFOUxSVTRBUms5U1FrbEVSRVZPQUVWT1NFRk9RMFZmV1U5VlVsOURRVXhOQUVoUVJWOUpUbFpCVEVsRVgxVlNUQUJDVEU5RFMwVkVYMEpaWDFCQlVrVk9WRUZNWDBOUFRsUlNUMHdBVFV0RFQwd0FRVU5NQUVoUVJWOUpUbFJGVWs1QlRBQlNSVkZWUlZOVVgwaEZRVVJGVWw5R1NVVk1SRk5mVkU5UFgweEJVa2RGWDFWT1QwWkdTVU5KUVV3QVNGQkZYMDlMQUZWT1RFbE9Td0JWVGt4UFEwc0FVRkpKQUZKRlZGSlpYMWRKVkVnQVNGQkZYMGxPVmtGTVNVUmZRMDlPVkVWT1ZGOU1SVTVIVkVnQVNGQkZYMVZPUlZoUVJVTlVSVVJmUTA5T1ZFVk9WRjlNUlU1SFZFZ0FSa3hWVTBnQVVGSlBVRkJCVkVOSUFFMHRVMFZCVWtOSUFGVlNTVjlVVDA5ZlRFOU9Sd0JRVWs5RFJWTlRTVTVIQUUxSlUwTkZURXhCVGtWUFZWTmZVRVZTVTBsVFZFVk9WRjlYUVZKT1NVNUhBRTFKVTBORlRFeEJUa1ZQVlZOZlYwRlNUa2xPUndCSVVFVmZTVTVXUVV4SlJGOVVVa0ZPVTBaRlVsOUZUa05QUkVsT1J3QkZlSEJsWTNSbFpDQkRVa3hHQUVoUVJWOUpUbFpCVEVsRVgwTklWVTVMWDFOSldrVUFUVTlXUlFCRFQwNVVTVTVWUlFCSVVFVmZRMEpmVTFSQlZGVlRYME5QVFZCTVJWUkZBRWhRUlY5RFFsOUlSVUZFUlZKVFgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5V1JWSlRTVTlPWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlWVWt4ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBOSVZVNUxYME5QVFZCTVJWUkZBRWhRUlY5RFFsOUlSVUZFUlZKZlZrRk1WVVZmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYME5JVlU1TFgwVllWRVZPVTBsUFRsOVdRVXhWUlY5RFQwMVFURVZVUlFCSVVFVmZRMEpmUTBoVlRrdGZSVmhVUlU1VFNVOU9YMDVCVFVWZlEwOU5VRXhGVkVVQVNGQkZYME5DWDAxRlUxTkJSMFZmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMDFGVkVoUFJGOURUMDFRVEVWVVJRQklVRVZmUTBKZlNFVkJSRVZTWDBaSlJVeEVYME5QVFZCTVJWUkZBRVJGVEVWVVJRQklVRVZmU1U1V1FVeEpSRjlGVDBaZlUxUkJWRVVBU1U1V1FVeEpSRjlUVTB4ZlEwVlNWRWxHU1VOQlZFVUFVRUZWVTBVQVRrOWZVa1ZUVUU5T1UwVUFWVTVUVlZCUVQxSlVSVVJmVFVWRVNVRmZWRmxRUlFCSFQwNUZBRTVQVkY5QlEwTkZVRlJCUWt4RkFGTkZVbFpKUTBWZlZVNUJWa0ZKVEVGQ1RFVUFVa0ZPUjBWZlRrOVVYMU5CVkVsVFJrbEJRa3hGQUU5U1NVZEpUbDlKVTE5VlRsSkZRVU5JUVVKTVJRQlNSVk5RVDA1VFJWOUpVMTlUVkVGTVJRQlFWVkpIUlFCTlJWSkhSUUJTUlZGVlJWTlVYMGhGUVVSRlVsOUdTVVZNUkZOZlZFOVBYMHhCVWtkRkFGSkZVVlZGVTFSZlNFVkJSRVZTWDFSUFQxOU1RVkpIUlFCUVFWbE1UMEZFWDFSUFQxOU1RVkpIUlFCSlRsTlZSa1pKUTBsRlRsUmZVMVJQVWtGSFJRQklVRVZmVUVGVlUwVkVYMVZRUjFKQlJFVUFTRkJGWDFCQlZWTkZSRjlJTWw5VlVFZFNRVVJGQUZOUFZWSkRSUUJCVGs1UFZVNURSUUJVVWtGRFJRQklVRVZmVlU1RldGQkZRMVJGUkY5VFVFRkRSUUJFUlZORFVrbENSUUJWVGxOVlFsTkRVa2xDUlFCU1JVTlBVa1FBU0ZCRlgwbE9Wa0ZNU1VSZlRVVlVTRTlFQUU1UFZGOUdUMVZPUkFCUVVrOVFSa2xPUkFCVlRrSkpUa1FBVWtWQ1NVNUVBRlZPUVZWVVNFOVNTVnBGUkFCTlJWUklUMFJmVGs5VVgwRk1URTlYUlVRQVNGUlVVRjlXUlZKVFNVOU9YMDVQVkY5VFZWQlFUMUpVUlVRQVFVeFNSVUZFV1Y5U1JWQlBVbFJGUkFCQlEwTkZVRlJGUkFCT1QxUmZTVTFRVEVWTlJVNVVSVVFBVEU5UFVGOUVSVlJGUTFSRlJBQklVRVZmUTFKZlJWaFFSVU5VUlVRQVNGQkZYMHhHWDBWWVVFVkRWRVZFQUVOU1JVRlVSVVFBU1UxZlZWTkZSQUJJVUVWZlVFRlZVMFZFQUZSSlRVVlBWVlJmVDBORFZWSkZSQUJRUVZsTlJVNVVYMUpGVVZWSlVrVkVBRkJTUlVOUFRrUkpWRWxQVGw5U1JWRlZTVkpGUkFCUVVrOVlXVjlCVlZSSVJVNVVTVU5CVkVsUFRsOVNSVkZWU1ZKRlJBQk9SVlJYVDFKTFgwRlZWRWhGVGxSSlEwRlVTVTlPWDFKRlVWVkpVa1ZFQUV4RlRrZFVTRjlTUlZGVlNWSkZSQUJUVTB4ZlEwVlNWRWxHU1VOQlZFVmZVa1ZSVlVsU1JVUUFWVkJIVWtGRVJWOVNSVkZWU1ZKRlJBQlFRVWRGWDBWWVVFbFNSVVFBVUZKRlEwOU9SRWxVU1U5T1gwWkJTVXhGUkFCRldGQkZRMVJCVkVsUFRsOUdRVWxNUlVRQVVrVldRVXhKUkVGVVNVOU9YMFpCU1V4RlJBQlRVMHhmU0VGT1JGTklRVXRGWDBaQlNVeEZSQUJNVDBOTFJVUUFWRkpCVGxOR1QxSk5RVlJKVDA1ZlFWQlFURWxGUkFCT1QxUmZUVTlFU1VaSlJVUUFUazlVWDBWWVZFVk9SRVZFQUVKQlRrUlhTVVJVU0Y5TVNVMUpWRjlGV0VORlJVUkZSQUJUU1ZSRlgwbFRYMDlXUlZKTVQwRkVSVVFBU0VWQlJBQkZlSEJsWTNSbFpDQklWRlJRTHdBQVhoTUFBQ1lUQUFBd0VBQUE4QmNBQUowVEFBQVZFZ0FBT1JjQUFQQVNBQUFLRUFBQWRSSUFBSzBTQUFDQ0V3QUFUeFFBQUg4UUFBQ2dGUUFBSXhRQUFJa1NBQUNMRkFBQVRSVUFBTlFSQUFEUEZBQUFFQmdBQU1rV0FBRGNGZ0FBd1JFQUFPQVhBQUM3RkFBQWRCUUFBSHdWQUFEbEZBQUFDQmNBQUI4UUFBQmxGUUFBb3hRQUFDZ1ZBQUFDRlFBQW1SVUFBQ3dRQUFDTEdRQUFUdzhBQU5RT0FBQnFFQUFBemhBQUFBSVhBQUNKRGdBQWJoTUFBQndUQUFCbUZBQUFWaGNBQU1FVEFBRE5Fd0FBYkJNQUFHZ1hBQUJtRndBQVh4Y0FBQ0lUQUFET0R3QUFhUTRBQU5nT0FBQmpGZ0FBeXhNQUFLb09BQUFvRndBQUpoY0FBTVVUQUFCZEZnQUE2QkVBQUdjVEFBQmxFd0FBOGhZQUFITVRBQUFkRndBQStSWUFBUE1SQUFEUERnQUF6aFVBQUF3U0FBQ3pFUUFBcFJFQUFHRVFBQUF5RndBQXV4TUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFRSUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlEQWdJQ0FnSUFBQUlDQUFJQ0FBSUNBZ0lDQWdJQ0FnSUFCQUFBQUFBQUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQUFBQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0FDQUFJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FBSUNBZ0lDQUFBQ0FnQUNBZ0FDQWdJQ0FnSUNBZ0lDQUFNQUJBQUFBQUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBQUFBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQUFnQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBYkc5elpXVmxjQzFoYkdsMlpRQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVCQVFFQkFRRUJBUUVCQVFJQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJZMmgxYm10bFpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFFQUFRRUJBUUVBQUFFQkFBRUJBQUVCQVFFQkFRRUJBUUVBQUFBQUFBQUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBQUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJsWTNScGIyNWxiblF0YkdWdVozUm9iMjV5YjNoNUxXTnZibTVsWTNScGIyNEFBQUFBQUFBQUFBQUFBQUFBQUFCeVlXNXpabVZ5TFdWdVkyOWthVzVuY0dkeVlXUmxEUW9OQ2cwS1UwME5DZzBLVkZSUUwwTkZMMVJUVUM4QUFBQUFBQUFBQUFBQUFBQUJBZ0FCQXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFBQUFBQUFBQVFJQUFRTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBUUVGQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUFBQUFBQUFBRUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQUFBQUFBQUFBQUFBQVFBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUVBQUFFQkFRRUJBUUVCQVFFQkFVRUJBUUVCQVFFQkFRRUJBUUFCQUFHQndRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUFBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlBQUFBQUFBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QUFBQUFBQUFNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBSUFBQUFBQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BQUFBQUFBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCT1QxVk9RMFZGUTB0UFZWUk9SVU5VUlZSRlExSkpRa1ZNVlZOSVJWUkZRVVJUUlVGU1EwaFNSMFZEVkVsV1NWUlpURVZPUkVGU1ZrVlBWRWxHV1ZCVVNVOU9VME5JVTBWQldWTlVRVlJEU0VkRlQxSkVTVkpGUTFSUFVsUlNRMGhRUVZKQlRVVlVSVkpWVWtORlFsTkRVa2xDUlVGU1JFOVhUa0ZEUlVsT1JFNUxRMHRWUWxORFVrbENSVWhVVkZBdlFVUlVVQzg9XCIsXCJiYXNlNjRcIiksbGxodHRwV2FzbX1vKHJlcXVpcmVMbGh0dHBXYXNtLFwicmVxdWlyZUxsaHR0cFdhc21cIik7dmFyIGxsaHR0cF9zaW1kV2FzbSxoYXNSZXF1aXJlZExsaHR0cF9zaW1kV2FzbTtmdW5jdGlvbiByZXF1aXJlTGxodHRwX3NpbWRXYXNtKCl7aWYoaGFzUmVxdWlyZWRMbGh0dHBfc2ltZFdhc20pcmV0dXJuIGxsaHR0cF9zaW1kV2FzbTtoYXNSZXF1aXJlZExsaHR0cF9zaW1kV2FzbT0xO2NvbnN0e0J1ZmZlcjplfT1yZXF1aXJlJCQ2X19kZWZhdWx0O3JldHVybiBsbGh0dHBfc2ltZFdhc209ZS5mcm9tKFwiQUdGemJRRUFBQUFCTUFoZ0FYOEJmMkFEZjM5L0FYOWdCSDkvZjM4QmYyQUFBR0FEZjM5L0FHQUJmd0JnQW45L0FHQUdmMzkvZjM5L0FBTExBUWdEWlc1MkdIZGhjMjFmYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFBQ0EyVnVkaFYzWVhOdFgyOXVYMjFsYzNOaFoyVmZZbVZuYVc0QUFBTmxibllMZDJGemJWOXZibDkxY213QUFRTmxibllPZDJGemJWOXZibDl6ZEdGMGRYTUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmWm1sbGJHUUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFBUU5sYm5ZTWQyRnpiVjl2Ymw5aWIyUjVBQUVEWlc1MkdIZGhjMjFmYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlFBQUEwWkZBd01FQUFBRkFBQUFBQUFBQlFFRkFBVUZCUUFBQmdBQUFBQUdCZ1lHQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQUFBQkFRY0FBQVVGQXdBQkJBVUJjQUVTRWdVREFRQUNCZ2dCZndGQmdOUUVDd2ZSQlNJR2JXVnRiM0o1QWdBTFgybHVhWFJwWVd4cGVtVUFDUmxmWDJsdVpHbHlaV04wWDJaMWJtTjBhVzl1WDNSaFlteGxBUUFMYkd4b2RIUndYMmx1YVhRQUNoaHNiR2gwZEhCZmMyaHZkV3hrWDJ0bFpYQmZZV3hwZG1VQVFReHNiR2gwZEhCZllXeHNiMk1BREFadFlXeHNiMk1BUmd0c2JHaDBkSEJmWm5KbFpRQU5CR1p5WldVQVNBOXNiR2gwZEhCZloyVjBYM1I1Y0dVQURoVnNiR2gwZEhCZloyVjBYMmgwZEhCZmJXRnFiM0lBRHhWc2JHaDBkSEJmWjJWMFgyaDBkSEJmYldsdWIzSUFFQkZzYkdoMGRIQmZaMlYwWDIxbGRHaHZaQUFSRm14c2FIUjBjRjluWlhSZmMzUmhkSFZ6WDJOdlpHVUFFaEpzYkdoMGRIQmZaMlYwWDNWd1ozSmhaR1VBRXd4c2JHaDBkSEJmY21WelpYUUFGQTVzYkdoMGRIQmZaWGhsWTNWMFpRQVZGR3hzYUhSMGNGOXpaWFIwYVc1bmMxOXBibWwwQUJZTmJHeG9kSFJ3WDJacGJtbHphQUFYREd4c2FIUjBjRjl3WVhWelpRQVlEV3hzYUhSMGNGOXlaWE4xYldVQUdSdHNiR2gwZEhCZmNtVnpkVzFsWDJGbWRHVnlYM1Z3WjNKaFpHVUFHaEJzYkdoMGRIQmZaMlYwWDJWeWNtNXZBQnNYYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl5WldGemIyNEFIQmRzYkdoMGRIQmZjMlYwWDJWeWNtOXlYM0psWVhOdmJnQWRGR3hzYUhSMGNGOW5aWFJmWlhKeWIzSmZjRzl6QUI0UmJHeG9kSFJ3WDJWeWNtNXZYMjVoYldVQUh4SnNiR2gwZEhCZmJXVjBhRzlrWDI1aGJXVUFJQkpzYkdoMGRIQmZjM1JoZEhWelgyNWhiV1VBSVJwc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmFHVmhaR1Z5Y3dBaUlXeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOWphSFZ1YTJWa1gyeGxibWQwYUFBakhXeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOXJaV1Z3WDJGc2FYWmxBQ1FrYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDNSeVlXNXpabVZ5WDJWdVkyOWthVzVuQUNVWWJHeG9kSFJ3WDIxbGMzTmhaMlZmYm1WbFpITmZaVzltQUQ4SkZ3RUFRUUVMRVFFQ0F3UUZDd1lITlRrM01TOHRKeXNwQ3JMZ0FrVUNBQXNJQUJDSWdJQ0FBQXNaQUNBQUVNS0FnSUFBR2lBQUlBSTJBamdnQUNBQk9nQW9DeHdBSUFBZ0FDOEJNaUFBTFFBdUlBQVF3WUNBZ0FBUWdJQ0FnQUFMS2dFQmYwSEFBQkRHZ0lDQUFDSUJFTUtBZ0lBQUdpQUJRWUNJZ0lBQU5nSTRJQUVnQURvQUtDQUJDd29BSUFBUXlJQ0FnQUFMQndBZ0FDMEFLQXNIQUNBQUxRQXFDd2NBSUFBdEFDc0xCd0FnQUMwQUtRc0hBQ0FBTHdFeUN3Y0FJQUF0QUM0TFJRRUVmeUFBS0FJWUlRRWdBQzBBTFNFQ0lBQXRBQ2doQXlBQUtBSTRJUVFnQUJEQ2dJQ0FBQm9nQUNBRU5nSTRJQUFnQXpvQUtDQUFJQUk2QUMwZ0FDQUJOZ0lZQ3hFQUlBQWdBU0FCSUFKcUVNT0FnSUFBQ3hBQUlBQkJBRUhjQUJETWdJQ0FBQm9MWndFQmYwRUFJUUVDUUNBQUtBSU1EUUFDUUFKQUFrQUNRQ0FBTFFBdkRnTUJBQU1DQ3lBQUtBSTRJZ0ZGRFFBZ0FTZ0NMQ0lCUlEwQUlBQWdBUkdBZ0lDQUFBQWlBUTBEQzBFQUR3c1F5b0NBZ0FBQUN5QUFRY09XZ0lBQU5nSVFRUTRoQVFzZ0FRc2VBQUpBSUFBb0Fnd05BQ0FBUWRHYmdJQUFOZ0lRSUFCQkZUWUNEQXNMRmdBQ1FDQUFLQUlNUVJWSERRQWdBRUVBTmdJTUN3c1dBQUpBSUFBb0FneEJGa2NOQUNBQVFRQTJBZ3dMQ3djQUlBQW9BZ3dMQndBZ0FDZ0NFQXNKQUNBQUlBRTJBaEFMQndBZ0FDZ0NGQXNpQUFKQUlBQkJKRWtOQUJES2dJQ0FBQUFMSUFCQkFuUkJvTE9BZ0FCcUtBSUFDeUlBQWtBZ0FFRXVTUTBBRU1xQWdJQUFBQXNnQUVFQ2RFR3d0SUNBQUdvb0FnQUw3Z3NCQVg5QjY2aUFnQUFoQVFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkJuSDlxRHZRRFkySUFBV0ZoWVdGaFlRSURCQVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEJnY0lDUW9MREEwT0QyRmhZV0ZoRUdGaFlXRmhZV0ZoWVdGaEVXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlSSVRGQlVXRnhnWkdodGhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhIQjBlSHlBaElpTWtKU1luS0NrcUt5d3RMaTh3TVRJek5EVTJZVGM0T1RwaFlXRmhZV0ZoWVR0aFlXRThZV0ZoWVQwK1AyRmhZV0ZoWVdGaFFHRmhRV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVVKRFJFVkdSMGhKU2t0TVRVNVBVRkZTVTJGaFlXRmhZV0ZoVkZWV1YxaFpXbHRoWEYxaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmVZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhYMkJoQzBIaHA0Q0FBQThMUWFTaGdJQUFEd3RCeTZ5QWdBQVBDMEgrc1lDQUFBOExRY0NrZ0lBQUR3dEJxNlNBZ0FBUEMwR05xSUNBQUE4TFFlS21nSUFBRHd0QmdMQ0FnQUFQQzBHNXI0Q0FBQThMUWRla2dJQUFEd3RCNzUrQWdBQVBDMEhobjRDQUFBOExRZnFmZ0lBQUR3dEI4cUNBZ0FBUEMwR29yNENBQUE4TFFhNnlnSUFBRHd0QmlMQ0FnQUFQQzBIc3A0Q0FBQThMUVlLaWdJQUFEd3RCanAyQWdBQVBDMEhRcm9DQUFBOExRY3FqZ0lBQUR3dEJ4YktBZ0FBUEMwSGZuSUNBQUE4TFFkS2NnSUFBRHd0QnhLQ0FnQUFQQzBIWG9JQ0FBQThMUWFLZmdJQUFEd3RCN2E2QWdBQVBDMEdyc0lDQUFBOExRZFNsZ0lBQUR3dEJ6SzZBZ0FBUEMwSDZyb0NBQUE4TFFmeXJnSUFBRHd0QjByQ0FnQUFQQzBIeG5ZQ0FBQThMUWJ1Z2dJQUFEd3RCOTZ1QWdBQVBDMEdRc1lDQUFBOExRZGV4Z0lBQUR3dEJvcTJBZ0FBUEMwSFVwNENBQUE4TFFlQ3JnSUFBRHd0Qm42eUFnQUFQQzBIcnNZQ0FBQThMUWRXZmdJQUFEd3RCeXJHQWdBQVBDMEhlcFlDQUFBOExRZFNlZ0lBQUR3dEI5SnlBZ0FBUEMwR25zb0NBQUE4TFFiR2RnSUFBRHd0Qm9KMkFnQUFQQzBHNXNZQ0FBQThMUWJ5d2dJQUFEd3RCa3FHQWdBQVBDMEd6cG9DQUFBOExRZW1zZ0lBQUR3dEJySjZBZ0FBUEMwSFVxNENBQUE4TFFmZW1nSUFBRHd0QmdLYUFnQUFQQzBHd29ZQ0FBQThMUWY2ZWdJQUFEd3RCamFPQWdBQVBDMEdKcllDQUFBOExRZmVpZ0lBQUR3dEJvTEdBZ0FBUEMwR3VuNENBQUE4TFFjYWxnSUFBRHd0QjZKNkFnQUFQQzBHVG9vQ0FBQThMUWNLdmdJQUFEd3RCdzUyQWdBQVBDMEdMcklDQUFBOExRZUdkZ0lBQUR3dEJqYStBZ0FBUEMwSHFvWUNBQUE4TFFiU3RnSUFBRHd0QjBxK0FnQUFQQzBIZnNvQ0FBQThMUWRLeWdJQUFEd3RCOExDQWdBQVBDMEdwb29DQUFBOExRZm1qZ0lBQUR3dEJtWjZBZ0FBUEMwRzFySUNBQUE4TFFadXdnSUFBRHd0QmtyS0FnQUFQQzBHMnE0Q0FBQThMUWNLaWdJQUFEd3RCK0xLQWdBQVBDMEdlcFlDQUFBOExRZENpZ0lBQUR3dEJ1cDZBZ0FBUEMwR0Jub0NBQUE4TEVNcUFnSUFBQUF0QjFxR0FnQUFoQVFzZ0FRc1dBQ0FBSUFBdEFDMUIvZ0Z4SUFGQkFFZHlPZ0F0Q3hrQUlBQWdBQzBBTFVIOUFYRWdBVUVBUjBFQmRISTZBQzBMR1FBZ0FDQUFMUUF0UWZzQmNTQUJRUUJIUVFKMGNqb0FMUXNaQUNBQUlBQXRBQzFCOXdGeElBRkJBRWRCQTNSeU9nQXRDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FnQWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NCQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFjYVJnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUl3SWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwa0JBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWdnaUJFVU5BQ0FBSUFFZ0FpQUJheUFFRVlHQWdJQUFBQ0lEUVg5SERRQWdBRUgyaW9DQUFEWUNFRUVZSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ05DSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSU1JZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQjdacUFnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BamdpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDRUNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRWldRZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJOElnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMGtCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FoUWlCRVVOQUNBQUlBRWdBaUFCYXlBRUVZR0FnSUFBQUNJRFFYOUhEUUFnQUVHcW00Q0FBRFlDRUVFWUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NRQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0SkFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUlZSWdSRkRRQWdBQ0FCSUFJZ0FXc2dCQkdCZ0lDQUFBQWlBMEYvUncwQUlBQkI3Wk9BZ0FBMkFoQkJHQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWtRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ0pDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSXNJZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQzBrQkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BaWdpQkVVTkFDQUFJQUVnQWlBQmF5QUVFWUdBZ0lBQUFDSURRWDlIRFFBZ0FFSDJpSUNBQURZQ0VFRVlJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDVUNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEpBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJY0lnUkZEUUFnQUNBQklBSWdBV3NnQkJHQmdJQ0FBQUFpQTBGL1J3MEFJQUJCd3BtQWdBQTJBaEJCR0NFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FrZ2lCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NJQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFaU1VnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUpNSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWxRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ1dDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RGQVFGL0FrQUNRQ0FBTHdFd1FSUnhRUlJIRFFCQkFTRURJQUF0QUNoQkFVWU5BU0FBTHdFeVFlVUFSaUVEREFFTElBQXRBQ2xCQlVZaEF3c2dBQ0FET2dBdVFRQUwvZ0VCQTM5QkFTRURBa0FnQUM4Qk1DSUVRUWh4RFFBZ0FDa0RJRUlBVWlFREN3SkFBa0FnQUMwQUxrVU5BRUVCSVFVZ0FDMEFLVUVGUmcwQlFRRWhCU0FFUWNBQWNVVWdBM0ZCQVVjTkFRdEJBQ0VGSUFSQndBQnhEUUJCQWlFRklBUkIvLzhEY1NJRFFRaHhEUUFDUUNBRFFZQUVjVVVOQUFKQUlBQXRBQ2hCQVVjTkFDQUFMUUF0UVFweERRQkJCUThMUVFRUEN3SkFJQU5CSUhFTkFBSkFJQUF0QUNoQkFVWU5BQ0FBTHdFeVFmLy9BM0VpQUVHY2YycEI1QUJKRFFBZ0FFSE1BVVlOQUNBQVFiQUNSZzBBUVFRaEJTQUVRU2h4UlEwQ0lBTkJpQVJ4UVlBRVJnMENDMEVBRHd0QkFFRURJQUFwQXlCUUd5RUZDeUFGQzJJQkFuOUJBQ0VCQWtBZ0FDMEFLRUVCUmcwQUlBQXZBVEpCLy84RGNTSUNRWngvYWtIa0FFa05BQ0FDUWN3QlJnMEFJQUpCc0FKR0RRQWdBQzhCTUNJQVFjQUFjUTBBUVFFaEFTQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUJDeUFCQzZjQkFRTi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUVFQUlRTWdBQzhCTUNJRVFRSnhSUTBCREFJTFFRQWhBeUFBTHdFd0lnUkJBWEZGRFFFTFFRRWhBeUFBTFFBb1FRRkdEUUFnQUM4Qk1rSC8vd054SWdWQm5IOXFRZVFBU1EwQUlBVkJ6QUZHRFFBZ0JVR3dBa1lOQUNBRVFjQUFjUTBBUVFBaEF5QUVRWWdFY1VHQUJFWU5BQ0FFUVNoeFFRQkhJUU1MSUFCQkFEc0JNQ0FBUVFBNkFDOGdBd3VaQVFFQ2Z3SkFBa0FDUUNBQUxRQXFSUTBBSUFBdEFDdEZEUUJCQUNFQklBQXZBVEFpQWtFQ2NVVU5BUXdDQzBFQUlRRWdBQzhCTUNJQ1FRRnhSUTBCQzBFQklRRWdBQzBBS0VFQlJnMEFJQUF2QVRKQi8vOERjU0lBUVp4L2FrSGtBRWtOQUNBQVFjd0JSZzBBSUFCQnNBSkdEUUFnQWtIQUFIRU5BRUVBSVFFZ0FrR0lCSEZCZ0FSR0RRQWdBa0VvY1VFQVJ5RUJDeUFCQzBrQkFYc2dBRUVRYXYwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNJQi9Rc0RBQ0FBSUFIOUN3TUFJQUJCTUdvZ0FmMExBd0FnQUVFZ2FpQUIvUXNEQUNBQVFkMEJOZ0ljUVFBTGV3RUJmd0pBSUFBb0Fnd2lBdzBBQWtBZ0FDZ0NCRVVOQUNBQUlBRTJBZ1FMQWtBZ0FDQUJJQUlReElDQWdBQWlBdzBBSUFBb0Fnd1BDeUFBSUFNMkFoeEJBQ0VESUFBb0FnUWlBVVVOQUNBQUlBRWdBaUFBS0FJSUVZR0FnSUFBQUNJQlJRMEFJQUFnQWpZQ0ZDQUFJQUUyQWd3Z0FTRURDeUFEQytUekFRTU9md04rQkg4amdJQ0FnQUJCRUdzaUF5U0FnSUNBQUNBQklRUWdBU0VGSUFFaEJpQUJJUWNnQVNFSUlBRWhDU0FCSVFvZ0FTRUxJQUVoRENBQklRMGdBU0VPSUFFaER3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUFLQUljSWhCQmYyb08zUUhhQVFIWkFRSURCQVVHQndnSkNnc01EUTdZQVE4UTF3RVJFdFlCRXhRVkZoY1lHUm9iNEFIZkFSd2RIdFVCSHlBaElpTWtKZFFCSmljb0tTb3JMTk1CMGdFdEx0RUIwQUV2TURFeU16UTFOamM0T1RvN1BEMCtQMEJCUWtORVJVYmJBVWRJU1VyUEFjNEJTODBCVE13QlRVNVBVRkZTVTFSVlZsZFlXVnBiWEYxZVgyQmhZbU5rWldabmFHbHFhMnh0Ym05d2NYSnpkSFYyZDNoNWVudDhmWDUvZ0FHQkFZSUJnd0dFQVlVQmhnR0hBWWdCaVFHS0FZc0JqQUdOQVk0Qmp3R1FBWkVCa2dHVEFaUUJsUUdXQVpjQm1BR1pBWm9CbXdHY0FaMEJuZ0dmQWFBQm9RR2lBYU1CcEFHbEFhWUJwd0dvQWFrQnFnR3JBYXdCclFHdUFhOEJzQUd4QWJJQnN3RzBBYlVCdGdHM0Fjc0J5Z0c0QWNrQnVRSElBYm9CdXdHOEFiMEJ2Z0cvQWNBQndRSENBY01CeEFIRkFjWUJBTndCQzBFQUlSQU14Z0VMUVE0aEVBekZBUXRCRFNFUURNUUJDMEVQSVJBTXd3RUxRUkFoRUF6Q0FRdEJFeUVRRE1FQkMwRVVJUkFNd0FFTFFSVWhFQXkvQVF0QkZpRVFETDRCQzBFWElSQU12UUVMUVJnaEVBeThBUXRCR1NFUURMc0JDMEVhSVJBTXVnRUxRUnNoRUF5NUFRdEJIQ0VRRExnQkMwRUlJUkFNdHdFTFFSMGhFQXkyQVF0QklDRVFETFVCQzBFZklSQU10QUVMUVFjaEVBeXpBUXRCSVNFUURMSUJDMEVpSVJBTXNRRUxRUjRoRUF5d0FRdEJJeUVRREs4QkMwRVNJUkFNcmdFTFFSRWhFQXl0QVF0QkpDRVFES3dCQzBFbElSQU1xd0VMUVNZaEVBeXFBUXRCSnlFUURLa0JDMEhEQVNFUURLZ0JDMEVwSVJBTXB3RUxRU3NoRUF5bUFRdEJMQ0VRREtVQkMwRXRJUkFNcEFFTFFTNGhFQXlqQVF0Qkx5RVFES0lCQzBIRUFTRVFES0VCQzBFd0lSQU1vQUVMUVRRaEVBeWZBUXRCRENFUURKNEJDMEV4SVJBTW5RRUxRVEloRUF5Y0FRdEJNeUVRREpzQkMwRTVJUkFNbWdFTFFUVWhFQXlaQVF0QnhRRWhFQXlZQVF0QkN5RVFESmNCQzBFNklSQU1sZ0VMUVRZaEVBeVZBUXRCQ2lFUURKUUJDMEUzSVJBTWt3RUxRVGdoRUF5U0FRdEJQQ0VRREpFQkMwRTdJUkFNa0FFTFFUMGhFQXlQQVF0QkNTRVFESTRCQzBFb0lSQU1qUUVMUVQ0aEVBeU1BUXRCUHlFUURJc0JDMEhBQUNFUURJb0JDMEhCQUNFUURJa0JDMEhDQUNFUURJZ0JDMEhEQUNFUURJY0JDMEhFQUNFUURJWUJDMEhGQUNFUURJVUJDMEhHQUNFUURJUUJDMEVxSVJBTWd3RUxRY2NBSVJBTWdnRUxRY2dBSVJBTWdRRUxRY2tBSVJBTWdBRUxRY29BSVJBTWZ3dEJ5d0FoRUF4K0MwSE5BQ0VRREgwTFFjd0FJUkFNZkF0QnpnQWhFQXg3QzBIUEFDRVFESG9MUWRBQUlSQU1lUXRCMFFBaEVBeDRDMEhTQUNFUURIY0xRZE1BSVJBTWRndEIxQUFoRUF4MUMwSFdBQ0VRREhRTFFkVUFJUkFNY3d0QkJpRVFESElMUWRjQUlSQU1jUXRCQlNFUURIQUxRZGdBSVJBTWJ3dEJCQ0VRREc0TFFka0FJUkFNYlF0QjJnQWhFQXhzQzBIYkFDRVFER3NMUWR3QUlSQU1hZ3RCQXlFUURHa0xRZDBBSVJBTWFBdEIzZ0FoRUF4bkMwSGZBQ0VRREdZTFFlRUFJUkFNWlF0QjRBQWhFQXhrQzBIaUFDRVFER01MUWVNQUlSQU1ZZ3RCQWlFUURHRUxRZVFBSVJBTVlBdEI1UUFoRUF4ZkMwSG1BQ0VRREY0TFFlY0FJUkFNWFF0QjZBQWhFQXhjQzBIcEFDRVFERnNMUWVvQUlSQU1XZ3RCNndBaEVBeFpDMEhzQUNFUURGZ0xRZTBBSVJBTVZ3dEI3Z0FoRUF4V0MwSHZBQ0VRREZVTFFmQUFJUkFNVkF0QjhRQWhFQXhUQzBIeUFDRVFERklMUWZNQUlSQU1VUXRCOUFBaEVBeFFDMEgxQUNFUURFOExRZllBSVJBTVRndEI5d0FoRUF4TkMwSDRBQ0VRREV3TFFma0FJUkFNU3d0QitnQWhFQXhLQzBIN0FDRVFERWtMUWZ3QUlSQU1TQXRCL1FBaEVBeEhDMEgrQUNFUURFWUxRZjhBSVJBTVJRdEJnQUVoRUF4RUMwR0JBU0VRREVNTFFZSUJJUkFNUWd0Qmd3RWhFQXhCQzBHRUFTRVFERUFMUVlVQklSQU1Qd3RCaGdFaEVBdytDMEdIQVNFUUREMExRWWdCSVJBTVBBdEJpUUVoRUF3N0MwR0tBU0VRRERvTFFZc0JJUkFNT1F0QmpBRWhFQXc0QzBHTkFTRVFERGNMUVk0QklSQU1OZ3RCandFaEVBdzFDMEdRQVNFUUREUUxRWkVCSVJBTU13dEJrZ0VoRUF3eUMwR1RBU0VRRERFTFFaUUJJUkFNTUF0QmxRRWhFQXd2QzBHV0FTRVFEQzRMUVpjQklSQU1MUXRCbUFFaEVBd3NDMEdaQVNFUURDc0xRWm9CSVJBTUtndEJtd0VoRUF3cEMwR2NBU0VRRENnTFFaMEJJUkFNSnd0Qm5nRWhFQXdtQzBHZkFTRVFEQ1VMUWFBQklSQU1KQXRCb1FFaEVBd2pDMEdpQVNFUURDSUxRYU1CSVJBTUlRdEJwQUVoRUF3Z0MwR2xBU0VRREI4TFFhWUJJUkFNSGd0QnB3RWhFQXdkQzBHb0FTRVFEQndMUWFrQklSQU1Hd3RCcWdFaEVBd2FDMEdyQVNFUURCa0xRYXdCSVJBTUdBdEJyUUVoRUF3WEMwR3VBU0VRREJZTFFRRWhFQXdWQzBHdkFTRVFEQlFMUWJBQklSQU1Fd3RCc1FFaEVBd1NDMEd6QVNFUURCRUxRYklCSVJBTUVBdEJ0QUVoRUF3UEMwRzFBU0VRREE0TFFiWUJJUkFNRFF0QnR3RWhFQXdNQzBHNEFTRVFEQXNMUWJrQklSQU1DZ3RCdWdFaEVBd0pDMEc3QVNFUURBZ0xRY1lCSVJBTUJ3dEJ2QUVoRUF3R0MwRzlBU0VRREFVTFFiNEJJUkFNQkF0QnZ3RWhFQXdEQzBIQUFTRVFEQUlMUWNJQklSQU1BUXRCd1FFaEVBc0RRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUJBT3h3RUFBUUlEQkFVR0J3Z0pDZ3NNRFE0UEVCRVNFeFFWRmhjWUdSb2JIQjRmSUNFakpTZy9RRUZFUlVaSFNFbEtTMHhOVDFCUlVsUGVBMWRaVzF4ZFlHSmxabWRvYVdwcmJHMXZjSEZ5YzNSMWRuZDRlWHA3ZkgxK2dBR0NBWVVCaGdHSEFZa0Jpd0dNQVkwQmpnR1BBWkFCa1FHVUFaVUJsZ0dYQVpnQm1RR2FBWnNCbkFHZEFaNEJud0dnQWFFQm9nR2pBYVFCcFFHbUFhY0JxQUdwQWFvQnF3R3NBYTBCcmdHdkFiQUJzUUd5QWJNQnRBRzFBYllCdHdHNEFia0J1Z0c3QWJ3QnZRRytBYjhCd0FIQkFjSUJ3d0hFQWNVQnhnSEhBY2dCeVFIS0Fjc0J6QUhOQWM0Qnp3SFFBZEVCMGdIVEFkUUIxUUhXQWRjQjJBSFpBZG9CMndIY0FkMEIzZ0hnQWVFQjRnSGpBZVFCNVFIbUFlY0I2QUhwQWVvQjZ3SHNBZTBCN2dIdkFmQUI4UUh5QWZNQm1RS2tBckFDL2dMK0Fnc2dBU0lFSUFKSERmTUJRZDBCSVJBTS93TUxJQUVpRUNBQ1J3M2RBVUhEQVNFUURQNERDeUFCSWdFZ0FrY05rQUZCOXdBaEVBejlBd3NnQVNJQklBSkhEWVlCUWU4QUlSQU0vQU1MSUFFaUFTQUNSdzEvUWVvQUlSQU0rd01MSUFFaUFTQUNSdzE3UWVnQUlSQU0rZ01MSUFFaUFTQUNSdzE0UWVZQUlSQU0rUU1MSUFFaUFTQUNSdzBhUVJnaEVBejRBd3NnQVNJQklBSkhEUlJCRWlFUURQY0RDeUFCSWdFZ0FrY05XVUhGQUNFUURQWURDeUFCSWdFZ0FrY05Ta0UvSVJBTTlRTUxJQUVpQVNBQ1J3MUlRVHdoRUF6MEF3c2dBU0lCSUFKSERVRkJNU0VRRFBNREN5QUFMUUF1UVFGR0Rlc0RESWNDQ3lBQUlBRWlBU0FDRU1DQWdJQUFRUUZIRGVZQklBQkNBRGNESUF6bkFRc2dBQ0FCSWdFZ0FoQzBnSUNBQUNJUURlY0JJQUVoQVF6MUFnc0NRQ0FCSWdFZ0FrY05BRUVHSVJBTThBTUxJQUFnQVVFQmFpSUJJQUlRdTRDQWdBQWlFQTNvQVNBQklRRU1NUXNnQUVJQU53TWdRUkloRUF6VkF3c2dBU0lRSUFKSERTdEJIU0VRRE8wREN3SkFJQUVpQVNBQ1JnMEFJQUZCQVdvaEFVRVFJUkFNMUFNTFFRY2hFQXpzQXdzZ0FFSUFJQUFwQXlBaUVTQUNJQUVpRUd1dEloSjlJaE1nRXlBUlZoczNBeUFnRVNBU1ZpSVVSUTNsQVVFSUlSQU02d01MQWtBZ0FTSUJJQUpHRFFBZ0FFR0pnSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJRUlFoRUF6U0F3dEJDU0VRRE9vREN5QUJJUUVnQUNrRElGQU41QUVnQVNFQkRQSUNDd0pBSUFFaUFTQUNSdzBBUVFzaEVBenBBd3NnQUNBQlFRRnFJZ0VnQWhDMmdJQ0FBQ0lRRGVVQklBRWhBUXp5QWdzZ0FDQUJJZ0VnQWhDNGdJQ0FBQ0lRRGVVQklBRWhBUXp5QWdzZ0FDQUJJZ0VnQWhDNGdJQ0FBQ0lRRGVZQklBRWhBUXdOQ3lBQUlBRWlBU0FDRUxxQWdJQUFJaEFONXdFZ0FTRUJEUEFDQ3dKQUlBRWlBU0FDUncwQVFROGhFQXpsQXdzZ0FTMEFBQ0lRUVR0R0RRZ2dFRUVOUnczb0FTQUJRUUZxSVFFTTd3SUxJQUFnQVNJQklBSVF1b0NBZ0FBaUVBM29BU0FCSVFFTThnSUxBMEFDUUNBQkxRQUFRZkMxZ0lBQWFpMEFBQ0lRUVFGR0RRQWdFRUVDUnczckFTQUFLQUlFSVJBZ0FFRUFOZ0lFSUFBZ0VDQUJRUUZxSWdFUXVZQ0FnQUFpRUEzcUFTQUJJUUVNOUFJTElBRkJBV29pQVNBQ1J3MEFDMEVTSVJBTTRnTUxJQUFnQVNJQklBSVF1b0NBZ0FBaUVBM3BBU0FCSVFFTUNnc2dBU0lCSUFKSERRWkJHeUVRRE9BREN3SkFJQUVpQVNBQ1J3MEFRUlloRUF6Z0F3c2dBRUdLZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBQ0FCSUFJUXVJQ0FnQUFpRUEzcUFTQUJJUUZCSUNFUURNWURDd0pBSUFFaUFTQUNSZzBBQTBBQ1FDQUJMUUFBUWZDM2dJQUFhaTBBQUNJUVFRSkdEUUFDUUNBUVFYOXFEZ1RsQWV3QkFPc0I3QUVMSUFGQkFXb2hBVUVJSVJBTXlBTUxJQUZCQVdvaUFTQUNSdzBBQzBFVklSQU0zd01MUVJVaEVBemVBd3NEUUFKQUlBRXRBQUJCOExtQWdBQnFMUUFBSWhCQkFrWU5BQ0FRUVg5cURnVGVBZXdCNEFIckFld0JDeUFCUVFGcUlnRWdBa2NOQUF0QkdDRVFETjBEQ3dKQUlBRWlBU0FDUmcwQUlBQkJpNENBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUVISVJBTXhBTUxRUmtoRUF6Y0F3c2dBVUVCYWlFQkRBSUxBa0FnQVNJVUlBSkhEUUJCR2lFUUROc0RDeUFVSVFFQ1FDQVVMUUFBUVhOcURoVGRBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBZ0R1QWd0QkFDRVFJQUJCQURZQ0hDQUFRYStMZ0lBQU5nSVFJQUJCQWpZQ0RDQUFJQlJCQVdvMkFoUU0yZ01MQWtBZ0FTMEFBQ0lRUVR0R0RRQWdFRUVOUnczb0FTQUJRUUZxSVFFTTVRSUxJQUZCQVdvaEFRdEJJaUVRREw4REN3SkFJQUVpRUNBQ1J3MEFRUndoRUF6WUF3dENBQ0VSSUJBaEFTQVFMUUFBUVZCcURqZm5BZVlCQVFJREJBVUdCd2dBQUFBQUFBQUFDUW9MREEwT0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUEVCRVNFeFFBQzBFZUlSQU12UU1MUWdJaEVRemxBUXRDQXlFUkRPUUJDMElFSVJFTTR3RUxRZ1VoRVF6aUFRdENCaUVSRE9FQkMwSUhJUkVNNEFFTFFnZ2hFUXpmQVF0Q0NTRVJETjRCQzBJS0lSRU0zUUVMUWdzaEVRemNBUXRDRENFUkROc0JDMElOSVJFTTJnRUxRZzRoRVF6WkFRdENEeUVSRE5nQkMwSUtJUkVNMXdFTFFnc2hFUXpXQVF0Q0RDRVJETlVCQzBJTklSRU0xQUVMUWc0aEVRelRBUXRDRHlFUkROSUJDMElBSVJFQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQkF0QUFCQlVHb09OK1VCNUFFQUFRSURCQVVHQitZQjVnSG1BZVlCNWdIbUFlWUJDQWtLQ3d3TjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQVE0UEVCRVNFK1lCQzBJQ0lSRU01QUVMUWdNaEVRempBUXRDQkNFUkRPSUJDMElGSVJFTTRRRUxRZ1loRVF6Z0FRdENCeUVSRE44QkMwSUlJUkVNM2dFTFFna2hFUXpkQVF0Q0NpRVJETndCQzBJTElSRU0yd0VMUWd3aEVRemFBUXRDRFNFUkROa0JDMElPSVJFTTJBRUxRZzhoRVF6WEFRdENDaUVSRE5ZQkMwSUxJUkVNMVFFTFFnd2hFUXpVQVF0Q0RTRVJETk1CQzBJT0lSRU0wZ0VMUWc4aEVRelJBUXNnQUVJQUlBQXBBeUFpRVNBQ0lBRWlFR3V0SWhKOUloTWdFeUFSVmhzM0F5QWdFU0FTVmlJVVJRM1NBVUVmSVJBTXdBTUxBa0FnQVNJQklBSkdEUUFnQUVHSmdJQ0FBRFlDQ0NBQUlBRTJBZ1FnQVNFQlFTUWhFQXluQXd0QklDRVFETDhEQ3lBQUlBRWlFQ0FDRUw2QWdJQUFRWDlxRGdXMkFRREZBZ0hSQWRJQkMwRVJJUkFNcEFNTElBQkJBVG9BTHlBUUlRRU11d01MSUFFaUFTQUNSdzNTQVVFa0lSQU11d01MSUFFaURTQUNSdzBlUWNZQUlSQU11Z01MSUFBZ0FTSUJJQUlRc29DQWdBQWlFQTNVQVNBQklRRU10UUVMSUFFaUVDQUNSdzBtUWRBQUlSQU11QU1MQWtBZ0FTSUJJQUpIRFFCQktDRVFETGdEQ3lBQVFRQTJBZ1FnQUVHTWdJQ0FBRFlDQ0NBQUlBRWdBUkN4Z0lDQUFDSVFEZE1CSUFFaEFRellBUXNDUUNBQkloQWdBa2NOQUVFcElSQU10d01MSUJBdEFBQWlBVUVnUmcwVUlBRkJDVWNOMHdFZ0VFRUJhaUVCREJVTEFrQWdBU0lCSUFKR0RRQWdBVUVCYWlFQkRCY0xRU29oRUF5MUF3c0NRQ0FCSWhBZ0FrY05BRUVySVJBTXRRTUxBa0FnRUMwQUFDSUJRUWxHRFFBZ0FVRWdSdzNWQVFzZ0FDMEFMRUVJUmczVEFTQVFJUUVNa1FNTEFrQWdBU0lCSUFKSERRQkJMQ0VRRExRREN5QUJMUUFBUVFwSERkVUJJQUZCQVdvaEFRekpBZ3NnQVNJT0lBSkhEZFVCUVM4aEVBeXlBd3NEUUFKQUlBRXRBQUFpRUVFZ1JnMEFBa0FnRUVGMmFnNEVBTndCM0FFQTJnRUxJQUVoQVF6Z0FRc2dBVUVCYWlJQklBSkhEUUFMUVRFaEVBeXhBd3RCTWlFUUlBRWlGQ0FDUmcyd0F5QUNJQlJySUFBb0FnQWlBV29oRlNBVUlBRnJRUU5xSVJZQ1FBTkFJQlF0QUFBaUYwRWdjaUFYSUJkQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQjhMdUFnQUJxTFFBQVJ3MEJBa0FnQVVFRFJ3MEFRUVloQVF5V0F3c2dBVUVCYWlFQklCUkJBV29pRkNBQ1J3MEFDeUFBSUJVMkFnQU1zUU1MSUFCQkFEWUNBQ0FVSVFFTTJRRUxRVE1oRUNBQkloUWdBa1lOcndNZ0FpQVVheUFBS0FJQUlnRnFJUlVnRkNBQmEwRUlhaUVXQWtBRFFDQVVMUUFBSWhkQklISWdGeUFYUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUWZTN2dJQUFhaTBBQUVjTkFRSkFJQUZCQ0VjTkFFRUZJUUVNbFFNTElBRkJBV29oQVNBVVFRRnFJaFFnQWtjTkFBc2dBQ0FWTmdJQURMQURDeUFBUVFBMkFnQWdGQ0VCRE5nQkMwRTBJUkFnQVNJVUlBSkdEYTRESUFJZ0ZHc2dBQ2dDQUNJQmFpRVZJQlFnQVd0QkJXb2hGZ0pBQTBBZ0ZDMEFBQ0lYUVNCeUlCY2dGMEcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUhRd29DQUFHb3RBQUJIRFFFQ1FDQUJRUVZIRFFCQkJ5RUJESlFEQ3lBQlFRRnFJUUVnRkVFQmFpSVVJQUpIRFFBTElBQWdGVFlDQUF5dkF3c2dBRUVBTmdJQUlCUWhBUXpYQVFzQ1FDQUJJZ0VnQWtZTkFBTkFBa0FnQVMwQUFFR0F2b0NBQUdvdEFBQWlFRUVCUmcwQUlCQkJBa1lOQ2lBQklRRU0zUUVMSUFGQkFXb2lBU0FDUncwQUMwRXdJUkFNcmdNTFFUQWhFQXl0QXdzQ1FDQUJJZ0VnQWtZTkFBTkFBa0FnQVMwQUFDSVFRU0JHRFFBZ0VFRjJhZzRFMlFIYUFkb0IyUUhhQVFzZ0FVRUJhaUlCSUFKSERRQUxRVGdoRUF5dEF3dEJPQ0VRREt3REN3TkFBa0FnQVMwQUFDSVFRU0JHRFFBZ0VFRUpSdzBEQ3lBQlFRRnFJZ0VnQWtjTkFBdEJQQ0VRREtzREN3TkFBa0FnQVMwQUFDSVFRU0JHRFFBQ1FBSkFJQkJCZG1vT0JOb0JBUUhhQVFBTElCQkJMRVlOMndFTElBRWhBUXdFQ3lBQlFRRnFJZ0VnQWtjTkFBdEJQeUVRREtvREN5QUJJUUVNMndFTFFjQUFJUkFnQVNJVUlBSkdEYWdESUFJZ0ZHc2dBQ2dDQUNJQmFpRVdJQlFnQVd0QkJtb2hGd0pBQTBBZ0ZDMEFBRUVnY2lBQlFZREFnSUFBYWkwQUFFY05BU0FCUVFaR0RZNERJQUZCQVdvaEFTQVVRUUZxSWhRZ0FrY05BQXNnQUNBV05nSUFES2tEQ3lBQVFRQTJBZ0FnRkNFQkMwRTJJUkFNamdNTEFrQWdBU0lQSUFKSERRQkJ3UUFoRUF5bkF3c2dBRUdNZ0lDQUFEWUNDQ0FBSUE4MkFnUWdEeUVCSUFBdEFDeEJmMm9PQk0wQjFRSFhBZGtCaHdNTElBRkJBV29oQVF6TUFRc0NRQ0FCSWdFZ0FrWU5BQU5BQWtBZ0FTMEFBQ0lRUVNCeUlCQWdFRUcvZjJwQi93RnhRUnBKRzBIL0FYRWlFRUVKUmcwQUlCQkJJRVlOQUFKQUFrQUNRQUpBSUJCQm5YOXFEaE1BQXdNREF3TURBd0VEQXdNREF3TURBd01DQXdzZ0FVRUJhaUVCUVRFaEVBeVJBd3NnQVVFQmFpRUJRVEloRUF5UUF3c2dBVUVCYWlFQlFUTWhFQXlQQXdzZ0FTRUJETkFCQ3lBQlFRRnFJZ0VnQWtjTkFBdEJOU0VRREtVREMwRTFJUkFNcEFNTEFrQWdBU0lCSUFKR0RRQURRQUpBSUFFdEFBQkJnTHlBZ0FCcUxRQUFRUUZHRFFBZ0FTRUJETk1CQ3lBQlFRRnFJZ0VnQWtjTkFBdEJQU0VRREtRREMwRTlJUkFNb3dNTElBQWdBU0lCSUFJUXNJQ0FnQUFpRUEzV0FTQUJJUUVNQVFzZ0VFRUJhaUVCQzBFOElSQU1od01MQWtBZ0FTSUJJQUpIRFFCQndnQWhFQXlnQXdzQ1FBTkFBa0FnQVMwQUFFRjNhZzRZQUFMK0F2NENoQVArQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0lBL2dJTElBRkJBV29pQVNBQ1J3MEFDMEhDQUNFUURLQURDeUFCUVFGcUlRRWdBQzBBTFVFQmNVVU52UUVnQVNFQkMwRXNJUkFNaFFNTElBRWlBU0FDUnczVEFVSEVBQ0VRREowREN3TkFBa0FnQVMwQUFFR1F3SUNBQUdvdEFBQkJBVVlOQUNBQklRRU10d0lMSUFGQkFXb2lBU0FDUncwQUMwSEZBQ0VRREp3REN5QU5MUUFBSWhCQklFWU5zd0VnRUVFNlJ3MkJBeUFBS0FJRUlRRWdBRUVBTmdJRUlBQWdBU0FORUsrQWdJQUFJZ0VOMEFFZ0RVRUJhaUVCRExNQ0MwSEhBQ0VRSUFFaURTQUNSZzJhQXlBQ0lBMXJJQUFvQWdBaUFXb2hGaUFOSUFGclFRVnFJUmNEUUNBTkxRQUFJaFJCSUhJZ0ZDQVVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRWkRDZ0lBQWFpMEFBRWNOZ0FNZ0FVRUZSZzMwQWlBQlFRRnFJUUVnRFVFQmFpSU5JQUpIRFFBTElBQWdGallDQUF5YUF3dEJ5QUFoRUNBQklnMGdBa1lObVFNZ0FpQU5heUFBS0FJQUlnRnFJUllnRFNBQmEwRUphaUVYQTBBZ0RTMEFBQ0lVUVNCeUlCUWdGRUcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUdXd29DQUFHb3RBQUJIRGY4Q0FrQWdBVUVKUncwQVFRSWhBUXoxQWdzZ0FVRUJhaUVCSUExQkFXb2lEU0FDUncwQUN5QUFJQlkyQWdBTW1RTUxBa0FnQVNJTklBSkhEUUJCeVFBaEVBeVpBd3NDUUFKQUlBMHRBQUFpQVVFZ2NpQUJJQUZCdjM5cVFmOEJjVUVhU1J0Qi93RnhRWkovYWc0SEFJQURnQU9BQTRBRGdBTUJnQU1MSUExQkFXb2hBVUUrSVJBTWdBTUxJQTFCQVdvaEFVRS9JUkFNL3dJTFFjb0FJUkFnQVNJTklBSkdEWmNESUFJZ0RXc2dBQ2dDQUNJQmFpRVdJQTBnQVd0QkFXb2hGd05BSUEwdEFBQWlGRUVnY2lBVUlCUkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkJvTUtBZ0FCcUxRQUFSdzM5QWlBQlFRRkdEZkFDSUFGQkFXb2hBU0FOUVFGcUlnMGdBa2NOQUFzZ0FDQVdOZ0lBREpjREMwSExBQ0VRSUFFaURTQUNSZzJXQXlBQ0lBMXJJQUFvQWdBaUFXb2hGaUFOSUFGclFRNXFJUmNEUUNBTkxRQUFJaFJCSUhJZ0ZDQVVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRYUxDZ0lBQWFpMEFBRWNOL0FJZ0FVRU9SZzN3QWlBQlFRRnFJUUVnRFVFQmFpSU5JQUpIRFFBTElBQWdGallDQUF5V0F3dEJ6QUFoRUNBQklnMGdBa1lObFFNZ0FpQU5heUFBS0FJQUlnRnFJUllnRFNBQmEwRVBhaUVYQTBBZ0RTMEFBQ0lVUVNCeUlCUWdGRUcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUhBd29DQUFHb3RBQUJIRGZzQ0FrQWdBVUVQUncwQVFRTWhBUXp4QWdzZ0FVRUJhaUVCSUExQkFXb2lEU0FDUncwQUN5QUFJQlkyQWdBTWxRTUxRYzBBSVJBZ0FTSU5JQUpHRFpRRElBSWdEV3NnQUNnQ0FDSUJhaUVXSUEwZ0FXdEJCV29oRndOQUlBMHRBQUFpRkVFZ2NpQVVJQlJCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCME1LQWdBQnFMUUFBUnczNkFnSkFJQUZCQlVjTkFFRUVJUUVNOEFJTElBRkJBV29oQVNBTlFRRnFJZzBnQWtjTkFBc2dBQ0FXTmdJQURKUURDd0pBSUFFaURTQUNSdzBBUWM0QUlSQU1sQU1MQWtBQ1FBSkFBa0FnRFMwQUFDSUJRU0J5SUFFZ0FVRy9mMnBCL3dGeFFScEpHMEgvQVhGQm5YOXFEaE1BL1FMOUF2MEMvUUw5QXYwQy9RTDlBdjBDL1FMOUF2MENBZjBDL1FMOUFnSUQvUUlMSUExQkFXb2hBVUhCQUNFUURQMENDeUFOUVFGcUlRRkJ3Z0FoRUF6OEFnc2dEVUVCYWlFQlFjTUFJUkFNK3dJTElBMUJBV29oQVVIRUFDRVFEUG9DQ3dKQUlBRWlBU0FDUmcwQUlBQkJqWUNBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUhGQUNFUURQb0NDMEhQQUNFUURKSURDeUFRSVFFQ1FBSkFJQkF0QUFCQmRtb09CQUdvQXFnQ0FLZ0NDeUFRUVFGcUlRRUxRU2NoRUF6NEFnc0NRQ0FCSWdFZ0FrY05BRUhSQUNFUURKRURDd0pBSUFFdEFBQkJJRVlOQUNBQklRRU1qUUVMSUFGQkFXb2hBU0FBTFFBdFFRRnhSUTNIQVNBQklRRU1qQUVMSUFFaUZ5QUNSdzNJQVVIU0FDRVFESThEQzBIVEFDRVFJQUVpRkNBQ1JnMk9BeUFDSUJScklBQW9BZ0FpQVdvaEZpQVVJQUZyUVFGcUlSY0RRQ0FVTFFBQUlBRkIxc0tBZ0FCcUxRQUFSdzNNQVNBQlFRRkdEY2NCSUFGQkFXb2hBU0FVUVFGcUloUWdBa2NOQUFzZ0FDQVdOZ0lBREk0REN3SkFJQUVpQVNBQ1J3MEFRZFVBSVJBTWpnTUxJQUV0QUFCQkNrY056QUVnQVVFQmFpRUJETWNCQ3dKQUlBRWlBU0FDUncwQVFkWUFJUkFNalFNTEFrQUNRQ0FCTFFBQVFYWnFEZ1FBelFITkFRSE5BUXNnQVVFQmFpRUJETWNCQ3lBQlFRRnFJUUZCeWdBaEVBenpBZ3NnQUNBQklnRWdBaEN1Z0lDQUFDSVFEY3NCSUFFaEFVSE5BQ0VRRFBJQ0N5QUFMUUFwUVNKR0RZVURES1lDQ3dKQUlBRWlBU0FDUncwQVFkc0FJUkFNaWdNTFFRQWhGRUVCSVJkQkFTRVdRUUFoRUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRVkJxRGdyVUFkTUJBQUVDQXdRRkJnalZBUXRCQWlFUURBWUxRUU1oRUF3RkMwRUVJUkFNQkF0QkJTRVFEQU1MUVFZaEVBd0NDMEVISVJBTUFRdEJDQ0VRQzBFQUlSZEJBQ0VXUVFBaEZBek1BUXRCQ1NFUVFRRWhGRUVBSVJkQkFDRVdETXNCQ3dKQUlBRWlBU0FDUncwQVFkMEFJUkFNaVFNTElBRXRBQUJCTGtjTnpBRWdBVUVCYWlFQkRLWUNDeUFCSWdFZ0FrY056QUZCM3dBaEVBeUhBd3NDUUNBQklnRWdBa1lOQUNBQVFZNkFnSUFBTmdJSUlBQWdBVFlDQkNBQklRRkIwQUFoRUF6dUFndEI0QUFoRUF5R0F3dEI0UUFoRUNBQklnRWdBa1lOaFFNZ0FpQUJheUFBS0FJQUloUnFJUllnQVNBVWEwRURhaUVYQTBBZ0FTMEFBQ0FVUWVMQ2dJQUFhaTBBQUVjTnpRRWdGRUVEUmczTUFTQVVRUUZxSVJRZ0FVRUJhaUlCSUFKSERRQUxJQUFnRmpZQ0FBeUZBd3RCNGdBaEVDQUJJZ0VnQWtZTmhBTWdBaUFCYXlBQUtBSUFJaFJxSVJZZ0FTQVVhMEVDYWlFWEEwQWdBUzBBQUNBVVFlYkNnSUFBYWkwQUFFY056QUVnRkVFQ1JnM09BU0FVUVFGcUlSUWdBVUVCYWlJQklBSkhEUUFMSUFBZ0ZqWUNBQXlFQXd0QjR3QWhFQ0FCSWdFZ0FrWU5nd01nQWlBQmF5QUFLQUlBSWhScUlSWWdBU0FVYTBFRGFpRVhBMEFnQVMwQUFDQVVRZW5DZ0lBQWFpMEFBRWNOeXdFZ0ZFRURSZzNPQVNBVVFRRnFJUlFnQVVFQmFpSUJJQUpIRFFBTElBQWdGallDQUF5REF3c0NRQ0FCSWdFZ0FrY05BRUhsQUNFUURJTURDeUFBSUFGQkFXb2lBU0FDRUtpQWdJQUFJaEFOelFFZ0FTRUJRZFlBSVJBTTZRSUxBa0FnQVNJQklBSkdEUUFEUUFKQUlBRXRBQUFpRUVFZ1JnMEFBa0FDUUFKQUlCQkJ1SDlxRGdzQUFjOEJ6d0hQQWM4Qnp3SFBBYzhCendFQ3p3RUxJQUZCQVdvaEFVSFNBQ0VRRE8wQ0N5QUJRUUZxSVFGQjB3QWhFQXpzQWdzZ0FVRUJhaUVCUWRRQUlSQU02d0lMSUFGQkFXb2lBU0FDUncwQUMwSGtBQ0VRRElJREMwSGtBQ0VRRElFREN3TkFBa0FnQVMwQUFFSHd3b0NBQUdvdEFBQWlFRUVCUmcwQUlCQkJmbW9PQTg4QjBBSFJBZElCQ3lBQlFRRnFJZ0VnQWtjTkFBdEI1Z0FoRUF5QUF3c0NRQ0FCSWdFZ0FrWU5BQ0FCUVFGcUlRRU1Bd3RCNXdBaEVBei9BZ3NEUUFKQUlBRXRBQUJCOE1TQWdBQnFMUUFBSWhCQkFVWU5BQUpBSUJCQmZtb09CTklCMHdIVUFRRFZBUXNnQVNFQlFkY0FJUkFNNXdJTElBRkJBV29pQVNBQ1J3MEFDMEhvQUNFUURQNENDd0pBSUFFaUFTQUNSdzBBUWVrQUlSQU0vZ0lMQWtBZ0FTMEFBQ0lRUVhacURocTZBZFVCMVFHOEFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFjb0IxUUhWQVFEVEFRc2dBVUVCYWlFQkMwRUdJUkFNNHdJTEEwQUNRQ0FCTFFBQVFmREdnSUFBYWkwQUFFRUJSZzBBSUFFaEFReWVBZ3NnQVVFQmFpSUJJQUpIRFFBTFFlb0FJUkFNK3dJTEFrQWdBU0lCSUFKR0RRQWdBVUVCYWlFQkRBTUxRZXNBSVJBTStnSUxBa0FnQVNJQklBSkhEUUJCN0FBaEVBejZBZ3NnQVVFQmFpRUJEQUVMQWtBZ0FTSUJJQUpIRFFCQjdRQWhFQXo1QWdzZ0FVRUJhaUVCQzBFRUlSQU0zZ0lMQWtBZ0FTSVVJQUpIRFFCQjdnQWhFQXozQWdzZ0ZDRUJBa0FDUUFKQUlCUXRBQUJCOE1pQWdBQnFMUUFBUVg5cURnZlVBZFVCMWdFQW5BSUJBdGNCQ3lBVVFRRnFJUUVNQ2dzZ0ZFRUJhaUVCRE0wQkMwRUFJUkFnQUVFQU5nSWNJQUJCbTVLQWdBQTJBaEFnQUVFSE5nSU1JQUFnRkVFQmFqWUNGQXoyQWdzQ1FBTkFBa0FnQVMwQUFFSHd5SUNBQUdvdEFBQWlFRUVFUmcwQUFrQUNRQ0FRUVg5cURnZlNBZE1CMUFIWkFRQUVBZGtCQ3lBQklRRkIyZ0FoRUF6Z0Fnc2dBVUVCYWlFQlFkd0FJUkFNM3dJTElBRkJBV29pQVNBQ1J3MEFDMEh2QUNFUURQWUNDeUFCUVFGcUlRRU15d0VMQWtBZ0FTSVVJQUpIRFFCQjhBQWhFQXoxQWdzZ0ZDMEFBRUV2UnczVUFTQVVRUUZxSVFFTUJnc0NRQ0FCSWhRZ0FrY05BRUh4QUNFUURQUUNDd0pBSUJRdEFBQWlBVUV2UncwQUlCUkJBV29oQVVIZEFDRVFETnNDQ3lBQlFYWnFJZ1JCRmtzTjB3RkJBU0FFZEVHSmdJQUNjVVVOMHdFTXlnSUxBa0FnQVNJQklBSkdEUUFnQVVFQmFpRUJRZDRBSVJBTTJnSUxRZklBSVJBTThnSUxBa0FnQVNJVUlBSkhEUUJCOUFBaEVBenlBZ3NnRkNFQkFrQWdGQzBBQUVId3pJQ0FBR290QUFCQmYyb09BOGtDbEFJQTFBRUxRZUVBSVJBTTJBSUxBa0FnQVNJVUlBSkdEUUFEUUFKQUlCUXRBQUJCOE1xQWdBQnFMUUFBSWdGQkEwWU5BQUpBSUFGQmYyb09Bc3NDQU5VQkN5QVVJUUZCM3dBaEVBemFBZ3NnRkVFQmFpSVVJQUpIRFFBTFFmTUFJUkFNOFFJTFFmTUFJUkFNOEFJTEFrQWdBU0lCSUFKR0RRQWdBRUdQZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBU0VCUWVBQUlSQU0xd0lMUWZVQUlSQU03d0lMQWtBZ0FTSUJJQUpIRFFCQjlnQWhFQXp2QWdzZ0FFR1BnSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJDMEVESVJBTTFBSUxBMEFnQVMwQUFFRWdSdzNEQWlBQlFRRnFJZ0VnQWtjTkFBdEI5d0FoRUF6c0Fnc0NRQ0FCSWdFZ0FrY05BRUg0QUNFUURPd0NDeUFCTFFBQVFTQkhEYzRCSUFGQkFXb2hBUXp2QVFzZ0FDQUJJZ0VnQWhDc2dJQ0FBQ0lRRGM0QklBRWhBUXlPQWdzQ1FDQUJJZ1FnQWtjTkFFSDZBQ0VRRE9vQ0N5QUVMUUFBUWN3QVJ3M1JBU0FFUVFGcUlRRkJFeUVRRE04QkN3SkFJQUVpQkNBQ1J3MEFRZnNBSVJBTTZRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQldvaEVBTkFJQVF0QUFBZ0FVSHd6b0NBQUdvdEFBQkhEZEFCSUFGQkJVWU56Z0VnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCK3dBaEVBem9BZ3NDUUNBQklnUWdBa2NOQUVIOEFDRVFET2dDQ3dKQUFrQWdCQzBBQUVHOWYyb09EQURSQWRFQjBRSFJBZEVCMFFIUkFkRUIwUUhSQVFIUkFRc2dCRUVCYWlFQlFlWUFJUkFNendJTElBUkJBV29oQVVIbkFDRVFETTRDQ3dKQUlBRWlCQ0FDUncwQVFmMEFJUkFNNXdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBbW9oRUFKQUEwQWdCQzBBQUNBQlFlM1BnSUFBYWkwQUFFY056d0VnQVVFQ1JnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZjBBSVJBTTV3SUxJQUJCQURZQ0FDQVFRUUZxSVFGQkVDRVFETXdCQ3dKQUlBRWlCQ0FDUncwQVFmNEFJUkFNNWdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJCV29oRUFKQUEwQWdCQzBBQUNBQlFmYk9nSUFBYWkwQUFFY056Z0VnQVVFRlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZjRBSVJBTTVnSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkZpRVFETXNCQ3dKQUlBRWlCQ0FDUncwQVFmOEFJUkFNNVFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBMm9oRUFKQUEwQWdCQzBBQUNBQlFmek9nSUFBYWkwQUFFY056UUVnQVVFRFJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZjhBSVJBTTVRSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkJTRVFETW9CQ3dKQUlBRWlCQ0FDUncwQVFZQUJJUkFNNUFJTElBUXRBQUJCMlFCSERjc0JJQVJCQVdvaEFVRUlJUkFNeVFFTEFrQWdBU0lFSUFKSERRQkJnUUVoRUF6akFnc0NRQUpBSUFRdEFBQkJzbjlxRGdNQXpBRUJ6QUVMSUFSQkFXb2hBVUhyQUNFUURNb0NDeUFFUVFGcUlRRkI3QUFoRUF6SkFnc0NRQ0FCSWdRZ0FrY05BRUdDQVNFUURPSUNDd0pBQWtBZ0JDMEFBRUc0ZjJvT0NBRExBY3NCeXdITEFjc0J5d0VCeXdFTElBUkJBV29oQVVIcUFDRVFETWtDQ3lBRVFRRnFJUUZCN1FBaEVBeklBZ3NDUUNBQklnUWdBa2NOQUVHREFTRVFET0VDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hFQ0FFSUFGclFRSnFJUlFDUUFOQUlBUXRBQUFnQVVHQXo0Q0FBR290QUFCSERja0JJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRURZQ0FFR0RBU0VRRE9FQ0MwRUFJUkFnQUVFQU5nSUFJQlJCQVdvaEFRekdBUXNDUUNBQklnUWdBa2NOQUVHRUFTRVFET0FDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRUnFJUkFDUUFOQUlBUXRBQUFnQVVHRHo0Q0FBR290QUFCSERjZ0JJQUZCQkVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR0VBU0VRRE9BQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVNNaEVBekZBUXNDUUNBQklnUWdBa2NOQUVHRkFTRVFETjhDQ3dKQUFrQWdCQzBBQUVHMGYyb09DQURJQWNnQnlBSElBY2dCeUFFQnlBRUxJQVJCQVdvaEFVSHZBQ0VRRE1ZQ0N5QUVRUUZxSVFGQjhBQWhFQXpGQWdzQ1FDQUJJZ1FnQWtjTkFFR0dBU0VRRE40Q0N5QUVMUUFBUWNVQVJ3M0ZBU0FFUVFGcUlRRU1nd0lMQWtBZ0FTSUVJQUpIRFFCQmh3RWhFQXpkQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRURhaUVRQWtBRFFDQUVMUUFBSUFGQmlNK0FnQUJxTFFBQVJ3M0ZBU0FCUVFOR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJod0VoRUF6ZEFnc2dBRUVBTmdJQUlCQkJBV29oQVVFdElSQU13Z0VMQWtBZ0FTSUVJQUpIRFFCQmlBRWhFQXpjQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUlhaUVRQWtBRFFDQUVMUUFBSUFGQjBNK0FnQUJxTFFBQVJ3M0VBU0FCUVFoR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJpQUVoRUF6Y0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFcElSQU13UUVMQWtBZ0FTSUJJQUpIRFFCQmlRRWhFQXpiQWd0QkFTRVFJQUV0QUFCQjN3QkhEY0FCSUFGQkFXb2hBUXlCQWdzQ1FDQUJJZ1FnQWtjTkFFR0tBU0VRRE5vQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUZxSVJBRFFDQUVMUUFBSUFGQmpNK0FnQUJxTFFBQVJ3M0JBU0FCUVFGR0RhOENJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWW9CSVJBTTJRSUxBa0FnQVNJRUlBSkhEUUJCaXdFaEVBelpBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQ2FpRVFBa0FEUUNBRUxRQUFJQUZCanMrQWdBQnFMUUFBUnczQkFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQml3RWhFQXpaQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVDSVJBTXZnRUxBa0FnQVNJRUlBSkhEUUJCakFFaEVBellBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCOE0rQWdBQnFMUUFBUnczQUFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQmpBRWhFQXpZQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVmSVJBTXZRRUxBa0FnQVNJRUlBSkhEUUJCalFFaEVBelhBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCOHMrQWdBQnFMUUFBUncyL0FTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQmpRRWhFQXpYQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVKSVJBTXZBRUxBa0FnQVNJRUlBSkhEUUJCamdFaEVBeldBZ3NDUUFKQUlBUXRBQUJCdDM5cURnY0F2d0cvQWI4QnZ3Ry9BUUcvQVFzZ0JFRUJhaUVCUWZnQUlSQU12UUlMSUFSQkFXb2hBVUg1QUNFUURMd0NDd0pBSUFFaUJDQUNSdzBBUVk4QklSQU0xUUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQUpBQTBBZ0JDMEFBQ0FCUVpIUGdJQUFhaTBBQUVjTnZRRWdBVUVGUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZOEJJUkFNMVFJTElBQkJBRFlDQUNBUVFRRnFJUUZCR0NFUURMb0JDd0pBSUFFaUJDQUNSdzBBUVpBQklSQU0xQUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUVpmUGdJQUFhaTBBQUVjTnZBRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaQUJJUkFNMUFJTElBQkJBRFlDQUNBUVFRRnFJUUZCRnlFUURMa0JDd0pBSUFFaUJDQUNSdzBBUVpFQklSQU0wd0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJtb2hFQUpBQTBBZ0JDMEFBQ0FCUVpyUGdJQUFhaTBBQUVjTnV3RWdBVUVHUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaRUJJUkFNMHdJTElBQkJBRFlDQUNBUVFRRnFJUUZCRlNFUURMZ0JDd0pBSUFFaUJDQUNSdzBBUVpJQklSQU0wZ0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQUpBQTBBZ0JDMEFBQ0FCUWFIUGdJQUFhaTBBQUVjTnVnRWdBVUVGUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaSUJJUkFNMGdJTElBQkJBRFlDQUNBUVFRRnFJUUZCSGlFUURMY0JDd0pBSUFFaUJDQUNSdzBBUVpNQklSQU0wUUlMSUFRdEFBQkJ6QUJIRGJnQklBUkJBV29oQVVFS0lSQU10Z0VMQWtBZ0JDQUNSdzBBUVpRQklSQU0wQUlMQWtBQ1FDQUVMUUFBUWI5L2FnNFBBTGtCdVFHNUFia0J1UUc1QWJrQnVRRzVBYmtCdVFHNUFia0JBYmtCQ3lBRVFRRnFJUUZCL2dBaEVBeTNBZ3NnQkVFQmFpRUJRZjhBSVJBTXRnSUxBa0FnQkNBQ1J3MEFRWlVCSVJBTXp3SUxBa0FDUUNBRUxRQUFRYjkvYWc0REFMZ0JBYmdCQ3lBRVFRRnFJUUZCL1FBaEVBeTJBZ3NnQkVFQmFpRUVRWUFCSVJBTXRRSUxBa0FnQkNBQ1J3MEFRWllCSVJBTXpnSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRYWZQZ0lBQWFpMEFBRWNOdGdFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVpZQklSQU16Z0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJDeUVRRExNQkN3SkFJQVFnQWtjTkFFR1hBU0VRRE0wQ0N3SkFBa0FDUUFKQUlBUXRBQUJCVTJvT0l3QzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0JBYmdCdUFHNEFiZ0J1QUVDdUFHNEFiZ0JBN2dCQ3lBRVFRRnFJUUZCK3dBaEVBeTJBZ3NnQkVFQmFpRUJRZndBSVJBTXRRSUxJQVJCQVdvaEJFR0JBU0VRRExRQ0N5QUVRUUZxSVFSQmdnRWhFQXl6QWdzQ1FDQUVJQUpIRFFCQm1BRWhFQXpNQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUVhaUVRQWtBRFFDQUVMUUFBSUFGQnFjK0FnQUJxTFFBQVJ3MjBBU0FCUVFSR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJtQUVoRUF6TUFnc2dBRUVBTmdJQUlCQkJBV29oQVVFWklSQU1zUUVMQWtBZ0JDQUNSdzBBUVprQklSQU15d0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQUpBQTBBZ0JDMEFBQ0FCUWE3UGdJQUFhaTBBQUVjTnN3RWdBVUVGUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaa0JJUkFNeXdJTElBQkJBRFlDQUNBUVFRRnFJUUZCQmlFUURMQUJDd0pBSUFRZ0FrY05BRUdhQVNFUURNb0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFGcUlSQUNRQU5BSUFRdEFBQWdBVUcwejRDQUFHb3RBQUJIRGJJQklBRkJBVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHYUFTRVFETW9DQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUndoRUF5dkFRc0NRQ0FFSUFKSERRQkJtd0VoRUF6SkFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVCYWlFUUFrQURRQ0FFTFFBQUlBRkJ0cytBZ0FCcUxRQUFSdzJ4QVNBQlFRRkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCbXdFaEVBekpBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRW5JUkFNcmdFTEFrQWdCQ0FDUncwQVFad0JJUkFNeUFJTEFrQUNRQ0FFTFFBQVFheC9hZzRDQUFHeEFRc2dCRUVCYWlFRVFZWUJJUkFNcndJTElBUkJBV29oQkVHSEFTRVFESzRDQ3dKQUlBUWdBa2NOQUVHZEFTRVFETWNDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRRnFJUkFDUUFOQUlBUXRBQUFnQVVHNHo0Q0FBR290QUFCSERhOEJJQUZCQVVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR2RBU0VRRE1jQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVNZaEVBeXNBUXNDUUNBRUlBSkhEUUJCbmdFaEVBekdBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCdXMrQWdBQnFMUUFBUncydUFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQm5nRWhFQXpHQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVESVJBTXF3RUxBa0FnQkNBQ1J3MEFRWjhCSVJBTXhRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQW1vaEVBSkFBMEFnQkMwQUFDQUJRZTNQZ0lBQWFpMEFBRWNOclFFZ0FVRUNSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVo4QklSQU14UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJEQ0VRREtvQkN3SkFJQVFnQWtjTkFFR2dBU0VRRE1RQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUU5xSVJBQ1FBTkFJQVF0QUFBZ0FVRzh6NENBQUdvdEFBQkhEYXdCSUFGQkEwWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdnQVNFUURNUUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFRMGhFQXlwQVFzQ1FDQUVJQUpIRFFCQm9RRWhFQXpEQWdzQ1FBSkFJQVF0QUFCQnVuOXFEZ3NBckFHc0Fhd0JyQUdzQWF3QnJBR3NBYXdCQWF3QkN5QUVRUUZxSVFSQml3RWhFQXlxQWdzZ0JFRUJhaUVFUVl3QklSQU1xUUlMQWtBZ0JDQUNSdzBBUWFJQklSQU13Z0lMSUFRdEFBQkIwQUJIRGFrQklBUkJBV29oQkF6cEFRc0NRQ0FFSUFKSERRQkJvd0VoRUF6QkFnc0NRQUpBSUFRdEFBQkJ0MzlxRGdjQnFnR3FBYW9CcWdHcUFRQ3FBUXNnQkVFQmFpRUVRWTRCSVJBTXFBSUxJQVJCQVdvaEFVRWlJUkFNcGdFTEFrQWdCQ0FDUncwQVFhUUJJUkFNd0FJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBV29oRUFKQUEwQWdCQzBBQUNBQlFjRFBnSUFBYWkwQUFFY05xQUVnQVVFQlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYVFCSVJBTXdBSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkhTRVFES1VCQ3dKQUlBUWdBa2NOQUVHbEFTRVFETDhDQ3dKQUFrQWdCQzBBQUVHdWYyb09Bd0NvQVFHb0FRc2dCRUVCYWlFRVFaQUJJUkFNcGdJTElBUkJBV29oQVVFRUlSQU1wQUVMQWtBZ0JDQUNSdzBBUWFZQklSQU12Z0lMQWtBQ1FBSkFBa0FDUUNBRUxRQUFRYjkvYWc0VkFLb0JxZ0dxQWFvQnFnR3FBYW9CcWdHcUFhb0JBYW9CcWdFQ3FnR3FBUU9xQWFvQkJLb0JDeUFFUVFGcUlRUkJpQUVoRUF5b0Fnc2dCRUVCYWlFRVFZa0JJUkFNcHdJTElBUkJBV29oQkVHS0FTRVFES1lDQ3lBRVFRRnFJUVJCandFaEVBeWxBZ3NnQkVFQmFpRUVRWkVCSVJBTXBBSUxBa0FnQkNBQ1J3MEFRYWNCSVJBTXZRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQW1vaEVBSkFBMEFnQkMwQUFDQUJRZTNQZ0lBQWFpMEFBRWNOcFFFZ0FVRUNSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWFjQklSQU12UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJFU0VRREtJQkN3SkFJQVFnQWtjTkFFR29BU0VRREx3Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSEN6NENBQUdvdEFBQkhEYVFCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdvQVNFUURMd0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFTd2hFQXloQVFzQ1FDQUVJQUpIRFFCQnFRRWhFQXk3QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUVhaUVRQWtBRFFDQUVMUUFBSUFGQnhjK0FnQUJxTFFBQVJ3MmpBU0FCUVFSR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJxUUVoRUF5N0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFcklSQU1vQUVMQWtBZ0JDQUNSdzBBUWFvQklSQU11Z0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUWNyUGdJQUFhaTBBQUVjTm9nRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFhb0JJUkFNdWdJTElBQkJBRFlDQUNBUVFRRnFJUUZCRkNFUURKOEJDd0pBSUFRZ0FrY05BRUdyQVNFUURMa0NDd0pBQWtBQ1FBSkFJQVF0QUFCQnZuOXFEZzhBQVFLa0FhUUJwQUdrQWFRQnBBR2tBYVFCcEFHa0FhUUJBNlFCQ3lBRVFRRnFJUVJCa3dFaEVBeWlBZ3NnQkVFQmFpRUVRWlFCSVJBTW9RSUxJQVJCQVdvaEJFR1ZBU0VRREtBQ0N5QUVRUUZxSVFSQmxnRWhFQXlmQWdzQ1FDQUVJQUpIRFFCQnJBRWhFQXk0QWdzZ0JDMEFBRUhGQUVjTm53RWdCRUVCYWlFRURPQUJDd0pBSUFRZ0FrY05BRUd0QVNFUURMY0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUhOejRDQUFHb3RBQUJIRFo4QklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHdEFTRVFETGNDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUTRoRUF5Y0FRc0NRQ0FFSUFKSERRQkJyZ0VoRUF5MkFnc2dCQzBBQUVIUUFFY05uUUVnQkVFQmFpRUJRU1VoRUF5YkFRc0NRQ0FFSUFKSERRQkJyd0VoRUF5MUFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVJYWlFUUFrQURRQ0FFTFFBQUlBRkIwTStBZ0FCcUxRQUFSdzJkQVNBQlFRaEdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCcndFaEVBeTFBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRXFJUkFNbWdFTEFrQWdCQ0FDUncwQVFiQUJJUkFNdEFJTEFrQUNRQ0FFTFFBQVFhdC9hZzRMQUowQm5RR2RBWjBCblFHZEFaMEJuUUdkQVFHZEFRc2dCRUVCYWlFRVFab0JJUkFNbXdJTElBUkJBV29oQkVHYkFTRVFESm9DQ3dKQUlBUWdBa2NOQUVHeEFTRVFETE1DQ3dKQUFrQWdCQzBBQUVHL2Yyb09GQUNjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUdjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUVCbkFFTElBUkJBV29oQkVHWkFTRVFESm9DQ3lBRVFRRnFJUVJCbkFFaEVBeVpBZ3NDUUNBRUlBSkhEUUJCc2dFaEVBeXlBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFRGFpRVFBa0FEUUNBRUxRQUFJQUZCMmMrQWdBQnFMUUFBUncyYUFTQUJRUU5HRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQnNnRWhFQXl5QWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVoSVJBTWx3RUxBa0FnQkNBQ1J3MEFRYk1CSVJBTXNRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQm1vaEVBSkFBMEFnQkMwQUFDQUJRZDNQZ0lBQWFpMEFBRWNObVFFZ0FVRUdSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWJNQklSQU1zUUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJHaUVRREpZQkN3SkFJQVFnQWtjTkFFRzBBU0VRRExBQ0N3SkFBa0FDUUNBRUxRQUFRYnQvYWc0UkFKb0JtZ0dhQVpvQm1nR2FBWm9CbWdHYUFRR2FBWm9CbWdHYUFab0JBcG9CQ3lBRVFRRnFJUVJCblFFaEVBeVlBZ3NnQkVFQmFpRUVRWjRCSVJBTWx3SUxJQVJCQVdvaEJFR2ZBU0VRREpZQ0N3SkFJQVFnQWtjTkFFRzFBU0VRREs4Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVZxSVJBQ1FBTkFJQVF0QUFBZ0FVSGt6NENBQUdvdEFBQkhEWmNCSUFGQkJVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUcxQVNFUURLOENDeUFBUVFBMkFnQWdFRUVCYWlFQlFTZ2hFQXlVQVFzQ1FDQUVJQUpIRFFCQnRnRWhFQXl1QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUNhaUVRQWtBRFFDQUVMUUFBSUFGQjZzK0FnQUJxTFFBQVJ3MldBU0FCUVFKR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJ0Z0VoRUF5dUFnc2dBRUVBTmdJQUlCQkJBV29oQVVFSElSQU1rd0VMQWtBZ0JDQUNSdzBBUWJjQklSQU1yUUlMQWtBQ1FDQUVMUUFBUWJ0L2FnNE9BSllCbGdHV0FaWUJsZ0dXQVpZQmxnR1dBWllCbGdHV0FRR1dBUXNnQkVFQmFpRUVRYUVCSVJBTWxBSUxJQVJCQVdvaEJFR2lBU0VRREpNQ0N3SkFJQVFnQWtjTkFFRzRBU0VRREt3Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSHR6NENBQUdvdEFBQkhEWlFCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUc0QVNFUURLd0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFSSWhFQXlSQVFzQ1FDQUVJQUpIRFFCQnVRRWhFQXlyQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUJhaUVRQWtBRFFDQUVMUUFBSUFGQjhNK0FnQUJxTFFBQVJ3MlRBU0FCUVFGR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJ1UUVoRUF5ckFnc2dBRUVBTmdJQUlCQkJBV29oQVVFZ0lSQU1rQUVMQWtBZ0JDQUNSdzBBUWJvQklSQU1xZ0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWZMUGdJQUFhaTBBQUVjTmtnRWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFib0JJUkFNcWdJTElBQkJBRFlDQUNBUVFRRnFJUUZCRHlFUURJOEJDd0pBSUFRZ0FrY05BRUc3QVNFUURLa0NDd0pBQWtBZ0JDMEFBRUczZjJvT0J3Q1NBWklCa2dHU0FaSUJBWklCQ3lBRVFRRnFJUVJCcFFFaEVBeVFBZ3NnQkVFQmFpRUVRYVlCSVJBTWp3SUxBa0FnQkNBQ1J3MEFRYndCSVJBTXFBSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQjJvaEVBSkFBMEFnQkMwQUFDQUJRZlRQZ0lBQWFpMEFBRWNOa0FFZ0FVRUhSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWJ3QklSQU1xQUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJHeUVRREkwQkN3SkFJQVFnQWtjTkFFRzlBU0VRREtjQ0N3SkFBa0FDUUNBRUxRQUFRYjUvYWc0U0FKRUJrUUdSQVpFQmtRR1JBWkVCa1FHUkFRR1JBWkVCa1FHUkFaRUJrUUVDa1FFTElBUkJBV29oQkVHa0FTRVFESThDQ3lBRVFRRnFJUVJCcHdFaEVBeU9BZ3NnQkVFQmFpRUVRYWdCSVJBTWpRSUxBa0FnQkNBQ1J3MEFRYjRCSVJBTXBnSUxJQVF0QUFCQnpnQkhEWTBCSUFSQkFXb2hCQXpQQVFzQ1FDQUVJQUpIRFFCQnZ3RWhFQXlsQWdzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FFTFFBQVFiOS9hZzRWQUFFQ0E1d0JCQVVHbkFHY0Fad0JCd2dKQ2d1Y0FRd05EZytjQVFzZ0JFRUJhaUVCUWVnQUlSQU1tZ0lMSUFSQkFXb2hBVUhwQUNFUURKa0NDeUFFUVFGcUlRRkI3Z0FoRUF5WUFnc2dCRUVCYWlFQlFmSUFJUkFNbHdJTElBUkJBV29oQVVIekFDRVFESllDQ3lBRVFRRnFJUUZCOWdBaEVBeVZBZ3NnQkVFQmFpRUJRZmNBSVJBTWxBSUxJQVJCQVdvaEFVSDZBQ0VRREpNQ0N5QUVRUUZxSVFSQmd3RWhFQXlTQWdzZ0JFRUJhaUVFUVlRQklSQU1rUUlMSUFSQkFXb2hCRUdGQVNFUURKQUNDeUFFUVFGcUlRUkJrZ0VoRUF5UEFnc2dCRUVCYWlFRVFaZ0JJUkFNamdJTElBUkJBV29oQkVHZ0FTRVFESTBDQ3lBRVFRRnFJUVJCb3dFaEVBeU1BZ3NnQkVFQmFpRUVRYW9CSVJBTWl3SUxBa0FnQkNBQ1JnMEFJQUJCa0lDQWdBQTJBZ2dnQUNBRU5nSUVRYXNCSVJBTWl3SUxRY0FCSVJBTW93SUxJQUFnQlNBQ0VLcUFnSUFBSWdFTml3RWdCU0VCREZ3TEFrQWdCaUFDUmcwQUlBWkJBV29oQlF5TkFRdEJ3Z0VoRUF5aEFnc0RRQUpBSUJBdEFBQkJkbW9PQkl3QkFBQ1BBUUFMSUJCQkFXb2lFQ0FDUncwQUMwSERBU0VRREtBQ0N3SkFJQWNnQWtZTkFDQUFRWkdBZ0lBQU5nSUlJQUFnQnpZQ0JDQUhJUUZCQVNFUURJY0NDMEhFQVNFUURKOENDd0pBSUFjZ0FrY05BRUhGQVNFUURKOENDd0pBQWtBZ0J5MEFBRUYyYWc0RUFjNEJ6Z0VBemdFTElBZEJBV29oQmd5TkFRc2dCMEVCYWlFRkRJa0JDd0pBSUFjZ0FrY05BRUhHQVNFUURKNENDd0pBQWtBZ0J5MEFBRUYyYWc0WEFZOEJqd0VCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCQUk4QkN5QUhRUUZxSVFjTFFiQUJJUkFNaEFJTEFrQWdDQ0FDUncwQVFjZ0JJUkFNblFJTElBZ3RBQUJCSUVjTmpRRWdBRUVBT3dFeUlBaEJBV29oQVVHekFTRVFESU1DQ3lBQklSY0NRQU5BSUJjaUJ5QUNSZzBCSUFjdEFBQkJVR3BCL3dGeEloQkJDazhOekFFQ1FDQUFMd0V5SWhSQm1UTkxEUUFnQUNBVVFRcHNJaFE3QVRJZ0VFSC8vd056SUJSQi92OERjVWtOQUNBSFFRRnFJUmNnQUNBVUlCQnFJaEE3QVRJZ0VFSC8vd054UWVnSFNRMEJDd3RCQUNFUUlBQkJBRFlDSENBQVFjR0pnSUFBTmdJUUlBQkJEVFlDRENBQUlBZEJBV28yQWhRTW5BSUxRY2NCSVJBTW13SUxJQUFnQ0NBQ0VLNkFnSUFBSWhCRkRjb0JJQkJCRlVjTmpBRWdBRUhJQVRZQ0hDQUFJQWcyQWhRZ0FFSEpsNENBQURZQ0VDQUFRUlUyQWd4QkFDRVFESm9DQ3dKQUlBa2dBa2NOQUVITUFTRVFESm9DQzBFQUlSUkJBU0VYUVFFaEZrRUFJUkFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQ1MwQUFFRlFhZzRLbGdHVkFRQUJBZ01FQlFZSWx3RUxRUUloRUF3R0MwRURJUkFNQlF0QkJDRVFEQVFMUVFVaEVBd0RDMEVHSVJBTUFndEJCeUVRREFFTFFRZ2hFQXRCQUNFWFFRQWhGa0VBSVJRTWpnRUxRUWtoRUVFQklSUkJBQ0VYUVFBaEZneU5BUXNDUUNBS0lBSkhEUUJCemdFaEVBeVpBZ3NnQ2kwQUFFRXVSdzJPQVNBS1FRRnFJUWtNeWdFTElBc2dBa2NOamdGQjBBRWhFQXlYQWdzQ1FDQUxJQUpHRFFBZ0FFR09nSUNBQURZQ0NDQUFJQXMyQWdSQnR3RWhFQXorQVF0QjBRRWhFQXlXQWdzQ1FDQUVJQUpIRFFCQjBnRWhFQXlXQWdzZ0FpQUVheUFBS0FJQUloQnFJUlFnQkNBUWEwRUVhaUVMQTBBZ0JDMEFBQ0FRUWZ6UGdJQUFhaTBBQUVjTmpnRWdFRUVFUmczcEFTQVFRUUZxSVJBZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSFNBU0VRREpVQ0N5QUFJQXdnQWhDc2dJQ0FBQ0lCRFkwQklBd2hBUXk0QVFzQ1FDQUVJQUpIRFFCQjFBRWhFQXlVQWdzZ0FpQUVheUFBS0FJQUloQnFJUlFnQkNBUWEwRUJhaUVNQTBBZ0JDMEFBQ0FRUVlIUWdJQUFhaTBBQUVjTmp3RWdFRUVCUmcyT0FTQVFRUUZxSVJBZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSFVBU0VRREpNQ0N3SkFJQVFnQWtjTkFFSFdBU0VRREpNQ0N5QUNJQVJySUFBb0FnQWlFR29oRkNBRUlCQnJRUUpxSVFzRFFDQUVMUUFBSUJCQmc5Q0FnQUJxTFFBQVJ3Mk9BU0FRUVFKR0RaQUJJQkJCQVdvaEVDQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZFlCSVJBTWtnSUxBa0FnQkNBQ1J3MEFRZGNCSVJBTWtnSUxBa0FDUUNBRUxRQUFRYnQvYWc0UUFJOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3RUJqd0VMSUFSQkFXb2hCRUc3QVNFUURQa0JDeUFFUVFGcUlRUkJ2QUVoRUF6NEFRc0NRQ0FFSUFKSERRQkIyQUVoRUF5UkFnc2dCQzBBQUVISUFFY05qQUVnQkVFQmFpRUVETVFCQ3dKQUlBUWdBa1lOQUNBQVFaQ0FnSUFBTmdJSUlBQWdCRFlDQkVHK0FTRVFEUGNCQzBIWkFTRVFESThDQ3dKQUlBUWdBa2NOQUVIYUFTRVFESThDQ3lBRUxRQUFRY2dBUmczREFTQUFRUUU2QUNnTXVRRUxJQUJCQWpvQUx5QUFJQVFnQWhDbWdJQ0FBQ0lRRFkwQlFjSUJJUkFNOUFFTElBQXRBQ2hCZjJvT0FyY0J1UUc0QVFzRFFBSkFJQVF0QUFCQmRtb09CQUNPQVk0QkFJNEJDeUFFUVFGcUlnUWdBa2NOQUF0QjNRRWhFQXlMQWdzZ0FFRUFPZ0F2SUFBdEFDMUJCSEZGRFlRQ0N5QUFRUUE2QUM4Z0FFRUJPZ0EwSUFFaEFReU1BUXNnRUVFVlJnM2FBU0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJwNDZBZ0FBMkFoQWdBRUVTTmdJTVFRQWhFQXlJQWdzQ1FDQUFJQkFnQWhDMGdJQ0FBQ0lFRFFBZ0VDRUJESUVDQ3dKQUlBUkJGVWNOQUNBQVFRTTJBaHdnQUNBUU5nSVVJQUJCc0ppQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF5SUFnc2dBRUVBTmdJY0lBQWdFRFlDRkNBQVFhZU9nSUFBTmdJUUlBQkJFallDREVFQUlSQU1od0lMSUJCQkZVWU4xZ0VnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZHFOZ0lBQU5nSVFJQUJCRkRZQ0RFRUFJUkFNaGdJTElBQW9BZ1FoRnlBQVFRQTJBZ1FnRUNBUnAyb2lGaUVCSUFBZ0Z5QVFJQllnRkJzaUVCQzFnSUNBQUNJVVJRMk5BU0FBUVFjMkFod2dBQ0FRTmdJVUlBQWdGRFlDREVFQUlSQU1oUUlMSUFBZ0FDOEJNRUdBQVhJN0FUQWdBU0VCQzBFcUlSQU02Z0VMSUJCQkZVWU4wUUVnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWU9NZ0lBQU5nSVFJQUJCRXpZQ0RFRUFJUkFNZ2dJTElCQkJGVVlOendFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVpxUGdJQUFOZ0lRSUFCQklqWUNERUVBSVJBTWdRSUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDM2dJQ0FBQ0lRRFFBZ0FVRUJhaUVCREkwQkN5QUFRUXcyQWh3Z0FDQVFOZ0lNSUFBZ0FVRUJhallDRkVFQUlSQU1nQUlMSUJCQkZVWU56QUVnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWnFQZ0lBQU5nSVFJQUJCSWpZQ0RFRUFJUkFNL3dFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkMzZ0lDQUFDSVFEUUFnQVVFQmFpRUJESXdCQ3lBQVFRMDJBaHdnQUNBUU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTS9nRUxJQkJCRlVZTnlRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFjYU1nSUFBTmdJUUlBQkJJellDREVFQUlSQU0vUUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzVnSUNBQUNJUURRQWdBVUVCYWlFQkRJc0JDeUFBUVE0MkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNL0FFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVIQWxZQ0FBRFlDRUNBQVFRSTJBZ3hCQUNFUURQc0JDeUFRUVJWR0RjVUJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEdqSUNBQURZQ0VDQUFRU00yQWd4QkFDRVFEUG9CQ3lBQVFSQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNK1FFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkM1Z0lDQUFDSUVEUUFnQVVFQmFpRUJEUEVCQ3lBQVFSRTJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTStBRUxJQkJCRlVZTndRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFjYU1nSUFBTmdJUUlBQkJJellDREVFQUlSQU05d0VMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzVnSUNBQUNJUURRQWdBVUVCYWlFQkRJZ0JDeUFBUVJNMkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNOWdFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkM1Z0lDQUFDSUVEUUFnQVVFQmFpRUJETzBCQ3lBQVFSUTJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTTlRRUxJQkJCRlVZTnZRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFacVBnSUFBTmdJUUlBQkJJallDREVFQUlSQU05QUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzNnSUNBQUNJUURRQWdBVUVCYWlFQkRJWUJDeUFBUVJZMkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNOHdFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkMzZ0lDQUFDSUVEUUFnQVVFQmFpRUJET2tCQ3lBQVFSYzJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTThnRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSE5rNENBQURZQ0VDQUFRUXcyQWd4QkFDRVFEUEVCQzBJQklSRUxJQkJCQVdvaEFRSkFJQUFwQXlBaUVrTC8vLy8vLy8vLy93OVdEUUFnQUNBU1FnU0dJQkdFTndNZ0lBRWhBUXlFQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWEySmdJQUFOZ0lRSUFCQkREWUNERUVBSVJBTTd3RUxJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFSE5rNENBQURZQ0VDQUFRUXcyQWd4QkFDRVFETzRCQ3lBQUtBSUVJUmNnQUVFQU5nSUVJQkFnRWFkcUloWWhBU0FBSUJjZ0VDQVdJQlFiSWhBUXRZQ0FnQUFpRkVVTmN5QUFRUVUyQWh3Z0FDQVFOZ0lVSUFBZ0ZEWUNERUVBSVJBTTdRRUxJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFR3FuSUNBQURZQ0VDQUFRUTgyQWd4QkFDRVFET3dCQ3lBQUlCQWdBaEMwZ0lDQUFDSUJEUUVnRUNFQkMwRU9JUkFNMFFFTEFrQWdBVUVWUncwQUlBQkJBallDSENBQUlCQTJBaFFnQUVHd21JQ0FBRFlDRUNBQVFSVTJBZ3hCQUNFUURPb0JDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkJwNDZBZ0FBMkFoQWdBRUVTTmdJTVFRQWhFQXpwQVFzZ0FVRUJhaUVRQWtBZ0FDOEJNQ0lCUVlBQmNVVU5BQUpBSUFBZ0VDQUNFTHVBZ0lBQUlnRU5BQ0FRSVFFTWNBc2dBVUVWUncyNkFTQUFRUVUyQWh3Z0FDQVFOZ0lVSUFCQitaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBenBBUXNDUUNBQlFhQUVjVUdnQkVjTkFDQUFMUUF0UVFKeERRQWdBRUVBTmdJY0lBQWdFRFlDRkNBQVFaYVRnSUFBTmdJUUlBQkJCRFlDREVFQUlSQU02UUVMSUFBZ0VDQUNFTDJBZ0lBQUdpQVFJUUVDUUFKQUFrQUNRQUpBSUFBZ0VDQUNFTE9BZ0lBQURoWUNBUUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFEQkFzZ0FFRUJPZ0F1Q3lBQUlBQXZBVEJCd0FCeU93RXdJQkFoQVF0QkppRVFETkVCQ3lBQVFTTTJBaHdnQUNBUU5nSVVJQUJCcFphQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF6cEFRc2dBRUVBTmdJY0lBQWdFRFlDRkNBQVFkV0xnSUFBTmdJUUlBQkJFVFlDREVFQUlSQU02QUVMSUFBdEFDMUJBWEZGRFFGQnd3RWhFQXpPQVFzQ1FDQU5JQUpHRFFBRFFBSkFJQTB0QUFCQklFWU5BQ0FOSVFFTXhBRUxJQTFCQVdvaURTQUNSdzBBQzBFbElSQU01d0VMUVNVaEVBem1BUXNnQUNnQ0JDRUVJQUJCQURZQ0JDQUFJQVFnRFJDdmdJQ0FBQ0lFUlEydEFTQUFRU1kyQWh3Z0FDQUVOZ0lNSUFBZ0RVRUJhallDRkVFQUlSQU01UUVMSUJCQkZVWU5xd0VnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZjJOZ0lBQU5nSVFJQUJCSFRZQ0RFRUFJUkFNNUFFTElBQkJKellDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF6akFRc2dFQ0VCUVFFaEZBSkFBa0FDUUFKQUFrQUNRQUpBSUFBdEFDeEJmbW9PQndZRkJRTUJBZ0FGQ3lBQUlBQXZBVEJCQ0hJN0FUQU1Bd3RCQWlFVURBRUxRUVFoRkFzZ0FFRUJPZ0FzSUFBZ0FDOEJNQ0FVY2pzQk1Bc2dFQ0VCQzBFcklSQU15Z0VMSUFCQkFEWUNIQ0FBSUJBMkFoUWdBRUdya29DQUFEWUNFQ0FBUVFzMkFneEJBQ0VRRE9JQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjRZK0FnQUEyQWhBZ0FFRUtOZ0lNUVFBaEVBemhBUXNnQUVFQU9nQXNJQkFoQVF5OUFRc2dFQ0VCUVFFaEZBSkFBa0FDUUFKQUFrQWdBQzBBTEVGN2FnNEVBd0VDQUFVTElBQWdBQzhCTUVFSWNqc0JNQXdEQzBFQ0lSUU1BUXRCQkNFVUN5QUFRUUU2QUN3Z0FDQUFMd0V3SUJSeU93RXdDeUFRSVFFTFFTa2hFQXpGQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZDVWdJQUFOZ0lRSUFCQkF6WUNERUVBSVJBTTNRRUxBa0FnRGkwQUFFRU5SdzBBSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0RoQ3hnSUNBQUNJQkRRQWdEa0VCYWlFQkRIVUxJQUJCTERZQ0hDQUFJQUUyQWd3Z0FDQU9RUUZxTmdJVVFRQWhFQXpkQVFzZ0FDMEFMVUVCY1VVTkFVSEVBU0VRRE1NQkN3SkFJQTRnQWtjTkFFRXRJUkFNM0FFTEFrQUNRQU5BQWtBZ0RpMEFBRUYyYWc0RUFnQUFBd0FMSUE1QkFXb2lEaUFDUncwQUMwRXRJUkFNM1FFTElBQW9BZ1FoQVNBQVFRQTJBZ1FDUUNBQUlBRWdEaEN4Z0lDQUFDSUJEUUFnRGlFQkRIUUxJQUJCTERZQ0hDQUFJQTQyQWhRZ0FDQUJOZ0lNUVFBaEVBemNBUXNnQUNnQ0JDRUJJQUJCQURZQ0JBSkFJQUFnQVNBT0VMR0FnSUFBSWdFTkFDQU9RUUZxSVFFTWN3c2dBRUVzTmdJY0lBQWdBVFlDRENBQUlBNUJBV28yQWhSQkFDRVFETnNCQ3lBQUtBSUVJUVFnQUVFQU5nSUVJQUFnQkNBT0VMR0FnSUFBSWdRTm9BRWdEaUVCRE00QkN5QVFRU3hIRFFFZ0FVRUJhaUVRUVFFaEFRSkFBa0FDUUFKQUFrQWdBQzBBTEVGN2FnNEVBd0VDQkFBTElCQWhBUXdFQzBFQ0lRRU1BUXRCQkNFQkN5QUFRUUU2QUN3Z0FDQUFMd0V3SUFGeU93RXdJQkFoQVF3QkN5QUFJQUF2QVRCQkNISTdBVEFnRUNFQkMwRTVJUkFNdndFTElBQkJBRG9BTENBQklRRUxRVFFoRUF5OUFRc2dBQ0FBTHdFd1FTQnlPd0V3SUFFaEFRd0NDeUFBS0FJRUlRUWdBRUVBTmdJRUFrQWdBQ0FFSUFFUXNZQ0FnQUFpQkEwQUlBRWhBUXpIQVFzZ0FFRTNOZ0ljSUFBZ0FUWUNGQ0FBSUFRMkFneEJBQ0VRRE5RQkN5QUFRUWc2QUN3Z0FTRUJDMEV3SVJBTXVRRUxBa0FnQUMwQUtFRUJSZzBBSUFFaEFRd0VDeUFBTFFBdFFRaHhSUTJUQVNBQklRRU1Bd3NnQUMwQU1FRWdjUTJVQVVIRkFTRVFETGNCQ3dKQUlBOGdBa1lOQUFKQUEwQUNRQ0FQTFFBQVFWQnFJZ0ZCL3dGeFFRcEpEUUFnRHlFQlFUVWhFQXk2QVFzZ0FDa0RJQ0lSUXBtejVzeVpzK2JNR1ZZTkFTQUFJQkZDQ240aUVUY0RJQ0FSSUFHdFF2OEJneUlTUW4rRlZnMEJJQUFnRVNBU2ZEY0RJQ0FQUVFGcUlnOGdBa2NOQUF0Qk9TRVFETkVCQ3lBQUtBSUVJUUlnQUVFQU5nSUVJQUFnQWlBUFFRRnFJZ1FRc1lDQWdBQWlBZzJWQVNBRUlRRU13d0VMUVRraEVBelBBUXNDUUNBQUx3RXdJZ0ZCQ0hGRkRRQWdBQzBBS0VFQlJ3MEFJQUF0QUMxQkNIRkZEWkFCQ3lBQUlBRkI5L3NEY1VHQUJISTdBVEFnRHlFQkMwRTNJUkFNdEFFTElBQWdBQzhCTUVFUWNqc0JNQXlyQVFzZ0VFRVZSZzJMQVNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCOEk2QWdBQTJBaEFnQUVFY05nSU1RUUFoRUF6TEFRc2dBRUhEQURZQ0hDQUFJQUUyQWd3Z0FDQU5RUUZxTmdJVVFRQWhFQXpLQVFzQ1FDQUJMUUFBUVRwSERRQWdBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUsrQWdJQUFJaEFOQUNBQlFRRnFJUUVNWXdzZ0FFSERBRFlDSENBQUlCQTJBZ3dnQUNBQlFRRnFOZ0lVUVFBaEVBektBUXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYkdSZ0lBQU5nSVFJQUJCQ2pZQ0RFRUFJUkFNeVFFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVHZ21ZQ0FBRFlDRUNBQVFSNDJBZ3hCQUNFUURNZ0JDeUFBUVFBMkFnQUxJQUJCZ0JJN0FTb2dBQ0FYUVFGcUlnRWdBaENvZ0lDQUFDSVFEUUVnQVNFQkMwSEhBQ0VRREt3QkN5QVFRUlZIRFlNQklBQkIwUUEyQWh3Z0FDQUJOZ0lVSUFCQjQ1ZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBekVBUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNWGdzZ0FFSFNBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF6REFRc2dBRUVBTmdJY0lBQWdGRFlDRkNBQVFjR29nSUFBTmdJUUlBQkJCellDRENBQVFRQTJBZ0JCQUNFUURNSUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhkQ3lBQVFkTUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRE1FQkMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWUNSZ0lBQU5nSVFJQUJCQ1RZQ0RBekFBUXNnRUVFVlJnMTlJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR1VqWUNBQURZQ0VDQUFRU0UyQWd4QkFDRVFETDhCQzBFQklSWkJBQ0VYUVFBaEZFRUJJUkFMSUFBZ0VEb0FLeUFCUVFGcUlRRUNRQUpBSUFBdEFDMUJFSEVOQUFKQUFrQUNRQ0FBTFFBcURnTUJBQUlFQ3lBV1JRMEREQUlMSUJRTkFRd0NDeUFYUlEwQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcllDQWdBQWlFQTBBSUFFaEFReGNDeUFBUWRnQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFETDRCQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVFyWUNBZ0FBaUJBMEFJQUVoQVF5dEFRc2dBRUhaQURZQ0hDQUFJQUUyQWhRZ0FDQUVOZ0lNUVFBaEVBeTlBUXNnQUNnQ0JDRUVJQUJCQURZQ0JBSkFJQUFnQkNBQkVLMkFnSUFBSWdRTkFDQUJJUUVNcXdFTElBQkIyZ0EyQWh3Z0FDQUJOZ0lVSUFBZ0JEWUNERUVBSVJBTXZBRUxJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDdGdJQ0FBQ0lFRFFBZ0FTRUJES2tCQ3lBQVFkd0FOZ0ljSUFBZ0FUWUNGQ0FBSUFRMkFneEJBQ0VRRExzQkN3SkFJQUV0QUFCQlVHb2lFRUgvQVhGQkNrOE5BQ0FBSUJBNkFDb2dBVUVCYWlFQlFjOEFJUkFNb2dFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkN0Z0lDQUFDSUVEUUFnQVNFQkRLY0JDeUFBUWQ0QU5nSWNJQUFnQVRZQ0ZDQUFJQVEyQWd4QkFDRVFETG9CQ3lBQVFRQTJBZ0FnRjBFQmFpRUJBa0FnQUMwQUtVRWpUdzBBSUFFaEFReFpDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkIwNG1BZ0FBMkFoQWdBRUVJTmdJTVFRQWhFQXk1QVFzZ0FFRUFOZ0lBQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFaQ3pnSUFBTmdJUUlBQkJDRFlDREF5M0FRc2dBRUVBTmdJQUlCZEJBV29oQVFKQUlBQXRBQ2xCSVVjTkFDQUJJUUVNVmdzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVp1S2dJQUFOZ0lRSUFCQkNEWUNERUVBSVJBTXRnRUxJQUJCQURZQ0FDQVhRUUZxSVFFQ1FDQUFMUUFwSWhCQlhXcEJDMDhOQUNBQklRRU1WUXNDUUNBUVFRWkxEUUJCQVNBUWRFSEtBSEZGRFFBZ0FTRUJERlVMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjk0bUFnQUEyQWhBZ0FFRUlOZ0lNRExVQkN5QVFRUlZHRFhFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWJtTmdJQUFOZ0lRSUFCQkdqWUNERUVBSVJBTXRBRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERlFMSUFCQjVRQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNc3dFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkNuZ0lDQUFDSVFEUUFnQVNFQkRFMExJQUJCMGdBMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU1zZ0VMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREUwTElBQkIwd0EyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXNRRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERkVMSUFCQjVRQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNc0FFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVIR2lvQ0FBRFlDRUNBQVFRYzJBZ3hCQUNFUURLOEJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhKQ3lBQVFkSUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRREs0QkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcDRDQWdBQWlFQTBBSUFFaEFReEpDeUFBUWRNQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFESzBCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVFwNENBZ0FBaUVBMEFJQUVoQVF4TkN5QUFRZVVBTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURLd0JDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkIzSWlBZ0FBMkFoQWdBRUVITmdJTVFRQWhFQXlyQVFzZ0VFRS9SdzBCSUFGQkFXb2hBUXRCQlNFUURKQUJDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWYyU2dJQUFOZ0lRSUFCQkJ6WUNEQXlvQVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFS2VBZ0lBQUloQU5BQ0FCSVFFTVFnc2dBRUhTQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeW5BUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNUWdzZ0FFSFRBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF5bUFRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUtlQWdJQUFJaEFOQUNBQklRRU1SZ3NnQUVIbEFEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXlsQVFzZ0FDZ0NCQ0VCSUFCQkFEWUNCQUpBSUFBZ0FTQVVFS2VBZ0lBQUlnRU5BQ0FVSVFFTVB3c2dBRUhTQURZQ0hDQUFJQlEyQWhRZ0FDQUJOZ0lNUVFBaEVBeWtBUXNnQUNnQ0JDRUJJQUJCQURZQ0JBSkFJQUFnQVNBVUVLZUFnSUFBSWdFTkFDQVVJUUVNUHdzZ0FFSFRBRFlDSENBQUlCUTJBaFFnQUNBQk5nSU1RUUFoRUF5akFRc2dBQ2dDQkNFQklBQkJBRFlDQkFKQUlBQWdBU0FVRUtlQWdJQUFJZ0VOQUNBVUlRRU1Rd3NnQUVIbEFEWUNIQ0FBSUJRMkFoUWdBQ0FCTmdJTVFRQWhFQXlpQVFzZ0FFRUFOZ0ljSUFBZ0ZEWUNGQ0FBUWNPUGdJQUFOZ0lRSUFCQkJ6WUNERUVBSVJBTW9RRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSERqNENBQURZQ0VDQUFRUWMyQWd4QkFDRVFES0FCQzBFQUlSQWdBRUVBTmdJY0lBQWdGRFlDRkNBQVFZeWNnSUFBTmdJUUlBQkJCellDREF5ZkFRc2dBRUVBTmdJY0lBQWdGRFlDRkNBQVFZeWNnSUFBTmdJUUlBQkJCellDREVFQUlSQU1uZ0VMSUFCQkFEWUNIQ0FBSUJRMkFoUWdBRUgra1lDQUFEWUNFQ0FBUVFjMkFneEJBQ0VRREowQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmpwdUFnQUEyQWhBZ0FFRUdOZ0lNUVFBaEVBeWNBUXNnRUVFVlJnMVhJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSE1qb0NBQURZQ0VDQUFRU0EyQWd4QkFDRVFESnNCQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRU1FoRUFzZ0FDQVFPZ0FwSUFBb0FnUWhFQ0FBUVFBMkFnUWdBQ0FRSUFFUXE0Q0FnQUFpRUExVUlBRWhBUXcrQ3lBQVFRQTJBZ0FMUVFBaEVDQUFRUUEyQWh3Z0FDQUVOZ0lVSUFCQjhadUFnQUEyQWhBZ0FFRUdOZ0lNREpjQkN5QUJRUlZHRFZBZ0FFRUFOZ0ljSUFBZ0JUWUNGQ0FBUWZDTWdJQUFOZ0lRSUFCQkd6WUNERUVBSVJBTWxnRUxJQUFvQWdRaEJTQUFRUUEyQWdRZ0FDQUZJQkFRcVlDQWdBQWlCUTBCSUJCQkFXb2hCUXRCclFFaEVBeDdDeUFBUWNFQk5nSWNJQUFnQlRZQ0RDQUFJQkJCQVdvMkFoUkJBQ0VRREpNQkN5QUFLQUlFSVFZZ0FFRUFOZ0lFSUFBZ0JpQVFFS21BZ0lBQUlnWU5BU0FRUVFGcUlRWUxRYTRCSVJBTWVBc2dBRUhDQVRZQ0hDQUFJQVkyQWd3Z0FDQVFRUUZxTmdJVVFRQWhFQXlRQVFzZ0FFRUFOZ0ljSUFBZ0J6WUNGQ0FBUVplTGdJQUFOZ0lRSUFCQkRUWUNERUVBSVJBTWp3RUxJQUJCQURZQ0hDQUFJQWcyQWhRZ0FFSGprSUNBQURZQ0VDQUFRUWsyQWd4QkFDRVFESTRCQ3lBQVFRQTJBaHdnQUNBSU5nSVVJQUJCbEkyQWdBQTJBaEFnQUVFaE5nSU1RUUFoRUF5TkFRdEJBU0VXUVFBaEYwRUFJUlJCQVNFUUN5QUFJQkE2QUNzZ0NVRUJhaUVJQWtBQ1FDQUFMUUF0UVJCeERRQUNRQUpBQWtBZ0FDMEFLZzREQVFBQ0JBc2dGa1VOQXd3Q0N5QVVEUUVNQWdzZ0YwVU5BUXNnQUNnQ0JDRVFJQUJCQURZQ0JDQUFJQkFnQ0JDdGdJQ0FBQ0lRUlEwOUlBQkJ5UUUyQWh3Z0FDQUlOZ0lVSUFBZ0VEWUNERUVBSVJBTWpBRUxJQUFvQWdRaEJDQUFRUUEyQWdRZ0FDQUVJQWdRcllDQWdBQWlCRVVOZGlBQVFjb0JOZ0ljSUFBZ0NEWUNGQ0FBSUFRMkFneEJBQ0VRRElzQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFSUFBZ0JDQUpFSzJBZ0lBQUlnUkZEWFFnQUVITEFUWUNIQ0FBSUFrMkFoUWdBQ0FFTmdJTVFRQWhFQXlLQVFzZ0FDZ0NCQ0VFSUFCQkFEWUNCQ0FBSUFRZ0NoQ3RnSUNBQUNJRVJRMXlJQUJCelFFMkFod2dBQ0FLTmdJVUlBQWdCRFlDREVFQUlSQU1pUUVMQWtBZ0N5MEFBRUZRYWlJUVFmOEJjVUVLVHcwQUlBQWdFRG9BS2lBTFFRRnFJUXBCdGdFaEVBeHdDeUFBS0FJRUlRUWdBRUVBTmdJRUlBQWdCQ0FMRUsyQWdJQUFJZ1JGRFhBZ0FFSFBBVFlDSENBQUlBczJBaFFnQUNBRU5nSU1RUUFoRUF5SUFRc2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFaQ3pnSUFBTmdJUUlBQkJDRFlDRENBQVFRQTJBZ0JCQUNFUURJY0JDeUFCUVJWR0RUOGdBRUVBTmdJY0lBQWdERFlDRkNBQVFjeU9nSUFBTmdJUUlBQkJJRFlDREVFQUlSQU1oZ0VMSUFCQmdRUTdBU2dnQUNnQ0JDRVFJQUJDQURjREFDQUFJQkFnREVFQmFpSU1FS3VBZ0lBQUloQkZEVGdnQUVIVEFUWUNIQ0FBSUF3MkFoUWdBQ0FRTmdJTVFRQWhFQXlGQVFzZ0FFRUFOZ0lBQzBFQUlSQWdBRUVBTmdJY0lBQWdCRFlDRkNBQVFkaWJnSUFBTmdJUUlBQkJDRFlDREF5REFRc2dBQ2dDQkNFUUlBQkNBRGNEQUNBQUlCQWdDMEVCYWlJTEVLdUFnSUFBSWhBTkFVSEdBU0VRREdrTElBQkJBam9BS0F4VkN5QUFRZFVCTmdJY0lBQWdDellDRkNBQUlCQTJBZ3hCQUNFUURJQUJDeUFRUVJWR0RUY2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFhU01nSUFBTmdJUUlBQkJFRFlDREVFQUlSQU1md3NnQUMwQU5FRUJSdzAwSUFBZ0JDQUNFTHlBZ0lBQUloQkZEVFFnRUVFVlJ3MDFJQUJCM0FFMkFod2dBQ0FFTmdJVUlBQkIxWmFBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXgrQzBFQUlSQWdBRUVBTmdJY0lBQkJyNHVBZ0FBMkFoQWdBRUVDTmdJTUlBQWdGRUVCYWpZQ0ZBeDlDMEVBSVJBTVl3dEJBaUVRREdJTFFRMGhFQXhoQzBFUElSQU1ZQXRCSlNFUURGOExRUk1oRUF4ZUMwRVZJUkFNWFF0QkZpRVFERndMUVJjaEVBeGJDMEVZSVJBTVdndEJHU0VRREZrTFFSb2hFQXhZQzBFYklSQU1Wd3RCSENFUURGWUxRUjBoRUF4VkMwRWZJUkFNVkF0QklTRVFERk1MUVNNaEVBeFNDMEhHQUNFUURGRUxRUzRoRUF4UUMwRXZJUkFNVHd0Qk95RVFERTRMUVQwaEVBeE5DMEhJQUNFUURFd0xRY2tBSVJBTVN3dEJ5d0FoRUF4S0MwSE1BQ0VRREVrTFFjNEFJUkFNU0F0QjBRQWhFQXhIQzBIVkFDRVFERVlMUWRnQUlSQU1SUXRCMlFBaEVBeEVDMEhiQUNFUURFTUxRZVFBSVJBTVFndEI1UUFoRUF4QkMwSHhBQ0VRREVBTFFmUUFJUkFNUHd0QmpRRWhFQXcrQzBHWEFTRVFERDBMUWFrQklSQU1QQXRCckFFaEVBdzdDMEhBQVNFUUREb0xRYmtCSVJBTU9RdEJyd0VoRUF3NEMwR3hBU0VRRERjTFFiSUJJUkFNTmd0QnRBRWhFQXcxQzBHMUFTRVFERFFMUWJvQklSQU1Nd3RCdlFFaEVBd3lDMEcvQVNFUURERUxRY0VCSVJBTU1Bc2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFlbUxnSUFBTmdJUUlBQkJIellDREVFQUlSQU1TQXNnQUVIYkFUWUNIQ0FBSUFRMkFoUWdBRUg2bG9DQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREVjTElBQkIrQUEyQWh3Z0FDQU1OZ0lVSUFCQnlwaUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeEdDeUFBUWRFQU5nSWNJQUFnQlRZQ0ZDQUFRYkNYZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNUlFzZ0FFSDVBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF4RUN5QUFRZmdBTmdJY0lBQWdBVFlDRkNBQVFjcVlnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1Rd3NnQUVIa0FEWUNIQ0FBSUFFMkFoUWdBRUhqbDRDQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREVJTElBQkIxd0EyQWh3Z0FDQUJOZ0lVSUFCQnlaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeEJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ1WTJBZ0FBMkFoQWdBRUVhTmdJTVFRQWhFQXhBQ3lBQVFjSUFOZ0ljSUFBZ0FUWUNGQ0FBUWVPWWdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTVB3c2dBRUVBTmdJRUlBQWdEeUFQRUxHQWdJQUFJZ1JGRFFFZ0FFRTZOZ0ljSUFBZ0JEWUNEQ0FBSUE5QkFXbzJBaFJCQUNFUURENExJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDeGdJQ0FBQ0lFUlEwQUlBQkJPellDSENBQUlBUTJBZ3dnQUNBQlFRRnFOZ0lVUVFBaEVBdytDeUFCUVFGcUlRRU1MUXNnRDBFQmFpRUJEQzBMSUFCQkFEWUNIQ0FBSUE4MkFoUWdBRUhra29DQUFEWUNFQ0FBUVFRMkFneEJBQ0VRRERzTElBQkJOallDSENBQUlBUTJBaFFnQUNBQ05nSU1RUUFoRUF3NkN5QUFRUzQyQWh3Z0FDQU9OZ0lVSUFBZ0JEWUNERUVBSVJBTU9Rc2dBRUhRQURZQ0hDQUFJQUUyQWhRZ0FFR1JtSUNBQURZQ0VDQUFRUlUyQWd4QkFDRVFERGdMSUExQkFXb2hBUXdzQ3lBQVFSVTJBaHdnQUNBQk5nSVVJQUJCZ3BtQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3MkN5QUFRUnMyQWh3Z0FDQUJOZ0lVSUFCQmtaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBdzFDeUFBUVE4MkFod2dBQ0FCTmdJVUlBQkJrWmVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXcwQ3lBQVFRczJBaHdnQUNBQk5nSVVJQUJCa1plQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3ekN5QUFRUm8yQWh3Z0FDQUJOZ0lVSUFCQmdwbUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBd3lDeUFBUVFzMkFod2dBQ0FCTmdJVUlBQkJncG1BZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXd4Q3lBQVFRbzJBaHdnQUNBQk5nSVVJQUJCNUphQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3d0N5QUFRUjQyQWh3Z0FDQUJOZ0lVSUFCQitaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBd3ZDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkIybzJBZ0FBMkFoQWdBRUVVTmdJTVFRQWhFQXd1Q3lBQVFRUTJBaHdnQUNBQk5nSVVJQUJCc0ppQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3dEN5QUFRUUEyQWdBZ0MwRUJhaUVMQzBHNEFTRVFEQklMSUFCQkFEWUNBQ0FRUVFGcUlRRkI5UUFoRUF3UkN5QUJJUUVDUUNBQUxRQXBRUVZIRFFCQjR3QWhFQXdSQzBIaUFDRVFEQkFMUVFBaEVDQUFRUUEyQWh3Z0FFSGtrWUNBQURZQ0VDQUFRUWMyQWd3Z0FDQVVRUUZxTmdJVURDZ0xJQUJCQURZQ0FDQVhRUUZxSVFGQndBQWhFQXdPQzBFQklRRUxJQUFnQVRvQUxDQUFRUUEyQWdBZ0YwRUJhaUVCQzBFb0lSQU1Dd3NnQVNFQkMwRTRJUkFNQ1FzQ1FDQUJJZzhnQWtZTkFBTkFBa0FnRHkwQUFFR0F2b0NBQUdvdEFBQWlBVUVCUmcwQUlBRkJBa2NOQXlBUFFRRnFJUUVNQkFzZ0QwRUJhaUlQSUFKSERRQUxRVDRoRUF3aUMwRStJUkFNSVFzZ0FFRUFPZ0FzSUE4aEFRd0JDMEVMSVJBTUJndEJPaUVRREFVTElBRkJBV29oQVVFdElSQU1CQXNnQUNBQk9nQXNJQUJCQURZQ0FDQVdRUUZxSVFGQkRDRVFEQU1MSUFCQkFEWUNBQ0FYUVFGcUlRRkJDaUVRREFJTElBQkJBRFlDQUFzZ0FFRUFPZ0FzSUEwaEFVRUpJUkFNQUFzTFFRQWhFQ0FBUVFBMkFod2dBQ0FMTmdJVUlBQkJ6WkNBZ0FBMkFoQWdBRUVKTmdJTURCY0xRUUFoRUNBQVFRQTJBaHdnQUNBS05nSVVJQUJCNllxQWdBQTJBaEFnQUVFSk5nSU1EQllMUVFBaEVDQUFRUUEyQWh3Z0FDQUpOZ0lVSUFCQnQ1Q0FnQUEyQWhBZ0FFRUpOZ0lNREJVTFFRQWhFQ0FBUVFBMkFod2dBQ0FJTmdJVUlBQkJuSkdBZ0FBMkFoQWdBRUVKTmdJTURCUUxRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCelpDQWdBQTJBaEFnQUVFSk5nSU1EQk1MUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjZZcUFnQUEyQWhBZ0FFRUpOZ0lNREJJTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJ0NUNBZ0FBMkFoQWdBRUVKTmdJTURCRUxRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCbkpHQWdBQTJBaEFnQUVFSk5nSU1EQkFMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmw1V0FnQUEyQWhBZ0FFRVBOZ0lNREE4TFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJsNVdBZ0FBMkFoQWdBRUVQTmdJTURBNExRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCd0pLQWdBQTJBaEFnQUVFTE5nSU1EQTBMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmxZbUFnQUEyQWhBZ0FFRUxOZ0lNREF3TFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkI0WStBZ0FBMkFoQWdBRUVLTmdJTURBc0xRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCKzQrQWdBQTJBaEFnQUVFS05nSU1EQW9MUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjhabUFnQUEyQWhBZ0FFRUNOZ0lNREFrTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJ4SlNBZ0FBMkFoQWdBRUVDTmdJTURBZ0xRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCOHBXQWdBQTJBaEFnQUVFQ05nSU1EQWNMSUFCQkFqWUNIQ0FBSUFFMkFoUWdBRUdjbW9DQUFEWUNFQ0FBUVJZMkFneEJBQ0VRREFZTFFRRWhFQXdGQzBIVUFDRVFJQUVpQkNBQ1JnMEVJQU5CQ0dvZ0FDQUVJQUpCMk1LQWdBQkJDaERGZ0lDQUFDQURLQUlNSVFRZ0F5Z0NDQTREQVFRQ0FBc1F5b0NBZ0FBQUN5QUFRUUEyQWh3Z0FFRzFtb0NBQURZQ0VDQUFRUmMyQWd3Z0FDQUVRUUZxTmdJVVFRQWhFQXdDQ3lBQVFRQTJBaHdnQUNBRU5nSVVJQUJCeXBxQWdBQTJBaEFnQUVFSk5nSU1RUUFoRUF3QkN3SkFJQUVpQkNBQ1J3MEFRU0loRUF3QkN5QUFRWW1BZ0lBQU5nSUlJQUFnQkRZQ0JFRWhJUkFMSUFOQkVHb2tnSUNBZ0FBZ0VBdXZBUUVDZnlBQktBSUFJUVlDUUFKQUlBSWdBMFlOQUNBRUlBWnFJUVFnQmlBRGFpQUNheUVISUFJZ0JrRi9jeUFGYWlJR2FpRUZBMEFDUUNBQ0xRQUFJQVF0QUFCR0RRQkJBaUVFREFNTEFrQWdCZzBBUVFBaEJDQUZJUUlNQXdzZ0JrRi9haUVHSUFSQkFXb2hCQ0FDUVFGcUlnSWdBMGNOQUFzZ0J5RUdJQU1oQWdzZ0FFRUJOZ0lBSUFFZ0JqWUNBQ0FBSUFJMkFnUVBDeUFCUVFBMkFnQWdBQ0FFTmdJQUlBQWdBallDQkFzS0FDQUFFTWVBZ0lBQUMvSTJBUXQvSTRDQWdJQUFRUkJySWdFa2dJQ0FnQUFDUUVFQUtBS2cwSUNBQUEwQVFRQVF5NENBZ0FCQmdOU0VnQUJySWdKQjJRQkpEUUJCQUNFREFrQkJBQ2dDNE5PQWdBQWlCQTBBUVFCQ2Z6Y0M3Tk9BZ0FCQkFFS0FnSVNBZ0lEQUFEY0M1Tk9BZ0FCQkFDQUJRUWhxUVhCeFFkaXExYW9GY3lJRU5nTGcwNENBQUVFQVFRQTJBdlRUZ0lBQVFRQkJBRFlDeE5PQWdBQUxRUUFnQWpZQ3pOT0FnQUJCQUVHQTFJU0FBRFlDeU5PQWdBQkJBRUdBMUlTQUFEWUNtTkNBZ0FCQkFDQUVOZ0tzMElDQUFFRUFRWDgyQXFqUWdJQUFBMEFnQTBIRTBJQ0FBR29nQTBHNDBJQ0FBR29pQkRZQ0FDQUVJQU5Cc05DQWdBQnFJZ1UyQWdBZ0EwRzgwSUNBQUdvZ0JUWUNBQ0FEUWN6UWdJQUFhaUFEUWNEUWdJQUFhaUlGTmdJQUlBVWdCRFlDQUNBRFFkVFFnSUFBYWlBRFFjalFnSUFBYWlJRU5nSUFJQVFnQlRZQ0FDQURRZERRZ0lBQWFpQUVOZ0lBSUFOQklHb2lBMEdBQWtjTkFBdEJnTlNFZ0FCQmVFR0ExSVNBQUd0QkQzRkJBRUdBMUlTQUFFRUlha0VQY1JzaUEyb2lCRUVFYWlBQ1FVaHFJZ1VnQTJzaUEwRUJjallDQUVFQVFRQW9BdkRUZ0lBQU5nS2swSUNBQUVFQUlBTTJBcFRRZ0lBQVFRQWdCRFlDb05DQWdBQkJnTlNFZ0FBZ0JXcEJPRFlDQkFzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQUVIc0FVc05BQUpBUVFBb0FvalFnSUFBSWdaQkVDQUFRUk5xUVhCeElBQkJDMGtiSWdKQkEzWWlCSFlpQTBFRGNVVU5BQUpBQWtBZ0EwRUJjU0FFY2tFQmN5SUZRUU4wSWdSQnNOQ0FnQUJxSWdNZ0JFRzQwSUNBQUdvb0FnQWlCQ2dDQ0NJQ1J3MEFRUUFnQmtGK0lBVjNjVFlDaU5DQWdBQU1BUXNnQXlBQ05nSUlJQUlnQXpZQ0RBc2dCRUVJYWlFRElBUWdCVUVEZENJRlFRTnlOZ0lFSUFRZ0JXb2lCQ0FFS0FJRVFRRnlOZ0lFREF3TElBSkJBQ2dDa05DQWdBQWlCMDBOQVFKQUlBTkZEUUFDUUFKQUlBTWdCSFJCQWlBRWRDSURRUUFnQTJ0eWNTSURRUUFnQTJ0eFFYOXFJZ01nQTBFTWRrRVFjU0lEZGlJRVFRVjJRUWh4SWdVZ0EzSWdCQ0FGZGlJRFFRSjJRUVJ4SWdSeUlBTWdCSFlpQTBFQmRrRUNjU0lFY2lBRElBUjJJZ05CQVhaQkFYRWlCSElnQXlBRWRtb2lCRUVEZENJRFFiRFFnSUFBYWlJRklBTkJ1TkNBZ0FCcUtBSUFJZ01vQWdnaUFFY05BRUVBSUFaQmZpQUVkM0VpQmpZQ2lOQ0FnQUFNQVFzZ0JTQUFOZ0lJSUFBZ0JUWUNEQXNnQXlBQ1FRTnlOZ0lFSUFNZ0JFRURkQ0lFYWlBRUlBSnJJZ1UyQWdBZ0F5QUNhaUlBSUFWQkFYSTJBZ1FDUUNBSFJRMEFJQWRCZUhGQnNOQ0FnQUJxSVFKQkFDZ0NuTkNBZ0FBaEJBSkFBa0FnQmtFQklBZEJBM1owSWdoeERRQkJBQ0FHSUFoeU5nS0kwSUNBQUNBQ0lRZ01BUXNnQWlnQ0NDRUlDeUFJSUFRMkFnd2dBaUFFTmdJSUlBUWdBallDRENBRUlBZzJBZ2dMSUFOQkNHb2hBMEVBSUFBMkFwelFnSUFBUVFBZ0JUWUNrTkNBZ0FBTURBdEJBQ2dDak5DQWdBQWlDVVVOQVNBSlFRQWdDV3R4UVg5cUlnTWdBMEVNZGtFUWNTSURkaUlFUVFWMlFRaHhJZ1VnQTNJZ0JDQUZkaUlEUVFKMlFRUnhJZ1J5SUFNZ0JIWWlBMEVCZGtFQ2NTSUVjaUFESUFSMklnTkJBWFpCQVhFaUJISWdBeUFFZG1wQkFuUkJ1TktBZ0FCcUtBSUFJZ0FvQWdSQmVIRWdBbXNoQkNBQUlRVUNRQU5BQWtBZ0JTZ0NFQ0lERFFBZ0JVRVVhaWdDQUNJRFJRMENDeUFES0FJRVFYaHhJQUpySWdVZ0JDQUZJQVJKSWdVYklRUWdBeUFBSUFVYklRQWdBeUVGREFBTEN5QUFLQUlZSVFvQ1FDQUFLQUlNSWdnZ0FFWU5BQ0FBS0FJSUlnTkJBQ2dDbU5DQWdBQkpHaUFJSUFNMkFnZ2dBeUFJTmdJTURBc0xBa0FnQUVFVWFpSUZLQUlBSWdNTkFDQUFLQUlRSWdORkRRTWdBRUVRYWlFRkN3TkFJQVVoQ3lBRElnaEJGR29pQlNnQ0FDSUREUUFnQ0VFUWFpRUZJQWdvQWhBaUF3MEFDeUFMUVFBMkFnQU1DZ3RCZnlFQ0lBQkJ2MzlMRFFBZ0FFRVRhaUlEUVhCeElRSkJBQ2dDak5DQWdBQWlCMFVOQUVFQUlRc0NRQ0FDUVlBQ1NRMEFRUjhoQ3lBQ1FmLy8vd2RMRFFBZ0EwRUlkaUlESUFOQmdQNC9ha0VRZGtFSWNTSURkQ0lFSUFSQmdPQWZha0VRZGtFRWNTSUVkQ0lGSUFWQmdJQVBha0VRZGtFQ2NTSUZkRUVQZGlBRElBUnlJQVZ5YXlJRFFRRjBJQUlnQTBFVmFuWkJBWEZ5UVJ4cUlRc0xRUUFnQW1zaEJBSkFBa0FDUUFKQUlBdEJBblJCdU5LQWdBQnFLQUlBSWdVTkFFRUFJUU5CQUNFSURBRUxRUUFoQXlBQ1FRQkJHU0FMUVFGMmF5QUxRUjlHRzNRaEFFRUFJUWdEUUFKQUlBVW9BZ1JCZUhFZ0Ftc2lCaUFFVHcwQUlBWWhCQ0FGSVFnZ0JnMEFRUUFoQkNBRklRZ2dCU0VEREFNTElBTWdCVUVVYWlnQ0FDSUdJQVlnQlNBQVFSMTJRUVJ4YWtFUWFpZ0NBQ0lGUmhzZ0F5QUdHeUVESUFCQkFYUWhBQ0FGRFFBTEN3SkFJQU1nQ0hJTkFFRUFJUWhCQWlBTGRDSURRUUFnQTJ0eUlBZHhJZ05GRFFNZ0EwRUFJQU5yY1VGL2FpSURJQU5CREhaQkVIRWlBM1lpQlVFRmRrRUljU0lBSUFOeUlBVWdBSFlpQTBFQ2RrRUVjU0lGY2lBRElBVjJJZ05CQVhaQkFuRWlCWElnQXlBRmRpSURRUUYyUVFGeElnVnlJQU1nQlhacVFRSjBRYmpTZ0lBQWFpZ0NBQ0VEQ3lBRFJRMEJDd05BSUFNb0FnUkJlSEVnQW1zaUJpQUVTU0VBQWtBZ0F5Z0NFQ0lGRFFBZ0EwRVVhaWdDQUNFRkN5QUdJQVFnQUJzaEJDQURJQWdnQUJzaENDQUZJUU1nQlEwQUN3c2dDRVVOQUNBRVFRQW9BcERRZ0lBQUlBSnJUdzBBSUFnb0FoZ2hDd0pBSUFnb0Fnd2lBQ0FJUmcwQUlBZ29BZ2dpQTBFQUtBS1kwSUNBQUVrYUlBQWdBellDQ0NBRElBQTJBZ3dNQ1FzQ1FDQUlRUlJxSWdVb0FnQWlBdzBBSUFnb0FoQWlBMFVOQXlBSVFSQnFJUVVMQTBBZ0JTRUdJQU1pQUVFVWFpSUZLQUlBSWdNTkFDQUFRUkJxSVFVZ0FDZ0NFQ0lERFFBTElBWkJBRFlDQUF3SUN3SkFRUUFvQXBEUWdJQUFJZ01nQWtrTkFFRUFLQUtjMElDQUFDRUVBa0FDUUNBRElBSnJJZ1ZCRUVrTkFDQUVJQUpxSWdBZ0JVRUJjallDQkVFQUlBVTJBcERRZ0lBQVFRQWdBRFlDbk5DQWdBQWdCQ0FEYWlBRk5nSUFJQVFnQWtFRGNqWUNCQXdCQ3lBRUlBTkJBM0kyQWdRZ0JDQURhaUlESUFNb0FnUkJBWEkyQWdSQkFFRUFOZ0tjMElDQUFFRUFRUUEyQXBEUWdJQUFDeUFFUVFocUlRTU1DZ3NDUUVFQUtBS1UwSUNBQUNJQUlBSk5EUUJCQUNnQ29OQ0FnQUFpQXlBQ2FpSUVJQUFnQW1zaUJVRUJjallDQkVFQUlBVTJBcFRRZ0lBQVFRQWdCRFlDb05DQWdBQWdBeUFDUVFOeU5nSUVJQU5CQ0dvaEF3d0tDd0pBQWtCQkFDZ0M0Tk9BZ0FCRkRRQkJBQ2dDNk5PQWdBQWhCQXdCQzBFQVFuODNBdXpUZ0lBQVFRQkNnSUNFZ0lDQXdBQTNBdVRUZ0lBQVFRQWdBVUVNYWtGd2NVSFlxdFdxQlhNMkF1RFRnSUFBUVFCQkFEWUM5Tk9BZ0FCQkFFRUFOZ0xFMDRDQUFFR0FnQVFoQkF0QkFDRURBa0FnQkNBQ1FjY0FhaUlIYWlJR1FRQWdCR3NpQzNFaUNDQUNTdzBBUVFCQk1EWUMrTk9BZ0FBTUNnc0NRRUVBS0FMQTA0Q0FBQ0lEUlEwQUFrQkJBQ2dDdU5PQWdBQWlCQ0FJYWlJRklBUk5EUUFnQlNBRFRRMEJDMEVBSVFOQkFFRXdOZ0w0MDRDQUFBd0tDMEVBTFFERTA0Q0FBRUVFY1EwRUFrQUNRQUpBUVFBb0FxRFFnSUFBSWdSRkRRQkJ5Tk9BZ0FBaEF3TkFBa0FnQXlnQ0FDSUZJQVJMRFFBZ0JTQURLQUlFYWlBRVN3MERDeUFES0FJSUlnTU5BQXNMUVFBUXk0Q0FnQUFpQUVGL1JnMEZJQWdoQmdKQVFRQW9BdVRUZ0lBQUlnTkJmMm9pQkNBQWNVVU5BQ0FJSUFCcklBUWdBR3BCQUNBRGEzRnFJUVlMSUFZZ0FrME5CU0FHUWY3Ly8vOEhTdzBGQWtCQkFDZ0N3Tk9BZ0FBaUEwVU5BRUVBS0FLNDA0Q0FBQ0lFSUFacUlnVWdCRTBOQmlBRklBTkxEUVlMSUFZUXk0Q0FnQUFpQXlBQVJ3MEJEQWNMSUFZZ0FHc2dDM0VpQmtIKy8vLy9CMHNOQkNBR0VNdUFnSUFBSWdBZ0F5Z0NBQ0FES0FJRWFrWU5BeUFBSVFNTEFrQWdBMEYvUmcwQUlBSkJ5QUJxSUFaTkRRQUNRQ0FISUFaclFRQW9BdWpUZ0lBQUlnUnFRUUFnQkd0eElnUkIvdi8vL3dkTkRRQWdBeUVBREFjTEFrQWdCQkRMZ0lDQUFFRi9SZzBBSUFRZ0Jtb2hCaUFESVFBTUJ3dEJBQ0FHYXhETGdJQ0FBQm9NQkFzZ0F5RUFJQU5CZjBjTkJRd0RDMEVBSVFnTUJ3dEJBQ0VBREFVTElBQkJmMGNOQWd0QkFFRUFLQUxFMDRDQUFFRUVjallDeE5PQWdBQUxJQWhCL3YvLy93ZExEUUVnQ0JETGdJQ0FBQ0VBUVFBUXk0Q0FnQUFoQXlBQVFYOUdEUUVnQTBGL1JnMEJJQUFnQTA4TkFTQURJQUJySWdZZ0FrRTRhazBOQVF0QkFFRUFLQUs0MDRDQUFDQUdhaUlETmdLNDA0Q0FBQUpBSUFOQkFDZ0N2Tk9BZ0FCTkRRQkJBQ0FETmdLODA0Q0FBQXNDUUFKQUFrQUNRRUVBS0FLZzBJQ0FBQ0lFUlEwQVFjalRnSUFBSVFNRFFDQUFJQU1vQWdBaUJTQURLQUlFSWdocVJnMENJQU1vQWdnaUF3MEFEQU1MQ3dKQUFrQkJBQ2dDbU5DQWdBQWlBMFVOQUNBQUlBTlBEUUVMUVFBZ0FEWUNtTkNBZ0FBTFFRQWhBMEVBSUFZMkFzelRnSUFBUVFBZ0FEWUN5Tk9BZ0FCQkFFRi9OZ0tvMElDQUFFRUFRUUFvQXVEVGdJQUFOZ0tzMElDQUFFRUFRUUEyQXRUVGdJQUFBMEFnQTBIRTBJQ0FBR29nQTBHNDBJQ0FBR29pQkRZQ0FDQUVJQU5Cc05DQWdBQnFJZ1UyQWdBZ0EwRzgwSUNBQUdvZ0JUWUNBQ0FEUWN6UWdJQUFhaUFEUWNEUWdJQUFhaUlGTmdJQUlBVWdCRFlDQUNBRFFkVFFnSUFBYWlBRFFjalFnSUFBYWlJRU5nSUFJQVFnQlRZQ0FDQURRZERRZ0lBQWFpQUVOZ0lBSUFOQklHb2lBMEdBQWtjTkFBc2dBRUY0SUFCclFROXhRUUFnQUVFSWFrRVBjUnNpQTJvaUJDQUdRVWhxSWdVZ0Eyc2lBMEVCY2pZQ0JFRUFRUUFvQXZEVGdJQUFOZ0trMElDQUFFRUFJQU0yQXBUUWdJQUFRUUFnQkRZQ29OQ0FnQUFnQUNBRmFrRTROZ0lFREFJTElBTXRBQXhCQ0hFTkFDQUVJQVZKRFFBZ0JDQUFUdzBBSUFSQmVDQUVhMEVQY1VFQUlBUkJDR3BCRDNFYklnVnFJZ0JCQUNnQ2xOQ0FnQUFnQm1vaUN5QUZheUlGUVFGeU5nSUVJQU1nQ0NBR2FqWUNCRUVBUVFBb0F2RFRnSUFBTmdLazBJQ0FBRUVBSUFVMkFwVFFnSUFBUVFBZ0FEWUNvTkNBZ0FBZ0JDQUxha0U0TmdJRURBRUxBa0FnQUVFQUtBS1kwSUNBQUNJSVR3MEFRUUFnQURZQ21OQ0FnQUFnQUNFSUN5QUFJQVpxSVFWQnlOT0FnQUFoQXdKQUFrQUNRQUpBQWtBQ1FBSkFBMEFnQXlnQ0FDQUZSZzBCSUFNb0FnZ2lBdzBBREFJTEN5QURMUUFNUVFoeFJRMEJDMEhJMDRDQUFDRURBMEFDUUNBREtBSUFJZ1VnQkVzTkFDQUZJQU1vQWdScUlnVWdCRXNOQXdzZ0F5Z0NDQ0VEREFBTEN5QURJQUEyQWdBZ0F5QURLQUlFSUFacU5nSUVJQUJCZUNBQWEwRVBjVUVBSUFCQkNHcEJEM0ViYWlJTElBSkJBM0kyQWdRZ0JVRjRJQVZyUVE5eFFRQWdCVUVJYWtFUGNSdHFJZ1lnQ3lBQ2FpSUNheUVEQWtBZ0JpQUVSdzBBUVFBZ0FqWUNvTkNBZ0FCQkFFRUFLQUtVMElDQUFDQURhaUlETmdLVTBJQ0FBQ0FDSUFOQkFYSTJBZ1FNQXdzQ1FDQUdRUUFvQXB6UWdJQUFSdzBBUVFBZ0FqWUNuTkNBZ0FCQkFFRUFLQUtRMElDQUFDQURhaUlETmdLUTBJQ0FBQ0FDSUFOQkFYSTJBZ1FnQWlBRGFpQUROZ0lBREFNTEFrQWdCaWdDQkNJRVFRTnhRUUZIRFFBZ0JFRjRjU0VIQWtBQ1FDQUVRZjhCU3cwQUlBWW9BZ2dpQlNBRVFRTjJJZ2hCQTNSQnNOQ0FnQUJxSWdCR0dnSkFJQVlvQWd3aUJDQUZSdzBBUVFCQkFDZ0NpTkNBZ0FCQmZpQUlkM0UyQW9qUWdJQUFEQUlMSUFRZ0FFWWFJQVFnQlRZQ0NDQUZJQVEyQWd3TUFRc2dCaWdDR0NFSkFrQUNRQ0FHS0FJTUlnQWdCa1lOQUNBR0tBSUlJZ1FnQ0VrYUlBQWdCRFlDQ0NBRUlBQTJBZ3dNQVFzQ1FDQUdRUlJxSWdRb0FnQWlCUTBBSUFaQkVHb2lCQ2dDQUNJRkRRQkJBQ0VBREFFTEEwQWdCQ0VJSUFVaUFFRVVhaUlFS0FJQUlnVU5BQ0FBUVJCcUlRUWdBQ2dDRUNJRkRRQUxJQWhCQURZQ0FBc2dDVVVOQUFKQUFrQWdCaUFHS0FJY0lnVkJBblJCdU5LQWdBQnFJZ1FvQWdCSERRQWdCQ0FBTmdJQUlBQU5BVUVBUVFBb0FvelFnSUFBUVg0Z0JYZHhOZ0tNMElDQUFBd0NDeUFKUVJCQkZDQUpLQUlRSUFaR0cyb2dBRFlDQUNBQVJRMEJDeUFBSUFrMkFoZ0NRQ0FHS0FJUUlnUkZEUUFnQUNBRU5nSVFJQVFnQURZQ0dBc2dCaWdDRkNJRVJRMEFJQUJCRkdvZ0JEWUNBQ0FFSUFBMkFoZ0xJQWNnQTJvaEF5QUdJQWRxSWdZb0FnUWhCQXNnQmlBRVFYNXhOZ0lFSUFJZ0Eyb2dBellDQUNBQ0lBTkJBWEkyQWdRQ1FDQURRZjhCU3cwQUlBTkJlSEZCc05DQWdBQnFJUVFDUUFKQVFRQW9Bb2pRZ0lBQUlnVkJBU0FEUVFOMmRDSURjUTBBUVFBZ0JTQURjallDaU5DQWdBQWdCQ0VEREFFTElBUW9BZ2doQXdzZ0F5QUNOZ0lNSUFRZ0FqWUNDQ0FDSUFRMkFnd2dBaUFETmdJSURBTUxRUjhoQkFKQUlBTkIvLy8vQjBzTkFDQURRUWgySWdRZ0JFR0EvajlxUVJCMlFRaHhJZ1IwSWdVZ0JVR0E0QjlxUVJCMlFRUnhJZ1YwSWdBZ0FFR0FnQTlxUVJCMlFRSnhJZ0IwUVE5MklBUWdCWElnQUhKcklnUkJBWFFnQXlBRVFSVnFka0VCY1hKQkhHb2hCQXNnQWlBRU5nSWNJQUpDQURjQ0VDQUVRUUowUWJqU2dJQUFhaUVGQWtCQkFDZ0NqTkNBZ0FBaUFFRUJJQVIwSWdoeERRQWdCU0FDTmdJQVFRQWdBQ0FJY2pZQ2pOQ0FnQUFnQWlBRk5nSVlJQUlnQWpZQ0NDQUNJQUkyQWd3TUF3c2dBMEVBUVJrZ0JFRUJkbXNnQkVFZlJodDBJUVFnQlNnQ0FDRUFBMEFnQUNJRktBSUVRWGh4SUFOR0RRSWdCRUVkZGlFQUlBUkJBWFFoQkNBRklBQkJCSEZxUVJCcUlnZ29BZ0FpQUEwQUN5QUlJQUkyQWdBZ0FpQUZOZ0lZSUFJZ0FqWUNEQ0FDSUFJMkFnZ01BZ3NnQUVGNElBQnJRUTl4UVFBZ0FFRUlha0VQY1JzaUEyb2lDeUFHUVVocUlnZ2dBMnNpQTBFQmNqWUNCQ0FBSUFocVFUZzJBZ1FnQkNBRlFUY2dCV3RCRDNGQkFDQUZRVWxxUVE5eEcycEJRV29pQ0NBSUlBUkJFR3BKR3lJSVFTTTJBZ1JCQUVFQUtBTHcwNENBQURZQ3BOQ0FnQUJCQUNBRE5nS1UwSUNBQUVFQUlBczJBcURRZ0lBQUlBaEJFR3BCQUNrQzBOT0FnQUEzQWdBZ0NFRUFLUUxJMDRDQUFEY0NDRUVBSUFoQkNHbzJBdERUZ0lBQVFRQWdCallDek5PQWdBQkJBQ0FBTmdMSTA0Q0FBRUVBUVFBMkF0VFRnSUFBSUFoQkpHb2hBd05BSUFOQkJ6WUNBQ0FEUVFScUlnTWdCVWtOQUFzZ0NDQUVSZzBESUFnZ0NDZ0NCRUYrY1RZQ0JDQUlJQWdnQkdzaUFEWUNBQ0FFSUFCQkFYSTJBZ1FDUUNBQVFmOEJTdzBBSUFCQmVIRkJzTkNBZ0FCcUlRTUNRQUpBUVFBb0FvalFnSUFBSWdWQkFTQUFRUU4yZENJQWNRMEFRUUFnQlNBQWNqWUNpTkNBZ0FBZ0F5RUZEQUVMSUFNb0FnZ2hCUXNnQlNBRU5nSU1JQU1nQkRZQ0NDQUVJQU0yQWd3Z0JDQUZOZ0lJREFRTFFSOGhBd0pBSUFCQi8vLy9CMHNOQUNBQVFRaDJJZ01nQTBHQS9qOXFRUkIyUVFoeElnTjBJZ1VnQlVHQTRCOXFRUkIyUVFSeElnVjBJZ2dnQ0VHQWdBOXFRUkIyUVFKeElnaDBRUTkySUFNZ0JYSWdDSEpySWdOQkFYUWdBQ0FEUVJWcWRrRUJjWEpCSEdvaEF3c2dCQ0FETmdJY0lBUkNBRGNDRUNBRFFRSjBRYmpTZ0lBQWFpRUZBa0JCQUNnQ2pOQ0FnQUFpQ0VFQklBTjBJZ1p4RFFBZ0JTQUVOZ0lBUVFBZ0NDQUdjallDak5DQWdBQWdCQ0FGTmdJWUlBUWdCRFlDQ0NBRUlBUTJBZ3dNQkFzZ0FFRUFRUmtnQTBFQmRtc2dBMEVmUmh0MElRTWdCU2dDQUNFSUEwQWdDQ0lGS0FJRVFYaHhJQUJHRFFNZ0EwRWRkaUVJSUFOQkFYUWhBeUFGSUFoQkJIRnFRUkJxSWdZb0FnQWlDQTBBQ3lBR0lBUTJBZ0FnQkNBRk5nSVlJQVFnQkRZQ0RDQUVJQVEyQWdnTUF3c2dCU2dDQ0NJRElBSTJBZ3dnQlNBQ05nSUlJQUpCQURZQ0dDQUNJQVUyQWd3Z0FpQUROZ0lJQ3lBTFFRaHFJUU1NQlFzZ0JTZ0NDQ0lESUFRMkFnd2dCU0FFTmdJSUlBUkJBRFlDR0NBRUlBVTJBZ3dnQkNBRE5nSUlDMEVBS0FLVTBJQ0FBQ0lESUFKTkRRQkJBQ2dDb05DQWdBQWlCQ0FDYWlJRklBTWdBbXNpQTBFQmNqWUNCRUVBSUFNMkFwVFFnSUFBUVFBZ0JUWUNvTkNBZ0FBZ0JDQUNRUU55TmdJRUlBUkJDR29oQXd3REMwRUFJUU5CQUVFd05nTDQwNENBQUF3Q0N3SkFJQXRGRFFBQ1FBSkFJQWdnQ0NnQ0hDSUZRUUowUWJqU2dJQUFhaUlES0FJQVJ3MEFJQU1nQURZQ0FDQUFEUUZCQUNBSFFYNGdCWGR4SWdjMkFvelFnSUFBREFJTElBdEJFRUVVSUFzb0FoQWdDRVliYWlBQU5nSUFJQUJGRFFFTElBQWdDellDR0FKQUlBZ29BaEFpQTBVTkFDQUFJQU0yQWhBZ0F5QUFOZ0lZQ3lBSVFSUnFLQUlBSWdORkRRQWdBRUVVYWlBRE5nSUFJQU1nQURZQ0dBc0NRQUpBSUFSQkQwc05BQ0FJSUFRZ0Ftb2lBMEVEY2pZQ0JDQUlJQU5xSWdNZ0F5Z0NCRUVCY2pZQ0JBd0JDeUFJSUFKcUlnQWdCRUVCY2pZQ0JDQUlJQUpCQTNJMkFnUWdBQ0FFYWlBRU5nSUFBa0FnQkVIL0FVc05BQ0FFUVhoeFFiRFFnSUFBYWlFREFrQUNRRUVBS0FLSTBJQ0FBQ0lGUVFFZ0JFRURkblFpQkhFTkFFRUFJQVVnQkhJMkFvalFnSUFBSUFNaEJBd0JDeUFES0FJSUlRUUxJQVFnQURZQ0RDQURJQUEyQWdnZ0FDQUROZ0lNSUFBZ0JEWUNDQXdCQzBFZklRTUNRQ0FFUWYvLy93ZExEUUFnQkVFSWRpSURJQU5CZ1A0L2FrRVFka0VJY1NJRGRDSUZJQVZCZ09BZmFrRVFka0VFY1NJRmRDSUNJQUpCZ0lBUGFrRVFka0VDY1NJQ2RFRVBkaUFESUFWeUlBSnlheUlEUVFGMElBUWdBMEVWYW5aQkFYRnlRUnhxSVFNTElBQWdBellDSENBQVFnQTNBaEFnQTBFQ2RFRzQwb0NBQUdvaEJRSkFJQWRCQVNBRGRDSUNjUTBBSUFVZ0FEWUNBRUVBSUFjZ0FuSTJBb3pRZ0lBQUlBQWdCVFlDR0NBQUlBQTJBZ2dnQUNBQU5nSU1EQUVMSUFSQkFFRVpJQU5CQVhacklBTkJIMFliZENFRElBVW9BZ0FoQWdKQUEwQWdBaUlGS0FJRVFYaHhJQVJHRFFFZ0EwRWRkaUVDSUFOQkFYUWhBeUFGSUFKQkJIRnFRUkJxSWdZb0FnQWlBZzBBQ3lBR0lBQTJBZ0FnQUNBRk5nSVlJQUFnQURZQ0RDQUFJQUEyQWdnTUFRc2dCU2dDQ0NJRElBQTJBZ3dnQlNBQU5nSUlJQUJCQURZQ0dDQUFJQVUyQWd3Z0FDQUROZ0lJQ3lBSVFRaHFJUU1NQVFzQ1FDQUtSUTBBQWtBQ1FDQUFJQUFvQWh3aUJVRUNkRUc0MG9DQUFHb2lBeWdDQUVjTkFDQURJQWcyQWdBZ0NBMEJRUUFnQ1VGK0lBVjNjVFlDak5DQWdBQU1BZ3NnQ2tFUVFSUWdDaWdDRUNBQVJodHFJQWcyQWdBZ0NFVU5BUXNnQ0NBS05nSVlBa0FnQUNnQ0VDSURSUTBBSUFnZ0F6WUNFQ0FESUFnMkFoZ0xJQUJCRkdvb0FnQWlBMFVOQUNBSVFSUnFJQU0yQWdBZ0F5QUlOZ0lZQ3dKQUFrQWdCRUVQU3cwQUlBQWdCQ0FDYWlJRFFRTnlOZ0lFSUFBZ0Eyb2lBeUFES0FJRVFRRnlOZ0lFREFFTElBQWdBbW9pQlNBRVFRRnlOZ0lFSUFBZ0FrRURjallDQkNBRklBUnFJQVEyQWdBQ1FDQUhSUTBBSUFkQmVIRkJzTkNBZ0FCcUlRSkJBQ2dDbk5DQWdBQWhBd0pBQWtCQkFTQUhRUU4yZENJSUlBWnhEUUJCQUNBSUlBWnlOZ0tJMElDQUFDQUNJUWdNQVFzZ0FpZ0NDQ0VJQ3lBSUlBTTJBZ3dnQWlBRE5nSUlJQU1nQWpZQ0RDQURJQWcyQWdnTFFRQWdCVFlDbk5DQWdBQkJBQ0FFTmdLUTBJQ0FBQXNnQUVFSWFpRURDeUFCUVJCcUpJQ0FnSUFBSUFNTENnQWdBQkRKZ0lDQUFBdmlEUUVIZndKQUlBQkZEUUFnQUVGNGFpSUJJQUJCZkdvb0FnQWlBa0Y0Y1NJQWFpRURBa0FnQWtFQmNRMEFJQUpCQTNGRkRRRWdBU0FCS0FJQUlnSnJJZ0ZCQUNnQ21OQ0FnQUFpQkVrTkFTQUNJQUJxSVFBQ1FDQUJRUUFvQXB6UWdJQUFSZzBBQWtBZ0FrSC9BVXNOQUNBQktBSUlJZ1FnQWtFRGRpSUZRUU4wUWJEUWdJQUFhaUlHUmhvQ1FDQUJLQUlNSWdJZ0JFY05BRUVBUVFBb0FvalFnSUFBUVg0Z0JYZHhOZ0tJMElDQUFBd0RDeUFDSUFaR0dpQUNJQVEyQWdnZ0JDQUNOZ0lNREFJTElBRW9BaGdoQndKQUFrQWdBU2dDRENJR0lBRkdEUUFnQVNnQ0NDSUNJQVJKR2lBR0lBSTJBZ2dnQWlBR05nSU1EQUVMQWtBZ0FVRVVhaUlDS0FJQUlnUU5BQ0FCUVJCcUlnSW9BZ0FpQkEwQVFRQWhCZ3dCQ3dOQUlBSWhCU0FFSWdaQkZHb2lBaWdDQUNJRURRQWdCa0VRYWlFQ0lBWW9BaEFpQkEwQUN5QUZRUUEyQWdBTElBZEZEUUVDUUFKQUlBRWdBU2dDSENJRVFRSjBRYmpTZ0lBQWFpSUNLQUlBUncwQUlBSWdCallDQUNBR0RRRkJBRUVBS0FLTTBJQ0FBRUYrSUFSM2NUWUNqTkNBZ0FBTUF3c2dCMEVRUVJRZ0J5Z0NFQ0FCUmh0cUlBWTJBZ0FnQmtVTkFnc2dCaUFITmdJWUFrQWdBU2dDRUNJQ1JRMEFJQVlnQWpZQ0VDQUNJQVkyQWhnTElBRW9BaFFpQWtVTkFTQUdRUlJxSUFJMkFnQWdBaUFHTmdJWURBRUxJQU1vQWdRaUFrRURjVUVEUncwQUlBTWdBa0YrY1RZQ0JFRUFJQUEyQXBEUWdJQUFJQUVnQUdvZ0FEWUNBQ0FCSUFCQkFYSTJBZ1FQQ3lBQklBTlBEUUFnQXlnQ0JDSUNRUUZ4UlEwQUFrQUNRQ0FDUVFKeERRQUNRQ0FEUVFBb0FxRFFnSUFBUncwQVFRQWdBVFlDb05DQWdBQkJBRUVBS0FLVTBJQ0FBQ0FBYWlJQU5nS1UwSUNBQUNBQklBQkJBWEkyQWdRZ0FVRUFLQUtjMElDQUFFY05BMEVBUVFBMkFwRFFnSUFBUVFCQkFEWUNuTkNBZ0FBUEN3SkFJQU5CQUNnQ25OQ0FnQUJIRFFCQkFDQUJOZ0tjMElDQUFFRUFRUUFvQXBEUWdJQUFJQUJxSWdBMkFwRFFnSUFBSUFFZ0FFRUJjallDQkNBQklBQnFJQUEyQWdBUEN5QUNRWGh4SUFCcUlRQUNRQUpBSUFKQi93RkxEUUFnQXlnQ0NDSUVJQUpCQTNZaUJVRURkRUd3MElDQUFHb2lCa1lhQWtBZ0F5Z0NEQ0lDSUFSSERRQkJBRUVBS0FLSTBJQ0FBRUYrSUFWM2NUWUNpTkNBZ0FBTUFnc2dBaUFHUmhvZ0FpQUVOZ0lJSUFRZ0FqWUNEQXdCQ3lBREtBSVlJUWNDUUFKQUlBTW9BZ3dpQmlBRFJnMEFJQU1vQWdnaUFrRUFLQUtZMElDQUFFa2FJQVlnQWpZQ0NDQUNJQVkyQWd3TUFRc0NRQ0FEUVJScUlnSW9BZ0FpQkEwQUlBTkJFR29pQWlnQ0FDSUVEUUJCQUNFR0RBRUxBMEFnQWlFRklBUWlCa0VVYWlJQ0tBSUFJZ1FOQUNBR1FSQnFJUUlnQmlnQ0VDSUVEUUFMSUFWQkFEWUNBQXNnQjBVTkFBSkFBa0FnQXlBREtBSWNJZ1JCQW5SQnVOS0FnQUJxSWdJb0FnQkhEUUFnQWlBR05nSUFJQVlOQVVFQVFRQW9Bb3pRZ0lBQVFYNGdCSGR4TmdLTTBJQ0FBQXdDQ3lBSFFSQkJGQ0FIS0FJUUlBTkdHMm9nQmpZQ0FDQUdSUTBCQ3lBR0lBYzJBaGdDUUNBREtBSVFJZ0pGRFFBZ0JpQUNOZ0lRSUFJZ0JqWUNHQXNnQXlnQ0ZDSUNSUTBBSUFaQkZHb2dBallDQUNBQ0lBWTJBaGdMSUFFZ0FHb2dBRFlDQUNBQklBQkJBWEkyQWdRZ0FVRUFLQUtjMElDQUFFY05BVUVBSUFBMkFwRFFnSUFBRHdzZ0F5QUNRWDV4TmdJRUlBRWdBR29nQURZQ0FDQUJJQUJCQVhJMkFnUUxBa0FnQUVIL0FVc05BQ0FBUVhoeFFiRFFnSUFBYWlFQ0FrQUNRRUVBS0FLSTBJQ0FBQ0lFUVFFZ0FFRURkblFpQUhFTkFFRUFJQVFnQUhJMkFvalFnSUFBSUFJaEFBd0JDeUFDS0FJSUlRQUxJQUFnQVRZQ0RDQUNJQUUyQWdnZ0FTQUNOZ0lNSUFFZ0FEWUNDQThMUVI4aEFnSkFJQUJCLy8vL0Iwc05BQ0FBUVFoMklnSWdBa0dBL2o5cVFSQjJRUWh4SWdKMElnUWdCRUdBNEI5cVFSQjJRUVJ4SWdSMElnWWdCa0dBZ0E5cVFSQjJRUUp4SWdaMFFROTJJQUlnQkhJZ0JuSnJJZ0pCQVhRZ0FDQUNRUlZxZGtFQmNYSkJIR29oQWdzZ0FTQUNOZ0ljSUFGQ0FEY0NFQ0FDUVFKMFFialNnSUFBYWlFRUFrQUNRRUVBS0FLTTBJQ0FBQ0lHUVFFZ0FuUWlBM0VOQUNBRUlBRTJBZ0JCQUNBR0lBTnlOZ0tNMElDQUFDQUJJQVEyQWhnZ0FTQUJOZ0lJSUFFZ0FUWUNEQXdCQ3lBQVFRQkJHU0FDUVFGMmF5QUNRUjlHRzNRaEFpQUVLQUlBSVFZQ1FBTkFJQVlpQkNnQ0JFRjRjU0FBUmcwQklBSkJIWFloQmlBQ1FRRjBJUUlnQkNBR1FRUnhha0VRYWlJREtBSUFJZ1lOQUFzZ0F5QUJOZ0lBSUFFZ0JEWUNHQ0FCSUFFMkFnd2dBU0FCTmdJSURBRUxJQVFvQWdnaUFDQUJOZ0lNSUFRZ0FUWUNDQ0FCUVFBMkFoZ2dBU0FFTmdJTUlBRWdBRFlDQ0F0QkFFRUFLQUtvMElDQUFFRi9haUlCUVg4Z0FSczJBcWpRZ0lBQUN3c0VBQUFBQzA0QUFrQWdBQTBBUHdCQkVIUVBDd0pBSUFCQi8vOERjUTBBSUFCQmYwd05BQUpBSUFCQkVIWkFBQ0lBUVg5SERRQkJBRUV3TmdMNDA0Q0FBRUYvRHdzZ0FFRVFkQThMRU1xQWdJQUFBQXZ5QWdJRGZ3RitBa0FnQWtVTkFDQUFJQUU2QUFBZ0FpQUFhaUlEUVg5cUlBRTZBQUFnQWtFRFNRMEFJQUFnQVRvQUFpQUFJQUU2QUFFZ0EwRjlhaUFCT2dBQUlBTkJmbW9nQVRvQUFDQUNRUWRKRFFBZ0FDQUJPZ0FESUFOQmZHb2dBVG9BQUNBQ1FRbEpEUUFnQUVFQUlBQnJRUU54SWdScUlnTWdBVUgvQVhGQmdZS0VDR3dpQVRZQ0FDQURJQUlnQkd0QmZIRWlCR29pQWtGOGFpQUJOZ0lBSUFSQkNVa05BQ0FESUFFMkFnZ2dBeUFCTmdJRUlBSkJlR29nQVRZQ0FDQUNRWFJxSUFFMkFnQWdCRUVaU1EwQUlBTWdBVFlDR0NBRElBRTJBaFFnQXlBQk5nSVFJQU1nQVRZQ0RDQUNRWEJxSUFFMkFnQWdBa0ZzYWlBQk5nSUFJQUpCYUdvZ0FUWUNBQ0FDUVdScUlBRTJBZ0FnQkNBRFFRUnhRUmh5SWdWcklnSkJJRWtOQUNBQnJVS0JnSUNBRUg0aEJpQURJQVZxSVFFRFFDQUJJQVkzQXhnZ0FTQUdOd01RSUFFZ0JqY0RDQ0FCSUFZM0F3QWdBVUVnYWlFQklBSkJZR29pQWtFZlN3MEFDd3NnQUFzTGprZ0JBRUdBQ0F1R1NBRUFBQUFDQUFBQUF3QUFBQUFBQUFBQUFBQUFCQUFBQUFVQUFBQUFBQUFBQUFBQUFBWUFBQUFIQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFTVzUyWVd4cFpDQmphR0Z5SUdsdUlIVnliQ0J4ZFdWeWVRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgySnZaSGtBUTI5dWRHVnVkQzFNWlc1bmRHZ2diM1psY21ac2IzY0FRMmgxYm1zZ2MybDZaU0J2ZG1WeVpteHZkd0JTWlhOd2IyNXpaU0J2ZG1WeVpteHZkd0JKYm5aaGJHbGtJRzFsZEdodlpDQm1iM0lnU0ZSVVVDOTRMbmdnY21WeGRXVnpkQUJKYm5aaGJHbGtJRzFsZEdodlpDQm1iM0lnVWxSVFVDOTRMbmdnY21WeGRXVnpkQUJGZUhCbFkzUmxaQ0JUVDFWU1EwVWdiV1YwYUc5a0lHWnZjaUJKUTBVdmVDNTRJSEpsY1hWbGMzUUFTVzUyWVd4cFpDQmphR0Z5SUdsdUlIVnliQ0JtY21GbmJXVnVkQ0J6ZEdGeWRBQkZlSEJsWTNSbFpDQmtiM1FBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDl6ZEdGMGRYTUFTVzUyWVd4cFpDQnlaWE53YjI1elpTQnpkR0YwZFhNQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN3QlZjMlZ5SUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5eVpYTmxkR0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJOb2RXNXJYMmhsWVdSbGNtQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMjFsYzNOaFoyVmZZbVZuYVc1Z0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmRtRnNkV1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5emRHRjBkWE5mWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5MlpYSnphVzl1WDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmRYSnNYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlvWldGa1pYSmZkbUZzZFdWZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXRaWE56WVdkbFgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZiV1YwYUc5a1gyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZhR1ZoWkdWeVgyWnBaV3hrWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDI1aGJXVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFGVnVaWGh3WldOMFpXUWdZMmhoY2lCcGJpQjFjbXdnYzJWeWRtVnlBRWx1ZG1Gc2FXUWdhR1ZoWkdWeUlIWmhiSFZsSUdOb1lYSUFTVzUyWVd4cFpDQm9aV0ZrWlhJZ1ptbGxiR1FnWTJoaGNnQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgzWmxjbk5wYjI0QVNXNTJZV3hwWkNCdGFXNXZjaUIyWlhKemFXOXVBRWx1ZG1Gc2FXUWdiV0ZxYjNJZ2RtVnljMmx2YmdCRmVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQjJaWEp6YVc5dUFFVjRjR1ZqZEdWa0lFTlNURVlnWVdaMFpYSWdkbVZ5YzJsdmJnQkpiblpoYkdsa0lFaFVWRkFnZG1WeWMybHZiZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQjBiMnRsYmdCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDNWeWJBQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNuTWdhVzRnZFhKc0FGVnVaWGh3WldOMFpXUWdjM1JoY25RZ1kyaGhjaUJwYmlCMWNtd0FSRzkxWW14bElFQWdhVzRnZFhKc0FFVnRjSFI1SUVOdmJuUmxiblF0VEdWdVozUm9BRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUVOdmJuUmxiblF0VEdWdVozUm9BRVIxY0d4cFkyRjBaU0JEYjI1MFpXNTBMVXhsYm1kMGFBQkpiblpoYkdsa0lHTm9ZWElnYVc0Z2RYSnNJSEJoZEdnQVEyOXVkR1Z1ZEMxTVpXNW5kR2dnWTJGdUozUWdZbVVnY0hKbGMyVnVkQ0IzYVhSb0lGUnlZVzV6Wm1WeUxVVnVZMjlrYVc1bkFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklITnBlbVVBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlvWldGa1pYSmZkbUZzZFdVQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmZG1Gc2RXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUIyWVd4MVpRQk5hWE56YVc1bklHVjRjR1ZqZEdWa0lFeEdJR0ZtZEdWeUlHaGxZV1JsY2lCMllXeDFaUUJKYm5aaGJHbGtJR0JVY21GdWMyWmxjaTFGYm1OdlpHbHVaMkFnYUdWaFpHVnlJSFpoYkhWbEFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTWdjWFZ2ZEdVZ2RtRnNkV1VBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3lCeGRXOTBaV1FnZG1Gc2RXVUFVR0YxYzJWa0lHSjVJRzl1WDJobFlXUmxjbk5mWTI5dGNHeGxkR1VBU1c1MllXeHBaQ0JGVDBZZ2MzUmhkR1VBYjI1ZmNtVnpaWFFnY0dGMWMyVUFiMjVmWTJoMWJtdGZhR1ZoWkdWeUlIQmhkWE5sQUc5dVgyMWxjM05oWjJWZlltVm5hVzRnY0dGMWMyVUFiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYM1poYkhWbElIQmhkWE5sQUc5dVgzTjBZWFIxYzE5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5MlpYSnphVzl1WDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDNWeWJGOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOWphSFZ1YTE5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5b1pXRmtaWEpmZG1Gc2RXVmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOXRaWFJvYjJSZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmFHVmhaR1Z5WDJacFpXeGtYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOXVZVzFsSUhCaGRYTmxBRlZ1Wlhod1pXTjBaV1FnYzNCaFkyVWdZV1owWlhJZ2MzUmhjblFnYkdsdVpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5dVlXMWxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nYm1GdFpRQlFZWFZ6WlNCdmJpQkRUMDVPUlVOVUwxVndaM0poWkdVQVVHRjFjMlVnYjI0Z1VGSkpMMVZ3WjNKaFpHVUFSWGh3WldOMFpXUWdTRlJVVUM4eUlFTnZibTVsWTNScGIyNGdVSEpsWm1GalpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyMWxkR2h2WkFCRmVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQnRaWFJvYjJRQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5b1pXRmtaWEpmWm1sbGJHUUFVR0YxYzJWa0FFbHVkbUZzYVdRZ2QyOXlaQ0JsYm1OdmRXNTBaWEpsWkFCSmJuWmhiR2xrSUcxbGRHaHZaQ0JsYm1OdmRXNTBaWEpsWkFCVmJtVjRjR1ZqZEdWa0lHTm9ZWElnYVc0Z2RYSnNJSE5qYUdWdFlRQlNaWEYxWlhOMElHaGhjeUJwYm5aaGJHbGtJR0JVY21GdWMyWmxjaTFGYm1OdlpHbHVaMkFBVTFkSlZFTklYMUJTVDFoWkFGVlRSVjlRVWs5WVdRQk5TMEZEVkVsV1NWUlpBRlZPVUZKUFEwVlRVMEZDVEVWZlJVNVVTVlJaQUVOUFVGa0FUVTlXUlVSZlVFVlNUVUZPUlU1VVRGa0FWRTlQWDBWQlVreFpBRTVQVkVsR1dRQkdRVWxNUlVSZlJFVlFSVTVFUlU1RFdRQkNRVVJmUjBGVVJWZEJXUUJRVEVGWkFGQlZWQUJEU0VWRFMwOVZWQUJIUVZSRlYwRlpYMVJKVFVWUFZWUUFVa1ZSVlVWVFZGOVVTVTFGVDFWVUFFNUZWRmRQVWt0ZlEwOU9Ua1ZEVkY5VVNVMUZUMVZVQUVOUFRrNUZRMVJKVDA1ZlZFbE5SVTlWVkFCTVQwZEpUbDlVU1UxRlQxVlVBRTVGVkZkUFVrdGZVa1ZCUkY5VVNVMUZUMVZVQUZCUFUxUUFUVWxUUkVsU1JVTlVSVVJmVWtWUlZVVlRWQUJEVEVsRlRsUmZRMHhQVTBWRVgxSkZVVlZGVTFRQVEweEpSVTVVWDBOTVQxTkZSRjlNVDBGRVgwSkJURUZPUTBWRVgxSkZVVlZGVTFRQVFrRkVYMUpGVVZWRlUxUUFTRlJVVUY5U1JWRlZSVk5VWDFORlRsUmZWRTlmU0ZSVVVGTmZVRTlTVkFCU1JWQlBVbFFBU1UxZlFWOVVSVUZRVDFRQVVrVlRSVlJmUTA5T1ZFVk9WQUJPVDE5RFQwNVVSVTVVQUZCQlVsUkpRVXhmUTA5T1ZFVk9WQUJJVUVWZlNVNVdRVXhKUkY5RFQwNVRWRUZPVkFCSVVFVmZRMEpmVWtWVFJWUUFSMFZVQUVoUVJWOVRWRkpKUTFRQVEwOU9Sa3hKUTFRQVZFVk5VRTlTUVZKWlgxSkZSRWxTUlVOVUFGQkZVazFCVGtWT1ZGOVNSVVJKVWtWRFZBQkRUMDVPUlVOVUFFMVZURlJKWDFOVVFWUlZVd0JJVUVWZlNVNVdRVXhKUkY5VFZFRlVWVk1BVkU5UFgwMUJUbGxmVWtWUlZVVlRWRk1BUlVGU1RGbGZTRWxPVkZNQVZVNUJWa0ZKVEVGQ1RFVmZSazlTWDB4RlIwRk1YMUpGUVZOUFRsTUFUMUJVU1U5T1V3QlRWMGxVUTBoSlRrZGZVRkpQVkU5RFQweFRBRlpCVWtsQlRsUmZRVXhUVDE5T1JVZFBWRWxCVkVWVEFFMVZURlJKVUV4RlgwTklUMGxEUlZNQVNVNVVSVkpPUVV4ZlUwVlNWa1ZTWDBWU1VrOVNBRmRGUWw5VFJWSldSVkpmVlU1TFRrOVhUbDlGVWxKUFVnQlNRVWxNUjFWT1gwVlNVazlTQUVsRVJVNVVTVlJaWDFCU1QxWkpSRVZTWDBGVlZFaEZUbFJKUTBGVVNVOU9YMFZTVWs5U0FGTlRURjlEUlZKVVNVWkpRMEZVUlY5RlVsSlBVZ0JKVGxaQlRFbEVYMWhmUms5U1YwRlNSRVZFWDBaUFVnQlRSVlJmVUVGU1FVMUZWRVZTQUVkRlZGOVFRVkpCVFVWVVJWSUFTRkJGWDFWVFJWSUFVMFZGWDA5VVNFVlNBRWhRUlY5RFFsOURTRlZPUzE5SVJVRkVSVklBVFV0RFFVeEZUa1JCVWdCVFJWUlZVQUJYUlVKZlUwVlNWa1ZTWDBsVFgwUlBWMDRBVkVWQlVrUlBWMDRBU0ZCRlgwTk1UMU5GUkY5RFQwNU9SVU5VU1U5T0FFaEZWVkpKVTFSSlExOUZXRkJKVWtGVVNVOU9BRVJKVTBOUFRrNUZRMVJGUkY5UFVFVlNRVlJKVDA0QVRrOU9YMEZWVkVoUFVrbFVRVlJKVmtWZlNVNUdUMUpOUVZSSlQwNEFTRkJGWDBsT1ZrRk1TVVJmVmtWU1UwbFBUZ0JJVUVWZlEwSmZUVVZUVTBGSFJWOUNSVWRKVGdCVFNWUkZYMGxUWDBaU1QxcEZUZ0JJVUVWZlNVNVdRVXhKUkY5SVJVRkVSVkpmVkU5TFJVNEFTVTVXUVV4SlJGOVVUMHRGVGdCR1QxSkNTVVJFUlU0QVJVNUlRVTVEUlY5WlQxVlNYME5CVEUwQVNGQkZYMGxPVmtGTVNVUmZWVkpNQUVKTVQwTkxSVVJmUWxsZlVFRlNSVTVVUVV4ZlEwOU9WRkpQVEFCTlMwTlBUQUJCUTB3QVNGQkZYMGxPVkVWU1RrRk1BRkpGVVZWRlUxUmZTRVZCUkVWU1gwWkpSVXhFVTE5VVQwOWZURUZTUjBWZlZVNVBSa1pKUTBsQlRBQklVRVZmVDBzQVZVNU1TVTVMQUZWT1RFOURTd0JRVWtrQVVrVlVVbGxmVjBsVVNBQklVRVZmU1U1V1FVeEpSRjlEVDA1VVJVNVVYMHhGVGtkVVNBQklVRVZmVlU1RldGQkZRMVJGUkY5RFQwNVVSVTVVWDB4RlRrZFVTQUJHVEZWVFNBQlFVazlRVUVGVVEwZ0FUUzFUUlVGU1EwZ0FWVkpKWDFSUFQxOU1UMDVIQUZCU1QwTkZVMU5KVGtjQVRVbFRRMFZNVEVGT1JVOVZVMTlRUlZKVFNWTlVSVTVVWDFkQlVrNUpUa2NBVFVsVFEwVk1URUZPUlU5VlUxOVhRVkpPU1U1SEFFaFFSVjlKVGxaQlRFbEVYMVJTUVU1VFJrVlNYMFZPUTA5RVNVNUhBRVY0Y0dWamRHVmtJRU5TVEVZQVNGQkZYMGxPVmtGTVNVUmZRMGhWVGt0ZlUwbGFSUUJOVDFaRkFFTlBUbFJKVGxWRkFFaFFSVjlEUWw5VFZFRlVWVk5mUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMGhGUVVSRlVsTmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gxWkZVbE5KVDA1ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDFWU1RGOURUMDFRVEVWVVJRQklVRVZmUTBKZlEwaFZUa3RmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMGhGUVVSRlVsOVdRVXhWUlY5RFQwMVFURVZVUlFCSVVFVmZRMEpmUTBoVlRrdGZSVmhVUlU1VFNVOU9YMVpCVEZWRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5RFNGVk9TMTlGV0ZSRlRsTkpUMDVmVGtGTlJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlRVVlRVMEZIUlY5RFQwMVFURVZVUlFCSVVFVmZRMEpmVFVWVVNFOUVYME5QVFZCTVJWUkZBRWhRUlY5RFFsOUlSVUZFUlZKZlJrbEZURVJmUTA5TlVFeEZWRVVBUkVWTVJWUkZBRWhRUlY5SlRsWkJURWxFWDBWUFJsOVRWRUZVUlFCSlRsWkJURWxFWDFOVFRGOURSVkpVU1VaSlEwRlVSUUJRUVZWVFJRQk9UMTlTUlZOUVQwNVRSUUJWVGxOVlVGQlBVbFJGUkY5TlJVUkpRVjlVV1ZCRkFFZFBUa1VBVGs5VVgwRkRRMFZRVkVGQ1RFVUFVMFZTVmtsRFJWOVZUa0ZXUVVsTVFVSk1SUUJTUVU1SFJWOU9UMVJmVTBGVVNWTkdTVUZDVEVVQVQxSkpSMGxPWDBsVFgxVk9Va1ZCUTBoQlFreEZBRkpGVTFCUFRsTkZYMGxUWDFOVVFVeEZBRkJWVWtkRkFFMUZVa2RGQUZKRlVWVkZVMVJmU0VWQlJFVlNYMFpKUlV4RVUxOVVUMDlmVEVGU1IwVUFVa1ZSVlVWVFZGOUlSVUZFUlZKZlZFOVBYMHhCVWtkRkFGQkJXVXhQUVVSZlZFOVBYMHhCVWtkRkFFbE9VMVZHUmtsRFNVVk9WRjlUVkU5U1FVZEZBRWhRUlY5UVFWVlRSVVJmVlZCSFVrRkVSUUJJVUVWZlVFRlZVMFZFWDBneVgxVlFSMUpCUkVVQVUwOVZVa05GQUVGT1RrOVZUa05GQUZSU1FVTkZBRWhRUlY5VlRrVllVRVZEVkVWRVgxTlFRVU5GQUVSRlUwTlNTVUpGQUZWT1UxVkNVME5TU1VKRkFGSkZRMDlTUkFCSVVFVmZTVTVXUVV4SlJGOU5SVlJJVDBRQVRrOVVYMFpQVlU1RUFGQlNUMUJHU1U1RUFGVk9Ra2xPUkFCU1JVSkpUa1FBVlU1QlZWUklUMUpKV2tWRUFFMUZWRWhQUkY5T1QxUmZRVXhNVDFkRlJBQklWRlJRWDFaRlVsTkpUMDVmVGs5VVgxTlZVRkJQVWxSRlJBQkJURkpGUVVSWlgxSkZVRTlTVkVWRUFFRkRRMFZRVkVWRUFFNVBWRjlKVFZCTVJVMUZUbFJGUkFCTVQwOVFYMFJGVkVWRFZFVkVBRWhRUlY5RFVsOUZXRkJGUTFSRlJBQklVRVZmVEVaZlJWaFFSVU5VUlVRQVExSkZRVlJGUkFCSlRWOVZVMFZFQUVoUVJWOVFRVlZUUlVRQVZFbE5SVTlWVkY5UFEwTlZVa1ZFQUZCQldVMUZUbFJmVWtWUlZVbFNSVVFBVUZKRlEwOU9SRWxVU1U5T1gxSkZVVlZKVWtWRUFGQlNUMWhaWDBGVlZFaEZUbFJKUTBGVVNVOU9YMUpGVVZWSlVrVkVBRTVGVkZkUFVrdGZRVlZVU0VWT1ZFbERRVlJKVDA1ZlVrVlJWVWxTUlVRQVRFVk9SMVJJWDFKRlVWVkpVa1ZFQUZOVFRGOURSVkpVU1VaSlEwRlVSVjlTUlZGVlNWSkZSQUJWVUVkU1FVUkZYMUpGVVZWSlVrVkVBRkJCUjBWZlJWaFFTVkpGUkFCUVVrVkRUMDVFU1ZSSlQwNWZSa0ZKVEVWRUFFVllVRVZEVkVGVVNVOU9YMFpCU1V4RlJBQlNSVlpCVEVsRVFWUkpUMDVmUmtGSlRFVkVBRk5UVEY5SVFVNUVVMGhCUzBWZlJrRkpURVZFQUV4UFEwdEZSQUJVVWtGT1UwWlBVazFCVkVsUFRsOUJVRkJNU1VWRUFFNVBWRjlOVDBSSlJrbEZSQUJPVDFSZlJWaFVSVTVFUlVRQVFrRk9SRmRKUkZSSVgweEpUVWxVWDBWWVEwVkZSRVZFQUZOSlZFVmZTVk5mVDFaRlVreFBRVVJGUkFCSVJVRkVBRVY0Y0dWamRHVmtJRWhVVkZBdkFBQmVFd0FBSmhNQUFEQVFBQUR3RndBQW5STUFBQlVTQUFBNUZ3QUE4QklBQUFvUUFBQjFFZ0FBclJJQUFJSVRBQUJQRkFBQWZ4QUFBS0FWQUFBakZBQUFpUklBQUlzVUFBQk5GUUFBMUJFQUFNOFVBQUFRR0FBQXlSWUFBTndXQUFEQkVRQUE0QmNBQUxzVUFBQjBGQUFBZkJVQUFPVVVBQUFJRndBQUh4QUFBR1VWQUFDakZBQUFLQlVBQUFJVkFBQ1pGUUFBTEJBQUFJc1pBQUJQRHdBQTFBNEFBR29RQUFET0VBQUFBaGNBQUlrT0FBQnVFd0FBSEJNQUFHWVVBQUJXRndBQXdSTUFBTTBUQUFCc0V3QUFhQmNBQUdZWEFBQmZGd0FBSWhNQUFNNFBBQUJwRGdBQTJBNEFBR01XQUFETEV3QUFxZzRBQUNnWEFBQW1Gd0FBeFJNQUFGMFdBQURvRVFBQVp4TUFBR1VUQUFEeUZnQUFjeE1BQUIwWEFBRDVGZ0FBOHhFQUFNOE9BQURPRlFBQURCSUFBTE1SQUFDbEVRQUFZUkFBQURJWEFBQzdFd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUJBZ0VCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWdNQ0FnSUNBZ0FBQWdJQUFnSUFBZ0lDQWdJQ0FnSUNBZ0FFQUFBQUFBQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUFBQUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFJQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSUFBZ0lDQWdJQUFBSUNBQUlDQUFJQ0FnSUNBZ0lDQWdJQUF3QUVBQUFBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQUFBQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUNBQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCc2IzTmxaV1Z3TFdGc2FYWmxBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFFQkFRRUJBUUVCQVFFQkFnRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUZqYUhWdWEyVmtBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFRQUJBUUVCQVFBQUFRRUFBUUVBQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdWamRHbHZibVZ1ZEMxc1pXNW5kR2h2Ym5KdmVIa3RZMjl1Ym1WamRHbHZiZ0FBQUFBQUFBQUFBQUFBQUFBQUFISmhibk5tWlhJdFpXNWpiMlJwYm1kd1ozSmhaR1VOQ2cwS0RRcFRUUTBLRFFwVVZGQXZRMFV2VkZOUUx3QUFBQUFBQUFBQUFBQUFBQUVDQUFFREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQUFBQkFnQUJBd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFCQVFVQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUFBQUFBQUFBQUFBUUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFBQUFBQkFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd1FBQUFRRUJBUUVCQVFFQkFRRUJRUUVCQVFFQkFRRUJBUUVCQUFFQUFZSEJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUFCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBZ0FBQUFBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdBQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFNVBWVTVEUlVWRFMwOVZWRTVGUTFSRlZFVkRVa2xDUlV4VlUwaEZWRVZCUkZORlFWSkRTRkpIUlVOVVNWWkpWRmxNUlU1RVFWSldSVTlVU1VaWlVGUkpUMDVUUTBoVFJVRlpVMVJCVkVOSVIwVlBVa1JKVWtWRFZFOVNWRkpEU0ZCQlVrRk5SVlJGVWxWU1EwVkNVME5TU1VKRlFWSkVUMWRPUVVORlNVNUVUa3REUzFWQ1UwTlNTVUpGU0ZSVVVDOUJSRlJRTHc9PVwiLFwiYmFzZTY0XCIpLGxsaHR0cF9zaW1kV2FzbX1vKHJlcXVpcmVMbGh0dHBfc2ltZFdhc20sXCJyZXF1aXJlTGxodHRwX3NpbWRXYXNtXCIpO3ZhciBjb25zdGFudHMkMyxoYXNSZXF1aXJlZENvbnN0YW50cyQyO2Z1bmN0aW9uIHJlcXVpcmVDb25zdGFudHMkMigpe2lmKGhhc1JlcXVpcmVkQ29uc3RhbnRzJDIpcmV0dXJuIGNvbnN0YW50cyQzO2hhc1JlcXVpcmVkQ29uc3RhbnRzJDI9MTtjb25zdCBlPVtcIkdFVFwiLFwiSEVBRFwiLFwiUE9TVFwiXSxBPW5ldyBTZXQoZSksdD1bMTAxLDIwNCwyMDUsMzA0XSxuPVszMDEsMzAyLDMwMywzMDcsMzA4XSxyPW5ldyBTZXQobikscz1bXCIxXCIsXCI3XCIsXCI5XCIsXCIxMVwiLFwiMTNcIixcIjE1XCIsXCIxN1wiLFwiMTlcIixcIjIwXCIsXCIyMVwiLFwiMjJcIixcIjIzXCIsXCIyNVwiLFwiMzdcIixcIjQyXCIsXCI0M1wiLFwiNTNcIixcIjY5XCIsXCI3N1wiLFwiNzlcIixcIjg3XCIsXCI5NVwiLFwiMTAxXCIsXCIxMDJcIixcIjEwM1wiLFwiMTA0XCIsXCIxMDlcIixcIjExMFwiLFwiMTExXCIsXCIxMTNcIixcIjExNVwiLFwiMTE3XCIsXCIxMTlcIixcIjEyM1wiLFwiMTM1XCIsXCIxMzdcIixcIjEzOVwiLFwiMTQzXCIsXCIxNjFcIixcIjE3OVwiLFwiMzg5XCIsXCI0MjdcIixcIjQ2NVwiLFwiNTEyXCIsXCI1MTNcIixcIjUxNFwiLFwiNTE1XCIsXCI1MjZcIixcIjUzMFwiLFwiNTMxXCIsXCI1MzJcIixcIjU0MFwiLFwiNTQ4XCIsXCI1NTRcIixcIjU1NlwiLFwiNTYzXCIsXCI1ODdcIixcIjYwMVwiLFwiNjM2XCIsXCI5ODlcIixcIjk5MFwiLFwiOTkzXCIsXCI5OTVcIixcIjE3MTlcIixcIjE3MjBcIixcIjE3MjNcIixcIjIwNDlcIixcIjM2NTlcIixcIjQwNDVcIixcIjQxOTBcIixcIjUwNjBcIixcIjUwNjFcIixcIjYwMDBcIixcIjY1NjZcIixcIjY2NjVcIixcIjY2NjZcIixcIjY2NjdcIixcIjY2NjhcIixcIjY2NjlcIixcIjY2NzlcIixcIjY2OTdcIixcIjEwMDgwXCJdLGk9bmV3IFNldChzKSxFPVtcIlwiLFwibm8tcmVmZXJyZXJcIixcIm5vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlXCIsXCJzYW1lLW9yaWdpblwiLFwib3JpZ2luXCIsXCJzdHJpY3Qtb3JpZ2luXCIsXCJvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIixcInN0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIixcInVuc2FmZS11cmxcIl0sUT1uZXcgU2V0KEUpLEM9W1wiZm9sbG93XCIsXCJtYW51YWxcIixcImVycm9yXCJdLEk9W1wiR0VUXCIsXCJIRUFEXCIsXCJPUFRJT05TXCIsXCJUUkFDRVwiXSxhPW5ldyBTZXQoSSksZj1bXCJuYXZpZ2F0ZVwiLFwic2FtZS1vcmlnaW5cIixcIm5vLWNvcnNcIixcImNvcnNcIl0saD1bXCJvbWl0XCIsXCJzYW1lLW9yaWdpblwiLFwiaW5jbHVkZVwiXSxMPVtcImRlZmF1bHRcIixcIm5vLXN0b3JlXCIsXCJyZWxvYWRcIixcIm5vLWNhY2hlXCIsXCJmb3JjZS1jYWNoZVwiLFwib25seS1pZi1jYWNoZWRcIl0sYz1bXCJjb250ZW50LWVuY29kaW5nXCIsXCJjb250ZW50LWxhbmd1YWdlXCIsXCJjb250ZW50LWxvY2F0aW9uXCIsXCJjb250ZW50LXR5cGVcIixcImNvbnRlbnQtbGVuZ3RoXCJdLGw9W1wiaGFsZlwiXSxTPVtcIkNPTk5FQ1RcIixcIlRSQUNFXCIsXCJUUkFDS1wiXSxrPW5ldyBTZXQoUyksdz1bXCJhdWRpb1wiLFwiYXVkaW93b3JrbGV0XCIsXCJmb250XCIsXCJpbWFnZVwiLFwibWFuaWZlc3RcIixcInBhaW50d29ya2xldFwiLFwic2NyaXB0XCIsXCJzdHlsZVwiLFwidHJhY2tcIixcInZpZGVvXCIsXCJ4c2x0XCIsXCJcIl0sVT1uZXcgU2V0KHcpO3JldHVybiBjb25zdGFudHMkMz17c3VicmVzb3VyY2U6dyxmb3JiaWRkZW5NZXRob2RzOlMscmVxdWVzdEJvZHlIZWFkZXI6YyxyZWZlcnJlclBvbGljeTpFLHJlcXVlc3RSZWRpcmVjdDpDLHJlcXVlc3RNb2RlOmYscmVxdWVzdENyZWRlbnRpYWxzOmgscmVxdWVzdENhY2hlOkwscmVkaXJlY3RTdGF0dXM6bixjb3JzU2FmZUxpc3RlZE1ldGhvZHM6ZSxudWxsQm9keVN0YXR1czp0LHNhZmVNZXRob2RzOkksYmFkUG9ydHM6cyxyZXF1ZXN0RHVwbGV4Omwsc3VicmVzb3VyY2VTZXQ6VSxiYWRQb3J0c1NldDppLHJlZGlyZWN0U3RhdHVzU2V0OnIsY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0OkEsc2FmZU1ldGhvZHNTZXQ6YSxmb3JiaWRkZW5NZXRob2RzU2V0OmsscmVmZXJyZXJQb2xpY3lTZXQ6UX0sY29uc3RhbnRzJDN9byhyZXF1aXJlQ29uc3RhbnRzJDIsXCJyZXF1aXJlQ29uc3RhbnRzJDJcIik7dmFyIGdsb2JhbCQxLGhhc1JlcXVpcmVkR2xvYmFsO2Z1bmN0aW9uIHJlcXVpcmVHbG9iYWwoKXtpZihoYXNSZXF1aXJlZEdsb2JhbClyZXR1cm4gZ2xvYmFsJDE7aGFzUmVxdWlyZWRHbG9iYWw9MTtjb25zdCBlPVN5bWJvbC5mb3IoXCJ1bmRpY2kuZ2xvYmFsT3JpZ2luLjFcIik7ZnVuY3Rpb24gQSgpe3JldHVybiBnbG9iYWxUaGlzW2VdfW8oQSxcImdldEdsb2JhbE9yaWdpblwiKTtmdW5jdGlvbiB0KG4pe2lmKG49PT12b2lkIDApe09iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLGUse3ZhbHVlOnZvaWQgMCx3cml0YWJsZTohMCxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMX0pO3JldHVybn1jb25zdCByPW5ldyBVUkwobik7aWYoci5wcm90b2NvbCE9PVwiaHR0cDpcIiYmci5wcm90b2NvbCE9PVwiaHR0cHM6XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgT25seSBodHRwICYgaHR0cHMgdXJscyBhcmUgYWxsb3dlZCwgcmVjZWl2ZWQgJHtyLnByb3RvY29sfWApO09iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLGUse3ZhbHVlOnIsd3JpdGFibGU6ITAsZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITF9KX1yZXR1cm4gbyh0LFwic2V0R2xvYmFsT3JpZ2luXCIpLGdsb2JhbCQxPXtnZXRHbG9iYWxPcmlnaW46QSxzZXRHbG9iYWxPcmlnaW46dH0sZ2xvYmFsJDF9byhyZXF1aXJlR2xvYmFsLFwicmVxdWlyZUdsb2JhbFwiKTt2YXIgZGF0YVVybCxoYXNSZXF1aXJlZERhdGFVcmw7ZnVuY3Rpb24gcmVxdWlyZURhdGFVcmwoKXtpZihoYXNSZXF1aXJlZERhdGFVcmwpcmV0dXJuIGRhdGFVcmw7aGFzUmVxdWlyZWREYXRhVXJsPTE7Y29uc3QgZT1yZXF1aXJlJCQwX19kZWZhdWx0LEE9bmV3IFRleHRFbmNvZGVyLHQ9L15bISMkJSYnKistLl5ffH5BLVphLXowLTldKyQvLG49L1tcXHUwMDBBXFx1MDAwRFxcdTAwMDlcXHUwMDIwXS8scj0vW1xcdTAwMDlcXHUwMDBBXFx1MDAwQ1xcdTAwMERcXHUwMDIwXS9nLHM9L1tcXHUwMDA5XFx1MDAyMC1cXHUwMDdFXFx1MDA4MC1cXHUwMEZGXS87ZnVuY3Rpb24gaShnKXtlKGcucHJvdG9jb2w9PT1cImRhdGE6XCIpO2xldCBkPUUoZywhMCk7ZD1kLnNsaWNlKDUpO2NvbnN0IEY9e3Bvc2l0aW9uOjB9O2xldCBOPUMoXCIsXCIsZCxGKTtjb25zdCB1PU4ubGVuZ3RoO2lmKE49TShOLCEwLCEwKSxGLnBvc2l0aW9uPj1kLmxlbmd0aClyZXR1cm5cImZhaWx1cmVcIjtGLnBvc2l0aW9uKys7Y29uc3QgYj1kLnNsaWNlKHUrMSk7bGV0IG09SShiKTtpZigvOyhcXHUwMDIwKXswLH1iYXNlNjQkL2kudGVzdChOKSl7Y29uc3Qgdj1EKG0pO2lmKG09Yyh2KSxtPT09XCJmYWlsdXJlXCIpcmV0dXJuXCJmYWlsdXJlXCI7Tj1OLnNsaWNlKDAsLTYpLE49Ti5yZXBsYWNlKC8oXFx1MDAyMCkrJC8sXCJcIiksTj1OLnNsaWNlKDAsLTEpfU4uc3RhcnRzV2l0aChcIjtcIikmJihOPVwidGV4dC9wbGFpblwiK04pO2xldCBUPUwoTik7cmV0dXJuIFQ9PT1cImZhaWx1cmVcIiYmKFQ9TChcInRleHQvcGxhaW47Y2hhcnNldD1VUy1BU0NJSVwiKSkse21pbWVUeXBlOlQsYm9keTptfX1vKGksXCJkYXRhVVJMUHJvY2Vzc29yXCIpO2Z1bmN0aW9uIEUoZyxkPSExKXtpZighZClyZXR1cm4gZy5ocmVmO2NvbnN0IEY9Zy5ocmVmLE49Zy5oYXNoLmxlbmd0aCx1PU49PT0wP0Y6Ri5zdWJzdHJpbmcoMCxGLmxlbmd0aC1OKTtyZXR1cm4hTiYmRi5lbmRzV2l0aChcIiNcIik/dS5zbGljZSgwLC0xKTp1fW8oRSxcIlVSTFNlcmlhbGl6ZXJcIik7ZnVuY3Rpb24gUShnLGQsRil7bGV0IE49XCJcIjtmb3IoO0YucG9zaXRpb248ZC5sZW5ndGgmJmcoZFtGLnBvc2l0aW9uXSk7KU4rPWRbRi5wb3NpdGlvbl0sRi5wb3NpdGlvbisrO3JldHVybiBOfW8oUSxcImNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNcIik7ZnVuY3Rpb24gQyhnLGQsRil7Y29uc3QgTj1kLmluZGV4T2YoZyxGLnBvc2l0aW9uKSx1PUYucG9zaXRpb247cmV0dXJuIE49PT0tMT8oRi5wb3NpdGlvbj1kLmxlbmd0aCxkLnNsaWNlKHUpKTooRi5wb3NpdGlvbj1OLGQuc2xpY2UodSxGLnBvc2l0aW9uKSl9byhDLFwiY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3RcIik7ZnVuY3Rpb24gSShnKXtjb25zdCBkPUEuZW5jb2RlKGcpO3JldHVybiBoKGQpfW8oSSxcInN0cmluZ1BlcmNlbnREZWNvZGVcIik7ZnVuY3Rpb24gYShnKXtyZXR1cm4gZz49NDgmJmc8PTU3fHxnPj02NSYmZzw9NzB8fGc+PTk3JiZnPD0xMDJ9byhhLFwiaXNIZXhDaGFyQnl0ZVwiKTtmdW5jdGlvbiBmKGcpe3JldHVybiBnPj00OCYmZzw9NTc/Zy00ODooZyYyMjMpLTU1fW8oZixcImhleEJ5dGVUb051bWJlclwiKTtmdW5jdGlvbiBoKGcpe2NvbnN0IGQ9Zy5sZW5ndGgsRj1uZXcgVWludDhBcnJheShkKTtsZXQgTj0wO2ZvcihsZXQgdT0wO3U8ZDsrK3Upe2NvbnN0IGI9Z1t1XTtiIT09Mzc/RltOKytdPWI6Yj09PTM3JiYhKGEoZ1t1KzFdKSYmYShnW3UrMl0pKT9GW04rK109Mzc6KEZbTisrXT1mKGdbdSsxXSk8PDR8ZihnW3UrMl0pLHUrPTIpfXJldHVybiBkPT09Tj9GOkYuc3ViYXJyYXkoMCxOKX1vKGgsXCJwZXJjZW50RGVjb2RlXCIpO2Z1bmN0aW9uIEwoZyl7Zz13KGcsITAsITApO2NvbnN0IGQ9e3Bvc2l0aW9uOjB9LEY9QyhcIi9cIixnLGQpO2lmKEYubGVuZ3RoPT09MHx8IXQudGVzdChGKXx8ZC5wb3NpdGlvbj5nLmxlbmd0aClyZXR1cm5cImZhaWx1cmVcIjtkLnBvc2l0aW9uKys7bGV0IE49QyhcIjtcIixnLGQpO2lmKE49dyhOLCExLCEwKSxOLmxlbmd0aD09PTB8fCF0LnRlc3QoTikpcmV0dXJuXCJmYWlsdXJlXCI7Y29uc3QgdT1GLnRvTG93ZXJDYXNlKCksYj1OLnRvTG93ZXJDYXNlKCksbT17dHlwZTp1LHN1YnR5cGU6YixwYXJhbWV0ZXJzOm5ldyBNYXAsZXNzZW5jZTpgJHt1fS8ke2J9YH07Zm9yKDtkLnBvc2l0aW9uPGcubGVuZ3RoOyl7ZC5wb3NpdGlvbisrLFEoWj0+bi50ZXN0KFopLGcsZCk7bGV0IFQ9UShaPT5aIT09XCI7XCImJlohPT1cIj1cIixnLGQpO2lmKFQ9VC50b0xvd2VyQ2FzZSgpLGQucG9zaXRpb248Zy5sZW5ndGgpe2lmKGdbZC5wb3NpdGlvbl09PT1cIjtcIiljb250aW51ZTtkLnBvc2l0aW9uKyt9aWYoZC5wb3NpdGlvbj5nLmxlbmd0aClicmVhaztsZXQgdj1udWxsO2lmKGdbZC5wb3NpdGlvbl09PT0nXCInKXY9bChnLGQsITApLEMoXCI7XCIsZyxkKTtlbHNlIGlmKHY9QyhcIjtcIixnLGQpLHY9dyh2LCExLCEwKSx2Lmxlbmd0aD09PTApY29udGludWU7VC5sZW5ndGghPT0wJiZ0LnRlc3QoVCkmJih2Lmxlbmd0aD09PTB8fHMudGVzdCh2KSkmJiFtLnBhcmFtZXRlcnMuaGFzKFQpJiZtLnBhcmFtZXRlcnMuc2V0KFQsdil9cmV0dXJuIG19byhMLFwicGFyc2VNSU1FVHlwZVwiKTtmdW5jdGlvbiBjKGcpe2c9Zy5yZXBsYWNlKHIsXCJcIik7bGV0IGQ9Zy5sZW5ndGg7aWYoZCU0PT09MCYmZy5jaGFyQ29kZUF0KGQtMSk9PT02MSYmKC0tZCxnLmNoYXJDb2RlQXQoZC0xKT09PTYxJiYtLWQpLGQlND09PTF8fC9bXisvMC05QS1aYS16XS8udGVzdChnLmxlbmd0aD09PWQ/ZzpnLnN1YnN0cmluZygwLGQpKSlyZXR1cm5cImZhaWx1cmVcIjtjb25zdCBGPUJ1ZmZlci5mcm9tKGcsXCJiYXNlNjRcIik7cmV0dXJuIG5ldyBVaW50OEFycmF5KEYuYnVmZmVyLEYuYnl0ZU9mZnNldCxGLmJ5dGVMZW5ndGgpfW8oYyxcImZvcmdpdmluZ0Jhc2U2NFwiKTtmdW5jdGlvbiBsKGcsZCxGKXtjb25zdCBOPWQucG9zaXRpb247bGV0IHU9XCJcIjtmb3IoZShnW2QucG9zaXRpb25dPT09J1wiJyksZC5wb3NpdGlvbisrO3UrPVEobT0+bSE9PSdcIicmJm0hPT1cIlxcXFxcIixnLGQpLCEoZC5wb3NpdGlvbj49Zy5sZW5ndGgpOyl7Y29uc3QgYj1nW2QucG9zaXRpb25dO2lmKGQucG9zaXRpb24rKyxiPT09XCJcXFxcXCIpe2lmKGQucG9zaXRpb24+PWcubGVuZ3RoKXt1Kz1cIlxcXFxcIjticmVha311Kz1nW2QucG9zaXRpb25dLGQucG9zaXRpb24rK31lbHNle2UoYj09PSdcIicpO2JyZWFrfX1yZXR1cm4gRj91Omcuc2xpY2UoTixkLnBvc2l0aW9uKX1vKGwsXCJjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nXCIpO2Z1bmN0aW9uIFMoZyl7ZShnIT09XCJmYWlsdXJlXCIpO2NvbnN0e3BhcmFtZXRlcnM6ZCxlc3NlbmNlOkZ9PWc7bGV0IE49Rjtmb3IobGV0W3UsYl1vZiBkLmVudHJpZXMoKSlOKz1cIjtcIixOKz11LE4rPVwiPVwiLHQudGVzdChiKXx8KGI9Yi5yZXBsYWNlKC8oXFxcXHxcIikvZyxcIlxcXFwkMVwiKSxiPSdcIicrYixiKz0nXCInKSxOKz1iO3JldHVybiBOfW8oUyxcInNlcmlhbGl6ZUFNaW1lVHlwZVwiKTtmdW5jdGlvbiBrKGcpe3JldHVybiBnPT09MTN8fGc9PT0xMHx8Zz09PTl8fGc9PT0zMn1vKGssXCJpc0hUVFBXaGl0ZVNwYWNlXCIpO2Z1bmN0aW9uIHcoZyxkPSEwLEY9ITApe3JldHVybiBCKGcsZCxGLGspfW8odyxcInJlbW92ZUhUVFBXaGl0ZXNwYWNlXCIpO2Z1bmN0aW9uIFUoZyl7cmV0dXJuIGc9PT0xM3x8Zz09PTEwfHxnPT09OXx8Zz09PTEyfHxnPT09MzJ9byhVLFwiaXNBU0NJSVdoaXRlc3BhY2VcIik7ZnVuY3Rpb24gTShnLGQ9ITAsRj0hMCl7cmV0dXJuIEIoZyxkLEYsVSl9byhNLFwicmVtb3ZlQVNDSUlXaGl0ZXNwYWNlXCIpO2Z1bmN0aW9uIEIoZyxkLEYsTil7bGV0IHU9MCxiPWcubGVuZ3RoLTE7aWYoZClmb3IoO3U8Zy5sZW5ndGgmJk4oZy5jaGFyQ29kZUF0KHUpKTspdSsrO2lmKEYpZm9yKDtiPjAmJk4oZy5jaGFyQ29kZUF0KGIpKTspYi0tO3JldHVybiB1PT09MCYmYj09PWcubGVuZ3RoLTE/ZzpnLnNsaWNlKHUsYisxKX1vKEIsXCJyZW1vdmVDaGFyc1wiKTtmdW5jdGlvbiBEKGcpe2NvbnN0IGQ9Zy5sZW5ndGg7aWYoNjU1MzU+ZClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLGcpO2xldCBGPVwiXCIsTj0wLHU9NjU1MzU7Zm9yKDtOPGQ7KU4rdT5kJiYodT1kLU4pLEYrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxnLnN1YmFycmF5KE4sTis9dSkpO3JldHVybiBGfW8oRCxcImlzb21vcnBoaWNEZWNvZGVcIik7ZnVuY3Rpb24gRyhnKXtzd2l0Y2goZy5lc3NlbmNlKXtjYXNlXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCI6Y2FzZVwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiOmNhc2VcImFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiOmNhc2VcImFwcGxpY2F0aW9uL3gtamF2YXNjcmlwdFwiOmNhc2VcInRleHQvZWNtYXNjcmlwdFwiOmNhc2VcInRleHQvamF2YXNjcmlwdFwiOmNhc2VcInRleHQvamF2YXNjcmlwdDEuMFwiOmNhc2VcInRleHQvamF2YXNjcmlwdDEuMVwiOmNhc2VcInRleHQvamF2YXNjcmlwdDEuMlwiOmNhc2VcInRleHQvamF2YXNjcmlwdDEuM1wiOmNhc2VcInRleHQvamF2YXNjcmlwdDEuNFwiOmNhc2VcInRleHQvamF2YXNjcmlwdDEuNVwiOmNhc2VcInRleHQvanNjcmlwdFwiOmNhc2VcInRleHQvbGl2ZXNjcmlwdFwiOmNhc2VcInRleHQveC1lY21hc2NyaXB0XCI6Y2FzZVwidGV4dC94LWphdmFzY3JpcHRcIjpyZXR1cm5cInRleHQvamF2YXNjcmlwdFwiO2Nhc2VcImFwcGxpY2F0aW9uL2pzb25cIjpjYXNlXCJ0ZXh0L2pzb25cIjpyZXR1cm5cImFwcGxpY2F0aW9uL2pzb25cIjtjYXNlXCJpbWFnZS9zdmcreG1sXCI6cmV0dXJuXCJpbWFnZS9zdmcreG1sXCI7Y2FzZVwidGV4dC94bWxcIjpjYXNlXCJhcHBsaWNhdGlvbi94bWxcIjpyZXR1cm5cImFwcGxpY2F0aW9uL3htbFwifXJldHVybiBnLnN1YnR5cGUuZW5kc1dpdGgoXCIranNvblwiKT9cImFwcGxpY2F0aW9uL2pzb25cIjpnLnN1YnR5cGUuZW5kc1dpdGgoXCIreG1sXCIpP1wiYXBwbGljYXRpb24veG1sXCI6XCJcIn1yZXR1cm4gbyhHLFwibWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZVwiKSxkYXRhVXJsPXtkYXRhVVJMUHJvY2Vzc29yOmksVVJMU2VyaWFsaXplcjpFLGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHM6USxjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdDpDLHN0cmluZ1BlcmNlbnREZWNvZGU6SSxwYXJzZU1JTUVUeXBlOkwsY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZzpsLHNlcmlhbGl6ZUFNaW1lVHlwZTpTLHJlbW92ZUNoYXJzOkIsbWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZTpHLEhUVFBfVE9LRU5fQ09ERVBPSU5UUzp0LGlzb21vcnBoaWNEZWNvZGU6RH0sZGF0YVVybH1vKHJlcXVpcmVEYXRhVXJsLFwicmVxdWlyZURhdGFVcmxcIik7dmFyIHdlYmlkbF8xLGhhc1JlcXVpcmVkV2ViaWRsO2Z1bmN0aW9uIHJlcXVpcmVXZWJpZGwoKXtpZihoYXNSZXF1aXJlZFdlYmlkbClyZXR1cm4gd2ViaWRsXzE7aGFzUmVxdWlyZWRXZWJpZGw9MTtjb25zdHt0eXBlczplLGluc3BlY3Q6QX09cmVxdWlyZSQkMF9fZGVmYXVsdCQxLHt0b1VTVlN0cmluZzp0fT11dGlsJG0sbj17fTtyZXR1cm4gbi5jb252ZXJ0ZXJzPXt9LG4udXRpbD17fSxuLmVycm9ycz17fSxuLmVycm9ycy5leGNlcHRpb249ZnVuY3Rpb24ocil7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYCR7ci5oZWFkZXJ9OiAke3IubWVzc2FnZX1gKX0sbi5lcnJvcnMuY29udmVyc2lvbkZhaWxlZD1mdW5jdGlvbihyKXtjb25zdCBzPXIudHlwZXMubGVuZ3RoPT09MT9cIlwiOlwiIG9uZSBvZlwiLGk9YCR7ci5hcmd1bWVudH0gY291bGQgbm90IGJlIGNvbnZlcnRlZCB0byR7c306ICR7ci50eXBlcy5qb2luKFwiLCBcIil9LmA7cmV0dXJuIG4uZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOnIucHJlZml4LG1lc3NhZ2U6aX0pfSxuLmVycm9ycy5pbnZhbGlkQXJndW1lbnQ9ZnVuY3Rpb24ocil7cmV0dXJuIG4uZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOnIucHJlZml4LG1lc3NhZ2U6YFwiJHtyLnZhbHVlfVwiIGlzIGFuIGludmFsaWQgJHtyLnR5cGV9LmB9KX0sbi5icmFuZENoZWNrPWZ1bmN0aW9uKHIscyxpPXZvaWQgMCl7aWYoaT8uc3RyaWN0IT09ITEpe2lmKCEociBpbnN0YW5jZW9mIHMpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIil9ZWxzZSBpZihyPy5bU3ltYm9sLnRvU3RyaW5nVGFnXSE9PXMucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10pdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvblwiKX0sbi5hcmd1bWVudExlbmd0aENoZWNrPWZ1bmN0aW9uKHtsZW5ndGg6cn0scyxpKXtpZihyPHMpdGhyb3cgbi5lcnJvcnMuZXhjZXB0aW9uKHttZXNzYWdlOmAke3N9IGFyZ3VtZW50JHtzIT09MT9cInNcIjpcIlwifSByZXF1aXJlZCwgYnV0JHtyP1wiIG9ubHlcIjpcIlwifSAke3J9IGZvdW5kLmAsLi4uaX0pfSxuLmlsbGVnYWxDb25zdHJ1Y3Rvcj1mdW5jdGlvbigpe3Rocm93IG4uZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOlwiVHlwZUVycm9yXCIsbWVzc2FnZTpcIklsbGVnYWwgY29uc3RydWN0b3JcIn0pfSxuLnV0aWwuVHlwZT1mdW5jdGlvbihyKXtzd2l0Y2godHlwZW9mIHIpe2Nhc2VcInVuZGVmaW5lZFwiOnJldHVyblwiVW5kZWZpbmVkXCI7Y2FzZVwiYm9vbGVhblwiOnJldHVyblwiQm9vbGVhblwiO2Nhc2VcInN0cmluZ1wiOnJldHVyblwiU3RyaW5nXCI7Y2FzZVwic3ltYm9sXCI6cmV0dXJuXCJTeW1ib2xcIjtjYXNlXCJudW1iZXJcIjpyZXR1cm5cIk51bWJlclwiO2Nhc2VcImJpZ2ludFwiOnJldHVyblwiQmlnSW50XCI7Y2FzZVwiZnVuY3Rpb25cIjpjYXNlXCJvYmplY3RcIjpyZXR1cm4gcj09PW51bGw/XCJOdWxsXCI6XCJPYmplY3RcIn19LG4udXRpbC5Db252ZXJ0VG9JbnQ9ZnVuY3Rpb24ocixzLGksRT17fSl7bGV0IFEsQztzPT09NjQ/KFE9TWF0aC5wb3coMiw1MyktMSxpPT09XCJ1bnNpZ25lZFwiP0M9MDpDPU1hdGgucG93KC0yLDUzKSsxKTppPT09XCJ1bnNpZ25lZFwiPyhDPTAsUT1NYXRoLnBvdygyLHMpLTEpOihDPU1hdGgucG93KC0yLHMpLTEsUT1NYXRoLnBvdygyLHMtMSktMSk7bGV0IEk9TnVtYmVyKHIpO2lmKEk9PT0wJiYoST0wKSxFLmVuZm9yY2VSYW5nZT09PSEwKXtpZihOdW1iZXIuaXNOYU4oSSl8fEk9PT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl8fEk9PT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpdGhyb3cgbi5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJJbnRlZ2VyIGNvbnZlcnNpb25cIixtZXNzYWdlOmBDb3VsZCBub3QgY29udmVydCAke24udXRpbC5TdHJpbmdpZnkocil9IHRvIGFuIGludGVnZXIuYH0pO2lmKEk9bi51dGlsLkludGVnZXJQYXJ0KEkpLEk8Q3x8ST5RKXRocm93IG4uZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOlwiSW50ZWdlciBjb252ZXJzaW9uXCIsbWVzc2FnZTpgVmFsdWUgbXVzdCBiZSBiZXR3ZWVuICR7Q30tJHtRfSwgZ290ICR7SX0uYH0pO3JldHVybiBJfXJldHVybiFOdW1iZXIuaXNOYU4oSSkmJkUuY2xhbXA9PT0hMD8oST1NYXRoLm1pbihNYXRoLm1heChJLEMpLFEpLE1hdGguZmxvb3IoSSklMj09PTA/ST1NYXRoLmZsb29yKEkpOkk9TWF0aC5jZWlsKEkpLEkpOk51bWJlci5pc05hTihJKXx8ST09PTAmJk9iamVjdC5pcygwLEkpfHxJPT09TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfHxJPT09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZPzA6KEk9bi51dGlsLkludGVnZXJQYXJ0KEkpLEk9SSVNYXRoLnBvdygyLHMpLGk9PT1cInNpZ25lZFwiJiZJPj1NYXRoLnBvdygyLHMpLTE/SS1NYXRoLnBvdygyLHMpOkkpfSxuLnV0aWwuSW50ZWdlclBhcnQ9ZnVuY3Rpb24ocil7Y29uc3Qgcz1NYXRoLmZsb29yKE1hdGguYWJzKHIpKTtyZXR1cm4gcjwwPy0xKnM6c30sbi51dGlsLlN0cmluZ2lmeT1mdW5jdGlvbihyKXtzd2l0Y2gobi51dGlsLlR5cGUocikpe2Nhc2VcIlN5bWJvbFwiOnJldHVybmBTeW1ib2woJHtyLmRlc2NyaXB0aW9ufSlgO2Nhc2VcIk9iamVjdFwiOnJldHVybiBBKHIpO2Nhc2VcIlN0cmluZ1wiOnJldHVybmBcIiR7cn1cImA7ZGVmYXVsdDpyZXR1cm5gJHtyfWB9fSxuLnNlcXVlbmNlQ29udmVydGVyPWZ1bmN0aW9uKHIpe3JldHVybihzLGkpPT57aWYobi51dGlsLlR5cGUocykhPT1cIk9iamVjdFwiKXRocm93IG4uZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOlwiU2VxdWVuY2VcIixtZXNzYWdlOmBWYWx1ZSBvZiB0eXBlICR7bi51dGlsLlR5cGUocyl9IGlzIG5vdCBhbiBPYmplY3QuYH0pO2NvbnN0IEU9dHlwZW9mIGk9PVwiZnVuY3Rpb25cIj9pKCk6cz8uW1N5bWJvbC5pdGVyYXRvcl0/LigpLFE9W107aWYoRT09PXZvaWQgMHx8dHlwZW9mIEUubmV4dCE9XCJmdW5jdGlvblwiKXRocm93IG4uZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOlwiU2VxdWVuY2VcIixtZXNzYWdlOlwiT2JqZWN0IGlzIG5vdCBhbiBpdGVyYXRvci5cIn0pO2Zvcig7Oyl7Y29uc3R7ZG9uZTpDLHZhbHVlOkl9PUUubmV4dCgpO2lmKEMpYnJlYWs7US5wdXNoKHIoSSkpfXJldHVybiBRfX0sbi5yZWNvcmRDb252ZXJ0ZXI9ZnVuY3Rpb24ocixzKXtyZXR1cm4gaT0+e2lmKG4udXRpbC5UeXBlKGkpIT09XCJPYmplY3RcIil0aHJvdyBuLmVycm9ycy5leGNlcHRpb24oe2hlYWRlcjpcIlJlY29yZFwiLG1lc3NhZ2U6YFZhbHVlIG9mIHR5cGUgJHtuLnV0aWwuVHlwZShpKX0gaXMgbm90IGFuIE9iamVjdC5gfSk7Y29uc3QgRT17fTtpZighZS5pc1Byb3h5KGkpKXtjb25zdCBDPVsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpKSwuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGkpXTtmb3IoY29uc3QgSSBvZiBDKXtjb25zdCBhPXIoSSksZj1zKGlbSV0pO0VbYV09Zn1yZXR1cm4gRX1jb25zdCBRPVJlZmxlY3Qub3duS2V5cyhpKTtmb3IoY29uc3QgQyBvZiBRKWlmKFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksQyk/LmVudW1lcmFibGUpe2NvbnN0IGE9cihDKSxmPXMoaVtDXSk7RVthXT1mfXJldHVybiBFfX0sbi5pbnRlcmZhY2VDb252ZXJ0ZXI9ZnVuY3Rpb24ocil7cmV0dXJuKHMsaT17fSk9PntpZihpLnN0cmljdCE9PSExJiYhKHMgaW5zdGFuY2VvZiByKSl0aHJvdyBuLmVycm9ycy5leGNlcHRpb24oe2hlYWRlcjpyLm5hbWUsbWVzc2FnZTpgRXhwZWN0ZWQgJHtuLnV0aWwuU3RyaW5naWZ5KHMpfSB0byBiZSBhbiBpbnN0YW5jZSBvZiAke3IubmFtZX0uYH0pO3JldHVybiBzfX0sbi5kaWN0aW9uYXJ5Q29udmVydGVyPWZ1bmN0aW9uKHIpe3JldHVybiBzPT57Y29uc3QgaT1uLnV0aWwuVHlwZShzKSxFPXt9O2lmKGk9PT1cIk51bGxcInx8aT09PVwiVW5kZWZpbmVkXCIpcmV0dXJuIEU7aWYoaSE9PVwiT2JqZWN0XCIpdGhyb3cgbi5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJEaWN0aW9uYXJ5XCIsbWVzc2FnZTpgRXhwZWN0ZWQgJHtzfSB0byBiZSBvbmUgb2Y6IE51bGwsIFVuZGVmaW5lZCwgT2JqZWN0LmB9KTtmb3IoY29uc3QgUSBvZiByKXtjb25zdHtrZXk6QyxkZWZhdWx0VmFsdWU6SSxyZXF1aXJlZDphLGNvbnZlcnRlcjpmfT1RO2lmKGE9PT0hMCYmIU9iamVjdC5oYXNPd24ocyxDKSl0aHJvdyBuLmVycm9ycy5leGNlcHRpb24oe2hlYWRlcjpcIkRpY3Rpb25hcnlcIixtZXNzYWdlOmBNaXNzaW5nIHJlcXVpcmVkIGtleSBcIiR7Q31cIi5gfSk7bGV0IGg9c1tDXTtjb25zdCBMPU9iamVjdC5oYXNPd24oUSxcImRlZmF1bHRWYWx1ZVwiKTtpZihMJiZoIT09bnVsbCYmKGg9aD8/SSksYXx8THx8aCE9PXZvaWQgMCl7aWYoaD1mKGgpLFEuYWxsb3dlZFZhbHVlcyYmIVEuYWxsb3dlZFZhbHVlcy5pbmNsdWRlcyhoKSl0aHJvdyBuLmVycm9ycy5leGNlcHRpb24oe2hlYWRlcjpcIkRpY3Rpb25hcnlcIixtZXNzYWdlOmAke2h9IGlzIG5vdCBhbiBhY2NlcHRlZCB0eXBlLiBFeHBlY3RlZCBvbmUgb2YgJHtRLmFsbG93ZWRWYWx1ZXMuam9pbihcIiwgXCIpfS5gfSk7RVtDXT1ofX1yZXR1cm4gRX19LG4ubnVsbGFibGVDb252ZXJ0ZXI9ZnVuY3Rpb24ocil7cmV0dXJuIHM9PnM9PT1udWxsP3M6cihzKX0sbi5jb252ZXJ0ZXJzLkRPTVN0cmluZz1mdW5jdGlvbihyLHM9e30pe2lmKHI9PT1udWxsJiZzLmxlZ2FjeU51bGxUb0VtcHR5U3RyaW5nKXJldHVyblwiXCI7aWYodHlwZW9mIHI9PVwic3ltYm9sXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvdWxkIG5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgc3ltYm9sIHRvIHN0cmluZy5cIik7cmV0dXJuIFN0cmluZyhyKX0sbi5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmc9ZnVuY3Rpb24ocil7Y29uc3Qgcz1uLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHIpO2ZvcihsZXQgaT0wO2k8cy5sZW5ndGg7aSsrKWlmKHMuY2hhckNvZGVBdChpKT4yNTUpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgdG8gYSBCeXRlU3RyaW5nIGJlY2F1c2UgdGhlIGNoYXJhY3RlciBhdCBpbmRleCAke2l9IGhhcyBhIHZhbHVlIG9mICR7cy5jaGFyQ29kZUF0KGkpfSB3aGljaCBpcyBncmVhdGVyIHRoYW4gMjU1LmApO3JldHVybiBzfSxuLmNvbnZlcnRlcnMuVVNWU3RyaW5nPXQsbi5jb252ZXJ0ZXJzLmJvb2xlYW49ZnVuY3Rpb24ocil7cmV0dXJuISFyfSxuLmNvbnZlcnRlcnMuYW55PWZ1bmN0aW9uKHIpe3JldHVybiByfSxuLmNvbnZlcnRlcnNbXCJsb25nIGxvbmdcIl09ZnVuY3Rpb24ocil7cmV0dXJuIG4udXRpbC5Db252ZXJ0VG9JbnQociw2NCxcInNpZ25lZFwiKX0sbi5jb252ZXJ0ZXJzW1widW5zaWduZWQgbG9uZyBsb25nXCJdPWZ1bmN0aW9uKHIpe3JldHVybiBuLnV0aWwuQ29udmVydFRvSW50KHIsNjQsXCJ1bnNpZ25lZFwiKX0sbi5jb252ZXJ0ZXJzW1widW5zaWduZWQgbG9uZ1wiXT1mdW5jdGlvbihyKXtyZXR1cm4gbi51dGlsLkNvbnZlcnRUb0ludChyLDMyLFwidW5zaWduZWRcIil9LG4uY29udmVydGVyc1tcInVuc2lnbmVkIHNob3J0XCJdPWZ1bmN0aW9uKHIscyl7cmV0dXJuIG4udXRpbC5Db252ZXJ0VG9JbnQociwxNixcInVuc2lnbmVkXCIscyl9LG4uY29udmVydGVycy5BcnJheUJ1ZmZlcj1mdW5jdGlvbihyLHM9e30pe2lmKG4udXRpbC5UeXBlKHIpIT09XCJPYmplY3RcInx8IWUuaXNBbnlBcnJheUJ1ZmZlcihyKSl0aHJvdyBuLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtwcmVmaXg6bi51dGlsLlN0cmluZ2lmeShyKSxhcmd1bWVudDpuLnV0aWwuU3RyaW5naWZ5KHIpLHR5cGVzOltcIkFycmF5QnVmZmVyXCJdfSk7aWYocy5hbGxvd1NoYXJlZD09PSExJiZlLmlzU2hhcmVkQXJyYXlCdWZmZXIocikpdGhyb3cgbi5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJBcnJheUJ1ZmZlclwiLG1lc3NhZ2U6XCJTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC5cIn0pO2lmKHIucmVzaXphYmxlfHxyLmdyb3dhYmxlKXRocm93IG4uZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOlwiQXJyYXlCdWZmZXJcIixtZXNzYWdlOlwiUmVjZWl2ZWQgYSByZXNpemFibGUgQXJyYXlCdWZmZXIuXCJ9KTtyZXR1cm4gcn0sbi5jb252ZXJ0ZXJzLlR5cGVkQXJyYXk9ZnVuY3Rpb24ocixzLGk9e30pe2lmKG4udXRpbC5UeXBlKHIpIT09XCJPYmplY3RcInx8IWUuaXNUeXBlZEFycmF5KHIpfHxyLmNvbnN0cnVjdG9yLm5hbWUhPT1zLm5hbWUpdGhyb3cgbi5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7cHJlZml4OmAke3MubmFtZX1gLGFyZ3VtZW50Om4udXRpbC5TdHJpbmdpZnkociksdHlwZXM6W3MubmFtZV19KTtpZihpLmFsbG93U2hhcmVkPT09ITEmJmUuaXNTaGFyZWRBcnJheUJ1ZmZlcihyLmJ1ZmZlcikpdGhyb3cgbi5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJBcnJheUJ1ZmZlclwiLG1lc3NhZ2U6XCJTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC5cIn0pO2lmKHIuYnVmZmVyLnJlc2l6YWJsZXx8ci5idWZmZXIuZ3Jvd2FibGUpdGhyb3cgbi5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJBcnJheUJ1ZmZlclwiLG1lc3NhZ2U6XCJSZWNlaXZlZCBhIHJlc2l6YWJsZSBBcnJheUJ1ZmZlci5cIn0pO3JldHVybiByfSxuLmNvbnZlcnRlcnMuRGF0YVZpZXc9ZnVuY3Rpb24ocixzPXt9KXtpZihuLnV0aWwuVHlwZShyKSE9PVwiT2JqZWN0XCJ8fCFlLmlzRGF0YVZpZXcocikpdGhyb3cgbi5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJEYXRhVmlld1wiLG1lc3NhZ2U6XCJPYmplY3QgaXMgbm90IGEgRGF0YVZpZXcuXCJ9KTtpZihzLmFsbG93U2hhcmVkPT09ITEmJmUuaXNTaGFyZWRBcnJheUJ1ZmZlcihyLmJ1ZmZlcikpdGhyb3cgbi5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJBcnJheUJ1ZmZlclwiLG1lc3NhZ2U6XCJTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC5cIn0pO2lmKHIuYnVmZmVyLnJlc2l6YWJsZXx8ci5idWZmZXIuZ3Jvd2FibGUpdGhyb3cgbi5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJBcnJheUJ1ZmZlclwiLG1lc3NhZ2U6XCJSZWNlaXZlZCBhIHJlc2l6YWJsZSBBcnJheUJ1ZmZlci5cIn0pO3JldHVybiByfSxuLmNvbnZlcnRlcnMuQnVmZmVyU291cmNlPWZ1bmN0aW9uKHIscz17fSl7aWYoZS5pc0FueUFycmF5QnVmZmVyKHIpKXJldHVybiBuLmNvbnZlcnRlcnMuQXJyYXlCdWZmZXIocix7Li4ucyxhbGxvd1NoYXJlZDohMX0pO2lmKGUuaXNUeXBlZEFycmF5KHIpKXJldHVybiBuLmNvbnZlcnRlcnMuVHlwZWRBcnJheShyLHIuY29uc3RydWN0b3Isey4uLnMsYWxsb3dTaGFyZWQ6ITF9KTtpZihlLmlzRGF0YVZpZXcocikpcmV0dXJuIG4uY29udmVydGVycy5EYXRhVmlldyhyLHMsey4uLnMsYWxsb3dTaGFyZWQ6ITF9KTt0aHJvdyBuZXcgVHlwZUVycm9yKGBDb3VsZCBub3QgY29udmVydCAke24udXRpbC5TdHJpbmdpZnkocil9IHRvIGEgQnVmZmVyU291cmNlLmApfSxuLmNvbnZlcnRlcnNbXCJzZXF1ZW5jZTxCeXRlU3RyaW5nPlwiXT1uLnNlcXVlbmNlQ29udmVydGVyKG4uY29udmVydGVycy5CeXRlU3RyaW5nKSxuLmNvbnZlcnRlcnNbXCJzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj5cIl09bi5zZXF1ZW5jZUNvbnZlcnRlcihuLmNvbnZlcnRlcnNbXCJzZXF1ZW5jZTxCeXRlU3RyaW5nPlwiXSksbi5jb252ZXJ0ZXJzW1wicmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+XCJdPW4ucmVjb3JkQ29udmVydGVyKG4uY29udmVydGVycy5CeXRlU3RyaW5nLG4uY29udmVydGVycy5CeXRlU3RyaW5nKSx3ZWJpZGxfMT17d2ViaWRsOm59LHdlYmlkbF8xfW8ocmVxdWlyZVdlYmlkbCxcInJlcXVpcmVXZWJpZGxcIik7dmFyIHV0aWwkaixoYXNSZXF1aXJlZFV0aWwkNTtmdW5jdGlvbiByZXF1aXJlVXRpbCQ1KCl7aWYoaGFzUmVxdWlyZWRVdGlsJDUpcmV0dXJuIHV0aWwkajtoYXNSZXF1aXJlZFV0aWwkNT0xO2NvbnN0e1RyYW5zZm9ybTplfT1TdHJlYW1fX2RlZmF1bHQsQT16bGliX19kZWZhdWx0LHtyZWRpcmVjdFN0YXR1c1NldDp0LHJlZmVycmVyUG9saWN5U2V0Om4sYmFkUG9ydHNTZXQ6cn09cmVxdWlyZUNvbnN0YW50cyQyKCkse2dldEdsb2JhbE9yaWdpbjpzfT1yZXF1aXJlR2xvYmFsKCkse2NvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHM6aSxjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nOkUscmVtb3ZlQ2hhcnM6USxwYXJzZU1JTUVUeXBlOkN9PXJlcXVpcmVEYXRhVXJsKCkse3BlcmZvcm1hbmNlOkl9PXJlcXVpcmUkJDVfX2RlZmF1bHQse2lzQmxvYkxpa2U6YSxSZWFkYWJsZVN0cmVhbUZyb206Zixpc1ZhbGlkSFRUUFRva2VuOmh9PXV0aWwkbSxMPXJlcXVpcmUkJDBfX2RlZmF1bHQse2lzVWludDhBcnJheTpjfT1yZXF1aXJlJCQ4X19kZWZhdWx0JDEse3dlYmlkbDpsfT1yZXF1aXJlV2ViaWRsKCk7bGV0IFM9W10sazt0cnl7az1yZXF1aXJlKFwibm9kZTpjcnlwdG9cIik7Y29uc3QgeT1bXCJzaGEyNTZcIixcInNoYTM4NFwiLFwic2hhNTEyXCJdO1M9ay5nZXRIYXNoZXMoKS5maWx0ZXIoWT0+eS5pbmNsdWRlcyhZKSl9Y2F0Y2h7fWZ1bmN0aW9uIHcoeSl7Y29uc3QgWT15LnVybExpc3QsVz1ZLmxlbmd0aDtyZXR1cm4gVz09PTA/bnVsbDpZW1ctMV0udG9TdHJpbmcoKX1vKHcsXCJyZXNwb25zZVVSTFwiKTtmdW5jdGlvbiBVKHksWSl7aWYoIXQuaGFzKHkuc3RhdHVzKSlyZXR1cm4gbnVsbDtsZXQgVz15LmhlYWRlcnNMaXN0LmdldChcImxvY2F0aW9uXCIsITApO3JldHVybiBXIT09bnVsbCYmTihXKSYmKE0oVyl8fChXPUIoVykpLFc9bmV3IFVSTChXLHcoeSkpKSxXJiYhVy5oYXNoJiYoVy5oYXNoPVkpLFd9byhVLFwicmVzcG9uc2VMb2NhdGlvblVSTFwiKTtmdW5jdGlvbiBNKHkpe2Zvcihjb25zdCBZIG9mIHkpe2NvbnN0IFc9WS5jaGFyQ29kZUF0KDApO2lmKFc+PTEyOHx8Vz49MCYmVzw9MzF8fFc9PT0xMjcpcmV0dXJuITF9cmV0dXJuITB9byhNLFwiaXNWYWxpZEVuY29kZWRVUkxcIik7ZnVuY3Rpb24gQih5KXtyZXR1cm4gQnVmZmVyLmZyb20oeSxcImJpbmFyeVwiKS50b1N0cmluZyhcInV0ZjhcIil9byhCLFwibm9ybWFsaXplQmluYXJ5U3RyaW5nVG9VdGY4XCIpO2Z1bmN0aW9uIEQoeSl7cmV0dXJuIHkudXJsTGlzdFt5LnVybExpc3QubGVuZ3RoLTFdfW8oRCxcInJlcXVlc3RDdXJyZW50VVJMXCIpO2Z1bmN0aW9uIEcoeSl7Y29uc3QgWT1EKHkpO3JldHVybiBaQShZKSYmci5oYXMoWS5wb3J0KT9cImJsb2NrZWRcIjpcImFsbG93ZWRcIn1vKEcsXCJyZXF1ZXN0QmFkUG9ydFwiKTtmdW5jdGlvbiBnKHkpe3JldHVybiB5IGluc3RhbmNlb2YgRXJyb3J8fHk/LmNvbnN0cnVjdG9yPy5uYW1lPT09XCJFcnJvclwifHx5Py5jb25zdHJ1Y3Rvcj8ubmFtZT09PVwiRE9NRXhjZXB0aW9uXCJ9byhnLFwiaXNFcnJvckxpa2VcIik7ZnVuY3Rpb24gZCh5KXtmb3IobGV0IFk9MDtZPHkubGVuZ3RoOysrWSl7Y29uc3QgVz15LmNoYXJDb2RlQXQoWSk7aWYoIShXPT09OXx8Vz49MzImJlc8PTEyNnx8Vz49MTI4JiZXPD0yNTUpKXJldHVybiExfXJldHVybiEwfW8oZCxcImlzVmFsaWRSZWFzb25QaHJhc2VcIik7Y29uc3QgRj1oO2Z1bmN0aW9uIE4oeSl7cmV0dXJuISh5LnN0YXJ0c1dpdGgoXCJcdFwiKXx8eS5zdGFydHNXaXRoKFwiIFwiKXx8eS5lbmRzV2l0aChcIlx0XCIpfHx5LmVuZHNXaXRoKFwiIFwiKXx8eS5pbmNsdWRlcyhcIlxcMFwiKXx8eS5pbmNsdWRlcyhcIlxcclwiKXx8eS5pbmNsdWRlcyhgXG5gKSl9byhOLFwiaXNWYWxpZEhlYWRlclZhbHVlXCIpO2Z1bmN0aW9uIHUoeSxZKXtjb25zdHtoZWFkZXJzTGlzdDpXfT1ZLGo9KFcuZ2V0KFwicmVmZXJyZXItcG9saWN5XCIsITApPz9cIlwiKS5zcGxpdChcIixcIik7bGV0IG5BPVwiXCI7aWYoai5sZW5ndGg+MClmb3IobGV0IFI9ai5sZW5ndGg7UiE9PTA7Ui0tKXtjb25zdCBPPWpbUi0xXS50cmltKCk7aWYobi5oYXMoTykpe25BPU87YnJlYWt9fW5BIT09XCJcIiYmKHkucmVmZXJyZXJQb2xpY3k9bkEpfW8odSxcInNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3RcIik7ZnVuY3Rpb24gYigpe3JldHVyblwiYWxsb3dlZFwifW8oYixcImNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVja1wiKTtmdW5jdGlvbiBtKCl7cmV0dXJuXCJzdWNjZXNzXCJ9byhtLFwiY29yc0NoZWNrXCIpO2Z1bmN0aW9uIFQoKXtyZXR1cm5cInN1Y2Nlc3NcIn1vKFQsXCJUQU9DaGVja1wiKTtmdW5jdGlvbiB2KHkpe2xldCBZPW51bGw7WT15Lm1vZGUseS5oZWFkZXJzTGlzdC5zZXQoXCJzZWMtZmV0Y2gtbW9kZVwiLFksITApfW8odixcImFwcGVuZEZldGNoTWV0YWRhdGFcIik7ZnVuY3Rpb24gWih5KXtsZXQgWT15Lm9yaWdpbjtpZih5LnJlc3BvbnNlVGFpbnRpbmc9PT1cImNvcnNcInx8eS5tb2RlPT09XCJ3ZWJzb2NrZXRcIilZJiZ5LmhlYWRlcnNMaXN0LmFwcGVuZChcIm9yaWdpblwiLFksITApO2Vsc2UgaWYoeS5tZXRob2QhPT1cIkdFVFwiJiZ5Lm1ldGhvZCE9PVwiSEVBRFwiKXtzd2l0Y2goeS5yZWZlcnJlclBvbGljeSl7Y2FzZVwibm8tcmVmZXJyZXJcIjpZPW51bGw7YnJlYWs7Y2FzZVwibm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGVcIjpjYXNlXCJzdHJpY3Qtb3JpZ2luXCI6Y2FzZVwic3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiOnkub3JpZ2luJiZlZSh5Lm9yaWdpbikmJiFlZShEKHkpKSYmKFk9bnVsbCk7YnJlYWs7Y2FzZVwic2FtZS1vcmlnaW5cIjp5QSh5LEQoeSkpfHwoWT1udWxsKTticmVha31ZJiZ5LmhlYWRlcnNMaXN0LmFwcGVuZChcIm9yaWdpblwiLFksITApfX1vKFosXCJhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyXCIpO2Z1bmN0aW9uIFAoeSxZKXtyZXR1cm4geX1vKFAsXCJjb2Fyc2VuVGltZVwiKTtmdW5jdGlvbiBBQSh5LFksVyl7cmV0dXJuIXk/LnN0YXJ0VGltZXx8eS5zdGFydFRpbWU8WT97ZG9tYWluTG9va3VwU3RhcnRUaW1lOlksZG9tYWluTG9va3VwRW5kVGltZTpZLGNvbm5lY3Rpb25TdGFydFRpbWU6WSxjb25uZWN0aW9uRW5kVGltZTpZLHNlY3VyZUNvbm5lY3Rpb25TdGFydFRpbWU6WSxBTFBOTmVnb3RpYXRlZFByb3RvY29sOnk/LkFMUE5OZWdvdGlhdGVkUHJvdG9jb2x9Ontkb21haW5Mb29rdXBTdGFydFRpbWU6UCh5LmRvbWFpbkxvb2t1cFN0YXJ0VGltZSksZG9tYWluTG9va3VwRW5kVGltZTpQKHkuZG9tYWluTG9va3VwRW5kVGltZSksY29ubmVjdGlvblN0YXJ0VGltZTpQKHkuY29ubmVjdGlvblN0YXJ0VGltZSksY29ubmVjdGlvbkVuZFRpbWU6UCh5LmNvbm5lY3Rpb25FbmRUaW1lKSxzZWN1cmVDb25uZWN0aW9uU3RhcnRUaW1lOlAoeS5zZWN1cmVDb25uZWN0aW9uU3RhcnRUaW1lKSxBTFBOTmVnb3RpYXRlZFByb3RvY29sOnkuQUxQTk5lZ290aWF0ZWRQcm90b2NvbH19byhBQSxcImNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvXCIpO2Z1bmN0aW9uIEsoeSl7cmV0dXJuIFAoSS5ub3coKSl9byhLLFwiY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWVcIik7ZnVuY3Rpb24gdEEoeSl7cmV0dXJue3N0YXJ0VGltZTp5LnN0YXJ0VGltZT8/MCxyZWRpcmVjdFN0YXJ0VGltZTowLHJlZGlyZWN0RW5kVGltZTowLHBvc3RSZWRpcmVjdFN0YXJ0VGltZTp5LnN0YXJ0VGltZT8/MCxmaW5hbFNlcnZpY2VXb3JrZXJTdGFydFRpbWU6MCxmaW5hbE5ldHdvcmtSZXNwb25zZVN0YXJ0VGltZTowLGZpbmFsTmV0d29ya1JlcXVlc3RTdGFydFRpbWU6MCxlbmRUaW1lOjAsZW5jb2RlZEJvZHlTaXplOjAsZGVjb2RlZEJvZHlTaXplOjAsZmluYWxDb25uZWN0aW9uVGltaW5nSW5mbzpudWxsfX1vKHRBLFwiY3JlYXRlT3BhcXVlVGltaW5nSW5mb1wiKTtmdW5jdGlvbiBhQSgpe3JldHVybntyZWZlcnJlclBvbGljeTpcInN0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIn19byhhQSxcIm1ha2VQb2xpY3lDb250YWluZXJcIik7ZnVuY3Rpb24gWCh5KXtyZXR1cm57cmVmZXJyZXJQb2xpY3k6eS5yZWZlcnJlclBvbGljeX19byhYLFwiY2xvbmVQb2xpY3lDb250YWluZXJcIik7ZnVuY3Rpb24gJCh5KXtjb25zdCBZPXkucmVmZXJyZXJQb2xpY3k7TChZKTtsZXQgVz1udWxsO2lmKHkucmVmZXJyZXI9PT1cImNsaWVudFwiKXtjb25zdCBIPXMoKTtpZighSHx8SC5vcmlnaW49PT1cIm51bGxcIilyZXR1cm5cIm5vLXJlZmVycmVyXCI7Vz1uZXcgVVJMKEgpfWVsc2UgeS5yZWZlcnJlciBpbnN0YW5jZW9mIFVSTCYmKFc9eS5yZWZlcnJlcik7bGV0IGo9VihXKTtjb25zdCBuQT1WKFcsITApO2oudG9TdHJpbmcoKS5sZW5ndGg+NDA5NiYmKGo9bkEpO2NvbnN0IFI9eUEoeSxqKSxPPXEoaikmJiFxKHkudXJsKTtzd2l0Y2goWSl7Y2FzZVwib3JpZ2luXCI6cmV0dXJuIG5BPz9WKFcsITApO2Nhc2VcInVuc2FmZS11cmxcIjpyZXR1cm4gajtjYXNlXCJzYW1lLW9yaWdpblwiOnJldHVybiBSP25BOlwibm8tcmVmZXJyZXJcIjtjYXNlXCJvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIjpyZXR1cm4gUj9qOm5BO2Nhc2VcInN0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIjp7Y29uc3QgSD1EKHkpO3JldHVybiB5QShqLEgpP2o6cShqKSYmIXEoSCk/XCJuby1yZWZlcnJlclwiOm5BfWNhc2VcInN0cmljdC1vcmlnaW5cIjpjYXNlXCJuby1yZWZlcnJlci13aGVuLWRvd25ncmFkZVwiOmRlZmF1bHQ6cmV0dXJuIE8/XCJuby1yZWZlcnJlclwiOm5BfX1vKCQsXCJkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyXCIpO2Z1bmN0aW9uIFYoeSxZKXtyZXR1cm4gTCh5IGluc3RhbmNlb2YgVVJMKSx5PW5ldyBVUkwoeSkseS5wcm90b2NvbD09PVwiZmlsZTpcInx8eS5wcm90b2NvbD09PVwiYWJvdXQ6XCJ8fHkucHJvdG9jb2w9PT1cImJsYW5rOlwiP1wibm8tcmVmZXJyZXJcIjooeS51c2VybmFtZT1cIlwiLHkucGFzc3dvcmQ9XCJcIix5Lmhhc2g9XCJcIixZJiYoeS5wYXRobmFtZT1cIlwiLHkuc2VhcmNoPVwiXCIpLHkpfW8oVixcInN0cmlwVVJMRm9yUmVmZXJyZXJcIik7ZnVuY3Rpb24gcSh5KXtpZighKHkgaW5zdGFuY2VvZiBVUkwpKXJldHVybiExO2lmKHkuaHJlZj09PVwiYWJvdXQ6YmxhbmtcInx8eS5ocmVmPT09XCJhYm91dDpzcmNkb2NcInx8eS5wcm90b2NvbD09PVwiZGF0YTpcInx8eS5wcm90b2NvbD09PVwiZmlsZTpcIilyZXR1cm4hMDtyZXR1cm4gWSh5Lm9yaWdpbik7ZnVuY3Rpb24gWShXKXtpZihXPT1udWxsfHxXPT09XCJudWxsXCIpcmV0dXJuITE7Y29uc3Qgaj1uZXcgVVJMKFcpO3JldHVybiEhKGoucHJvdG9jb2w9PT1cImh0dHBzOlwifHxqLnByb3RvY29sPT09XCJ3c3M6XCJ8fC9eMTI3KD86XFwuWzAtOV0rKXswLDJ9XFwuWzAtOV0rJHxeXFxbKD86MCo6KSo/Oj8wKjFcXF0kLy50ZXN0KGouaG9zdG5hbWUpfHxqLmhvc3RuYW1lPT09XCJsb2NhbGhvc3RcInx8ai5ob3N0bmFtZS5pbmNsdWRlcyhcImxvY2FsaG9zdC5cIil8fGouaG9zdG5hbWUuZW5kc1dpdGgoXCIubG9jYWxob3N0XCIpKX19byhxLFwiaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5XCIpO2Z1bmN0aW9uIHooeSxZKXtpZihrPT09dm9pZCAwKXJldHVybiEwO2NvbnN0IFc9aUEoWSk7aWYoVz09PVwibm8gbWV0YWRhdGFcInx8Vy5sZW5ndGg9PT0wKXJldHVybiEwO2NvbnN0IGo9Z0EoVyksbkE9QkEoVyxqKTtmb3IoY29uc3QgUiBvZiBuQSl7Y29uc3QgTz1SLmFsZ28sSD1SLmhhc2g7bGV0IEo9ay5jcmVhdGVIYXNoKE8pLnVwZGF0ZSh5KS5kaWdlc3QoXCJiYXNlNjRcIik7aWYoSltKLmxlbmd0aC0xXT09PVwiPVwiJiYoSltKLmxlbmd0aC0yXT09PVwiPVwiP0o9Si5zbGljZSgwLC0yKTpKPUouc2xpY2UoMCwtMSkpLHNBKEosSCkpcmV0dXJuITB9cmV0dXJuITF9byh6LFwiYnl0ZXNNYXRjaFwiKTtjb25zdCByQT0vKD88YWxnbz5zaGEyNTZ8c2hhMzg0fHNoYTUxMiktKCg/PGhhc2g+W0EtWmEtejAtOSsvXSt8W0EtWmEtejAtOV8tXSspPXswLDJ9KD86XFxzfCQpKCArWyEtfl0qKT8pPy9pO2Z1bmN0aW9uIGlBKHkpe2NvbnN0IFk9W107bGV0IFc9ITA7Zm9yKGNvbnN0IGogb2YgeS5zcGxpdChcIiBcIikpe1c9ITE7Y29uc3QgbkE9ckEuZXhlYyhqKTtpZihuQT09PW51bGx8fG5BLmdyb3Vwcz09PXZvaWQgMHx8bkEuZ3JvdXBzLmFsZ289PT12b2lkIDApY29udGludWU7Y29uc3QgUj1uQS5ncm91cHMuYWxnby50b0xvd2VyQ2FzZSgpO1MuaW5jbHVkZXMoUikmJlkucHVzaChuQS5ncm91cHMpfXJldHVybiBXPT09ITA/XCJubyBtZXRhZGF0YVwiOll9byhpQSxcInBhcnNlTWV0YWRhdGFcIik7ZnVuY3Rpb24gZ0EoeSl7bGV0IFk9eVswXS5hbGdvO2lmKFlbM109PT1cIjVcIilyZXR1cm4gWTtmb3IobGV0IFc9MTtXPHkubGVuZ3RoOysrVyl7Y29uc3Qgaj15W1ddO2lmKGouYWxnb1szXT09PVwiNVwiKXtZPVwic2hhNTEyXCI7YnJlYWt9ZWxzZXtpZihZWzNdPT09XCIzXCIpY29udGludWU7ai5hbGdvWzNdPT09XCIzXCImJihZPVwic2hhMzg0XCIpfX1yZXR1cm4gWX1vKGdBLFwiZ2V0U3Ryb25nZXN0TWV0YWRhdGFcIik7ZnVuY3Rpb24gQkEoeSxZKXtpZih5Lmxlbmd0aD09PTEpcmV0dXJuIHk7bGV0IFc9MDtmb3IobGV0IGo9MDtqPHkubGVuZ3RoOysrail5W2pdLmFsZ289PT1ZJiYoeVtXKytdPXlbal0pO3JldHVybiB5Lmxlbmd0aD1XLHl9byhCQSxcImZpbHRlck1ldGFkYXRhTGlzdEJ5QWxnb3JpdGhtXCIpO2Z1bmN0aW9uIHNBKHksWSl7aWYoeS5sZW5ndGghPT1ZLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IFc9MDtXPHkubGVuZ3RoOysrVylpZih5W1ddIT09WVtXXSl7aWYoeVtXXT09PVwiK1wiJiZZW1ddPT09XCItXCJ8fHlbV109PT1cIi9cIiYmWVtXXT09PVwiX1wiKWNvbnRpbnVlO3JldHVybiExfXJldHVybiEwfW8oc0EsXCJjb21wYXJlQmFzZTY0TWl4ZWRcIik7ZnVuY3Rpb24gZUEoeSl7fW8oZUEsXCJ0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkxcIik7ZnVuY3Rpb24geUEoeSxZKXtyZXR1cm4geS5vcmlnaW49PT1ZLm9yaWdpbiYmeS5vcmlnaW49PT1cIm51bGxcInx8eS5wcm90b2NvbD09PVkucHJvdG9jb2wmJnkuaG9zdG5hbWU9PT1ZLmhvc3RuYW1lJiZ5LnBvcnQ9PT1ZLnBvcnR9byh5QSxcInNhbWVPcmlnaW5cIik7ZnVuY3Rpb24gV0EoKXtsZXQgeSxZO3JldHVybntwcm9taXNlOm5ldyBQcm9taXNlKChqLG5BKT0+e3k9aixZPW5BfSkscmVzb2x2ZTp5LHJlamVjdDpZfX1vKFdBLFwiY3JlYXRlRGVmZXJyZWRQcm9taXNlXCIpO2Z1bmN0aW9uIHdBKHkpe3JldHVybiB5LmNvbnRyb2xsZXIuc3RhdGU9PT1cImFib3J0ZWRcIn1vKHdBLFwiaXNBYm9ydGVkXCIpO2Z1bmN0aW9uIHFBKHkpe3JldHVybiB5LmNvbnRyb2xsZXIuc3RhdGU9PT1cImFib3J0ZWRcInx8eS5jb250cm9sbGVyLnN0YXRlPT09XCJ0ZXJtaW5hdGVkXCJ9byhxQSxcImlzQ2FuY2VsbGVkXCIpO2NvbnN0IE1BPXtkZWxldGU6XCJERUxFVEVcIixERUxFVEU6XCJERUxFVEVcIixnZXQ6XCJHRVRcIixHRVQ6XCJHRVRcIixoZWFkOlwiSEVBRFwiLEhFQUQ6XCJIRUFEXCIsb3B0aW9uczpcIk9QVElPTlNcIixPUFRJT05TOlwiT1BUSU9OU1wiLHBvc3Q6XCJQT1NUXCIsUE9TVDpcIlBPU1RcIixwdXQ6XCJQVVRcIixQVVQ6XCJQVVRcIn0sSEE9ey4uLk1BLHBhdGNoOlwicGF0Y2hcIixQQVRDSDpcIlBBVENIXCJ9O09iamVjdC5zZXRQcm90b3R5cGVPZihNQSxudWxsKSxPYmplY3Quc2V0UHJvdG90eXBlT2YoSEEsbnVsbCk7ZnVuY3Rpb24gcEEoeSl7cmV0dXJuIE1BW3kudG9Mb3dlckNhc2UoKV0/P3l9byhwQSxcIm5vcm1hbGl6ZU1ldGhvZFwiKTtmdW5jdGlvbiBZQSh5KXtjb25zdCBZPUpTT04uc3RyaW5naWZ5KHkpO2lmKFk9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbHVlIGlzIG5vdCBKU09OIHNlcmlhbGl6YWJsZVwiKTtyZXR1cm4gTCh0eXBlb2YgWT09XCJzdHJpbmdcIiksWX1vKFlBLFwic2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nXCIpO2NvbnN0IFVBPU9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSk7ZnVuY3Rpb24gSkEoeSxZLFc9MCxqPTEpe3ZhciBSLE8sSDtjb25zdCBKPWNsYXNzIEp7Y29uc3RydWN0b3IoeCxRQSl7Q0EodGhpcyxSLHZvaWQgMCk7Q0EodGhpcyxPLHZvaWQgMCk7Q0EodGhpcyxILHZvaWQgMCk7RUEodGhpcyxSLHgpLEVBKHRoaXMsTyxRQSksRUEodGhpcyxILDApfW5leHQoKXtpZih0eXBlb2YgdGhpcyE9XCJvYmplY3RcInx8dGhpcz09PW51bGx8fCF5dChSLHRoaXMpKXRocm93IG5ldyBUeXBlRXJyb3IoYCduZXh0JyBjYWxsZWQgb24gYW4gb2JqZWN0IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSAke3l9IEl0ZXJhdG9yLmApO2NvbnN0IHg9cCh0aGlzLEgpLFFBPXAodGhpcyxSKVtZXSxsQT1RQS5sZW5ndGg7aWYoeD49bEEpcmV0dXJue3ZhbHVlOnZvaWQgMCxkb25lOiEwfTtjb25zdHtbV106dUEsW2pdOmNBfT1RQVt4XTtFQSh0aGlzLEgseCsxKTtsZXQgZkE7c3dpdGNoKHAodGhpcyxPKSl7Y2FzZVwia2V5XCI6ZkE9dUE7YnJlYWs7Y2FzZVwidmFsdWVcIjpmQT1jQTticmVhaztjYXNlXCJrZXkrdmFsdWVcIjpmQT1bdUEsY0FdO2JyZWFrfXJldHVybnt2YWx1ZTpmQSxkb25lOiExfX19O1I9bmV3IFdlYWtNYXAsTz1uZXcgV2Vha01hcCxIPW5ldyBXZWFrTWFwLG8oSixcIkZhc3RJdGVyYWJsZUl0ZXJhdG9yXCIpO2xldCBuQT1KO3JldHVybiBkZWxldGUgbkEucHJvdG90eXBlLmNvbnN0cnVjdG9yLE9iamVjdC5zZXRQcm90b3R5cGVPZihuQS5wcm90b3R5cGUsVUEpLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5BLnByb3RvdHlwZSx7W1N5bWJvbC50b1N0cmluZ1RhZ106e3dyaXRhYmxlOiExLGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwLHZhbHVlOmAke3l9IEl0ZXJhdG9yYH0sbmV4dDp7d3JpdGFibGU6ITAsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksZnVuY3Rpb24oXyx4KXtyZXR1cm4gbmV3IG5BKF8seCl9fW8oSkEsXCJjcmVhdGVJdGVyYXRvclwiKTtmdW5jdGlvbiBWQSh5LFksVyxqPTAsbkE9MSl7Y29uc3QgUj1KQSh5LFcsaixuQSksTz17a2V5czp7d3JpdGFibGU6ITAsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsdmFsdWU6byhmdW5jdGlvbigpe3JldHVybiBsLmJyYW5kQ2hlY2sodGhpcyxZKSxSKHRoaXMsXCJrZXlcIil9LFwia2V5c1wiKX0sdmFsdWVzOnt3cml0YWJsZTohMCxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx2YWx1ZTpvKGZ1bmN0aW9uKCl7cmV0dXJuIGwuYnJhbmRDaGVjayh0aGlzLFkpLFIodGhpcyxcInZhbHVlXCIpfSxcInZhbHVlc1wiKX0sZW50cmllczp7d3JpdGFibGU6ITAsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsdmFsdWU6byhmdW5jdGlvbigpe3JldHVybiBsLmJyYW5kQ2hlY2sodGhpcyxZKSxSKHRoaXMsXCJrZXkrdmFsdWVcIil9LFwiZW50cmllc1wiKX0sZm9yRWFjaDp7d3JpdGFibGU6ITAsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsdmFsdWU6byhmdW5jdGlvbihKLF89Z2xvYmFsVGhpcyl7aWYobC5icmFuZENoZWNrKHRoaXMsWSksbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6YCR7eX0uZm9yRWFjaGB9KSx0eXBlb2YgSiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICdmb3JFYWNoJyBvbiAnJHt5fSc6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdGdW5jdGlvbicuYCk7Zm9yKGNvbnN0ezA6eCwxOlFBfW9mIFIodGhpcyxcImtleSt2YWx1ZVwiKSlKLmNhbGwoXyxRQSx4LHRoaXMpfSxcImZvckVhY2hcIil9fTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoWS5wcm90b3R5cGUsey4uLk8sW1N5bWJvbC5pdGVyYXRvcl06e3dyaXRhYmxlOiEwLGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwLHZhbHVlOk8uZW50cmllcy52YWx1ZX19KX1vKFZBLFwiaXRlcmF0b3JNaXhpblwiKTthc3luYyBmdW5jdGlvbiBPQSh5LFksVyl7Y29uc3Qgaj1ZLG5BPVc7bGV0IFI7dHJ5e1I9eS5zdHJlYW0uZ2V0UmVhZGVyKCl9Y2F0Y2goTyl7bkEoTyk7cmV0dXJufXRyeXtjb25zdCBPPWF3YWl0IFBBKFIpO2ooTyl9Y2F0Y2goTyl7bkEoTyl9fW8oT0EsXCJmdWxseVJlYWRCb2R5XCIpO2Z1bmN0aW9uIElBKHkpe3JldHVybiB5IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW18fHlbU3ltYm9sLnRvU3RyaW5nVGFnXT09PVwiUmVhZGFibGVTdHJlYW1cIiYmdHlwZW9mIHkudGVlPT1cImZ1bmN0aW9uXCJ9byhJQSxcImlzUmVhZGFibGVTdHJlYW1MaWtlXCIpO2Z1bmN0aW9uIGhBKHkpe3RyeXt5LmNsb3NlKCkseS5ieW9iUmVxdWVzdD8ucmVzcG9uZCgwKX1jYXRjaChZKXtpZighWS5tZXNzYWdlLmluY2x1ZGVzKFwiQ29udHJvbGxlciBpcyBhbHJlYWR5IGNsb3NlZFwiKSYmIVkubWVzc2FnZS5pbmNsdWRlcyhcIlJlYWRhYmxlU3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkXCIpKXRocm93IFl9fW8oaEEsXCJyZWFkYWJsZVN0cmVhbUNsb3NlXCIpO2Z1bmN0aW9uIFNBKHkpe2ZvcihsZXQgWT0wO1k8eS5sZW5ndGg7WSsrKUwoeS5jaGFyQ29kZUF0KFkpPD0yNTUpO3JldHVybiB5fW8oU0EsXCJpc29tb3JwaGljRW5jb2RlXCIpO2FzeW5jIGZ1bmN0aW9uIFBBKHkpe2NvbnN0IFk9W107bGV0IFc9MDtmb3IoOzspe2NvbnN0e2RvbmU6aix2YWx1ZTpuQX09YXdhaXQgeS5yZWFkKCk7aWYoailyZXR1cm4gQnVmZmVyLmNvbmNhdChZLFcpO2lmKCFjKG5BKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmVjZWl2ZWQgbm9uLVVpbnQ4QXJyYXkgY2h1bmtcIik7WS5wdXNoKG5BKSxXKz1uQS5sZW5ndGh9fW8oUEEsXCJyZWFkQWxsQnl0ZXNcIik7ZnVuY3Rpb24gUGUoeSl7TChcInByb3RvY29sXCJpbiB5KTtjb25zdCBZPXkucHJvdG9jb2w7cmV0dXJuIFk9PT1cImFib3V0OlwifHxZPT09XCJibG9iOlwifHxZPT09XCJkYXRhOlwifW8oUGUsXCJ1cmxJc0xvY2FsXCIpO2Z1bmN0aW9uIGVlKHkpe3JldHVybiB0eXBlb2YgeT09XCJzdHJpbmdcIj95LnN0YXJ0c1dpdGgoXCJodHRwczpcIik6eS5wcm90b2NvbD09PVwiaHR0cHM6XCJ9byhlZSxcInVybEhhc0h0dHBzU2NoZW1lXCIpO2Z1bmN0aW9uIFpBKHkpe0woXCJwcm90b2NvbFwiaW4geSk7Y29uc3QgWT15LnByb3RvY29sO3JldHVybiBZPT09XCJodHRwOlwifHxZPT09XCJodHRwczpcIn1vKFpBLFwidXJsSXNIdHRwSHR0cHNTY2hlbWVcIik7ZnVuY3Rpb24gWEEoeSxZKXtjb25zdCBXPXk7aWYoIVcuc3RhcnRzV2l0aChcImJ5dGVzXCIpKXJldHVyblwiZmFpbHVyZVwiO2NvbnN0IGo9e3Bvc2l0aW9uOjV9O2lmKFkmJmkoSj0+Sj09PVwiXHRcInx8Sj09PVwiIFwiLFcsaiksVy5jaGFyQ29kZUF0KGoucG9zaXRpb24pIT09NjEpcmV0dXJuXCJmYWlsdXJlXCI7ai5wb3NpdGlvbisrLFkmJmkoSj0+Sj09PVwiXHRcInx8Sj09PVwiIFwiLFcsaik7Y29uc3QgbkE9aShKPT57Y29uc3QgXz1KLmNoYXJDb2RlQXQoMCk7cmV0dXJuIF8+PTQ4JiZfPD01N30sVyxqKSxSPW5BLmxlbmd0aD9OdW1iZXIobkEpOm51bGw7aWYoWSYmaShKPT5KPT09XCJcdFwifHxKPT09XCIgXCIsVyxqKSxXLmNoYXJDb2RlQXQoai5wb3NpdGlvbikhPT00NSlyZXR1cm5cImZhaWx1cmVcIjtqLnBvc2l0aW9uKyssWSYmaShKPT5KPT09XCJcdFwifHxKPT09XCIgXCIsVyxqKTtjb25zdCBPPWkoSj0+e2NvbnN0IF89Si5jaGFyQ29kZUF0KDApO3JldHVybiBfPj00OCYmXzw9NTd9LFcsaiksSD1PLmxlbmd0aD9OdW1iZXIoTyk6bnVsbDtyZXR1cm4gai5wb3NpdGlvbjxXLmxlbmd0aHx8SD09PW51bGwmJlI9PT1udWxsfHxSPkg/XCJmYWlsdXJlXCI6e3JhbmdlU3RhcnRWYWx1ZTpSLHJhbmdlRW5kVmFsdWU6SH19byhYQSxcInNpbXBsZVJhbmdlSGVhZGVyVmFsdWVcIik7ZnVuY3Rpb24gWmUoeSxZLFcpe2xldCBqPVwiYnl0ZXMgXCI7cmV0dXJuIGorPVNBKGAke3l9YCksais9XCItXCIsais9U0EoYCR7WX1gKSxqKz1cIi9cIixqKz1TQShgJHtXfWApLGp9byhaZSxcImJ1aWxkQ29udGVudFJhbmdlXCIpO2NvbnN0IHZBPWNsYXNzIHZBIGV4dGVuZHMgZXtfdHJhbnNmb3JtKFksVyxqKXtpZighdGhpcy5faW5mbGF0ZVN0cmVhbSl7aWYoWS5sZW5ndGg9PT0wKXtqKCk7cmV0dXJufXRoaXMuX2luZmxhdGVTdHJlYW09KFlbMF0mMTUpPT09OD9BLmNyZWF0ZUluZmxhdGUoKTpBLmNyZWF0ZUluZmxhdGVSYXcoKSx0aGlzLl9pbmZsYXRlU3RyZWFtLm9uKFwiZGF0YVwiLHRoaXMucHVzaC5iaW5kKHRoaXMpKSx0aGlzLl9pbmZsYXRlU3RyZWFtLm9uKFwiZW5kXCIsKCk9PnRoaXMucHVzaChudWxsKSksdGhpcy5faW5mbGF0ZVN0cmVhbS5vbihcImVycm9yXCIsbkE9PnRoaXMuZGVzdHJveShuQSkpfXRoaXMuX2luZmxhdGVTdHJlYW0ud3JpdGUoWSxXLGopfV9maW5hbChZKXt0aGlzLl9pbmZsYXRlU3RyZWFtJiYodGhpcy5faW5mbGF0ZVN0cmVhbS5lbmQoKSx0aGlzLl9pbmZsYXRlU3RyZWFtPW51bGwpLFkoKX19O28odkEsXCJJbmZsYXRlU3RyZWFtXCIpO2xldCBLQT12QTtmdW5jdGlvbiBIZSgpe3JldHVybiBuZXcgS0F9byhIZSxcImNyZWF0ZUluZmxhdGVcIik7ZnVuY3Rpb24gdGUoeSl7bGV0IFk9bnVsbCxXPW51bGwsaj1udWxsO2NvbnN0IG5BPXJlKFwiY29udGVudC10eXBlXCIseSk7aWYobkE9PT1udWxsKXJldHVyblwiZmFpbHVyZVwiO2Zvcihjb25zdCBSIG9mIG5BKXtjb25zdCBPPUMoUik7Tz09PVwiZmFpbHVyZVwifHxPLmVzc2VuY2U9PT1cIiovKlwifHwoaj1PLGouZXNzZW5jZSE9PVc/KFk9bnVsbCxqLnBhcmFtZXRlcnMuaGFzKFwiY2hhcnNldFwiKSYmKFk9ai5wYXJhbWV0ZXJzLmdldChcImNoYXJzZXRcIikpLFc9ai5lc3NlbmNlKTohai5wYXJhbWV0ZXJzLmhhcyhcImNoYXJzZXRcIikmJlkhPT1udWxsJiZqLnBhcmFtZXRlcnMuc2V0KFwiY2hhcnNldFwiLFkpKX1yZXR1cm4gaj8/XCJmYWlsdXJlXCJ9byh0ZSxcImV4dHJhY3RNaW1lVHlwZVwiKTtmdW5jdGlvbiBWZSh5KXtjb25zdCBZPXksVz17cG9zaXRpb246MH0saj1bXTtsZXQgbkE9XCJcIjtmb3IoO1cucG9zaXRpb248WS5sZW5ndGg7KXtpZihuQSs9aShSPT5SIT09J1wiJyYmUiE9PVwiLFwiLFksVyksVy5wb3NpdGlvbjxZLmxlbmd0aClpZihZLmNoYXJDb2RlQXQoVy5wb3NpdGlvbik9PT0zNCl7aWYobkErPUUoWSxXKSxXLnBvc2l0aW9uPFkubGVuZ3RoKWNvbnRpbnVlfWVsc2UgTChZLmNoYXJDb2RlQXQoVy5wb3NpdGlvbik9PT00NCksVy5wb3NpdGlvbisrO25BPVEobkEsITAsITAsUj0+Uj09PTl8fFI9PT0zMiksai5wdXNoKG5BKSxuQT1cIlwifXJldHVybiBqfW8oVmUsXCJnZXR0aW5nRGVjb2RpbmdTcGxpdHRpbmdcIik7ZnVuY3Rpb24gcmUoeSxZKXtjb25zdCBXPVkuZ2V0KHksITApO3JldHVybiBXPT09bnVsbD9udWxsOlZlKFcpfW8ocmUsXCJnZXREZWNvZGVTcGxpdFwiKTtjb25zdCB2ZT1uZXcgVGV4dERlY29kZXI7ZnVuY3Rpb24gWGUoeSl7cmV0dXJuIHkubGVuZ3RoPT09MD9cIlwiOih5WzBdPT09MjM5JiZ5WzFdPT09MTg3JiZ5WzJdPT09MTkxJiYoeT15LnN1YmFycmF5KDMpKSx2ZS5kZWNvZGUoeSkpfXJldHVybiBvKFhlLFwidXRmOERlY29kZUJ5dGVzXCIpLHV0aWwkaj17aXNBYm9ydGVkOndBLGlzQ2FuY2VsbGVkOnFBLGNyZWF0ZURlZmVycmVkUHJvbWlzZTpXQSxSZWFkYWJsZVN0cmVhbUZyb206Zix0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkw6ZUEsY2xhbXBBbmRDb2Fyc2VuQ29ubmVjdGlvblRpbWluZ0luZm86QUEsY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWU6SyxkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyOiQsbWFrZVBvbGljeUNvbnRhaW5lcjphQSxjbG9uZVBvbGljeUNvbnRhaW5lcjpYLGFwcGVuZEZldGNoTWV0YWRhdGE6dixhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyOlosVEFPQ2hlY2s6VCxjb3JzQ2hlY2s6bSxjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2s6YixjcmVhdGVPcGFxdWVUaW1pbmdJbmZvOnRBLHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3Q6dSxpc1ZhbGlkSFRUUFRva2VuOmgscmVxdWVzdEJhZFBvcnQ6RyxyZXF1ZXN0Q3VycmVudFVSTDpELHJlc3BvbnNlVVJMOncscmVzcG9uc2VMb2NhdGlvblVSTDpVLGlzQmxvYkxpa2U6YSxpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHk6cSxpc1ZhbGlkUmVhc29uUGhyYXNlOmQsc2FtZU9yaWdpbjp5QSxub3JtYWxpemVNZXRob2Q6cEEsc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nOllBLGl0ZXJhdG9yTWl4aW46VkEsY3JlYXRlSXRlcmF0b3I6SkEsaXNWYWxpZEhlYWRlck5hbWU6Rixpc1ZhbGlkSGVhZGVyVmFsdWU6Tixpc0Vycm9yTGlrZTpnLGZ1bGx5UmVhZEJvZHk6T0EsYnl0ZXNNYXRjaDp6LGlzUmVhZGFibGVTdHJlYW1MaWtlOklBLHJlYWRhYmxlU3RyZWFtQ2xvc2U6aEEsaXNvbW9ycGhpY0VuY29kZTpTQSx1cmxJc0xvY2FsOlBlLHVybEhhc0h0dHBzU2NoZW1lOmVlLHVybElzSHR0cEh0dHBzU2NoZW1lOlpBLHJlYWRBbGxCeXRlczpQQSxub3JtYWxpemVNZXRob2RSZWNvcmQ6SEEsc2ltcGxlUmFuZ2VIZWFkZXJWYWx1ZTpYQSxidWlsZENvbnRlbnRSYW5nZTpaZSxwYXJzZU1ldGFkYXRhOmlBLGNyZWF0ZUluZmxhdGU6SGUsZXh0cmFjdE1pbWVUeXBlOnRlLGdldERlY29kZVNwbGl0OnJlLHV0ZjhEZWNvZGVCeXRlczpYZX0sdXRpbCRqfW8ocmVxdWlyZVV0aWwkNSxcInJlcXVpcmVVdGlsJDVcIik7dmFyIHN5bWJvbHMkMyxoYXNSZXF1aXJlZFN5bWJvbHMkMztmdW5jdGlvbiByZXF1aXJlU3ltYm9scyQzKCl7cmV0dXJuIGhhc1JlcXVpcmVkU3ltYm9scyQzfHwoaGFzUmVxdWlyZWRTeW1ib2xzJDM9MSxzeW1ib2xzJDM9e2tVcmw6U3ltYm9sKFwidXJsXCIpLGtIZWFkZXJzOlN5bWJvbChcImhlYWRlcnNcIiksa1NpZ25hbDpTeW1ib2woXCJzaWduYWxcIiksa1N0YXRlOlN5bWJvbChcInN0YXRlXCIpLGtHdWFyZDpTeW1ib2woXCJndWFyZFwiKSxrUmVhbG06U3ltYm9sKFwicmVhbG1cIiksa0Rpc3BhdGNoZXI6U3ltYm9sKFwiZGlzcGF0Y2hlclwiKX0pLHN5bWJvbHMkM31vKHJlcXVpcmVTeW1ib2xzJDMsXCJyZXF1aXJlU3ltYm9scyQzXCIpO3ZhciBmaWxlLGhhc1JlcXVpcmVkRmlsZTtmdW5jdGlvbiByZXF1aXJlRmlsZSgpe2lmKGhhc1JlcXVpcmVkRmlsZSlyZXR1cm4gZmlsZTtoYXNSZXF1aXJlZEZpbGU9MTtjb25zdHtFT0w6ZX09cmVxdWlyZSQkMF9fZGVmYXVsdCQ0LHtCbG9iOkEsRmlsZTp0fT1yZXF1aXJlJCQ2X19kZWZhdWx0LHt0eXBlczpufT1yZXF1aXJlJCQwX19kZWZhdWx0JDEse2tTdGF0ZTpyfT1yZXF1aXJlU3ltYm9scyQzKCkse2lzQmxvYkxpa2U6c309cmVxdWlyZVV0aWwkNSgpLHt3ZWJpZGw6aX09cmVxdWlyZVdlYmlkbCgpLHtwYXJzZU1JTUVUeXBlOkUsc2VyaWFsaXplQU1pbWVUeXBlOlF9PXJlcXVpcmVEYXRhVXJsKCkse2tFbnVtZXJhYmxlUHJvcGVydHk6Q309dXRpbCRtLEk9bmV3IFRleHRFbmNvZGVyLGw9Y2xhc3MgbCBleHRlbmRzIEF7Y29uc3RydWN0b3IodyxVLE09e30pe2kuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMix7aGVhZGVyOlwiRmlsZSBjb25zdHJ1Y3RvclwifSksdz1pLmNvbnZlcnRlcnNbXCJzZXF1ZW5jZTxCbG9iUGFydD5cIl0odyksVT1pLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFUpLE09aS5jb252ZXJ0ZXJzLkZpbGVQcm9wZXJ0eUJhZyhNKTtjb25zdCBCPVU7bGV0IEQ9TS50eXBlLEc7QTp7aWYoRCl7aWYoRD1FKEQpLEQ9PT1cImZhaWx1cmVcIil7RD1cIlwiO2JyZWFrIEF9RD1RKEQpLnRvTG93ZXJDYXNlKCl9Rz1NLmxhc3RNb2RpZmllZH1zdXBlcihoKHcsTSkse3R5cGU6RH0pLHRoaXNbcl09e25hbWU6QixsYXN0TW9kaWZpZWQ6Ryx0eXBlOkR9fWdldCBuYW1lKCl7cmV0dXJuIGkuYnJhbmRDaGVjayh0aGlzLGwpLHRoaXNbcl0ubmFtZX1nZXQgbGFzdE1vZGlmaWVkKCl7cmV0dXJuIGkuYnJhbmRDaGVjayh0aGlzLGwpLHRoaXNbcl0ubGFzdE1vZGlmaWVkfWdldCB0eXBlKCl7cmV0dXJuIGkuYnJhbmRDaGVjayh0aGlzLGwpLHRoaXNbcl0udHlwZX19O28obCxcIkZpbGVcIik7bGV0IGE9bDtjb25zdCBTPWNsYXNzIFN7Y29uc3RydWN0b3IodyxVLE09e30pe2NvbnN0IEI9VSxEPU0udHlwZSxHPU0ubGFzdE1vZGlmaWVkPz9EYXRlLm5vdygpO3RoaXNbcl09e2Jsb2JMaWtlOncsbmFtZTpCLHR5cGU6RCxsYXN0TW9kaWZpZWQ6R319c3RyZWFtKC4uLncpe3JldHVybiBpLmJyYW5kQ2hlY2sodGhpcyxTKSx0aGlzW3JdLmJsb2JMaWtlLnN0cmVhbSguLi53KX1hcnJheUJ1ZmZlciguLi53KXtyZXR1cm4gaS5icmFuZENoZWNrKHRoaXMsUyksdGhpc1tyXS5ibG9iTGlrZS5hcnJheUJ1ZmZlciguLi53KX1zbGljZSguLi53KXtyZXR1cm4gaS5icmFuZENoZWNrKHRoaXMsUyksdGhpc1tyXS5ibG9iTGlrZS5zbGljZSguLi53KX10ZXh0KC4uLncpe3JldHVybiBpLmJyYW5kQ2hlY2sodGhpcyxTKSx0aGlzW3JdLmJsb2JMaWtlLnRleHQoLi4udyl9Z2V0IHNpemUoKXtyZXR1cm4gaS5icmFuZENoZWNrKHRoaXMsUyksdGhpc1tyXS5ibG9iTGlrZS5zaXplfWdldCB0eXBlKCl7cmV0dXJuIGkuYnJhbmRDaGVjayh0aGlzLFMpLHRoaXNbcl0uYmxvYkxpa2UudHlwZX1nZXQgbmFtZSgpe3JldHVybiBpLmJyYW5kQ2hlY2sodGhpcyxTKSx0aGlzW3JdLm5hbWV9Z2V0IGxhc3RNb2RpZmllZCgpe3JldHVybiBpLmJyYW5kQ2hlY2sodGhpcyxTKSx0aGlzW3JdLmxhc3RNb2RpZmllZH1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVyblwiRmlsZVwifX07byhTLFwiRmlsZUxpa2VcIik7bGV0IGY9UztPYmplY3QuZGVmaW5lUHJvcGVydGllcyhhLnByb3RvdHlwZSx7W1N5bWJvbC50b1N0cmluZ1RhZ106e3ZhbHVlOlwiRmlsZVwiLGNvbmZpZ3VyYWJsZTohMH0sbmFtZTpDLGxhc3RNb2RpZmllZDpDfSksaS5jb252ZXJ0ZXJzLkJsb2I9aS5pbnRlcmZhY2VDb252ZXJ0ZXIoQSksaS5jb252ZXJ0ZXJzLkJsb2JQYXJ0PWZ1bmN0aW9uKGssdyl7aWYoaS51dGlsLlR5cGUoayk9PT1cIk9iamVjdFwiKXtpZihzKGspKXJldHVybiBpLmNvbnZlcnRlcnMuQmxvYihrLHtzdHJpY3Q6ITF9KTtpZihBcnJheUJ1ZmZlci5pc1ZpZXcoayl8fG4uaXNBbnlBcnJheUJ1ZmZlcihrKSlyZXR1cm4gaS5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShrLHcpfXJldHVybiBpLmNvbnZlcnRlcnMuVVNWU3RyaW5nKGssdyl9LGkuY29udmVydGVyc1tcInNlcXVlbmNlPEJsb2JQYXJ0PlwiXT1pLnNlcXVlbmNlQ29udmVydGVyKGkuY29udmVydGVycy5CbG9iUGFydCksaS5jb252ZXJ0ZXJzLkZpbGVQcm9wZXJ0eUJhZz1pLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW3trZXk6XCJsYXN0TW9kaWZpZWRcIixjb252ZXJ0ZXI6aS5jb252ZXJ0ZXJzW1wibG9uZyBsb25nXCJdLGdldCBkZWZhdWx0VmFsdWUoKXtyZXR1cm4gRGF0ZS5ub3coKX19LHtrZXk6XCJ0eXBlXCIsY29udmVydGVyOmkuY29udmVydGVycy5ET01TdHJpbmcsZGVmYXVsdFZhbHVlOlwiXCJ9LHtrZXk6XCJlbmRpbmdzXCIsY29udmVydGVyOms9PihrPWkuY29udmVydGVycy5ET01TdHJpbmcoayksaz1rLnRvTG93ZXJDYXNlKCksayE9PVwibmF0aXZlXCImJihrPVwidHJhbnNwYXJlbnRcIiksayksZGVmYXVsdFZhbHVlOlwidHJhbnNwYXJlbnRcIn1dKTtmdW5jdGlvbiBoKGssdyl7Y29uc3QgVT1bXTtmb3IoY29uc3QgTSBvZiBrKWlmKHR5cGVvZiBNPT1cInN0cmluZ1wiKXtsZXQgQj1NO3cuZW5kaW5ncz09PVwibmF0aXZlXCImJihCPUwoQikpLFUucHVzaChJLmVuY29kZShCKSl9ZWxzZSBBcnJheUJ1ZmZlci5pc1ZpZXcoTSl8fG4uaXNBcnJheUJ1ZmZlcihNKT9NLmJ1ZmZlcj9VLnB1c2gobmV3IFVpbnQ4QXJyYXkoTS5idWZmZXIsTS5ieXRlT2Zmc2V0LE0uYnl0ZUxlbmd0aCkpOlUucHVzaChuZXcgVWludDhBcnJheShNKSk6cyhNKSYmVS5wdXNoKE0pO3JldHVybiBVfW8oaCxcInByb2Nlc3NCbG9iUGFydHNcIik7ZnVuY3Rpb24gTChrKXtyZXR1cm4gay5yZXBsYWNlKC9cXHI/XFxuL2csZSl9byhMLFwiY29udmVydExpbmVFbmRpbmdzTmF0aXZlXCIpO2Z1bmN0aW9uIGMoayl7cmV0dXJuIHQmJmsgaW5zdGFuY2VvZiB0fHxrIGluc3RhbmNlb2YgYXx8ayYmKHR5cGVvZiBrLnN0cmVhbT09XCJmdW5jdGlvblwifHx0eXBlb2Ygay5hcnJheUJ1ZmZlcj09XCJmdW5jdGlvblwiKSYma1tTeW1ib2wudG9TdHJpbmdUYWddPT09XCJGaWxlXCJ9cmV0dXJuIG8oYyxcImlzRmlsZUxpa2VcIiksZmlsZT17RmlsZTphLEZpbGVMaWtlOmYsaXNGaWxlTGlrZTpjfSxmaWxlfW8ocmVxdWlyZUZpbGUsXCJyZXF1aXJlRmlsZVwiKTt2YXIgZm9ybWRhdGEsaGFzUmVxdWlyZWRGb3JtZGF0YTtmdW5jdGlvbiByZXF1aXJlRm9ybWRhdGEoKXtpZihoYXNSZXF1aXJlZEZvcm1kYXRhKXJldHVybiBmb3JtZGF0YTtoYXNSZXF1aXJlZEZvcm1kYXRhPTE7Y29uc3R7aXNCbG9iTGlrZTplLGl0ZXJhdG9yTWl4aW46QX09cmVxdWlyZVV0aWwkNSgpLHtrU3RhdGU6dH09cmVxdWlyZVN5bWJvbHMkMygpLHtrRW51bWVyYWJsZVByb3BlcnR5Om59PXV0aWwkbSx7RmlsZTpyLEZpbGVMaWtlOnMsaXNGaWxlTGlrZTppfT1yZXF1aXJlRmlsZSgpLHt3ZWJpZGw6RX09cmVxdWlyZVdlYmlkbCgpLHtGaWxlOlF9PXJlcXVpcmUkJDZfX2RlZmF1bHQsQz1yZXF1aXJlJCQwX19kZWZhdWx0JDEsST1RPz9yLGg9Y2xhc3MgaHtjb25zdHJ1Y3RvcihjKXtpZihjIT09dm9pZCAwKXRocm93IEUuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe3ByZWZpeDpcIkZvcm1EYXRhIGNvbnN0cnVjdG9yXCIsYXJndW1lbnQ6XCJBcmd1bWVudCAxXCIsdHlwZXM6W1widW5kZWZpbmVkXCJdfSk7dGhpc1t0XT1bXX1hcHBlbmQoYyxsLFM9dm9pZCAwKXtpZihFLmJyYW5kQ2hlY2sodGhpcyxoKSxFLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLDIse2hlYWRlcjpcIkZvcm1EYXRhLmFwcGVuZFwifSksYXJndW1lbnRzLmxlbmd0aD09PTMmJiFlKGwpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnYXBwZW5kJyBvbiAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMiBpcyBub3Qgb2YgdHlwZSAnQmxvYidcIik7Yz1FLmNvbnZlcnRlcnMuVVNWU3RyaW5nKGMpLGw9ZShsKT9FLmNvbnZlcnRlcnMuQmxvYihsLHtzdHJpY3Q6ITF9KTpFLmNvbnZlcnRlcnMuVVNWU3RyaW5nKGwpLFM9YXJndW1lbnRzLmxlbmd0aD09PTM/RS5jb252ZXJ0ZXJzLlVTVlN0cmluZyhTKTp2b2lkIDA7Y29uc3Qgaz1mKGMsbCxTKTt0aGlzW3RdLnB1c2goayl9ZGVsZXRlKGMpe0UuYnJhbmRDaGVjayh0aGlzLGgpLEUuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMSx7aGVhZGVyOlwiRm9ybURhdGEuZGVsZXRlXCJ9KSxjPUUuY29udmVydGVycy5VU1ZTdHJpbmcoYyksdGhpc1t0XT10aGlzW3RdLmZpbHRlcihsPT5sLm5hbWUhPT1jKX1nZXQoYyl7RS5icmFuZENoZWNrKHRoaXMsaCksRS5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6XCJGb3JtRGF0YS5nZXRcIn0pLGM9RS5jb252ZXJ0ZXJzLlVTVlN0cmluZyhjKTtjb25zdCBsPXRoaXNbdF0uZmluZEluZGV4KFM9PlMubmFtZT09PWMpO3JldHVybiBsPT09LTE/bnVsbDp0aGlzW3RdW2xdLnZhbHVlfWdldEFsbChjKXtyZXR1cm4gRS5icmFuZENoZWNrKHRoaXMsaCksRS5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6XCJGb3JtRGF0YS5nZXRBbGxcIn0pLGM9RS5jb252ZXJ0ZXJzLlVTVlN0cmluZyhjKSx0aGlzW3RdLmZpbHRlcihsPT5sLm5hbWU9PT1jKS5tYXAobD0+bC52YWx1ZSl9aGFzKGMpe3JldHVybiBFLmJyYW5kQ2hlY2sodGhpcyxoKSxFLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLDEse2hlYWRlcjpcIkZvcm1EYXRhLmhhc1wifSksYz1FLmNvbnZlcnRlcnMuVVNWU3RyaW5nKGMpLHRoaXNbdF0uZmluZEluZGV4KGw9PmwubmFtZT09PWMpIT09LTF9c2V0KGMsbCxTPXZvaWQgMCl7aWYoRS5icmFuZENoZWNrKHRoaXMsaCksRS5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywyLHtoZWFkZXI6XCJGb3JtRGF0YS5zZXRcIn0pLGFyZ3VtZW50cy5sZW5ndGg9PT0zJiYhZShsKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ3NldCcgb24gJ0Zvcm1EYXRhJzogcGFyYW1ldGVyIDIgaXMgbm90IG9mIHR5cGUgJ0Jsb2InXCIpO2M9RS5jb252ZXJ0ZXJzLlVTVlN0cmluZyhjKSxsPWUobCk/RS5jb252ZXJ0ZXJzLkJsb2IobCx7c3RyaWN0OiExfSk6RS5jb252ZXJ0ZXJzLlVTVlN0cmluZyhsKSxTPWFyZ3VtZW50cy5sZW5ndGg9PT0zP0UuY29udmVydGVycy5VU1ZTdHJpbmcoUyk6dm9pZCAwO2NvbnN0IGs9ZihjLGwsUyksdz10aGlzW3RdLmZpbmRJbmRleChVPT5VLm5hbWU9PT1jKTt3IT09LTE/dGhpc1t0XT1bLi4udGhpc1t0XS5zbGljZSgwLHcpLGssLi4udGhpc1t0XS5zbGljZSh3KzEpLmZpbHRlcihVPT5VLm5hbWUhPT1jKV06dGhpc1t0XS5wdXNoKGspfVtDLmluc3BlY3QuY3VzdG9tXShjLGwpe2NvbnN0IFM9dGhpc1t0XS5yZWR1Y2UoKHcsVSk9Pih3W1UubmFtZV0/QXJyYXkuaXNBcnJheSh3W1UubmFtZV0pP3dbVS5uYW1lXS5wdXNoKFUudmFsdWUpOndbVS5uYW1lXT1bd1tVLm5hbWVdLFUudmFsdWVdOndbVS5uYW1lXT1VLnZhbHVlLHcpLHtfX3Byb3RvX186bnVsbH0pO2wuZGVwdGg/PyhsLmRlcHRoPWMpLGwuY29sb3JzPz8obC5jb2xvcnM9ITApO2NvbnN0IGs9Qy5mb3JtYXRXaXRoT3B0aW9ucyhsLFMpO3JldHVybmBGb3JtRGF0YSAke2suc2xpY2Uoay5pbmRleE9mKFwiXVwiKSsyKX1gfX07byhoLFwiRm9ybURhdGFcIik7bGV0IGE9aDtBKFwiRm9ybURhdGFcIixhLHQsXCJuYW1lXCIsXCJ2YWx1ZVwiKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhhLnByb3RvdHlwZSx7YXBwZW5kOm4sZGVsZXRlOm4sZ2V0Om4sZ2V0QWxsOm4saGFzOm4sc2V0Om4sW1N5bWJvbC50b1N0cmluZ1RhZ106e3ZhbHVlOlwiRm9ybURhdGFcIixjb25maWd1cmFibGU6ITB9fSk7ZnVuY3Rpb24gZihMLGMsbCl7aWYodHlwZW9mIGMhPVwic3RyaW5nXCIpe2lmKGkoYyl8fChjPWMgaW5zdGFuY2VvZiBCbG9iP25ldyBJKFtjXSxcImJsb2JcIix7dHlwZTpjLnR5cGV9KTpuZXcgcyhjLFwiYmxvYlwiLHt0eXBlOmMudHlwZX0pKSxsIT09dm9pZCAwKXtjb25zdCBTPXt0eXBlOmMudHlwZSxsYXN0TW9kaWZpZWQ6Yy5sYXN0TW9kaWZpZWR9O2M9USYmYyBpbnN0YW5jZW9mIFF8fGMgaW5zdGFuY2VvZiByP25ldyBJKFtjXSxsLFMpOm5ldyBzKGMsbCxTKX19cmV0dXJue25hbWU6TCx2YWx1ZTpjfX1yZXR1cm4gbyhmLFwibWFrZUVudHJ5XCIpLGZvcm1kYXRhPXtGb3JtRGF0YTphLG1ha2VFbnRyeTpmfSxmb3JtZGF0YX1vKHJlcXVpcmVGb3JtZGF0YSxcInJlcXVpcmVGb3JtZGF0YVwiKTt2YXIgZm9ybWRhdGFQYXJzZXIsaGFzUmVxdWlyZWRGb3JtZGF0YVBhcnNlcjtmdW5jdGlvbiByZXF1aXJlRm9ybWRhdGFQYXJzZXIoKXtpZihoYXNSZXF1aXJlZEZvcm1kYXRhUGFyc2VyKXJldHVybiBmb3JtZGF0YVBhcnNlcjtoYXNSZXF1aXJlZEZvcm1kYXRhUGFyc2VyPTE7Y29uc3R7dG9VU1ZTdHJpbmc6ZSxpc1VTVlN0cmluZzpBLGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWU6dH09dXRpbCRtLHt1dGY4RGVjb2RlQnl0ZXM6bn09cmVxdWlyZVV0aWwkNSgpLHtIVFRQX1RPS0VOX0NPREVQT0lOVFM6cixpc29tb3JwaGljRGVjb2RlOnN9PXJlcXVpcmVEYXRhVXJsKCkse2lzRmlsZUxpa2U6aSxGaWxlOkV9PXJlcXVpcmVGaWxlKCkse21ha2VFbnRyeTpRfT1yZXF1aXJlRm9ybWRhdGEoKSxDPXJlcXVpcmUkJDBfX2RlZmF1bHQse0ZpbGU6SX09cmVxdWlyZSQkNl9fZGVmYXVsdCxhPWdsb2JhbFRoaXMuRmlsZT8/ST8/RSxmPUJ1ZmZlci5mcm9tKCdmb3JtLWRhdGE7IG5hbWU9XCInKSxoPUJ1ZmZlci5mcm9tKFwiOyBmaWxlbmFtZVwiKSxMPUJ1ZmZlci5mcm9tKFwiLS1cIiksYz1CdWZmZXIuZnJvbShgLS1cXHJcbmApO2Z1bmN0aW9uIGwoZyl7Zm9yKGxldCBkPTA7ZDxnLmxlbmd0aDsrK2QpaWYoZy5jaGFyQ29kZUF0KGQpJi0xMjgpcmV0dXJuITE7cmV0dXJuITB9byhsLFwiaXNBc2NpaVN0cmluZ1wiKTtmdW5jdGlvbiBTKGcpe2NvbnN0IGQ9Zy5sZW5ndGg7aWYoZDwyN3x8ZD43MClyZXR1cm4hMTtmb3IobGV0IEY9MDtGPGQ7KytGKXtjb25zdCBOPWcuY2hhckNvZGVBdChGKTtpZighKE4+PTQ4JiZOPD01N3x8Tj49NjUmJk48PTkwfHxOPj05NyYmTjw9MTIyfHxOPT09Mzl8fE49PT00NXx8Tj09PTk1KSlyZXR1cm4hMX1yZXR1cm4hMH1vKFMsXCJ2YWxpZGF0ZUJvdW5kYXJ5XCIpO2Z1bmN0aW9uIGsoZyxkPVwidXRmLThcIixGPSExKXtyZXR1cm4gRj9nPWUoZyk6KEMoQShnKSksZz1nLnJlcGxhY2UoL1xcclxcbj98XFxyP1xcbi9nLGBcXHJcbmApKSxDKEJ1ZmZlci5pc0VuY29kaW5nKGQpKSxnPWcucmVwbGFjZSgvXFxuL2csXCIlMEFcIikucmVwbGFjZSgvXFxyL2csXCIlMERcIikucmVwbGFjZSgvXCIvZyxcIiUyMlwiKSxCdWZmZXIuZnJvbShnLGQpfW8oayxcImVzY2FwZUZvcm1EYXRhTmFtZVwiKTtmdW5jdGlvbiB3KGcsZCl7QyhkIT09XCJmYWlsdXJlXCImJmQuZXNzZW5jZT09PVwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKTtjb25zdCBGPWQucGFyYW1ldGVycy5nZXQoXCJib3VuZGFyeVwiKTtpZihGPT09dm9pZCAwKXJldHVyblwiZmFpbHVyZVwiO2NvbnN0IE49QnVmZmVyLmZyb20oYC0tJHtGfWAsXCJ1dGY4XCIpLHU9W10sYj17cG9zaXRpb246MH07Zm9yKGdbMF09PT0xMyYmZ1sxXT09PTEwJiYoYi5wb3NpdGlvbis9Mik7Oyl7aWYoZy5zdWJhcnJheShiLnBvc2l0aW9uLGIucG9zaXRpb24rTi5sZW5ndGgpLmVxdWFscyhOKSliLnBvc2l0aW9uKz1OLmxlbmd0aDtlbHNlIHJldHVyblwiZmFpbHVyZVwiO2lmKGIucG9zaXRpb249PT1nLmxlbmd0aC0yJiZHKGcsTCxiKXx8Yi5wb3NpdGlvbj09PWcubGVuZ3RoLTQmJkcoZyxjLGIpKXJldHVybiB1O2lmKGdbYi5wb3NpdGlvbl0hPT0xM3x8Z1tiLnBvc2l0aW9uKzFdIT09MTApcmV0dXJuXCJmYWlsdXJlXCI7Yi5wb3NpdGlvbis9Mjtjb25zdCBtPVUoZyxiKTtpZihtPT09XCJmYWlsdXJlXCIpcmV0dXJuXCJmYWlsdXJlXCI7bGV0e25hbWU6VCxmaWxlbmFtZTp2LGNvbnRlbnRUeXBlOlosZW5jb2Rpbmc6UH09bTtiLnBvc2l0aW9uKz0yO2xldCBBQTt7Y29uc3QgdEE9Zy5pbmRleE9mKE4uc3ViYXJyYXkoMiksYi5wb3NpdGlvbik7aWYodEE9PT0tMSlyZXR1cm5cImZhaWx1cmVcIjtBQT1nLnN1YmFycmF5KGIucG9zaXRpb24sdEEtNCksYi5wb3NpdGlvbis9QUEubGVuZ3RoLFA9PT1cImJhc2U2NFwiJiYoQUE9QnVmZmVyLmZyb20oQUEudG9TdHJpbmcoKSxcImJhc2U2NFwiKSl9aWYoZ1tiLnBvc2l0aW9uXSE9PTEzfHxnW2IucG9zaXRpb24rMV0hPT0xMClyZXR1cm5cImZhaWx1cmVcIjtiLnBvc2l0aW9uKz0yO2xldCBLO3YhPT1udWxsPyhaPz8oWj1cInRleHQvcGxhaW5cIiksbChaKXx8KFo9XCJcIiksSz1uZXcgYShbQUFdLHYse3R5cGU6Wn0pKTpLPW4oQnVmZmVyLmZyb20oQUEpKSxDKEEoVCkpLEModHlwZW9mIEs9PVwic3RyaW5nXCImJkEoSyl8fGkoSykpLHUucHVzaChRKFQsSyx2KSl9fW8odyxcIm11bHRpcGFydEZvcm1EYXRhUGFyc2VyXCIpO2Z1bmN0aW9uIFUoZyxkKXtsZXQgRj1udWxsLE49bnVsbCx1PW51bGwsYj1udWxsO2Zvcig7Oyl7aWYoZ1tkLnBvc2l0aW9uXT09PTEzJiZnW2QucG9zaXRpb24rMV09PT0xMClyZXR1cm4gRj09PW51bGw/XCJmYWlsdXJlXCI6e25hbWU6RixmaWxlbmFtZTpOLGNvbnRlbnRUeXBlOnUsZW5jb2Rpbmc6Yn07bGV0IG09QihUPT5UIT09MTAmJlQhPT0xMyYmVCE9PTU4LGcsZCk7aWYobT1EKG0sITAsITAsVD0+VD09PTl8fFQ9PT0zMiksIXIudGVzdChtLnRvU3RyaW5nKCkpfHxnW2QucG9zaXRpb25dIT09NTgpcmV0dXJuXCJmYWlsdXJlXCI7c3dpdGNoKGQucG9zaXRpb24rKyxCKFQ9PlQ9PT0zMnx8VD09PTksZyxkKSx0KG0pKXtjYXNlXCJjb250ZW50LWRpc3Bvc2l0aW9uXCI6e2lmKEY9Tj1udWxsLCFHKGcsZixkKXx8KGQucG9zaXRpb24rPTE3LEY9TShnLGQpLEY9PT1udWxsKSlyZXR1cm5cImZhaWx1cmVcIjtpZihHKGcsaCxkKSl7bGV0IFQ9ZC5wb3NpdGlvbitoLmxlbmd0aDtpZihnW1RdPT09NDImJihkLnBvc2l0aW9uKz0xLFQrPTEpLGdbVF0hPT02MXx8Z1tUKzFdIT09MzR8fChkLnBvc2l0aW9uKz0xMixOPU0oZyxkKSxOPT09bnVsbCkpcmV0dXJuXCJmYWlsdXJlXCJ9YnJlYWt9Y2FzZVwiY29udGVudC10eXBlXCI6e2xldCBUPUIodj0+diE9PTEwJiZ2IT09MTMsZyxkKTtUPUQoVCwhMSwhMCx2PT52PT09OXx8dj09PTMyKSx1PXMoVCk7YnJlYWt9Y2FzZVwiY29udGVudC10cmFuc2Zlci1lbmNvZGluZ1wiOntsZXQgVD1CKHY9PnYhPT0xMCYmdiE9PTEzLGcsZCk7VD1EKFQsITEsITAsdj0+dj09PTl8fHY9PT0zMiksYj1zKFQpO2JyZWFrfWRlZmF1bHQ6QihUPT5UIT09MTAmJlQhPT0xMyxnLGQpfWlmKGdbZC5wb3NpdGlvbl0hPT0xMyYmZ1tkLnBvc2l0aW9uKzFdIT09MTApcmV0dXJuXCJmYWlsdXJlXCI7ZC5wb3NpdGlvbis9Mn19byhVLFwicGFyc2VNdWx0aXBhcnRGb3JtRGF0YUhlYWRlcnNcIik7ZnVuY3Rpb24gTShnLGQpe0MoZ1tkLnBvc2l0aW9uLTFdPT09MzQpO2xldCBGPUIoTj0+TiE9PTEwJiZOIT09MTMmJk4hPT0zNCxnLGQpO3JldHVybiBnW2QucG9zaXRpb25dIT09MzQ/bnVsbDooZC5wb3NpdGlvbisrLEY9bmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKEYpLnJlcGxhY2UoLyUwQS9pZyxgXG5gKS5yZXBsYWNlKC8lMEQvaWcsXCJcXHJcIikucmVwbGFjZSgvJTIyL2csJ1wiJyksRil9byhNLFwicGFyc2VNdWx0aXBhcnRGb3JtRGF0YU5hbWVcIik7ZnVuY3Rpb24gQihnLGQsRil7bGV0IE49Ri5wb3NpdGlvbjtmb3IoO048ZC5sZW5ndGgmJmcoZFtOXSk7KSsrTjtyZXR1cm4gZC5zdWJhcnJheShGLnBvc2l0aW9uLEYucG9zaXRpb249Til9byhCLFwiY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXNcIik7ZnVuY3Rpb24gRChnLGQsRixOKXtsZXQgdT0wLGI9Zy5sZW5ndGgtMTtpZihkKWZvcig7dTxnLmxlbmd0aCYmTihnW3VdKTspdSsrO2lmKEYpZm9yKDtiPjAmJk4oZ1tiXSk7KWItLTtyZXR1cm4gdT09PTAmJmI9PT1nLmxlbmd0aC0xP2c6Zy5zdWJhcnJheSh1LGIrMSl9byhELFwicmVtb3ZlQ2hhcnNcIik7ZnVuY3Rpb24gRyhnLGQsRil7aWYoZy5sZW5ndGg8ZC5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBOPTA7TjxkLmxlbmd0aDtOKyspaWYoZFtOXSE9PWdbRi5wb3NpdGlvbitOXSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gbyhHLFwiYnVmZmVyU3RhcnRzV2l0aFwiKSxmb3JtZGF0YVBhcnNlcj17bXVsdGlwYXJ0Rm9ybURhdGFQYXJzZXI6dyx2YWxpZGF0ZUJvdW5kYXJ5OlMsZXNjYXBlRm9ybURhdGFOYW1lOmt9LGZvcm1kYXRhUGFyc2VyfW8ocmVxdWlyZUZvcm1kYXRhUGFyc2VyLFwicmVxdWlyZUZvcm1kYXRhUGFyc2VyXCIpO3ZhciBib2R5LGhhc1JlcXVpcmVkQm9keTtmdW5jdGlvbiByZXF1aXJlQm9keSgpe2lmKGhhc1JlcXVpcmVkQm9keSlyZXR1cm4gYm9keTtoYXNSZXF1aXJlZEJvZHk9MTtjb25zdCBlPXV0aWwkbSx7UmVhZGFibGVTdHJlYW1Gcm9tOkEsaXNCbG9iTGlrZTp0LGlzUmVhZGFibGVTdHJlYW1MaWtlOm4scmVhZGFibGVTdHJlYW1DbG9zZTpyLGNyZWF0ZURlZmVycmVkUHJvbWlzZTpzLGZ1bGx5UmVhZEJvZHk6aSxleHRyYWN0TWltZVR5cGU6RSx1dGY4RGVjb2RlQnl0ZXM6UX09cmVxdWlyZVV0aWwkNSgpLHtGb3JtRGF0YTpDfT1yZXF1aXJlRm9ybWRhdGEoKSx7a1N0YXRlOkl9PXJlcXVpcmVTeW1ib2xzJDMoKSx7d2ViaWRsOmF9PXJlcXVpcmVXZWJpZGwoKSx7QmxvYjpmfT1yZXF1aXJlJCQ2X19kZWZhdWx0LGg9cmVxdWlyZSQkMF9fZGVmYXVsdCx7aXNFcnJvcmVkOkx9PXV0aWwkbSx7aXNBcnJheUJ1ZmZlcjpjfT1yZXF1aXJlJCQ4X19kZWZhdWx0JDEse3NlcmlhbGl6ZUFNaW1lVHlwZTpsfT1yZXF1aXJlRGF0YVVybCgpLHttdWx0aXBhcnRGb3JtRGF0YVBhcnNlcjpTfT1yZXF1aXJlRm9ybWRhdGFQYXJzZXIoKSxrPW5ldyBUZXh0RW5jb2RlcjtmdW5jdGlvbiB3KHUsYj0hMSl7bGV0IG09bnVsbDt1IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0/bT11OnQodSk/bT11LnN0cmVhbSgpOm09bmV3IFJlYWRhYmxlU3RyZWFtKHthc3luYyBwdWxsKEspe2NvbnN0IHRBPXR5cGVvZiB2PT1cInN0cmluZ1wiP2suZW5jb2RlKHYpOnY7dEEuYnl0ZUxlbmd0aCYmSy5lbnF1ZXVlKHRBKSxxdWV1ZU1pY3JvdGFzaygoKT0+cihLKSl9LHN0YXJ0KCl7fSx0eXBlOlwiYnl0ZXNcIn0pLGgobihtKSk7bGV0IFQ9bnVsbCx2PW51bGwsWj1udWxsLFA9bnVsbDtpZih0eXBlb2YgdT09XCJzdHJpbmdcIil2PXUsUD1cInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiO2Vsc2UgaWYodSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyl2PXUudG9TdHJpbmcoKSxQPVwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLThcIjtlbHNlIGlmKGModSkpdj1uZXcgVWludDhBcnJheSh1LnNsaWNlKCkpO2Vsc2UgaWYoQXJyYXlCdWZmZXIuaXNWaWV3KHUpKXY9bmV3IFVpbnQ4QXJyYXkodS5idWZmZXIuc2xpY2UodS5ieXRlT2Zmc2V0LHUuYnl0ZU9mZnNldCt1LmJ5dGVMZW5ndGgpKTtlbHNlIGlmKGUuaXNGb3JtRGF0YUxpa2UodSkpe2NvbnN0IEs9YC0tLS1mb3JtZGF0YS11bmRpY2ktMCR7YCR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjFlMTEpfWAucGFkU3RhcnQoMTEsXCIwXCIpfWAsdEE9YC0tJHtLfVxcclxuQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhYDsvKiEgZm9ybWRhdGEtcG9seWZpbGwuIE1JVCBMaWNlbnNlLiBKaW1teSBXw6RydGluZyA8aHR0cHM6Ly9qaW1teS53YXJ0aW5nLnNlL29wZW5zb3VyY2U+ICovY29uc3QgYUE9byhyQT0+ckEucmVwbGFjZSgvXFxuL2csXCIlMEFcIikucmVwbGFjZSgvXFxyL2csXCIlMERcIikucmVwbGFjZSgvXCIvZyxcIiUyMlwiKSxcImVzY2FwZVwiKSxYPW8ockE9PnJBLnJlcGxhY2UoL1xccj9cXG58XFxyL2csYFxcclxuYCksXCJub3JtYWxpemVMaW5lZmVlZHNcIiksJD1bXSxWPW5ldyBVaW50OEFycmF5KFsxMywxMF0pO1o9MDtsZXQgcT0hMTtmb3IoY29uc3RbckEsaUFdb2YgdSlpZih0eXBlb2YgaUE9PVwic3RyaW5nXCIpe2NvbnN0IGdBPWsuZW5jb2RlKHRBK2A7IG5hbWU9XCIke2FBKFgockEpKX1cIlxcclxuXFxyXG4ke1goaUEpfVxcclxuYCk7JC5wdXNoKGdBKSxaKz1nQS5ieXRlTGVuZ3RofWVsc2V7Y29uc3QgZ0E9ay5lbmNvZGUoYCR7dEF9OyBuYW1lPVwiJHthQShYKHJBKSl9XCJgKyhpQS5uYW1lP2A7IGZpbGVuYW1lPVwiJHthQShpQS5uYW1lKX1cImA6XCJcIikrYFxcclxuQ29udGVudC1UeXBlOiAke2lBLnR5cGV8fFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9XFxyXG5cXHJcbmApOyQucHVzaChnQSxpQSxWKSx0eXBlb2YgaUEuc2l6ZT09XCJudW1iZXJcIj9aKz1nQS5ieXRlTGVuZ3RoK2lBLnNpemUrVi5ieXRlTGVuZ3RoOnE9ITB9Y29uc3Qgej1rLmVuY29kZShgLS0ke0t9LS1gKTskLnB1c2goeiksWis9ei5ieXRlTGVuZ3RoLHEmJihaPW51bGwpLHY9dSxUPW8oYXN5bmMgZnVuY3Rpb24qKCl7Zm9yKGNvbnN0IHJBIG9mICQpckEuc3RyZWFtP3lpZWxkKnJBLnN0cmVhbSgpOnlpZWxkIHJBfSxcImFjdGlvblwiKSxQPWBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke0t9YH1lbHNlIGlmKHQodSkpdj11LFo9dS5zaXplLHUudHlwZSYmKFA9dS50eXBlKTtlbHNlIGlmKHR5cGVvZiB1W1N5bWJvbC5hc3luY0l0ZXJhdG9yXT09XCJmdW5jdGlvblwiKXtpZihiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJrZWVwYWxpdmVcIik7aWYoZS5pc0Rpc3R1cmJlZCh1KXx8dS5sb2NrZWQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJlc3BvbnNlIGJvZHkgb2JqZWN0IHNob3VsZCBub3QgYmUgZGlzdHVyYmVkIG9yIGxvY2tlZFwiKTttPXUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbT91OkEodSl9aWYoKHR5cGVvZiB2PT1cInN0cmluZ1wifHxlLmlzQnVmZmVyKHYpKSYmKFo9QnVmZmVyLmJ5dGVMZW5ndGgodikpLFQhPW51bGwpe2xldCBLO209bmV3IFJlYWRhYmxlU3RyZWFtKHthc3luYyBzdGFydCgpe0s9VCh1KVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKX0sYXN5bmMgcHVsbCh0QSl7Y29uc3R7dmFsdWU6YUEsZG9uZTpYfT1hd2FpdCBLLm5leHQoKTtpZihYKXF1ZXVlTWljcm90YXNrKCgpPT57dEEuY2xvc2UoKSx0QS5ieW9iUmVxdWVzdD8ucmVzcG9uZCgwKX0pO2Vsc2UgaWYoIUwobSkpe2NvbnN0ICQ9bmV3IFVpbnQ4QXJyYXkoYUEpOyQuYnl0ZUxlbmd0aCYmdEEuZW5xdWV1ZSgkKX1yZXR1cm4gdEEuZGVzaXJlZFNpemU+MH0sYXN5bmMgY2FuY2VsKHRBKXthd2FpdCBLLnJldHVybigpfSx0eXBlOlwiYnl0ZXNcIn0pfXJldHVyblt7c3RyZWFtOm0sc291cmNlOnYsbGVuZ3RoOlp9LFBdfW8odyxcImV4dHJhY3RCb2R5XCIpO2Z1bmN0aW9uIFUodSxiPSExKXtyZXR1cm4gdSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtJiYoaCghZS5pc0Rpc3R1cmJlZCh1KSxcIlRoZSBib2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuXCIpLGgoIXUubG9ja2VkLFwiVGhlIHN0cmVhbSBpcyBsb2NrZWQuXCIpKSx3KHUsYil9byhVLFwic2FmZWx5RXh0cmFjdEJvZHlcIik7ZnVuY3Rpb24gTSh1KXtjb25zdFtiLG1dPXUuc3RyZWFtLnRlZSgpO3JldHVybiB1LnN0cmVhbT1iLHtzdHJlYW06bSxsZW5ndGg6dS5sZW5ndGgsc291cmNlOnUuc291cmNlfX1vKE0sXCJjbG9uZUJvZHlcIik7ZnVuY3Rpb24gQih1KXtpZih1LmFib3J0ZWQpdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIsXCJBYm9ydEVycm9yXCIpfW8oQixcInRocm93SWZBYm9ydGVkXCIpO2Z1bmN0aW9uIEQodSl7cmV0dXJue2Jsb2IoKXtyZXR1cm4gZyh0aGlzLG09PntsZXQgVD1OKHRoaXMpO3JldHVybiBUPT09bnVsbD9UPVwiXCI6VCYmKFQ9bChUKSksbmV3IGYoW21dLHt0eXBlOlR9KX0sdSl9LGFycmF5QnVmZmVyKCl7cmV0dXJuIGcodGhpcyxtPT5uZXcgVWludDhBcnJheShtKS5idWZmZXIsdSl9LHRleHQoKXtyZXR1cm4gZyh0aGlzLFEsdSl9LGpzb24oKXtyZXR1cm4gZyh0aGlzLEYsdSl9LGZvcm1EYXRhKCl7cmV0dXJuIGcodGhpcyxtPT57Y29uc3QgVD1OKHRoaXMpO2lmKFQhPT1udWxsKXN3aXRjaChULmVzc2VuY2Upe2Nhc2VcIm11bHRpcGFydC9mb3JtLWRhdGFcIjp7Y29uc3Qgdj1TKG0sVCk7aWYodj09PVwiZmFpbHVyZVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgYm9keSBhcyBGb3JtRGF0YS5cIik7Y29uc3QgWj1uZXcgQztyZXR1cm4gWltJXT12LFp9Y2FzZVwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI6e2NvbnN0IHY9bmV3IFVSTFNlYXJjaFBhcmFtcyhtLnRvU3RyaW5nKCkpLFo9bmV3IEM7Zm9yKGNvbnN0W1AsQUFdb2YgdilaLmFwcGVuZChQLEFBKTtyZXR1cm4gWn19dGhyb3cgbmV3IFR5cGVFcnJvcignQ29udGVudC1UeXBlIHdhcyBub3Qgb25lIG9mIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIG9yIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIuJyl9LHUpfX19byhELFwiYm9keU1peGluTWV0aG9kc1wiKTtmdW5jdGlvbiBHKHUpe09iamVjdC5hc3NpZ24odS5wcm90b3R5cGUsRCh1KSl9byhHLFwibWl4aW5Cb2R5XCIpO2FzeW5jIGZ1bmN0aW9uIGcodSxiLG0pe2lmKGEuYnJhbmRDaGVjayh1LG0pLEIodVtJXSksZCh1W0ldLmJvZHkpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJCb2R5IGlzIHVudXNhYmxlXCIpO2NvbnN0IFQ9cygpLHY9byhQPT5ULnJlamVjdChQKSxcImVycm9yU3RlcHNcIiksWj1vKFA9Pnt0cnl7VC5yZXNvbHZlKGIoUCkpfWNhdGNoKEFBKXt2KEFBKX19LFwic3VjY2Vzc1N0ZXBzXCIpO3JldHVybiB1W0ldLmJvZHk9PW51bGw/KFoobmV3IFVpbnQ4QXJyYXkpLFQucHJvbWlzZSk6KGF3YWl0IGkodVtJXS5ib2R5LFosdiksVC5wcm9taXNlKX1vKGcsXCJjb25zdW1lQm9keVwiKTtmdW5jdGlvbiBkKHUpe3JldHVybiB1IT1udWxsJiYodS5zdHJlYW0ubG9ja2VkfHxlLmlzRGlzdHVyYmVkKHUuc3RyZWFtKSl9byhkLFwiYm9keVVudXNhYmxlXCIpO2Z1bmN0aW9uIEYodSl7cmV0dXJuIEpTT04ucGFyc2UoUSh1KSl9byhGLFwicGFyc2VKU09ORnJvbUJ5dGVzXCIpO2Z1bmN0aW9uIE4odSl7Y29uc3QgYj11W0ldLmhlYWRlcnNMaXN0LG09RShiKTtyZXR1cm4gbT09PVwiZmFpbHVyZVwiP251bGw6bX1yZXR1cm4gbyhOLFwiYm9keU1pbWVUeXBlXCIpLGJvZHk9e2V4dHJhY3RCb2R5Oncsc2FmZWx5RXh0cmFjdEJvZHk6VSxjbG9uZUJvZHk6TSxtaXhpbkJvZHk6R30sYm9keX1vKHJlcXVpcmVCb2R5LFwicmVxdWlyZUJvZHlcIik7Y29uc3QgYXNzZXJ0JGE9cmVxdWlyZSQkMF9fZGVmYXVsdCx1dGlsJGk9dXRpbCRtLHtjaGFubmVsczpjaGFubmVscyQxfT1kaWFnbm9zdGljcyx0aW1lcnM9dGltZXJzJDEse1JlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcjpSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IkMSxSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFJlcXVlc3RBYm9ydGVkRXJyb3I6UmVxdWVzdEFib3J0ZWRFcnJvciQ1LEhlYWRlcnNUaW1lb3V0RXJyb3IsSGVhZGVyc092ZXJmbG93RXJyb3IsU29ja2V0RXJyb3I6U29ja2V0RXJyb3IkMyxJbmZvcm1hdGlvbmFsRXJyb3I6SW5mb3JtYXRpb25hbEVycm9yJDIsQm9keVRpbWVvdXRFcnJvcixIVFRQUGFyc2VyRXJyb3IsUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcn09ZXJyb3JzJDEse2tVcmw6a1VybCQ0LGtSZXNldDprUmVzZXQkMSxrQ2xpZW50OmtDbGllbnQkMyxrUGFyc2VyLGtCbG9ja2luZyxrUnVubmluZzprUnVubmluZyQ1LGtQZW5kaW5nOmtQZW5kaW5nJDQsa1NpemU6a1NpemUkNCxrV3JpdGluZyxrUXVldWU6a1F1ZXVlJDMsa05vUmVmLGtLZWVwQWxpdmVEZWZhdWx0VGltZW91dDprS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXQkMSxrSG9zdEhlYWRlcjprSG9zdEhlYWRlciQxLGtQZW5kaW5nSWR4OmtQZW5kaW5nSWR4JDIsa1J1bm5pbmdJZHg6a1J1bm5pbmdJZHgkMixrRXJyb3I6a0Vycm9yJDIsa1BpcGVsaW5pbmc6a1BpcGVsaW5pbmckMSxrU29ja2V0OmtTb2NrZXQkMSxrS2VlcEFsaXZlVGltZW91dFZhbHVlOmtLZWVwQWxpdmVUaW1lb3V0VmFsdWUkMSxrTWF4SGVhZGVyc1NpemU6a01heEhlYWRlcnNTaXplJDEsa0tlZXBBbGl2ZU1heFRpbWVvdXQ6a0tlZXBBbGl2ZU1heFRpbWVvdXQkMSxrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZDprS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCQxLGtIZWFkZXJzVGltZW91dDprSGVhZGVyc1RpbWVvdXQkMSxrQm9keVRpbWVvdXQ6a0JvZHlUaW1lb3V0JDEsa1N0cmljdENvbnRlbnRMZW5ndGg6a1N0cmljdENvbnRlbnRMZW5ndGgkMixrTWF4UmVxdWVzdHM6a01heFJlcXVlc3RzJDEsa0NvdW50ZXI6a0NvdW50ZXIkMSxrTWF4UmVzcG9uc2VTaXplOmtNYXhSZXNwb25zZVNpemUkMSxrT25FcnJvcjprT25FcnJvciQyLGtSZXN1bWU6a1Jlc3VtZSQzLGtIVFRQQ29udGV4dDprSFRUUENvbnRleHQkMX09c3ltYm9scyQ0LGNvbnN0YW50cyQyPWNvbnN0YW50cyQ0LEVNUFRZX0JVRj1CdWZmZXIuYWxsb2MoMCksRmFzdEJ1ZmZlcj1CdWZmZXJbU3ltYm9sLnNwZWNpZXNdLGFkZExpc3RlbmVyPXV0aWwkaS5hZGRMaXN0ZW5lcixyZW1vdmVBbGxMaXN0ZW5lcnM9dXRpbCRpLnJlbW92ZUFsbExpc3RlbmVycztsZXQgZXh0cmFjdEJvZHk7YXN5bmMgZnVuY3Rpb24gbGF6eWxsaHR0cCgpe2NvbnN0IGU9cHJvY2Vzcy5lbnYuSkVTVF9XT1JLRVJfSUQ/cmVxdWlyZUxsaHR0cFdhc20oKTp2b2lkIDA7bGV0IEE7dHJ5e0E9YXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShyZXF1aXJlTGxodHRwX3NpbWRXYXNtKCkpfWNhdGNoe0E9YXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShlfHxyZXF1aXJlTGxodHRwV2FzbSgpKX1yZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoQSx7ZW52Ont3YXNtX29uX3VybDoodCxuLHIpPT4wLHdhc21fb25fc3RhdHVzOih0LG4scik9Pnthc3NlcnQkYS5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0cix0KTtjb25zdCBzPW4tY3VycmVudEJ1ZmZlclB0citjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXQ7cmV0dXJuIGN1cnJlbnRQYXJzZXIub25TdGF0dXMobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIscyxyKSl8fDB9LHdhc21fb25fbWVzc2FnZV9iZWdpbjp0PT4oYXNzZXJ0JGEuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsdCksY3VycmVudFBhcnNlci5vbk1lc3NhZ2VCZWdpbigpfHwwKSx3YXNtX29uX2hlYWRlcl9maWVsZDoodCxuLHIpPT57YXNzZXJ0JGEuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsdCk7Y29uc3Qgcz1uLWN1cnJlbnRCdWZmZXJQdHIrY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0O3JldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyRmllbGQobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIscyxyKSl8fDB9LHdhc21fb25faGVhZGVyX3ZhbHVlOih0LG4scik9Pnthc3NlcnQkYS5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0cix0KTtjb25zdCBzPW4tY3VycmVudEJ1ZmZlclB0citjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXQ7cmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJWYWx1ZShuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlcixzLHIpKXx8MH0sd2FzbV9vbl9oZWFkZXJzX2NvbXBsZXRlOih0LG4scixzKT0+KGFzc2VydCRhLnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLHQpLGN1cnJlbnRQYXJzZXIub25IZWFkZXJzQ29tcGxldGUobiwhIXIsISFzKXx8MCksd2FzbV9vbl9ib2R5Oih0LG4scik9Pnthc3NlcnQkYS5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0cix0KTtjb25zdCBzPW4tY3VycmVudEJ1ZmZlclB0citjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXQ7cmV0dXJuIGN1cnJlbnRQYXJzZXIub25Cb2R5KG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLHMscikpfHwwfSx3YXNtX29uX21lc3NhZ2VfY29tcGxldGU6dD0+KGFzc2VydCRhLnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLHQpLGN1cnJlbnRQYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKXx8MCl9fSl9byhsYXp5bGxodHRwLFwibGF6eWxsaHR0cFwiKTtsZXQgbGxodHRwSW5zdGFuY2U9bnVsbCxsbGh0dHBQcm9taXNlPWxhenlsbGh0dHAoKTtsbGh0dHBQcm9taXNlLmNhdGNoKCk7bGV0IGN1cnJlbnRQYXJzZXI9bnVsbCxjdXJyZW50QnVmZmVyUmVmPW51bGwsY3VycmVudEJ1ZmZlclNpemU9MCxjdXJyZW50QnVmZmVyUHRyPW51bGw7Y29uc3QgVElNRU9VVF9IRUFERVJTPTEsVElNRU9VVF9CT0RZPTIsVElNRU9VVF9JRExFPTMsc3Q9Y2xhc3Mgc3R7Y29uc3RydWN0b3IoQSx0LHtleHBvcnRzOm59KXthc3NlcnQkYShOdW1iZXIuaXNGaW5pdGUoQVtrTWF4SGVhZGVyc1NpemUkMV0pJiZBW2tNYXhIZWFkZXJzU2l6ZSQxXT4wKSx0aGlzLmxsaHR0cD1uLHRoaXMucHRyPXRoaXMubGxodHRwLmxsaHR0cF9hbGxvYyhjb25zdGFudHMkMi5UWVBFLlJFU1BPTlNFKSx0aGlzLmNsaWVudD1BLHRoaXMuc29ja2V0PXQsdGhpcy50aW1lb3V0PW51bGwsdGhpcy50aW1lb3V0VmFsdWU9bnVsbCx0aGlzLnRpbWVvdXRUeXBlPW51bGwsdGhpcy5zdGF0dXNDb2RlPW51bGwsdGhpcy5zdGF0dXNUZXh0PVwiXCIsdGhpcy51cGdyYWRlPSExLHRoaXMuaGVhZGVycz1bXSx0aGlzLmhlYWRlcnNTaXplPTAsdGhpcy5oZWFkZXJzTWF4U2l6ZT1BW2tNYXhIZWFkZXJzU2l6ZSQxXSx0aGlzLnNob3VsZEtlZXBBbGl2ZT0hMSx0aGlzLnBhdXNlZD0hMSx0aGlzLnJlc3VtZT10aGlzLnJlc3VtZS5iaW5kKHRoaXMpLHRoaXMuYnl0ZXNSZWFkPTAsdGhpcy5rZWVwQWxpdmU9XCJcIix0aGlzLmNvbnRlbnRMZW5ndGg9XCJcIix0aGlzLmNvbm5lY3Rpb249XCJcIix0aGlzLm1heFJlc3BvbnNlU2l6ZT1BW2tNYXhSZXNwb25zZVNpemUkMV19c2V0VGltZW91dChBLHQpe3RoaXMudGltZW91dFR5cGU9dCxBIT09dGhpcy50aW1lb3V0VmFsdWU/KHRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KSxBPyh0aGlzLnRpbWVvdXQ9dGltZXJzLnNldFRpbWVvdXQob25QYXJzZXJUaW1lb3V0LEEsdGhpcyksdGhpcy50aW1lb3V0LnVucmVmJiZ0aGlzLnRpbWVvdXQudW5yZWYoKSk6dGhpcy50aW1lb3V0PW51bGwsdGhpcy50aW1lb3V0VmFsdWU9QSk6dGhpcy50aW1lb3V0JiZ0aGlzLnRpbWVvdXQucmVmcmVzaCYmdGhpcy50aW1lb3V0LnJlZnJlc2goKX1yZXN1bWUoKXt0aGlzLnNvY2tldC5kZXN0cm95ZWR8fCF0aGlzLnBhdXNlZHx8KGFzc2VydCRhKHRoaXMucHRyIT1udWxsKSxhc3NlcnQkYShjdXJyZW50UGFyc2VyPT1udWxsKSx0aGlzLmxsaHR0cC5sbGh0dHBfcmVzdW1lKHRoaXMucHRyKSxhc3NlcnQkYSh0aGlzLnRpbWVvdXRUeXBlPT09VElNRU9VVF9CT0RZKSx0aGlzLnRpbWVvdXQmJnRoaXMudGltZW91dC5yZWZyZXNoJiZ0aGlzLnRpbWVvdXQucmVmcmVzaCgpLHRoaXMucGF1c2VkPSExLHRoaXMuZXhlY3V0ZSh0aGlzLnNvY2tldC5yZWFkKCl8fEVNUFRZX0JVRiksdGhpcy5yZWFkTW9yZSgpKX1yZWFkTW9yZSgpe2Zvcig7IXRoaXMucGF1c2VkJiZ0aGlzLnB0cjspe2NvbnN0IEE9dGhpcy5zb2NrZXQucmVhZCgpO2lmKEE9PT1udWxsKWJyZWFrO3RoaXMuZXhlY3V0ZShBKX19ZXhlY3V0ZShBKXthc3NlcnQkYSh0aGlzLnB0ciE9bnVsbCksYXNzZXJ0JGEoY3VycmVudFBhcnNlcj09bnVsbCksYXNzZXJ0JGEoIXRoaXMucGF1c2VkKTtjb25zdHtzb2NrZXQ6dCxsbGh0dHA6bn09dGhpcztBLmxlbmd0aD5jdXJyZW50QnVmZmVyU2l6ZSYmKGN1cnJlbnRCdWZmZXJQdHImJm4uZnJlZShjdXJyZW50QnVmZmVyUHRyKSxjdXJyZW50QnVmZmVyU2l6ZT1NYXRoLmNlaWwoQS5sZW5ndGgvNDA5NikqNDA5NixjdXJyZW50QnVmZmVyUHRyPW4ubWFsbG9jKGN1cnJlbnRCdWZmZXJTaXplKSksbmV3IFVpbnQ4QXJyYXkobi5tZW1vcnkuYnVmZmVyLGN1cnJlbnRCdWZmZXJQdHIsY3VycmVudEJ1ZmZlclNpemUpLnNldChBKTt0cnl7bGV0IHI7dHJ5e2N1cnJlbnRCdWZmZXJSZWY9QSxjdXJyZW50UGFyc2VyPXRoaXMscj1uLmxsaHR0cF9leGVjdXRlKHRoaXMucHRyLGN1cnJlbnRCdWZmZXJQdHIsQS5sZW5ndGgpfWNhdGNoKGkpe3Rocm93IGl9ZmluYWxseXtjdXJyZW50UGFyc2VyPW51bGwsY3VycmVudEJ1ZmZlclJlZj1udWxsfWNvbnN0IHM9bi5sbGh0dHBfZ2V0X2Vycm9yX3Bvcyh0aGlzLnB0ciktY3VycmVudEJ1ZmZlclB0cjtpZihyPT09Y29uc3RhbnRzJDIuRVJST1IuUEFVU0VEX1VQR1JBREUpdGhpcy5vblVwZ3JhZGUoQS5zbGljZShzKSk7ZWxzZSBpZihyPT09Y29uc3RhbnRzJDIuRVJST1IuUEFVU0VEKXRoaXMucGF1c2VkPSEwLHQudW5zaGlmdChBLnNsaWNlKHMpKTtlbHNlIGlmKHIhPT1jb25zdGFudHMkMi5FUlJPUi5PSyl7Y29uc3QgaT1uLmxsaHR0cF9nZXRfZXJyb3JfcmVhc29uKHRoaXMucHRyKTtsZXQgRT1cIlwiO2lmKGkpe2NvbnN0IFE9bmV3IFVpbnQ4QXJyYXkobi5tZW1vcnkuYnVmZmVyLGkpLmluZGV4T2YoMCk7RT1cIlJlc3BvbnNlIGRvZXMgbm90IG1hdGNoIHRoZSBIVFRQLzEuMSBwcm90b2NvbCAoXCIrQnVmZmVyLmZyb20obi5tZW1vcnkuYnVmZmVyLGksUSkudG9TdHJpbmcoKStcIilcIn10aHJvdyBuZXcgSFRUUFBhcnNlckVycm9yKEUsY29uc3RhbnRzJDIuRVJST1Jbcl0sQS5zbGljZShzKSl9fWNhdGNoKHIpe3V0aWwkaS5kZXN0cm95KHQscil9fWRlc3Ryb3koKXthc3NlcnQkYSh0aGlzLnB0ciE9bnVsbCksYXNzZXJ0JGEoY3VycmVudFBhcnNlcj09bnVsbCksdGhpcy5sbGh0dHAubGxodHRwX2ZyZWUodGhpcy5wdHIpLHRoaXMucHRyPW51bGwsdGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpLHRoaXMudGltZW91dD1udWxsLHRoaXMudGltZW91dFZhbHVlPW51bGwsdGhpcy50aW1lb3V0VHlwZT1udWxsLHRoaXMucGF1c2VkPSExfW9uU3RhdHVzKEEpe3RoaXMuc3RhdHVzVGV4dD1BLnRvU3RyaW5nKCl9b25NZXNzYWdlQmVnaW4oKXtjb25zdHtzb2NrZXQ6QSxjbGllbnQ6dH09dGhpcztpZihBLmRlc3Ryb3llZClyZXR1cm4tMTtjb25zdCBuPXRba1F1ZXVlJDNdW3Rba1J1bm5pbmdJZHgkMl1dO2lmKCFuKXJldHVybi0xO24ub25SZXNwb25zZVN0YXJ0ZWQoKX1vbkhlYWRlckZpZWxkKEEpe2NvbnN0IHQ9dGhpcy5oZWFkZXJzLmxlbmd0aDt0JjE/dGhpcy5oZWFkZXJzW3QtMV09QnVmZmVyLmNvbmNhdChbdGhpcy5oZWFkZXJzW3QtMV0sQV0pOnRoaXMuaGVhZGVycy5wdXNoKEEpLHRoaXMudHJhY2tIZWFkZXIoQS5sZW5ndGgpfW9uSGVhZGVyVmFsdWUoQSl7bGV0IHQ9dGhpcy5oZWFkZXJzLmxlbmd0aDsodCYxKT09PTE/KHRoaXMuaGVhZGVycy5wdXNoKEEpLHQrPTEpOnRoaXMuaGVhZGVyc1t0LTFdPUJ1ZmZlci5jb25jYXQoW3RoaXMuaGVhZGVyc1t0LTFdLEFdKTtjb25zdCBuPXRoaXMuaGVhZGVyc1t0LTJdO2lmKG4ubGVuZ3RoPT09MTApe2NvbnN0IHI9dXRpbCRpLmJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUobik7cj09PVwia2VlcC1hbGl2ZVwiP3RoaXMua2VlcEFsaXZlKz1BLnRvU3RyaW5nKCk6cj09PVwiY29ubmVjdGlvblwiJiYodGhpcy5jb25uZWN0aW9uKz1BLnRvU3RyaW5nKCkpfWVsc2Ugbi5sZW5ndGg9PT0xNCYmdXRpbCRpLmJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUobik9PT1cImNvbnRlbnQtbGVuZ3RoXCImJih0aGlzLmNvbnRlbnRMZW5ndGgrPUEudG9TdHJpbmcoKSk7dGhpcy50cmFja0hlYWRlcihBLmxlbmd0aCl9dHJhY2tIZWFkZXIoQSl7dGhpcy5oZWFkZXJzU2l6ZSs9QSx0aGlzLmhlYWRlcnNTaXplPj10aGlzLmhlYWRlcnNNYXhTaXplJiZ1dGlsJGkuZGVzdHJveSh0aGlzLnNvY2tldCxuZXcgSGVhZGVyc092ZXJmbG93RXJyb3IpfW9uVXBncmFkZShBKXtjb25zdHt1cGdyYWRlOnQsY2xpZW50Om4sc29ja2V0OnIsaGVhZGVyczpzLHN0YXR1c0NvZGU6aX09dGhpczthc3NlcnQkYSh0KTtjb25zdCBFPW5ba1F1ZXVlJDNdW25ba1J1bm5pbmdJZHgkMl1dO2Fzc2VydCRhKEUpLGFzc2VydCRhKCFyLmRlc3Ryb3llZCksYXNzZXJ0JGEocj09PW5ba1NvY2tldCQxXSksYXNzZXJ0JGEoIXRoaXMucGF1c2VkKSxhc3NlcnQkYShFLnVwZ3JhZGV8fEUubWV0aG9kPT09XCJDT05ORUNUXCIpLHRoaXMuc3RhdHVzQ29kZT1udWxsLHRoaXMuc3RhdHVzVGV4dD1cIlwiLHRoaXMuc2hvdWxkS2VlcEFsaXZlPW51bGwsYXNzZXJ0JGEodGhpcy5oZWFkZXJzLmxlbmd0aCUyPT09MCksdGhpcy5oZWFkZXJzPVtdLHRoaXMuaGVhZGVyc1NpemU9MCxyLnVuc2hpZnQoQSkscltrUGFyc2VyXS5kZXN0cm95KCkscltrUGFyc2VyXT1udWxsLHJba0NsaWVudCQzXT1udWxsLHJba0Vycm9yJDJdPW51bGwscmVtb3ZlQWxsTGlzdGVuZXJzKHIpLG5ba1NvY2tldCQxXT1udWxsLG5ba0hUVFBDb250ZXh0JDFdPW51bGwsbltrUXVldWUkM11bbltrUnVubmluZ0lkeCQyXSsrXT1udWxsLG4uZW1pdChcImRpc2Nvbm5lY3RcIixuW2tVcmwkNF0sW25dLG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IkMihcInVwZ3JhZGVcIikpO3RyeXtFLm9uVXBncmFkZShpLHMscil9Y2F0Y2goUSl7dXRpbCRpLmRlc3Ryb3kocixRKX1uW2tSZXN1bWUkM10oKX1vbkhlYWRlcnNDb21wbGV0ZShBLHQsbil7Y29uc3R7Y2xpZW50OnIsc29ja2V0OnMsaGVhZGVyczppLHN0YXR1c1RleHQ6RX09dGhpcztpZihzLmRlc3Ryb3llZClyZXR1cm4tMTtjb25zdCBRPXJba1F1ZXVlJDNdW3Jba1J1bm5pbmdJZHgkMl1dO2lmKCFRKXJldHVybi0xO2lmKGFzc2VydCRhKCF0aGlzLnVwZ3JhZGUpLGFzc2VydCRhKHRoaXMuc3RhdHVzQ29kZTwyMDApLEE9PT0xMDApcmV0dXJuIHV0aWwkaS5kZXN0cm95KHMsbmV3IFNvY2tldEVycm9yJDMoXCJiYWQgcmVzcG9uc2VcIix1dGlsJGkuZ2V0U29ja2V0SW5mbyhzKSkpLC0xO2lmKHQmJiFRLnVwZ3JhZGUpcmV0dXJuIHV0aWwkaS5kZXN0cm95KHMsbmV3IFNvY2tldEVycm9yJDMoXCJiYWQgdXBncmFkZVwiLHV0aWwkaS5nZXRTb2NrZXRJbmZvKHMpKSksLTE7aWYoYXNzZXJ0JGEuc3RyaWN0RXF1YWwodGhpcy50aW1lb3V0VHlwZSxUSU1FT1VUX0hFQURFUlMpLHRoaXMuc3RhdHVzQ29kZT1BLHRoaXMuc2hvdWxkS2VlcEFsaXZlPW58fFEubWV0aG9kPT09XCJIRUFEXCImJiFzW2tSZXNldCQxXSYmdGhpcy5jb25uZWN0aW9uLnRvTG93ZXJDYXNlKCk9PT1cImtlZXAtYWxpdmVcIix0aGlzLnN0YXR1c0NvZGU+PTIwMCl7Y29uc3QgST1RLmJvZHlUaW1lb3V0IT1udWxsP1EuYm9keVRpbWVvdXQ6cltrQm9keVRpbWVvdXQkMV07dGhpcy5zZXRUaW1lb3V0KEksVElNRU9VVF9CT0RZKX1lbHNlIHRoaXMudGltZW91dCYmdGhpcy50aW1lb3V0LnJlZnJlc2gmJnRoaXMudGltZW91dC5yZWZyZXNoKCk7aWYoUS5tZXRob2Q9PT1cIkNPTk5FQ1RcIilyZXR1cm4gYXNzZXJ0JGEocltrUnVubmluZyQ1XT09PTEpLHRoaXMudXBncmFkZT0hMCwyO2lmKHQpcmV0dXJuIGFzc2VydCRhKHJba1J1bm5pbmckNV09PT0xKSx0aGlzLnVwZ3JhZGU9ITAsMjtpZihhc3NlcnQkYSh0aGlzLmhlYWRlcnMubGVuZ3RoJTI9PT0wKSx0aGlzLmhlYWRlcnM9W10sdGhpcy5oZWFkZXJzU2l6ZT0wLHRoaXMuc2hvdWxkS2VlcEFsaXZlJiZyW2tQaXBlbGluaW5nJDFdKXtjb25zdCBJPXRoaXMua2VlcEFsaXZlP3V0aWwkaS5wYXJzZUtlZXBBbGl2ZVRpbWVvdXQodGhpcy5rZWVwQWxpdmUpOm51bGw7aWYoSSE9bnVsbCl7Y29uc3QgYT1NYXRoLm1pbihJLXJba0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQkMV0scltrS2VlcEFsaXZlTWF4VGltZW91dCQxXSk7YTw9MD9zW2tSZXNldCQxXT0hMDpyW2tLZWVwQWxpdmVUaW1lb3V0VmFsdWUkMV09YX1lbHNlIHJba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSQxXT1yW2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dCQxXX1lbHNlIHNba1Jlc2V0JDFdPSEwO2NvbnN0IEM9US5vbkhlYWRlcnMoQSxpLHRoaXMucmVzdW1lLEUpPT09ITE7cmV0dXJuIFEuYWJvcnRlZD8tMTpRLm1ldGhvZD09PVwiSEVBRFwifHxBPDIwMD8xOihzW2tCbG9ja2luZ10mJihzW2tCbG9ja2luZ109ITEscltrUmVzdW1lJDNdKCkpLEM/Y29uc3RhbnRzJDIuRVJST1IuUEFVU0VEOjApfW9uQm9keShBKXtjb25zdHtjbGllbnQ6dCxzb2NrZXQ6bixzdGF0dXNDb2RlOnIsbWF4UmVzcG9uc2VTaXplOnN9PXRoaXM7aWYobi5kZXN0cm95ZWQpcmV0dXJuLTE7Y29uc3QgaT10W2tRdWV1ZSQzXVt0W2tSdW5uaW5nSWR4JDJdXTtpZihhc3NlcnQkYShpKSxhc3NlcnQkYS5zdHJpY3RFcXVhbCh0aGlzLnRpbWVvdXRUeXBlLFRJTUVPVVRfQk9EWSksdGhpcy50aW1lb3V0JiZ0aGlzLnRpbWVvdXQucmVmcmVzaCYmdGhpcy50aW1lb3V0LnJlZnJlc2goKSxhc3NlcnQkYShyPj0yMDApLHM+LTEmJnRoaXMuYnl0ZXNSZWFkK0EubGVuZ3RoPnMpcmV0dXJuIHV0aWwkaS5kZXN0cm95KG4sbmV3IFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IpLC0xO2lmKHRoaXMuYnl0ZXNSZWFkKz1BLmxlbmd0aCxpLm9uRGF0YShBKT09PSExKXJldHVybiBjb25zdGFudHMkMi5FUlJPUi5QQVVTRUR9b25NZXNzYWdlQ29tcGxldGUoKXtjb25zdHtjbGllbnQ6QSxzb2NrZXQ6dCxzdGF0dXNDb2RlOm4sdXBncmFkZTpyLGhlYWRlcnM6cyxjb250ZW50TGVuZ3RoOmksYnl0ZXNSZWFkOkUsc2hvdWxkS2VlcEFsaXZlOlF9PXRoaXM7aWYodC5kZXN0cm95ZWQmJighbnx8USkpcmV0dXJuLTE7aWYocilyZXR1cm47Y29uc3QgQz1BW2tRdWV1ZSQzXVtBW2tSdW5uaW5nSWR4JDJdXTtpZihhc3NlcnQkYShDKSxhc3NlcnQkYShuPj0xMDApLHRoaXMuc3RhdHVzQ29kZT1udWxsLHRoaXMuc3RhdHVzVGV4dD1cIlwiLHRoaXMuYnl0ZXNSZWFkPTAsdGhpcy5jb250ZW50TGVuZ3RoPVwiXCIsdGhpcy5rZWVwQWxpdmU9XCJcIix0aGlzLmNvbm5lY3Rpb249XCJcIixhc3NlcnQkYSh0aGlzLmhlYWRlcnMubGVuZ3RoJTI9PT0wKSx0aGlzLmhlYWRlcnM9W10sdGhpcy5oZWFkZXJzU2l6ZT0wLCEobjwyMDApKXtpZihDLm1ldGhvZCE9PVwiSEVBRFwiJiZpJiZFIT09cGFyc2VJbnQoaSwxMCkpcmV0dXJuIHV0aWwkaS5kZXN0cm95KHQsbmV3IFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IpLC0xO2lmKEMub25Db21wbGV0ZShzKSxBW2tRdWV1ZSQzXVtBW2tSdW5uaW5nSWR4JDJdKytdPW51bGwsdFtrV3JpdGluZ10pcmV0dXJuIGFzc2VydCRhLnN0cmljdEVxdWFsKEFba1J1bm5pbmckNV0sMCksdXRpbCRpLmRlc3Ryb3kodCxuZXcgSW5mb3JtYXRpb25hbEVycm9yJDIoXCJyZXNldFwiKSksY29uc3RhbnRzJDIuRVJST1IuUEFVU0VEO2lmKFEpe2lmKHRba1Jlc2V0JDFdJiZBW2tSdW5uaW5nJDVdPT09MClyZXR1cm4gdXRpbCRpLmRlc3Ryb3kodCxuZXcgSW5mb3JtYXRpb25hbEVycm9yJDIoXCJyZXNldFwiKSksY29uc3RhbnRzJDIuRVJST1IuUEFVU0VEO0Fba1BpcGVsaW5pbmckMV09PW51bGx8fEFba1BpcGVsaW5pbmckMV09PT0xP3NldEltbWVkaWF0ZSgoKT0+QVtrUmVzdW1lJDNdKCkpOkFba1Jlc3VtZSQzXSgpfWVsc2UgcmV0dXJuIHV0aWwkaS5kZXN0cm95KHQsbmV3IEluZm9ybWF0aW9uYWxFcnJvciQyKFwicmVzZXRcIikpLGNvbnN0YW50cyQyLkVSUk9SLlBBVVNFRH19fTtvKHN0LFwiUGFyc2VyXCIpO2xldCBQYXJzZXI9c3Q7ZnVuY3Rpb24gb25QYXJzZXJUaW1lb3V0KGUpe2NvbnN0e3NvY2tldDpBLHRpbWVvdXRUeXBlOnQsY2xpZW50Om59PWU7dD09PVRJTUVPVVRfSEVBREVSUz8oIUFba1dyaXRpbmddfHxBLndyaXRhYmxlTmVlZERyYWlufHxuW2tSdW5uaW5nJDVdPjEpJiYoYXNzZXJ0JGEoIWUucGF1c2VkLFwiY2Fubm90IGJlIHBhdXNlZCB3aGlsZSB3YWl0aW5nIGZvciBoZWFkZXJzXCIpLHV0aWwkaS5kZXN0cm95KEEsbmV3IEhlYWRlcnNUaW1lb3V0RXJyb3IpKTp0PT09VElNRU9VVF9CT0RZP2UucGF1c2VkfHx1dGlsJGkuZGVzdHJveShBLG5ldyBCb2R5VGltZW91dEVycm9yKTp0PT09VElNRU9VVF9JRExFJiYoYXNzZXJ0JGEobltrUnVubmluZyQ1XT09PTAmJm5ba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSQxXSksdXRpbCRpLmRlc3Ryb3koQSxuZXcgSW5mb3JtYXRpb25hbEVycm9yJDIoXCJzb2NrZXQgaWRsZSB0aW1lb3V0XCIpKSl9byhvblBhcnNlclRpbWVvdXQsXCJvblBhcnNlclRpbWVvdXRcIik7YXN5bmMgZnVuY3Rpb24gY29ubmVjdEgxJDEoZSxBKXtlW2tTb2NrZXQkMV09QSxsbGh0dHBJbnN0YW5jZXx8KGxsaHR0cEluc3RhbmNlPWF3YWl0IGxsaHR0cFByb21pc2UsbGxodHRwUHJvbWlzZT1udWxsKSxBW2tOb1JlZl09ITEsQVtrV3JpdGluZ109ITEsQVtrUmVzZXQkMV09ITEsQVtrQmxvY2tpbmddPSExLEFba1BhcnNlcl09bmV3IFBhcnNlcihlLEEsbGxodHRwSW5zdGFuY2UpLGFkZExpc3RlbmVyKEEsXCJlcnJvclwiLGZ1bmN0aW9uKG4pe2NvbnN0IHI9dGhpc1trUGFyc2VyXTtpZihhc3NlcnQkYShuLmNvZGUhPT1cIkVSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSURcIiksbi5jb2RlPT09XCJFQ09OTlJFU0VUXCImJnIuc3RhdHVzQ29kZSYmIXIuc2hvdWxkS2VlcEFsaXZlKXtyLm9uTWVzc2FnZUNvbXBsZXRlKCk7cmV0dXJufXRoaXNba0Vycm9yJDJdPW4sdGhpc1trQ2xpZW50JDNdW2tPbkVycm9yJDJdKG4pfSksYWRkTGlzdGVuZXIoQSxcInJlYWRhYmxlXCIsZnVuY3Rpb24oKXtjb25zdCBuPXRoaXNba1BhcnNlcl07biYmbi5yZWFkTW9yZSgpfSksYWRkTGlzdGVuZXIoQSxcImVuZFwiLGZ1bmN0aW9uKCl7Y29uc3Qgbj10aGlzW2tQYXJzZXJdO2lmKG4uc3RhdHVzQ29kZSYmIW4uc2hvdWxkS2VlcEFsaXZlKXtuLm9uTWVzc2FnZUNvbXBsZXRlKCk7cmV0dXJufXV0aWwkaS5kZXN0cm95KHRoaXMsbmV3IFNvY2tldEVycm9yJDMoXCJvdGhlciBzaWRlIGNsb3NlZFwiLHV0aWwkaS5nZXRTb2NrZXRJbmZvKHRoaXMpKSl9KSxhZGRMaXN0ZW5lcihBLFwiY2xvc2VcIixmdW5jdGlvbigpe2NvbnN0IG49dGhpc1trQ2xpZW50JDNdLHI9dGhpc1trUGFyc2VyXTtyJiYoIXRoaXNba0Vycm9yJDJdJiZyLnN0YXR1c0NvZGUmJiFyLnNob3VsZEtlZXBBbGl2ZSYmci5vbk1lc3NhZ2VDb21wbGV0ZSgpLHRoaXNba1BhcnNlcl0uZGVzdHJveSgpLHRoaXNba1BhcnNlcl09bnVsbCk7Y29uc3Qgcz10aGlzW2tFcnJvciQyXXx8bmV3IFNvY2tldEVycm9yJDMoXCJjbG9zZWRcIix1dGlsJGkuZ2V0U29ja2V0SW5mbyh0aGlzKSk7aWYobltrU29ja2V0JDFdPW51bGwsbltrSFRUUENvbnRleHQkMV09bnVsbCxuLmRlc3Ryb3llZCl7YXNzZXJ0JGEobltrUGVuZGluZyQ0XT09PTApO2NvbnN0IGk9bltrUXVldWUkM10uc3BsaWNlKG5ba1J1bm5pbmdJZHgkMl0pO2ZvcihsZXQgRT0wO0U8aS5sZW5ndGg7RSsrKXtjb25zdCBRPWlbRV07dXRpbCRpLmVycm9yUmVxdWVzdChuLFEscyl9fWVsc2UgaWYobltrUnVubmluZyQ1XT4wJiZzLmNvZGUhPT1cIlVORF9FUlJfSU5GT1wiKXtjb25zdCBpPW5ba1F1ZXVlJDNdW25ba1J1bm5pbmdJZHgkMl1dO25ba1F1ZXVlJDNdW25ba1J1bm5pbmdJZHgkMl0rK109bnVsbCx1dGlsJGkuZXJyb3JSZXF1ZXN0KG4saSxzKX1uW2tQZW5kaW5nSWR4JDJdPW5ba1J1bm5pbmdJZHgkMl0sYXNzZXJ0JGEobltrUnVubmluZyQ1XT09PTApLG4uZW1pdChcImRpc2Nvbm5lY3RcIixuW2tVcmwkNF0sW25dLHMpLG5ba1Jlc3VtZSQzXSgpfSk7bGV0IHQ9ITE7cmV0dXJuIEEub24oXCJjbG9zZVwiLCgpPT57dD0hMH0pLHt2ZXJzaW9uOlwiaDFcIixkZWZhdWx0UGlwZWxpbmluZzoxLHdyaXRlKC4uLm4pe3JldHVybiB3cml0ZUgxKGUsLi4ubil9LHJlc3VtZSgpe3Jlc3VtZUgxKGUpfSxkZXN0cm95KG4scil7dD9xdWV1ZU1pY3JvdGFzayhyKTpBLmRlc3Ryb3kobikub24oXCJjbG9zZVwiLHIpfSxnZXQgZGVzdHJveWVkKCl7cmV0dXJuIEEuZGVzdHJveWVkfSxidXN5KG4pe3JldHVybiEhKEFba1dyaXRpbmddfHxBW2tSZXNldCQxXXx8QVtrQmxvY2tpbmddfHxuJiYoZVtrUnVubmluZyQ1XT4wJiYhbi5pZGVtcG90ZW50fHxlW2tSdW5uaW5nJDVdPjAmJihuLnVwZ3JhZGV8fG4ubWV0aG9kPT09XCJDT05ORUNUXCIpfHxlW2tSdW5uaW5nJDVdPjAmJnV0aWwkaS5ib2R5TGVuZ3RoKG4uYm9keSkhPT0wJiYodXRpbCRpLmlzU3RyZWFtKG4uYm9keSl8fHV0aWwkaS5pc0FzeW5jSXRlcmFibGUobi5ib2R5KXx8dXRpbCRpLmlzRm9ybURhdGFMaWtlKG4uYm9keSkpKSl9fX1vKGNvbm5lY3RIMSQxLFwiY29ubmVjdEgxJDFcIik7ZnVuY3Rpb24gcmVzdW1lSDEoZSl7Y29uc3QgQT1lW2tTb2NrZXQkMV07aWYoQSYmIUEuZGVzdHJveWVkKXtpZihlW2tTaXplJDRdPT09MD8hQVtrTm9SZWZdJiZBLnVucmVmJiYoQS51bnJlZigpLEFba05vUmVmXT0hMCk6QVtrTm9SZWZdJiZBLnJlZiYmKEEucmVmKCksQVtrTm9SZWZdPSExKSxlW2tTaXplJDRdPT09MClBW2tQYXJzZXJdLnRpbWVvdXRUeXBlIT09VElNRU9VVF9JRExFJiZBW2tQYXJzZXJdLnNldFRpbWVvdXQoZVtrS2VlcEFsaXZlVGltZW91dFZhbHVlJDFdLFRJTUVPVVRfSURMRSk7ZWxzZSBpZihlW2tSdW5uaW5nJDVdPjAmJkFba1BhcnNlcl0uc3RhdHVzQ29kZTwyMDAmJkFba1BhcnNlcl0udGltZW91dFR5cGUhPT1USU1FT1VUX0hFQURFUlMpe2NvbnN0IHQ9ZVtrUXVldWUkM11bZVtrUnVubmluZ0lkeCQyXV0sbj10LmhlYWRlcnNUaW1lb3V0IT1udWxsP3QuaGVhZGVyc1RpbWVvdXQ6ZVtrSGVhZGVyc1RpbWVvdXQkMV07QVtrUGFyc2VyXS5zZXRUaW1lb3V0KG4sVElNRU9VVF9IRUFERVJTKX19fW8ocmVzdW1lSDEsXCJyZXN1bWVIMVwiKTtmdW5jdGlvbiBzaG91bGRTZW5kQ29udGVudExlbmd0aCQxKGUpe3JldHVybiBlIT09XCJHRVRcIiYmZSE9PVwiSEVBRFwiJiZlIT09XCJPUFRJT05TXCImJmUhPT1cIlRSQUNFXCImJmUhPT1cIkNPTk5FQ1RcIn1vKHNob3VsZFNlbmRDb250ZW50TGVuZ3RoJDEsXCJzaG91bGRTZW5kQ29udGVudExlbmd0aCQxXCIpO2Z1bmN0aW9uIHdyaXRlSDEoZSxBKXtjb25zdHttZXRob2Q6dCxwYXRoOm4saG9zdDpyLHVwZ3JhZGU6cyxibG9ja2luZzppLHJlc2V0OkV9PUE7bGV0e2JvZHk6USxoZWFkZXJzOkMsY29udGVudExlbmd0aDpJfT1BO2NvbnN0IGE9dD09PVwiUFVUXCJ8fHQ9PT1cIlBPU1RcInx8dD09PVwiUEFUQ0hcIjtpZih1dGlsJGkuaXNGb3JtRGF0YUxpa2UoUSkpe2V4dHJhY3RCb2R5fHwoZXh0cmFjdEJvZHk9cmVxdWlyZUJvZHkoKS5leHRyYWN0Qm9keSk7Y29uc3RbbCxTXT1leHRyYWN0Qm9keShRKTtBLmNvbnRlbnRUeXBlPT1udWxsJiZDLnB1c2goXCJjb250ZW50LXR5cGVcIixTKSxRPWwuc3RyZWFtLEk9bC5sZW5ndGh9ZWxzZSB1dGlsJGkuaXNCbG9iTGlrZShRKSYmQS5jb250ZW50VHlwZT09bnVsbCYmUS50eXBlJiZDLnB1c2goXCJjb250ZW50LXR5cGVcIixRLnR5cGUpO1EmJnR5cGVvZiBRLnJlYWQ9PVwiZnVuY3Rpb25cIiYmUS5yZWFkKDApO2NvbnN0IGY9dXRpbCRpLmJvZHlMZW5ndGgoUSk7aWYoST1mPz9JLEk9PT1udWxsJiYoST1BLmNvbnRlbnRMZW5ndGgpLEk9PT0wJiYhYSYmKEk9bnVsbCksc2hvdWxkU2VuZENvbnRlbnRMZW5ndGgkMSh0KSYmST4wJiZBLmNvbnRlbnRMZW5ndGghPT1udWxsJiZBLmNvbnRlbnRMZW5ndGghPT1JKXtpZihlW2tTdHJpY3RDb250ZW50TGVuZ3RoJDJdKXJldHVybiB1dGlsJGkuZXJyb3JSZXF1ZXN0KGUsQSxuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJDEpLCExO3Byb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciQxKX1jb25zdCBoPWVba1NvY2tldCQxXSxMPW8obD0+e0EuYWJvcnRlZHx8QS5jb21wbGV0ZWR8fCh1dGlsJGkuZXJyb3JSZXF1ZXN0KGUsQSxsfHxuZXcgUmVxdWVzdEFib3J0ZWRFcnJvciQ1KSx1dGlsJGkuZGVzdHJveShRKSx1dGlsJGkuZGVzdHJveShoLG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IkMihcImFib3J0ZWRcIikpKX0sXCJhYm9ydFwiKTt0cnl7QS5vbkNvbm5lY3QoTCl9Y2F0Y2gobCl7dXRpbCRpLmVycm9yUmVxdWVzdChlLEEsbCl9aWYoQS5hYm9ydGVkKXJldHVybiExO3Q9PT1cIkhFQURcIiYmKGhba1Jlc2V0JDFdPSEwKSwoc3x8dD09PVwiQ09OTkVDVFwiKSYmKGhba1Jlc2V0JDFdPSEwKSxFIT1udWxsJiYoaFtrUmVzZXQkMV09RSksZVtrTWF4UmVxdWVzdHMkMV0mJmhba0NvdW50ZXIkMV0rKz49ZVtrTWF4UmVxdWVzdHMkMV0mJihoW2tSZXNldCQxXT0hMCksaSYmKGhba0Jsb2NraW5nXT0hMCk7bGV0IGM9YCR7dH0gJHtufSBIVFRQLzEuMVxcclxuYDtpZih0eXBlb2Ygcj09XCJzdHJpbmdcIj9jKz1gaG9zdDogJHtyfVxcclxuYDpjKz1lW2tIb3N0SGVhZGVyJDFdLHM/Yys9YGNvbm5lY3Rpb246IHVwZ3JhZGVcXHJcbnVwZ3JhZGU6ICR7c31cXHJcbmA6ZVtrUGlwZWxpbmluZyQxXSYmIWhba1Jlc2V0JDFdP2MrPWBjb25uZWN0aW9uOiBrZWVwLWFsaXZlXFxyXG5gOmMrPWBjb25uZWN0aW9uOiBjbG9zZVxcclxuYCxBcnJheS5pc0FycmF5KEMpKWZvcihsZXQgbD0wO2w8Qy5sZW5ndGg7bCs9Mil7Y29uc3QgUz1DW2wrMF0saz1DW2wrMV07aWYoQXJyYXkuaXNBcnJheShrKSlmb3IobGV0IHc9MDt3PGsubGVuZ3RoO3crKyljKz1gJHtTfTogJHtrW3ddfVxcclxuYDtlbHNlIGMrPWAke1N9OiAke2t9XFxyXG5gfXJldHVybiBjaGFubmVscyQxLnNlbmRIZWFkZXJzLmhhc1N1YnNjcmliZXJzJiZjaGFubmVscyQxLnNlbmRIZWFkZXJzLnB1Ymxpc2goe3JlcXVlc3Q6QSxoZWFkZXJzOmMsc29ja2V0Omh9KSwhUXx8Zj09PTA/d3JpdGVCdWZmZXIoe2Fib3J0OkwsYm9keTpudWxsLGNsaWVudDplLHJlcXVlc3Q6QSxzb2NrZXQ6aCxjb250ZW50TGVuZ3RoOkksaGVhZGVyOmMsZXhwZWN0c1BheWxvYWQ6YX0pOnV0aWwkaS5pc0J1ZmZlcihRKT93cml0ZUJ1ZmZlcih7YWJvcnQ6TCxib2R5OlEsY2xpZW50OmUscmVxdWVzdDpBLHNvY2tldDpoLGNvbnRlbnRMZW5ndGg6SSxoZWFkZXI6YyxleHBlY3RzUGF5bG9hZDphfSk6dXRpbCRpLmlzQmxvYkxpa2UoUSk/dHlwZW9mIFEuc3RyZWFtPT1cImZ1bmN0aW9uXCI/d3JpdGVJdGVyYWJsZSQxKHthYm9ydDpMLGJvZHk6US5zdHJlYW0oKSxjbGllbnQ6ZSxyZXF1ZXN0OkEsc29ja2V0OmgsY29udGVudExlbmd0aDpJLGhlYWRlcjpjLGV4cGVjdHNQYXlsb2FkOmF9KTp3cml0ZUJsb2IkMSh7YWJvcnQ6TCxib2R5OlEsY2xpZW50OmUscmVxdWVzdDpBLHNvY2tldDpoLGNvbnRlbnRMZW5ndGg6SSxoZWFkZXI6YyxleHBlY3RzUGF5bG9hZDphfSk6dXRpbCRpLmlzU3RyZWFtKFEpP3dyaXRlU3RyZWFtJDEoe2Fib3J0OkwsYm9keTpRLGNsaWVudDplLHJlcXVlc3Q6QSxzb2NrZXQ6aCxjb250ZW50TGVuZ3RoOkksaGVhZGVyOmMsZXhwZWN0c1BheWxvYWQ6YX0pOnV0aWwkaS5pc0l0ZXJhYmxlKFEpP3dyaXRlSXRlcmFibGUkMSh7YWJvcnQ6TCxib2R5OlEsY2xpZW50OmUscmVxdWVzdDpBLHNvY2tldDpoLGNvbnRlbnRMZW5ndGg6SSxoZWFkZXI6YyxleHBlY3RzUGF5bG9hZDphfSk6YXNzZXJ0JGEoITEpLCEwfW8od3JpdGVIMSxcIndyaXRlSDFcIik7ZnVuY3Rpb24gd3JpdGVTdHJlYW0kMSh7YWJvcnQ6ZSxib2R5OkEsY2xpZW50OnQscmVxdWVzdDpuLHNvY2tldDpyLGNvbnRlbnRMZW5ndGg6cyxoZWFkZXI6aSxleHBlY3RzUGF5bG9hZDpFfSl7YXNzZXJ0JGEocyE9PTB8fHRba1J1bm5pbmckNV09PT0wLFwic3RyZWFtIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZFwiKTtsZXQgUT0hMTtjb25zdCBDPW5ldyBBc3luY1dyaXRlcih7YWJvcnQ6ZSxzb2NrZXQ6cixyZXF1ZXN0Om4sY29udGVudExlbmd0aDpzLGNsaWVudDp0LGV4cGVjdHNQYXlsb2FkOkUsaGVhZGVyOml9KSxJPW8oZnVuY3Rpb24oTCl7aWYoIVEpdHJ5eyFDLndyaXRlKEwpJiZ0aGlzLnBhdXNlJiZ0aGlzLnBhdXNlKCl9Y2F0Y2goYyl7dXRpbCRpLmRlc3Ryb3kodGhpcyxjKX19LFwib25EYXRhXCIpLGE9byhmdW5jdGlvbigpe1F8fEEucmVzdW1lJiZBLnJlc3VtZSgpfSxcIm9uRHJhaW5cIiksZj1vKGZ1bmN0aW9uKCl7aWYocXVldWVNaWNyb3Rhc2soKCk9PntBLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIixoKX0pLCFRKXtjb25zdCBMPW5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yJDU7cXVldWVNaWNyb3Rhc2soKCk9PmgoTCkpfX0sXCJvbkNsb3NlXCIpLGg9byhmdW5jdGlvbihMKXtpZighUSl7aWYoUT0hMCxhc3NlcnQkYShyLmRlc3Ryb3llZHx8cltrV3JpdGluZ10mJnRba1J1bm5pbmckNV08PTEpLHIub2ZmKFwiZHJhaW5cIixhKS5vZmYoXCJlcnJvclwiLGgpLEEucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsSSkucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIixoKS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsZiksIUwpdHJ5e0MuZW5kKCl9Y2F0Y2goYyl7TD1jfUMuZGVzdHJveShMKSxMJiYoTC5jb2RlIT09XCJVTkRfRVJSX0lORk9cInx8TC5tZXNzYWdlIT09XCJyZXNldFwiKT91dGlsJGkuZGVzdHJveShBLEwpOnV0aWwkaS5kZXN0cm95KEEpfX0sXCJvbkZpbmlzaGVkXCIpO0Eub24oXCJkYXRhXCIsSSkub24oXCJlbmRcIixoKS5vbihcImVycm9yXCIsaCkub24oXCJjbG9zZVwiLGYpLEEucmVzdW1lJiZBLnJlc3VtZSgpLHIub24oXCJkcmFpblwiLGEpLm9uKFwiZXJyb3JcIixoKSxBLmVycm9yRW1pdHRlZD8/QS5lcnJvcmVkP3NldEltbWVkaWF0ZSgoKT0+aChBLmVycm9yZWQpKTooQS5lbmRFbWl0dGVkPz9BLnJlYWRhYmxlRW5kZWQpJiZzZXRJbW1lZGlhdGUoKCk9PmgobnVsbCkpLChBLmNsb3NlRW1pdHRlZD8/QS5jbG9zZWQpJiZzZXRJbW1lZGlhdGUoZil9byh3cml0ZVN0cmVhbSQxLFwid3JpdGVTdHJlYW0kMVwiKTthc3luYyBmdW5jdGlvbiB3cml0ZUJ1ZmZlcih7YWJvcnQ6ZSxib2R5OkEsY2xpZW50OnQscmVxdWVzdDpuLHNvY2tldDpyLGNvbnRlbnRMZW5ndGg6cyxoZWFkZXI6aSxleHBlY3RzUGF5bG9hZDpFfSl7dHJ5e0E/dXRpbCRpLmlzQnVmZmVyKEEpJiYoYXNzZXJ0JGEocz09PUEuYnl0ZUxlbmd0aCxcImJ1ZmZlciBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aFwiKSxyLmNvcmsoKSxyLndyaXRlKGAke2l9Y29udGVudC1sZW5ndGg6ICR7c31cXHJcblxcclxuYCxcImxhdGluMVwiKSxyLndyaXRlKEEpLHIudW5jb3JrKCksbi5vbkJvZHlTZW50KEEpLEV8fChyW2tSZXNldCQxXT0hMCkpOnM9PT0wP3Iud3JpdGUoYCR7aX1jb250ZW50LWxlbmd0aDogMFxcclxuXFxyXG5gLFwibGF0aW4xXCIpOihhc3NlcnQkYShzPT09bnVsbCxcIm5vIGJvZHkgbXVzdCBub3QgaGF2ZSBjb250ZW50IGxlbmd0aFwiKSxyLndyaXRlKGAke2l9XFxyXG5gLFwibGF0aW4xXCIpKSxuLm9uUmVxdWVzdFNlbnQoKSx0W2tSZXN1bWUkM10oKX1jYXRjaChRKXtlKFEpfX1vKHdyaXRlQnVmZmVyLFwid3JpdGVCdWZmZXJcIik7YXN5bmMgZnVuY3Rpb24gd3JpdGVCbG9iJDEoe2Fib3J0OmUsYm9keTpBLGNsaWVudDp0LHJlcXVlc3Q6bixzb2NrZXQ6cixjb250ZW50TGVuZ3RoOnMsaGVhZGVyOmksZXhwZWN0c1BheWxvYWQ6RX0pe2Fzc2VydCRhKHM9PT1BLnNpemUsXCJibG9iIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoXCIpO3RyeXtpZihzIT1udWxsJiZzIT09QS5zaXplKXRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IkMTtjb25zdCBRPUJ1ZmZlci5mcm9tKGF3YWl0IEEuYXJyYXlCdWZmZXIoKSk7ci5jb3JrKCksci53cml0ZShgJHtpfWNvbnRlbnQtbGVuZ3RoOiAke3N9XFxyXG5cXHJcbmAsXCJsYXRpbjFcIiksci53cml0ZShRKSxyLnVuY29yaygpLG4ub25Cb2R5U2VudChRKSxuLm9uUmVxdWVzdFNlbnQoKSxFfHwocltrUmVzZXQkMV09ITApLHRba1Jlc3VtZSQzXSgpfWNhdGNoKFEpe2UoUSl9fW8od3JpdGVCbG9iJDEsXCJ3cml0ZUJsb2IkMVwiKTthc3luYyBmdW5jdGlvbiB3cml0ZUl0ZXJhYmxlJDEoe2Fib3J0OmUsYm9keTpBLGNsaWVudDp0LHJlcXVlc3Q6bixzb2NrZXQ6cixjb250ZW50TGVuZ3RoOnMsaGVhZGVyOmksZXhwZWN0c1BheWxvYWQ6RX0pe2Fzc2VydCRhKHMhPT0wfHx0W2tSdW5uaW5nJDVdPT09MCxcIml0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZFwiKTtsZXQgUT1udWxsO2Z1bmN0aW9uIEMoKXtpZihRKXtjb25zdCBmPVE7UT1udWxsLGYoKX19byhDLFwib25EcmFpblwiKTtjb25zdCBJPW8oKCk9Pm5ldyBQcm9taXNlKChmLGgpPT57YXNzZXJ0JGEoUT09PW51bGwpLHJba0Vycm9yJDJdP2gocltrRXJyb3IkMl0pOlE9Zn0pLFwid2FpdEZvckRyYWluXCIpO3Iub24oXCJjbG9zZVwiLEMpLm9uKFwiZHJhaW5cIixDKTtjb25zdCBhPW5ldyBBc3luY1dyaXRlcih7YWJvcnQ6ZSxzb2NrZXQ6cixyZXF1ZXN0Om4sY29udGVudExlbmd0aDpzLGNsaWVudDp0LGV4cGVjdHNQYXlsb2FkOkUsaGVhZGVyOml9KTt0cnl7Zm9yIGF3YWl0KGNvbnN0IGYgb2YgQSl7aWYocltrRXJyb3IkMl0pdGhyb3cgcltrRXJyb3IkMl07YS53cml0ZShmKXx8YXdhaXQgSSgpfWEuZW5kKCl9Y2F0Y2goZil7YS5kZXN0cm95KGYpfWZpbmFsbHl7ci5vZmYoXCJjbG9zZVwiLEMpLm9mZihcImRyYWluXCIsQyl9fW8od3JpdGVJdGVyYWJsZSQxLFwid3JpdGVJdGVyYWJsZSQxXCIpO2NvbnN0IG90PWNsYXNzIG90e2NvbnN0cnVjdG9yKHthYm9ydDpBLHNvY2tldDp0LHJlcXVlc3Q6bixjb250ZW50TGVuZ3RoOnIsY2xpZW50OnMsZXhwZWN0c1BheWxvYWQ6aSxoZWFkZXI6RX0pe3RoaXMuc29ja2V0PXQsdGhpcy5yZXF1ZXN0PW4sdGhpcy5jb250ZW50TGVuZ3RoPXIsdGhpcy5jbGllbnQ9cyx0aGlzLmJ5dGVzV3JpdHRlbj0wLHRoaXMuZXhwZWN0c1BheWxvYWQ9aSx0aGlzLmhlYWRlcj1FLHRoaXMuYWJvcnQ9QSx0W2tXcml0aW5nXT0hMH13cml0ZShBKXtjb25zdHtzb2NrZXQ6dCxyZXF1ZXN0Om4sY29udGVudExlbmd0aDpyLGNsaWVudDpzLGJ5dGVzV3JpdHRlbjppLGV4cGVjdHNQYXlsb2FkOkUsaGVhZGVyOlF9PXRoaXM7aWYodFtrRXJyb3IkMl0pdGhyb3cgdFtrRXJyb3IkMl07aWYodC5kZXN0cm95ZWQpcmV0dXJuITE7Y29uc3QgQz1CdWZmZXIuYnl0ZUxlbmd0aChBKTtpZighQylyZXR1cm4hMDtpZihyIT09bnVsbCYmaStDPnIpe2lmKHNba1N0cmljdENvbnRlbnRMZW5ndGgkMl0pdGhyb3cgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciQxO3Byb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciQxKX10LmNvcmsoKSxpPT09MCYmKEV8fCh0W2tSZXNldCQxXT0hMCkscj09PW51bGw/dC53cml0ZShgJHtRfXRyYW5zZmVyLWVuY29kaW5nOiBjaHVua2VkXFxyXG5gLFwibGF0aW4xXCIpOnQud3JpdGUoYCR7UX1jb250ZW50LWxlbmd0aDogJHtyfVxcclxuXFxyXG5gLFwibGF0aW4xXCIpKSxyPT09bnVsbCYmdC53cml0ZShgXFxyXG4ke0MudG9TdHJpbmcoMTYpfVxcclxuYCxcImxhdGluMVwiKSx0aGlzLmJ5dGVzV3JpdHRlbis9Qztjb25zdCBJPXQud3JpdGUoQSk7cmV0dXJuIHQudW5jb3JrKCksbi5vbkJvZHlTZW50KEEpLEl8fHRba1BhcnNlcl0udGltZW91dCYmdFtrUGFyc2VyXS50aW1lb3V0VHlwZT09PVRJTUVPVVRfSEVBREVSUyYmdFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2gmJnRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKCksSX1lbmQoKXtjb25zdHtzb2NrZXQ6QSxjb250ZW50TGVuZ3RoOnQsY2xpZW50Om4sYnl0ZXNXcml0dGVuOnIsZXhwZWN0c1BheWxvYWQ6cyxoZWFkZXI6aSxyZXF1ZXN0OkV9PXRoaXM7aWYoRS5vblJlcXVlc3RTZW50KCksQVtrV3JpdGluZ109ITEsQVtrRXJyb3IkMl0pdGhyb3cgQVtrRXJyb3IkMl07aWYoIUEuZGVzdHJveWVkKXtpZihyPT09MD9zP0Eud3JpdGUoYCR7aX1jb250ZW50LWxlbmd0aDogMFxcclxuXFxyXG5gLFwibGF0aW4xXCIpOkEud3JpdGUoYCR7aX1cXHJcbmAsXCJsYXRpbjFcIik6dD09PW51bGwmJkEud3JpdGUoYFxcclxuMFxcclxuXFxyXG5gLFwibGF0aW4xXCIpLHQhPT1udWxsJiZyIT09dCl7aWYobltrU3RyaWN0Q29udGVudExlbmd0aCQyXSl0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJDE7cHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJDEpfUFba1BhcnNlcl0udGltZW91dCYmQVtrUGFyc2VyXS50aW1lb3V0VHlwZT09PVRJTUVPVVRfSEVBREVSUyYmQVtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2gmJkFba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKCksbltrUmVzdW1lJDNdKCl9fWRlc3Ryb3koQSl7Y29uc3R7c29ja2V0OnQsY2xpZW50Om4sYWJvcnQ6cn09dGhpczt0W2tXcml0aW5nXT0hMSxBJiYoYXNzZXJ0JGEobltrUnVubmluZyQ1XTw9MSxcInBpcGVsaW5lIHNob3VsZCBvbmx5IGNvbnRhaW4gdGhpcyByZXF1ZXN0XCIpLHIoQSkpfX07byhvdCxcIkFzeW5jV3JpdGVyXCIpO2xldCBBc3luY1dyaXRlcj1vdDt2YXIgY2xpZW50SDE9Y29ubmVjdEgxJDE7Y29uc3QgYXNzZXJ0JDk9cmVxdWlyZSQkMF9fZGVmYXVsdCx7cGlwZWxpbmU6cGlwZWxpbmUkMX09U3RyZWFtX19kZWZhdWx0LHV0aWwkaD11dGlsJG0se1JlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixSZXF1ZXN0QWJvcnRlZEVycm9yOlJlcXVlc3RBYm9ydGVkRXJyb3IkNCxTb2NrZXRFcnJvcjpTb2NrZXRFcnJvciQyLEluZm9ybWF0aW9uYWxFcnJvcjpJbmZvcm1hdGlvbmFsRXJyb3IkMX09ZXJyb3JzJDEse2tVcmw6a1VybCQzLGtSZXNldCxrQ2xpZW50OmtDbGllbnQkMixrUnVubmluZzprUnVubmluZyQ0LGtQZW5kaW5nOmtQZW5kaW5nJDMsa1F1ZXVlOmtRdWV1ZSQyLGtQZW5kaW5nSWR4OmtQZW5kaW5nSWR4JDEsa1J1bm5pbmdJZHg6a1J1bm5pbmdJZHgkMSxrRXJyb3I6a0Vycm9yJDEsa1NvY2tldCxrU3RyaWN0Q29udGVudExlbmd0aDprU3RyaWN0Q29udGVudExlbmd0aCQxLGtPbkVycm9yOmtPbkVycm9yJDEsa01heENvbmN1cnJlbnRTdHJlYW1zOmtNYXhDb25jdXJyZW50U3RyZWFtcyQxLGtIVFRQMlNlc3Npb24sa1Jlc3VtZTprUmVzdW1lJDJ9PXN5bWJvbHMkNCxrT3BlblN0cmVhbXM9U3ltYm9sKFwib3BlbiBzdHJlYW1zXCIpO2xldCBoMkV4cGVyaW1lbnRhbFdhcm5lZD0hMSxodHRwMjt0cnl7aHR0cDI9cmVxdWlyZShcIm5vZGU6aHR0cDJcIil9Y2F0Y2h7aHR0cDI9e2NvbnN0YW50czp7fX19Y29uc3R7Y29uc3RhbnRzOntIVFRQMl9IRUFERVJfQVVUSE9SSVRZLEhUVFAyX0hFQURFUl9NRVRIT0QsSFRUUDJfSEVBREVSX1BBVEgsSFRUUDJfSEVBREVSX1NDSEVNRSxIVFRQMl9IRUFERVJfQ09OVEVOVF9MRU5HVEgsSFRUUDJfSEVBREVSX0VYUEVDVCxIVFRQMl9IRUFERVJfU1RBVFVTfX09aHR0cDI7ZnVuY3Rpb24gcGFyc2VIMkhlYWRlcnMoZSl7Y29uc3QgQT1bXTtmb3IoY29uc3RbdCxuXW9mIE9iamVjdC5lbnRyaWVzKGUpKWlmKEFycmF5LmlzQXJyYXkobikpZm9yKGNvbnN0IHIgb2YgbilBLnB1c2goQnVmZmVyLmZyb20odCksQnVmZmVyLmZyb20ocikpO2Vsc2UgQS5wdXNoKEJ1ZmZlci5mcm9tKHQpLEJ1ZmZlci5mcm9tKG4pKTtyZXR1cm4gQX1vKHBhcnNlSDJIZWFkZXJzLFwicGFyc2VIMkhlYWRlcnNcIik7YXN5bmMgZnVuY3Rpb24gY29ubmVjdEgyJDEoZSxBKXtlW2tTb2NrZXRdPUEsaDJFeHBlcmltZW50YWxXYXJuZWR8fChoMkV4cGVyaW1lbnRhbFdhcm5lZD0hMCxwcm9jZXNzLmVtaXRXYXJuaW5nKFwiSDIgc3VwcG9ydCBpcyBleHBlcmltZW50YWwsIGV4cGVjdCB0aGVtIHRvIGNoYW5nZSBhdCBhbnkgdGltZS5cIix7Y29kZTpcIlVORElDSS1IMlwifSkpO2NvbnN0IHQ9aHR0cDIuY29ubmVjdChlW2tVcmwkM10se2NyZWF0ZUNvbm5lY3Rpb246KCk9PkEscGVlck1heENvbmN1cnJlbnRTdHJlYW1zOmVba01heENvbmN1cnJlbnRTdHJlYW1zJDFdfSk7dFtrT3BlblN0cmVhbXNdPTAsdFtrQ2xpZW50JDJdPWUsdFtrU29ja2V0XT1BLHV0aWwkaC5hZGRMaXN0ZW5lcih0LFwiZXJyb3JcIixvbkh0dHAyU2Vzc2lvbkVycm9yKSx1dGlsJGguYWRkTGlzdGVuZXIodCxcImZyYW1lRXJyb3JcIixvbkh0dHAyRnJhbWVFcnJvciksdXRpbCRoLmFkZExpc3RlbmVyKHQsXCJlbmRcIixvbkh0dHAyU2Vzc2lvbkVuZCksdXRpbCRoLmFkZExpc3RlbmVyKHQsXCJnb2F3YXlcIixvbkhUVFAyR29Bd2F5KSx1dGlsJGguYWRkTGlzdGVuZXIodCxcImNsb3NlXCIsZnVuY3Rpb24oKXtjb25zdHtba0NsaWVudCQyXTpyfT10aGlzLHM9dGhpc1trU29ja2V0XVtrRXJyb3IkMV18fG5ldyBTb2NrZXRFcnJvciQyKFwiY2xvc2VkXCIsdXRpbCRoLmdldFNvY2tldEluZm8odGhpcykpO3Jba1NvY2tldF09bnVsbCxyW2tIVFRQMlNlc3Npb25dPW51bGwsYXNzZXJ0JDkocltrUGVuZGluZyQzXT09PTApO2NvbnN0IGk9cltrUXVldWUkMl0uc3BsaWNlKHJba1J1bm5pbmdJZHgkMV0pO2ZvcihsZXQgRT0wO0U8aS5sZW5ndGg7RSsrKXtjb25zdCBRPWlbRV07dXRpbCRoLmVycm9yUmVxdWVzdChyLFEscyl9cltrUGVuZGluZ0lkeCQxXT1yW2tSdW5uaW5nSWR4JDFdLGFzc2VydCQ5KHJba1J1bm5pbmckNF09PT0wKSxyLmVtaXQoXCJkaXNjb25uZWN0XCIscltrVXJsJDNdLFtyXSxzKSxyW2tSZXN1bWUkMl0oKX0pLHQudW5yZWYoKSxlW2tIVFRQMlNlc3Npb25dPXQsQVtrSFRUUDJTZXNzaW9uXT10LHV0aWwkaC5hZGRMaXN0ZW5lcihBLFwiZXJyb3JcIixmdW5jdGlvbihyKXthc3NlcnQkOShyLmNvZGUhPT1cIkVSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSURcIiksdGhpc1trRXJyb3IkMV09cix0aGlzW2tDbGllbnQkMl1ba09uRXJyb3IkMV0ocil9KSx1dGlsJGguYWRkTGlzdGVuZXIoQSxcImVuZFwiLGZ1bmN0aW9uKCl7dXRpbCRoLmRlc3Ryb3kodGhpcyxuZXcgU29ja2V0RXJyb3IkMihcIm90aGVyIHNpZGUgY2xvc2VkXCIsdXRpbCRoLmdldFNvY2tldEluZm8odGhpcykpKX0pO2xldCBuPSExO3JldHVybiBBLm9uKFwiY2xvc2VcIiwoKT0+e249ITB9KSx7dmVyc2lvbjpcImgyXCIsZGVmYXVsdFBpcGVsaW5pbmc6MS8wLHdyaXRlKC4uLnIpe3dyaXRlSDIoZSwuLi5yKX0scmVzdW1lKCl7fSxkZXN0cm95KHIscyl7dC5kZXN0cm95KHIpLG4/cXVldWVNaWNyb3Rhc2socyk6QS5kZXN0cm95KHIpLm9uKFwiY2xvc2VcIixzKX0sZ2V0IGRlc3Ryb3llZCgpe3JldHVybiBBLmRlc3Ryb3llZH0sYnVzeSgpe3JldHVybiExfX19byhjb25uZWN0SDIkMSxcImNvbm5lY3RIMiQxXCIpO2Z1bmN0aW9uIG9uSHR0cDJTZXNzaW9uRXJyb3IoZSl7YXNzZXJ0JDkoZS5jb2RlIT09XCJFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEXCIpLHRoaXNba1NvY2tldF1ba0Vycm9yJDFdPWUsdGhpc1trQ2xpZW50JDJdW2tPbkVycm9yJDFdKGUpfW8ob25IdHRwMlNlc3Npb25FcnJvcixcIm9uSHR0cDJTZXNzaW9uRXJyb3JcIik7ZnVuY3Rpb24gb25IdHRwMkZyYW1lRXJyb3IoZSxBLHQpe2lmKHQ9PT0wKXtjb25zdCBuPW5ldyBJbmZvcm1hdGlvbmFsRXJyb3IkMShgSFRUUC8yOiBcImZyYW1lRXJyb3JcIiByZWNlaXZlZCAtIHR5cGUgJHtlfSwgY29kZSAke0F9YCk7dGhpc1trU29ja2V0XVtrRXJyb3IkMV09bix0aGlzW2tDbGllbnQkMl1ba09uRXJyb3IkMV0obil9fW8ob25IdHRwMkZyYW1lRXJyb3IsXCJvbkh0dHAyRnJhbWVFcnJvclwiKTtmdW5jdGlvbiBvbkh0dHAyU2Vzc2lvbkVuZCgpe2NvbnN0IGU9bmV3IFNvY2tldEVycm9yJDIoXCJvdGhlciBzaWRlIGNsb3NlZFwiLHV0aWwkaC5nZXRTb2NrZXRJbmZvKHRoaXNba1NvY2tldF0pKTt0aGlzLmRlc3Ryb3koZSksdXRpbCRoLmRlc3Ryb3kodGhpc1trU29ja2V0XSxlKX1vKG9uSHR0cDJTZXNzaW9uRW5kLFwib25IdHRwMlNlc3Npb25FbmRcIik7ZnVuY3Rpb24gb25IVFRQMkdvQXdheShlKXtjb25zdCBBPW5ldyBJbmZvcm1hdGlvbmFsRXJyb3IkMShgSFRUUC8yOiBcIkdPQVdBWVwiIGZyYW1lIHJlY2VpdmVkIHdpdGggY29kZSAke2V9YCk7dGhpc1trU29ja2V0XVtrRXJyb3IkMV09QSx0aGlzW2tDbGllbnQkMl1ba09uRXJyb3IkMV0oQSksdGhpcy51bnJlZigpLHRoaXMuZGVzdHJveSgpLHV0aWwkaC5kZXN0cm95KHRoaXNba1NvY2tldF0sQSl9byhvbkhUVFAyR29Bd2F5LFwib25IVFRQMkdvQXdheVwiKTtmdW5jdGlvbiBzaG91bGRTZW5kQ29udGVudExlbmd0aChlKXtyZXR1cm4gZSE9PVwiR0VUXCImJmUhPT1cIkhFQURcIiYmZSE9PVwiT1BUSU9OU1wiJiZlIT09XCJUUkFDRVwiJiZlIT09XCJDT05ORUNUXCJ9byhzaG91bGRTZW5kQ29udGVudExlbmd0aCxcInNob3VsZFNlbmRDb250ZW50TGVuZ3RoXCIpO2Z1bmN0aW9uIHdyaXRlSDIoZSxBKXtjb25zdCB0PWVba0hUVFAyU2Vzc2lvbl0se2JvZHk6bixtZXRob2Q6cixwYXRoOnMsaG9zdDppLHVwZ3JhZGU6RSxleHBlY3RDb250aW51ZTpRLHNpZ25hbDpDLGhlYWRlcnM6SX09QTtpZihFKXJldHVybiB1dGlsJGguZXJyb3JSZXF1ZXN0KGUsQSxuZXcgRXJyb3IoXCJVcGdyYWRlIG5vdCBzdXBwb3J0ZWQgZm9yIEgyXCIpKSwhMTtpZihBLmFib3J0ZWQpcmV0dXJuITE7Y29uc3QgYT17fTtmb3IobGV0IHc9MDt3PEkubGVuZ3RoO3crPTIpe2NvbnN0IFU9SVt3KzBdLE09SVt3KzFdO2lmKEFycmF5LmlzQXJyYXkoTSkpZm9yKGxldCBCPTA7QjxNLmxlbmd0aDtCKyspYVtVXT9hW1VdKz1gLCR7TVtCXX1gOmFbVV09TVtCXTtlbHNlIGFbVV09TX1sZXQgZjtjb25zdHtob3N0bmFtZTpoLHBvcnQ6TH09ZVtrVXJsJDNdO2FbSFRUUDJfSEVBREVSX0FVVEhPUklUWV09aXx8YCR7aH0ke0w/YDoke0x9YDpcIlwifWAsYVtIVFRQMl9IRUFERVJfTUVUSE9EXT1yO3RyeXtBLm9uQ29ubmVjdCh3PT57QS5hYm9ydGVkfHxBLmNvbXBsZXRlZHx8KHc9d3x8bmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IkNCxmIT1udWxsJiYodXRpbCRoLmRlc3Ryb3koZix3KSx0W2tPcGVuU3RyZWFtc10tPTEsdFtrT3BlblN0cmVhbXNdPT09MCYmdC51bnJlZigpKSx1dGlsJGguZXJyb3JSZXF1ZXN0KGUsQSx3KSl9KX1jYXRjaCh3KXt1dGlsJGguZXJyb3JSZXF1ZXN0KGUsQSx3KX1pZihyPT09XCJDT05ORUNUXCIpcmV0dXJuIHQucmVmKCksZj10LnJlcXVlc3QoYSx7ZW5kU3RyZWFtOiExLHNpZ25hbDpDfSksZi5pZCYmIWYucGVuZGluZz8oQS5vblVwZ3JhZGUobnVsbCxudWxsLGYpLCsrdFtrT3BlblN0cmVhbXNdKTpmLm9uY2UoXCJyZWFkeVwiLCgpPT57QS5vblVwZ3JhZGUobnVsbCxudWxsLGYpLCsrdFtrT3BlblN0cmVhbXNdfSksZi5vbmNlKFwiY2xvc2VcIiwoKT0+e3Rba09wZW5TdHJlYW1zXS09MSx0W2tPcGVuU3RyZWFtc109PT0wJiZ0LnVucmVmKCl9KSwhMDthW0hUVFAyX0hFQURFUl9QQVRIXT1zLGFbSFRUUDJfSEVBREVSX1NDSEVNRV09XCJodHRwc1wiO2NvbnN0IGM9cj09PVwiUFVUXCJ8fHI9PT1cIlBPU1RcInx8cj09PVwiUEFUQ0hcIjtuJiZ0eXBlb2Ygbi5yZWFkPT1cImZ1bmN0aW9uXCImJm4ucmVhZCgwKTtsZXQgbD11dGlsJGguYm9keUxlbmd0aChuKTtpZihsPT1udWxsJiYobD1BLmNvbnRlbnRMZW5ndGgpLChsPT09MHx8IWMpJiYobD1udWxsKSxzaG91bGRTZW5kQ29udGVudExlbmd0aChyKSYmbD4wJiZBLmNvbnRlbnRMZW5ndGghPW51bGwmJkEuY29udGVudExlbmd0aCE9PWwpe2lmKGVba1N0cmljdENvbnRlbnRMZW5ndGgkMV0pcmV0dXJuIHV0aWwkaC5lcnJvclJlcXVlc3QoZSxBLG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IpLCExO3Byb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcil9bCE9bnVsbCYmKGFzc2VydCQ5KG4sXCJubyBib2R5IG11c3Qgbm90IGhhdmUgY29udGVudCBsZW5ndGhcIiksYVtIVFRQMl9IRUFERVJfQ09OVEVOVF9MRU5HVEhdPWAke2x9YCksdC5yZWYoKTtjb25zdCBTPXI9PT1cIkdFVFwifHxyPT09XCJIRUFEXCJ8fG49PT1udWxsO3JldHVybiBRPyhhW0hUVFAyX0hFQURFUl9FWFBFQ1RdPVwiMTAwLWNvbnRpbnVlXCIsZj10LnJlcXVlc3QoYSx7ZW5kU3RyZWFtOlMsc2lnbmFsOkN9KSxmLm9uY2UoXCJjb250aW51ZVwiLGspKTooZj10LnJlcXVlc3QoYSx7ZW5kU3RyZWFtOlMsc2lnbmFsOkN9KSxrKCkpLCsrdFtrT3BlblN0cmVhbXNdLGYub25jZShcInJlc3BvbnNlXCIsdz0+e2NvbnN0e1tIVFRQMl9IRUFERVJfU1RBVFVTXTpVLC4uLk19PXc7aWYoQS5vblJlc3BvbnNlU3RhcnRlZCgpLEEuYWJvcnRlZHx8QS5jb21wbGV0ZWQpe2NvbnN0IEI9bmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IkNDt1dGlsJGguZXJyb3JSZXF1ZXN0KGUsQSxCKSx1dGlsJGguZGVzdHJveShmLEIpO3JldHVybn1BLm9uSGVhZGVycyhOdW1iZXIoVSkscGFyc2VIMkhlYWRlcnMoTSksZi5yZXN1bWUuYmluZChmKSxcIlwiKT09PSExJiZmLnBhdXNlKCksZi5vbihcImRhdGFcIixCPT57QS5vbkRhdGEoQik9PT0hMSYmZi5wYXVzZSgpfSl9KSxmLm9uY2UoXCJlbmRcIiwoKT0+e2lmKGYuc3RhdGU/LnN0YXRlPT1udWxsfHxmLnN0YXRlLnN0YXRlPDYpe0Eub25Db21wbGV0ZShbXSk7cmV0dXJufXRba09wZW5TdHJlYW1zXS09MSx0W2tPcGVuU3RyZWFtc109PT0wJiZ0LnVucmVmKCk7Y29uc3Qgdz1uZXcgSW5mb3JtYXRpb25hbEVycm9yJDEoXCJIVFRQLzI6IHN0cmVhbSBoYWxmLWNsb3NlZCAocmVtb3RlKVwiKTt1dGlsJGguZXJyb3JSZXF1ZXN0KGUsQSx3KSx1dGlsJGguZGVzdHJveShmLHcpfSksZi5vbmNlKFwiY2xvc2VcIiwoKT0+e3Rba09wZW5TdHJlYW1zXS09MSx0W2tPcGVuU3RyZWFtc109PT0wJiZ0LnVucmVmKCl9KSxmLm9uY2UoXCJlcnJvclwiLGZ1bmN0aW9uKHcpe2Vba0hUVFAyU2Vzc2lvbl0mJiFlW2tIVFRQMlNlc3Npb25dLmRlc3Ryb3llZCYmIXRoaXMuY2xvc2VkJiYhdGhpcy5kZXN0cm95ZWQmJih0W2tPcGVuU3RyZWFtc10tPTEsdXRpbCRoLmVycm9yUmVxdWVzdChlLEEsdyksdXRpbCRoLmRlc3Ryb3koZix3KSl9KSxmLm9uY2UoXCJmcmFtZUVycm9yXCIsKHcsVSk9Pntjb25zdCBNPW5ldyBJbmZvcm1hdGlvbmFsRXJyb3IkMShgSFRUUC8yOiBcImZyYW1lRXJyb3JcIiByZWNlaXZlZCAtIHR5cGUgJHt3fSwgY29kZSAke1V9YCk7dXRpbCRoLmVycm9yUmVxdWVzdChlLEEsTSksZVtrSFRUUDJTZXNzaW9uXSYmIWVba0hUVFAyU2Vzc2lvbl0uZGVzdHJveWVkJiYhdGhpcy5jbG9zZWQmJiF0aGlzLmRlc3Ryb3llZCYmKHRba09wZW5TdHJlYW1zXS09MSx1dGlsJGguZGVzdHJveShmLE0pKX0pLCEwO2Z1bmN0aW9uIGsoKXtuP3V0aWwkaC5pc0J1ZmZlcihuKT8oYXNzZXJ0JDkobD09PW4uYnl0ZUxlbmd0aCxcImJ1ZmZlciBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aFwiKSxmLmNvcmsoKSxmLndyaXRlKG4pLGYudW5jb3JrKCksZi5lbmQoKSxBLm9uQm9keVNlbnQobiksQS5vblJlcXVlc3RTZW50KCkpOnV0aWwkaC5pc0Jsb2JMaWtlKG4pP3R5cGVvZiBuLnN0cmVhbT09XCJmdW5jdGlvblwiP3dyaXRlSXRlcmFibGUoe2NsaWVudDplLHJlcXVlc3Q6QSxjb250ZW50TGVuZ3RoOmwsaDJzdHJlYW06ZixleHBlY3RzUGF5bG9hZDpjLGJvZHk6bi5zdHJlYW0oKSxzb2NrZXQ6ZVtrU29ja2V0XSxoZWFkZXI6XCJcIn0pOndyaXRlQmxvYih7Ym9keTpuLGNsaWVudDplLHJlcXVlc3Q6QSxjb250ZW50TGVuZ3RoOmwsZXhwZWN0c1BheWxvYWQ6YyxoMnN0cmVhbTpmLGhlYWRlcjpcIlwiLHNvY2tldDplW2tTb2NrZXRdfSk6dXRpbCRoLmlzU3RyZWFtKG4pP3dyaXRlU3RyZWFtKHtib2R5Om4sY2xpZW50OmUscmVxdWVzdDpBLGNvbnRlbnRMZW5ndGg6bCxleHBlY3RzUGF5bG9hZDpjLHNvY2tldDplW2tTb2NrZXRdLGgyc3RyZWFtOmYsaGVhZGVyOlwiXCJ9KTp1dGlsJGguaXNJdGVyYWJsZShuKT93cml0ZUl0ZXJhYmxlKHtib2R5Om4sY2xpZW50OmUscmVxdWVzdDpBLGNvbnRlbnRMZW5ndGg6bCxleHBlY3RzUGF5bG9hZDpjLGhlYWRlcjpcIlwiLGgyc3RyZWFtOmYsc29ja2V0OmVba1NvY2tldF19KTphc3NlcnQkOSghMSk6QS5vblJlcXVlc3RTZW50KCl9byhrLFwid3JpdGVCb2R5SDJcIil9byh3cml0ZUgyLFwid3JpdGVIMlwiKTtmdW5jdGlvbiB3cml0ZVN0cmVhbSh7aDJzdHJlYW06ZSxib2R5OkEsY2xpZW50OnQscmVxdWVzdDpuLHNvY2tldDpyLGNvbnRlbnRMZW5ndGg6cyxoZWFkZXI6aSxleHBlY3RzUGF5bG9hZDpFfSl7YXNzZXJ0JDkocyE9PTB8fHRba1J1bm5pbmckNF09PT0wLFwic3RyZWFtIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZFwiKTtjb25zdCBRPXBpcGVsaW5lJDEoQSxlLEk9PntJPyh1dGlsJGguZGVzdHJveShBLEkpLHV0aWwkaC5kZXN0cm95KGUsSSkpOm4ub25SZXF1ZXN0U2VudCgpfSk7US5vbihcImRhdGFcIixDKSxRLm9uY2UoXCJlbmRcIiwoKT0+e1EucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsQyksdXRpbCRoLmRlc3Ryb3koUSl9KTtmdW5jdGlvbiBDKEkpe24ub25Cb2R5U2VudChJKX1vKEMsXCJvblBpcGVEYXRhXCIpfW8od3JpdGVTdHJlYW0sXCJ3cml0ZVN0cmVhbVwiKTthc3luYyBmdW5jdGlvbiB3cml0ZUJsb2Ioe2gyc3RyZWFtOmUsYm9keTpBLGNsaWVudDp0LHJlcXVlc3Q6bixzb2NrZXQ6cixjb250ZW50TGVuZ3RoOnMsaGVhZGVyOmksZXhwZWN0c1BheWxvYWQ6RX0pe2Fzc2VydCQ5KHM9PT1BLnNpemUsXCJibG9iIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoXCIpO3RyeXtpZihzIT1udWxsJiZzIT09QS5zaXplKXRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3I7Y29uc3QgUT1CdWZmZXIuZnJvbShhd2FpdCBBLmFycmF5QnVmZmVyKCkpO2UuY29yaygpLGUud3JpdGUoUSksZS51bmNvcmsoKSxuLm9uQm9keVNlbnQoUSksbi5vblJlcXVlc3RTZW50KCksRXx8KHJba1Jlc2V0XT0hMCksdFtrUmVzdW1lJDJdKCl9Y2F0Y2h7dXRpbCRoLmRlc3Ryb3koZSl9fW8od3JpdGVCbG9iLFwid3JpdGVCbG9iXCIpO2FzeW5jIGZ1bmN0aW9uIHdyaXRlSXRlcmFibGUoe2gyc3RyZWFtOmUsYm9keTpBLGNsaWVudDp0LHJlcXVlc3Q6bixzb2NrZXQ6cixjb250ZW50TGVuZ3RoOnMsaGVhZGVyOmksZXhwZWN0c1BheWxvYWQ6RX0pe2Fzc2VydCQ5KHMhPT0wfHx0W2tSdW5uaW5nJDRdPT09MCxcIml0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZFwiKTtsZXQgUT1udWxsO2Z1bmN0aW9uIEMoKXtpZihRKXtjb25zdCBhPVE7UT1udWxsLGEoKX19byhDLFwib25EcmFpblwiKTtjb25zdCBJPW8oKCk9Pm5ldyBQcm9taXNlKChhLGYpPT57YXNzZXJ0JDkoUT09PW51bGwpLHJba0Vycm9yJDFdP2YocltrRXJyb3IkMV0pOlE9YX0pLFwid2FpdEZvckRyYWluXCIpO2Uub24oXCJjbG9zZVwiLEMpLm9uKFwiZHJhaW5cIixDKTt0cnl7Zm9yIGF3YWl0KGNvbnN0IGEgb2YgQSl7aWYocltrRXJyb3IkMV0pdGhyb3cgcltrRXJyb3IkMV07Y29uc3QgZj1lLndyaXRlKGEpO24ub25Cb2R5U2VudChhKSxmfHxhd2FpdCBJKCl9fWNhdGNoKGEpe2UuZGVzdHJveShhKX1maW5hbGx5e24ub25SZXF1ZXN0U2VudCgpLGUuZW5kKCksZS5vZmYoXCJjbG9zZVwiLEMpLm9mZihcImRyYWluXCIsQyl9fW8od3JpdGVJdGVyYWJsZSxcIndyaXRlSXRlcmFibGVcIik7dmFyIGNsaWVudEgyPWNvbm5lY3RIMiQxO2NvbnN0IHV0aWwkZz11dGlsJG0se2tCb2R5VXNlZH09c3ltYm9scyQ0LGFzc2VydCQ4PXJlcXVpcmUkJDBfX2RlZmF1bHQse0ludmFsaWRBcmd1bWVudEVycm9yOkludmFsaWRBcmd1bWVudEVycm9yJGZ9PWVycm9ycyQxLEVFPXJlcXVpcmUkJDBfX2RlZmF1bHQkMyxyZWRpcmVjdGFibGVTdGF0dXNDb2Rlcz1bMzAwLDMwMSwzMDIsMzAzLDMwNywzMDhdLGtCb2R5JDE9U3ltYm9sKFwiYm9keVwiKSxpdD1jbGFzcyBpdHtjb25zdHJ1Y3RvcihBKXt0aGlzW2tCb2R5JDFdPUEsdGhpc1trQm9keVVzZWRdPSExfWFzeW5jKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKXthc3NlcnQkOCghdGhpc1trQm9keVVzZWRdLFwiZGlzdHVyYmVkXCIpLHRoaXNba0JvZHlVc2VkXT0hMCx5aWVsZCp0aGlzW2tCb2R5JDFdfX07byhpdCxcIkJvZHlBc3luY0l0ZXJhYmxlXCIpO2xldCBCb2R5QXN5bmNJdGVyYWJsZT1pdCxSZWRpcmVjdEhhbmRsZXIkMT0oVWU9Y2xhc3N7Y29uc3RydWN0b3IoQSx0LG4scil7aWYodCE9bnVsbCYmKCFOdW1iZXIuaXNJbnRlZ2VyKHQpfHx0PDApKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRmKFwibWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7dXRpbCRnLnZhbGlkYXRlSGFuZGxlcihyLG4ubWV0aG9kLG4udXBncmFkZSksdGhpcy5kaXNwYXRjaD1BLHRoaXMubG9jYXRpb249bnVsbCx0aGlzLmFib3J0PW51bGwsdGhpcy5vcHRzPXsuLi5uLG1heFJlZGlyZWN0aW9uczowfSx0aGlzLm1heFJlZGlyZWN0aW9ucz10LHRoaXMuaGFuZGxlcj1yLHRoaXMuaGlzdG9yeT1bXSx0aGlzLnJlZGlyZWN0aW9uTGltaXRSZWFjaGVkPSExLHV0aWwkZy5pc1N0cmVhbSh0aGlzLm9wdHMuYm9keSk/KHV0aWwkZy5ib2R5TGVuZ3RoKHRoaXMub3B0cy5ib2R5KT09PTAmJnRoaXMub3B0cy5ib2R5Lm9uKFwiZGF0YVwiLGZ1bmN0aW9uKCl7YXNzZXJ0JDgoITEpfSksdHlwZW9mIHRoaXMub3B0cy5ib2R5LnJlYWRhYmxlRGlkUmVhZCE9XCJib29sZWFuXCImJih0aGlzLm9wdHMuYm9keVtrQm9keVVzZWRdPSExLEVFLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMub3B0cy5ib2R5LFwiZGF0YVwiLGZ1bmN0aW9uKCl7dGhpc1trQm9keVVzZWRdPSEwfSkpKTp0aGlzLm9wdHMuYm9keSYmdHlwZW9mIHRoaXMub3B0cy5ib2R5LnBpcGVUbz09XCJmdW5jdGlvblwiP3RoaXMub3B0cy5ib2R5PW5ldyBCb2R5QXN5bmNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSk6dGhpcy5vcHRzLmJvZHkmJnR5cGVvZiB0aGlzLm9wdHMuYm9keSE9XCJzdHJpbmdcIiYmIUFycmF5QnVmZmVyLmlzVmlldyh0aGlzLm9wdHMuYm9keSkmJnV0aWwkZy5pc0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KSYmKHRoaXMub3B0cy5ib2R5PW5ldyBCb2R5QXN5bmNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSkpfW9uQ29ubmVjdChBKXt0aGlzLmFib3J0PUEsdGhpcy5oYW5kbGVyLm9uQ29ubmVjdChBLHtoaXN0b3J5OnRoaXMuaGlzdG9yeX0pfW9uVXBncmFkZShBLHQsbil7dGhpcy5oYW5kbGVyLm9uVXBncmFkZShBLHQsbil9b25FcnJvcihBKXt0aGlzLmhhbmRsZXIub25FcnJvcihBKX1vbkhlYWRlcnMoQSx0LG4scil7aWYodGhpcy5sb2NhdGlvbj10aGlzLmhpc3RvcnkubGVuZ3RoPj10aGlzLm1heFJlZGlyZWN0aW9uc3x8dXRpbCRnLmlzRGlzdHVyYmVkKHRoaXMub3B0cy5ib2R5KT9udWxsOnBhcnNlTG9jYXRpb24oQSx0KSx0aGlzLm9wdHMudGhyb3dPbk1heFJlZGlyZWN0JiZ0aGlzLmhpc3RvcnkubGVuZ3RoPj10aGlzLm1heFJlZGlyZWN0aW9ucyl7dGhpcy5yZXF1ZXN0JiZ0aGlzLnJlcXVlc3QuYWJvcnQobmV3IEVycm9yKFwibWF4IHJlZGlyZWN0c1wiKSksdGhpcy5yZWRpcmVjdGlvbkxpbWl0UmVhY2hlZD0hMCx0aGlzLmFib3J0KG5ldyBFcnJvcihcIm1heCByZWRpcmVjdHNcIikpO3JldHVybn1pZih0aGlzLm9wdHMub3JpZ2luJiZ0aGlzLmhpc3RvcnkucHVzaChuZXcgVVJMKHRoaXMub3B0cy5wYXRoLHRoaXMub3B0cy5vcmlnaW4pKSwhdGhpcy5sb2NhdGlvbilyZXR1cm4gdGhpcy5oYW5kbGVyLm9uSGVhZGVycyhBLHQsbixyKTtjb25zdHtvcmlnaW46cyxwYXRobmFtZTppLHNlYXJjaDpFfT11dGlsJGcucGFyc2VVUkwobmV3IFVSTCh0aGlzLmxvY2F0aW9uLHRoaXMub3B0cy5vcmlnaW4mJm5ldyBVUkwodGhpcy5vcHRzLnBhdGgsdGhpcy5vcHRzLm9yaWdpbikpKSxRPUU/YCR7aX0ke0V9YDppO3RoaXMub3B0cy5oZWFkZXJzPWNsZWFuUmVxdWVzdEhlYWRlcnModGhpcy5vcHRzLmhlYWRlcnMsQT09PTMwMyx0aGlzLm9wdHMub3JpZ2luIT09cyksdGhpcy5vcHRzLnBhdGg9USx0aGlzLm9wdHMub3JpZ2luPXMsdGhpcy5vcHRzLm1heFJlZGlyZWN0aW9ucz0wLHRoaXMub3B0cy5xdWVyeT1udWxsLEE9PT0zMDMmJnRoaXMub3B0cy5tZXRob2QhPT1cIkhFQURcIiYmKHRoaXMub3B0cy5tZXRob2Q9XCJHRVRcIix0aGlzLm9wdHMuYm9keT1udWxsKX1vbkRhdGEoQSl7aWYoIXRoaXMubG9jYXRpb24pcmV0dXJuIHRoaXMuaGFuZGxlci5vbkRhdGEoQSl9b25Db21wbGV0ZShBKXt0aGlzLmxvY2F0aW9uPyh0aGlzLmxvY2F0aW9uPW51bGwsdGhpcy5hYm9ydD1udWxsLHRoaXMuZGlzcGF0Y2godGhpcy5vcHRzLHRoaXMpKTp0aGlzLmhhbmRsZXIub25Db21wbGV0ZShBKX1vbkJvZHlTZW50KEEpe3RoaXMuaGFuZGxlci5vbkJvZHlTZW50JiZ0aGlzLmhhbmRsZXIub25Cb2R5U2VudChBKX19LG8oVWUsXCJSZWRpcmVjdEhhbmRsZXJcIiksVWUpO2Z1bmN0aW9uIHBhcnNlTG9jYXRpb24oZSxBKXtpZihyZWRpcmVjdGFibGVTdGF0dXNDb2Rlcy5pbmRleE9mKGUpPT09LTEpcmV0dXJuIG51bGw7Zm9yKGxldCB0PTA7dDxBLmxlbmd0aDt0Kz0yKWlmKEFbdF0ubGVuZ3RoPT09OCYmdXRpbCRnLmhlYWRlck5hbWVUb1N0cmluZyhBW3RdKT09PVwibG9jYXRpb25cIilyZXR1cm4gQVt0KzFdfW8ocGFyc2VMb2NhdGlvbixcInBhcnNlTG9jYXRpb25cIik7ZnVuY3Rpb24gc2hvdWxkUmVtb3ZlSGVhZGVyKGUsQSx0KXtpZihlLmxlbmd0aD09PTQpcmV0dXJuIHV0aWwkZy5oZWFkZXJOYW1lVG9TdHJpbmcoZSk9PT1cImhvc3RcIjtpZihBJiZ1dGlsJGcuaGVhZGVyTmFtZVRvU3RyaW5nKGUpLnN0YXJ0c1dpdGgoXCJjb250ZW50LVwiKSlyZXR1cm4hMDtpZih0JiYoZS5sZW5ndGg9PT0xM3x8ZS5sZW5ndGg9PT02fHxlLmxlbmd0aD09PTE5KSl7Y29uc3Qgbj11dGlsJGcuaGVhZGVyTmFtZVRvU3RyaW5nKGUpO3JldHVybiBuPT09XCJhdXRob3JpemF0aW9uXCJ8fG49PT1cImNvb2tpZVwifHxuPT09XCJwcm94eS1hdXRob3JpemF0aW9uXCJ9cmV0dXJuITF9byhzaG91bGRSZW1vdmVIZWFkZXIsXCJzaG91bGRSZW1vdmVIZWFkZXJcIik7ZnVuY3Rpb24gY2xlYW5SZXF1ZXN0SGVhZGVycyhlLEEsdCl7Y29uc3Qgbj1bXTtpZihBcnJheS5pc0FycmF5KGUpKWZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cis9MilzaG91bGRSZW1vdmVIZWFkZXIoZVtyXSxBLHQpfHxuLnB1c2goZVtyXSxlW3IrMV0pO2Vsc2UgaWYoZSYmdHlwZW9mIGU9PVwib2JqZWN0XCIpZm9yKGNvbnN0IHIgb2YgT2JqZWN0LmtleXMoZSkpc2hvdWxkUmVtb3ZlSGVhZGVyKHIsQSx0KXx8bi5wdXNoKHIsZVtyXSk7ZWxzZSBhc3NlcnQkOChlPT1udWxsLFwiaGVhZGVycyBtdXN0IGJlIGFuIG9iamVjdCBvciBhbiBhcnJheVwiKTtyZXR1cm4gbn1vKGNsZWFuUmVxdWVzdEhlYWRlcnMsXCJjbGVhblJlcXVlc3RIZWFkZXJzXCIpO3ZhciByZWRpcmVjdEhhbmRsZXI9UmVkaXJlY3RIYW5kbGVyJDE7Y29uc3QgUmVkaXJlY3RIYW5kbGVyPXJlZGlyZWN0SGFuZGxlcjtmdW5jdGlvbiBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yJDIoe21heFJlZGlyZWN0aW9uczplfSl7cmV0dXJuIEE9Pm8oZnVuY3Rpb24obixyKXtjb25zdHttYXhSZWRpcmVjdGlvbnM6cz1lfT1uO2lmKCFzKXJldHVybiBBKG4scik7Y29uc3QgaT1uZXcgUmVkaXJlY3RIYW5kbGVyKEEscyxuLHIpO3JldHVybiBuPXsuLi5uLG1heFJlZGlyZWN0aW9uczowfSxBKG4saSl9LFwiSW50ZXJjZXB0XCIpfW8oY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciQyLFwiY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciQyXCIpO3ZhciByZWRpcmVjdEludGVyY2VwdG9yPWNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IkMjtjb25zdCBhc3NlcnQkNz1yZXF1aXJlJCQwX19kZWZhdWx0LG5ldD1yZXF1aXJlJCQ0X19kZWZhdWx0LGh0dHA9aHR0cF9fZGVmYXVsdCx1dGlsJGY9dXRpbCRtLHtjaGFubmVsc309ZGlhZ25vc3RpY3MsUmVxdWVzdD1yZXF1ZXN0JDIsRGlzcGF0Y2hlckJhc2UkMz1kaXNwYXRjaGVyQmFzZSx7SW52YWxpZEFyZ3VtZW50RXJyb3I6SW52YWxpZEFyZ3VtZW50RXJyb3IkZSxJbmZvcm1hdGlvbmFsRXJyb3IsQ2xpZW50RGVzdHJveWVkRXJyb3J9PWVycm9ycyQxLGJ1aWxkQ29ubmVjdG9yJDI9Y29ubmVjdCQyLHtrVXJsOmtVcmwkMixrU2VydmVyTmFtZSxrQ2xpZW50OmtDbGllbnQkMSxrQnVzeTprQnVzeSQxLGtDb25uZWN0LGtSZXN1bWluZyxrUnVubmluZzprUnVubmluZyQzLGtQZW5kaW5nOmtQZW5kaW5nJDIsa1NpemU6a1NpemUkMyxrUXVldWU6a1F1ZXVlJDEsa0Nvbm5lY3RlZDprQ29ubmVjdGVkJDQsa0Nvbm5lY3Rpbmcsa05lZWREcmFpbjprTmVlZERyYWluJDIsa0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0LGtIb3N0SGVhZGVyLGtQZW5kaW5nSWR4LGtSdW5uaW5nSWR4LGtFcnJvcixrUGlwZWxpbmluZyxrS2VlcEFsaXZlVGltZW91dFZhbHVlLGtNYXhIZWFkZXJzU2l6ZSxrS2VlcEFsaXZlTWF4VGltZW91dCxrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxrSGVhZGVyc1RpbWVvdXQsa0JvZHlUaW1lb3V0LGtTdHJpY3RDb250ZW50TGVuZ3RoLGtDb25uZWN0b3Isa01heFJlZGlyZWN0aW9uczprTWF4UmVkaXJlY3Rpb25zJDEsa01heFJlcXVlc3RzLGtDb3VudGVyLGtDbG9zZTprQ2xvc2UkNSxrRGVzdHJveTprRGVzdHJveSQzLGtEaXNwYXRjaDprRGlzcGF0Y2gkMixrSW50ZXJjZXB0b3JzOmtJbnRlcmNlcHRvcnMkMyxrTG9jYWxBZGRyZXNzLGtNYXhSZXNwb25zZVNpemUsa09uRXJyb3Isa0hUVFBDb250ZXh0LGtNYXhDb25jdXJyZW50U3RyZWFtcyxrUmVzdW1lOmtSZXN1bWUkMX09c3ltYm9scyQ0LGNvbm5lY3RIMT1jbGllbnRIMSxjb25uZWN0SDI9Y2xpZW50SDI7bGV0IGRlcHJlY2F0ZWRJbnRlcmNlcHRvcldhcm5lZD0hMTtjb25zdCBrQ2xvc2VkUmVzb2x2ZSQxPVN5bWJvbChcImtDbG9zZWRSZXNvbHZlXCIpO2Z1bmN0aW9uIGdldFBpcGVsaW5pbmcoZSl7cmV0dXJuIGVba1BpcGVsaW5pbmddPz9lW2tIVFRQQ29udGV4dF0/LmRlZmF1bHRQaXBlbGluaW5nPz8xfW8oZ2V0UGlwZWxpbmluZyxcImdldFBpcGVsaW5pbmdcIik7bGV0IENsaWVudCQzPShiZT1jbGFzcyBleHRlbmRzIERpc3BhdGNoZXJCYXNlJDN7Y29uc3RydWN0b3IoQSx7aW50ZXJjZXB0b3JzOnQsbWF4SGVhZGVyU2l6ZTpuLGhlYWRlcnNUaW1lb3V0OnIsc29ja2V0VGltZW91dDpzLHJlcXVlc3RUaW1lb3V0OmksY29ubmVjdFRpbWVvdXQ6RSxib2R5VGltZW91dDpRLGlkbGVUaW1lb3V0OkMsa2VlcEFsaXZlOkksa2VlcEFsaXZlVGltZW91dDphLG1heEtlZXBBbGl2ZVRpbWVvdXQ6ZixrZWVwQWxpdmVNYXhUaW1lb3V0Omgsa2VlcEFsaXZlVGltZW91dFRocmVzaG9sZDpMLHNvY2tldFBhdGg6YyxwaXBlbGluaW5nOmwsdGxzOlMsc3RyaWN0Q29udGVudExlbmd0aDprLG1heENhY2hlZFNlc3Npb25zOncsbWF4UmVkaXJlY3Rpb25zOlUsY29ubmVjdDpNLG1heFJlcXVlc3RzUGVyQ2xpZW50OkIsbG9jYWxBZGRyZXNzOkQsbWF4UmVzcG9uc2VTaXplOkcsYXV0b1NlbGVjdEZhbWlseTpnLGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dDpkLG1heENvbmN1cnJlbnRTdHJlYW1zOkYsYWxsb3dIMjpOfT17fSl7aWYoc3VwZXIoKSxJIT09dm9pZCAwKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRlKFwidW5zdXBwb3J0ZWQga2VlcEFsaXZlLCB1c2UgcGlwZWxpbmluZz0wIGluc3RlYWRcIik7aWYocyE9PXZvaWQgMCl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkZShcInVuc3VwcG9ydGVkIHNvY2tldFRpbWVvdXQsIHVzZSBoZWFkZXJzVGltZW91dCAmIGJvZHlUaW1lb3V0IGluc3RlYWRcIik7aWYoaSE9PXZvaWQgMCl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkZShcInVuc3VwcG9ydGVkIHJlcXVlc3RUaW1lb3V0LCB1c2UgaGVhZGVyc1RpbWVvdXQgJiBib2R5VGltZW91dCBpbnN0ZWFkXCIpO2lmKEMhPT12b2lkIDApdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGUoXCJ1bnN1cHBvcnRlZCBpZGxlVGltZW91dCwgdXNlIGtlZXBBbGl2ZVRpbWVvdXQgaW5zdGVhZFwiKTtpZihmIT09dm9pZCAwKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRlKFwidW5zdXBwb3J0ZWQgbWF4S2VlcEFsaXZlVGltZW91dCwgdXNlIGtlZXBBbGl2ZU1heFRpbWVvdXQgaW5zdGVhZFwiKTtpZihuIT1udWxsJiYhTnVtYmVyLmlzRmluaXRlKG4pKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRlKFwiaW52YWxpZCBtYXhIZWFkZXJTaXplXCIpO2lmKGMhPW51bGwmJnR5cGVvZiBjIT1cInN0cmluZ1wiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRlKFwiaW52YWxpZCBzb2NrZXRQYXRoXCIpO2lmKEUhPW51bGwmJighTnVtYmVyLmlzRmluaXRlKEUpfHxFPDApKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRlKFwiaW52YWxpZCBjb25uZWN0VGltZW91dFwiKTtpZihhIT1udWxsJiYoIU51bWJlci5pc0Zpbml0ZShhKXx8YTw9MCkpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGUoXCJpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXRcIik7aWYoaCE9bnVsbCYmKCFOdW1iZXIuaXNGaW5pdGUoaCl8fGg8PTApKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRlKFwiaW52YWxpZCBrZWVwQWxpdmVNYXhUaW1lb3V0XCIpO2lmKEwhPW51bGwmJiFOdW1iZXIuaXNGaW5pdGUoTCkpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGUoXCJpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGRcIik7aWYociE9bnVsbCYmKCFOdW1iZXIuaXNJbnRlZ2VyKHIpfHxyPDApKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRlKFwiaGVhZGVyc1RpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVyb1wiKTtpZihRIT1udWxsJiYoIU51bWJlci5pc0ludGVnZXIoUSl8fFE8MCkpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGUoXCJib2R5VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvXCIpO2lmKE0hPW51bGwmJnR5cGVvZiBNIT1cImZ1bmN0aW9uXCImJnR5cGVvZiBNIT1cIm9iamVjdFwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRlKFwiY29ubmVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0XCIpO2lmKFUhPW51bGwmJighTnVtYmVyLmlzSW50ZWdlcihVKXx8VTwwKSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkZShcIm1heFJlZGlyZWN0aW9ucyBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO2lmKEIhPW51bGwmJighTnVtYmVyLmlzSW50ZWdlcihCKXx8QjwwKSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkZShcIm1heFJlcXVlc3RzUGVyQ2xpZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7aWYoRCE9bnVsbCYmKHR5cGVvZiBEIT1cInN0cmluZ1wifHxuZXQuaXNJUChEKT09PTApKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRlKFwibG9jYWxBZGRyZXNzIG11c3QgYmUgdmFsaWQgc3RyaW5nIElQIGFkZHJlc3NcIik7aWYoRyE9bnVsbCYmKCFOdW1iZXIuaXNJbnRlZ2VyKEcpfHxHPC0xKSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkZShcIm1heFJlc3BvbnNlU2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO2lmKGQhPW51bGwmJighTnVtYmVyLmlzSW50ZWdlcihkKXx8ZDwtMSkpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGUoXCJhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtpZihOIT1udWxsJiZ0eXBlb2YgTiE9XCJib29sZWFuXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGUoXCJhbGxvd0gyIG11c3QgYmUgYSB2YWxpZCBib29sZWFuIHZhbHVlXCIpO2lmKEYhPW51bGwmJih0eXBlb2YgRiE9XCJudW1iZXJcInx8RjwxKSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkZShcIm1heENvbmN1cnJlbnRTdHJlYW1zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBncmVhdGVyIHRoYW4gMFwiKTt0eXBlb2YgTSE9XCJmdW5jdGlvblwiJiYoTT1idWlsZENvbm5lY3RvciQyKHsuLi5TLG1heENhY2hlZFNlc3Npb25zOncsYWxsb3dIMjpOLHNvY2tldFBhdGg6Yyx0aW1lb3V0OkUsLi4udXRpbCRmLm5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5JiZnP3thdXRvU2VsZWN0RmFtaWx5OmcsYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0OmR9OnZvaWQgMCwuLi5NfSkpLHQ/LkNsaWVudCYmQXJyYXkuaXNBcnJheSh0LkNsaWVudCk/KHRoaXNba0ludGVyY2VwdG9ycyQzXT10LkNsaWVudCxkZXByZWNhdGVkSW50ZXJjZXB0b3JXYXJuZWR8fChkZXByZWNhdGVkSW50ZXJjZXB0b3JXYXJuZWQ9ITAscHJvY2Vzcy5lbWl0V2FybmluZyhcIkNsaWVudC5PcHRpb25zI2ludGVyY2VwdG9yIGlzIGRlcHJlY2F0ZWQuIFVzZSBEaXNwYXRjaGVyI2NvbXBvc2UgaW5zdGVhZC5cIix7Y29kZTpcIlVORElDSS1DTElFTlQtSU5URVJDRVBUT1ItREVQUkVDQVRFRFwifSkpKTp0aGlzW2tJbnRlcmNlcHRvcnMkM109W2NyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IkMSh7bWF4UmVkaXJlY3Rpb25zOlV9KV0sdGhpc1trVXJsJDJdPXV0aWwkZi5wYXJzZU9yaWdpbihBKSx0aGlzW2tDb25uZWN0b3JdPU0sdGhpc1trUGlwZWxpbmluZ109bD8/MSx0aGlzW2tNYXhIZWFkZXJzU2l6ZV09bnx8aHR0cC5tYXhIZWFkZXJTaXplLHRoaXNba0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0XT1hPz80ZTMsdGhpc1trS2VlcEFsaXZlTWF4VGltZW91dF09aD8/NmU1LHRoaXNba0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGRdPUw/PzFlMyx0aGlzW2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdPXRoaXNba0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0XSx0aGlzW2tTZXJ2ZXJOYW1lXT1udWxsLHRoaXNba0xvY2FsQWRkcmVzc109RD8/bnVsbCx0aGlzW2tSZXN1bWluZ109MCx0aGlzW2tOZWVkRHJhaW4kMl09MCx0aGlzW2tIb3N0SGVhZGVyXT1gaG9zdDogJHt0aGlzW2tVcmwkMl0uaG9zdG5hbWV9JHt0aGlzW2tVcmwkMl0ucG9ydD9gOiR7dGhpc1trVXJsJDJdLnBvcnR9YDpcIlwifVxcclxuYCx0aGlzW2tCb2R5VGltZW91dF09UT8/M2U1LHRoaXNba0hlYWRlcnNUaW1lb3V0XT1yPz8zZTUsdGhpc1trU3RyaWN0Q29udGVudExlbmd0aF09az8/ITAsdGhpc1trTWF4UmVkaXJlY3Rpb25zJDFdPVUsdGhpc1trTWF4UmVxdWVzdHNdPUIsdGhpc1trQ2xvc2VkUmVzb2x2ZSQxXT1udWxsLHRoaXNba01heFJlc3BvbnNlU2l6ZV09Rz4tMT9HOi0xLHRoaXNba01heENvbmN1cnJlbnRTdHJlYW1zXT1GPz8xMDAsdGhpc1trSFRUUENvbnRleHRdPW51bGwsdGhpc1trUXVldWUkMV09W10sdGhpc1trUnVubmluZ0lkeF09MCx0aGlzW2tQZW5kaW5nSWR4XT0wLHRoaXNba1Jlc3VtZSQxXT11PT5yZXN1bWUodGhpcyx1KSx0aGlzW2tPbkVycm9yXT11PT5vbkVycm9yKHRoaXMsdSl9Z2V0IHBpcGVsaW5pbmcoKXtyZXR1cm4gdGhpc1trUGlwZWxpbmluZ119c2V0IHBpcGVsaW5pbmcoQSl7dGhpc1trUGlwZWxpbmluZ109QSx0aGlzW2tSZXN1bWUkMV0oITApfWdldFtrUGVuZGluZyQyXSgpe3JldHVybiB0aGlzW2tRdWV1ZSQxXS5sZW5ndGgtdGhpc1trUGVuZGluZ0lkeF19Z2V0W2tSdW5uaW5nJDNdKCl7cmV0dXJuIHRoaXNba1BlbmRpbmdJZHhdLXRoaXNba1J1bm5pbmdJZHhdfWdldFtrU2l6ZSQzXSgpe3JldHVybiB0aGlzW2tRdWV1ZSQxXS5sZW5ndGgtdGhpc1trUnVubmluZ0lkeF19Z2V0W2tDb25uZWN0ZWQkNF0oKXtyZXR1cm4hIXRoaXNba0hUVFBDb250ZXh0XSYmIXRoaXNba0Nvbm5lY3RpbmddJiYhdGhpc1trSFRUUENvbnRleHRdLmRlc3Ryb3llZH1nZXRba0J1c3kkMV0oKXtyZXR1cm4hISh0aGlzW2tIVFRQQ29udGV4dF0/LmJ1c3kobnVsbCl8fHRoaXNba1NpemUkM10+PShnZXRQaXBlbGluaW5nKHRoaXMpfHwxKXx8dGhpc1trUGVuZGluZyQyXT4wKX1ba0Nvbm5lY3RdKEEpe2Nvbm5lY3QkMSh0aGlzKSx0aGlzLm9uY2UoXCJjb25uZWN0XCIsQSl9W2tEaXNwYXRjaCQyXShBLHQpe2NvbnN0IG49QS5vcmlnaW58fHRoaXNba1VybCQyXS5vcmlnaW4scj1uZXcgUmVxdWVzdChuLEEsdCk7cmV0dXJuIHRoaXNba1F1ZXVlJDFdLnB1c2gociksdGhpc1trUmVzdW1pbmddfHwodXRpbCRmLmJvZHlMZW5ndGgoci5ib2R5KT09bnVsbCYmdXRpbCRmLmlzSXRlcmFibGUoci5ib2R5KT8odGhpc1trUmVzdW1pbmddPTEscXVldWVNaWNyb3Rhc2soKCk9PnJlc3VtZSh0aGlzKSkpOnRoaXNba1Jlc3VtZSQxXSghMCkpLHRoaXNba1Jlc3VtaW5nXSYmdGhpc1trTmVlZERyYWluJDJdIT09MiYmdGhpc1trQnVzeSQxXSYmKHRoaXNba05lZWREcmFpbiQyXT0yKSx0aGlzW2tOZWVkRHJhaW4kMl08Mn1hc3luY1trQ2xvc2UkNV0oKXtyZXR1cm4gbmV3IFByb21pc2UoQT0+e3RoaXNba1NpemUkM10/dGhpc1trQ2xvc2VkUmVzb2x2ZSQxXT1BOkEobnVsbCl9KX1hc3luY1trRGVzdHJveSQzXShBKXtyZXR1cm4gbmV3IFByb21pc2UodD0+e2NvbnN0IG49dGhpc1trUXVldWUkMV0uc3BsaWNlKHRoaXNba1BlbmRpbmdJZHhdKTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7Y29uc3QgaT1uW3NdO3V0aWwkZi5lcnJvclJlcXVlc3QodGhpcyxpLEEpfWNvbnN0IHI9bygoKT0+e3RoaXNba0Nsb3NlZFJlc29sdmUkMV0mJih0aGlzW2tDbG9zZWRSZXNvbHZlJDFdKCksdGhpc1trQ2xvc2VkUmVzb2x2ZSQxXT1udWxsKSx0KG51bGwpfSxcImNhbGxiYWNrXCIpO3RoaXNba0hUVFBDb250ZXh0XT8odGhpc1trSFRUUENvbnRleHRdLmRlc3Ryb3koQSxyKSx0aGlzW2tIVFRQQ29udGV4dF09bnVsbCk6cXVldWVNaWNyb3Rhc2sociksdGhpc1trUmVzdW1lJDFdKCl9KX19LG8oYmUsXCJDbGllbnRcIiksYmUpO2NvbnN0IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IkMT1yZWRpcmVjdEludGVyY2VwdG9yO2Z1bmN0aW9uIG9uRXJyb3IoZSxBKXtpZihlW2tSdW5uaW5nJDNdPT09MCYmQS5jb2RlIT09XCJVTkRfRVJSX0lORk9cIiYmQS5jb2RlIT09XCJVTkRfRVJSX1NPQ0tFVFwiKXthc3NlcnQkNyhlW2tQZW5kaW5nSWR4XT09PWVba1J1bm5pbmdJZHhdKTtjb25zdCB0PWVba1F1ZXVlJDFdLnNwbGljZShlW2tSdW5uaW5nSWR4XSk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHI9dFtuXTt1dGlsJGYuZXJyb3JSZXF1ZXN0KGUscixBKX1hc3NlcnQkNyhlW2tTaXplJDNdPT09MCl9fW8ob25FcnJvcixcIm9uRXJyb3JcIik7YXN5bmMgZnVuY3Rpb24gY29ubmVjdCQxKGUpe2Fzc2VydCQ3KCFlW2tDb25uZWN0aW5nXSksYXNzZXJ0JDcoIWVba0hUVFBDb250ZXh0XSk7bGV0e2hvc3Q6QSxob3N0bmFtZTp0LHByb3RvY29sOm4scG9ydDpyfT1lW2tVcmwkMl07aWYodFswXT09PVwiW1wiKXtjb25zdCBzPXQuaW5kZXhPZihcIl1cIik7YXNzZXJ0JDcocyE9PS0xKTtjb25zdCBpPXQuc3Vic3RyaW5nKDEscyk7YXNzZXJ0JDcobmV0LmlzSVAoaSkpLHQ9aX1lW2tDb25uZWN0aW5nXT0hMCxjaGFubmVscy5iZWZvcmVDb25uZWN0Lmhhc1N1YnNjcmliZXJzJiZjaGFubmVscy5iZWZvcmVDb25uZWN0LnB1Ymxpc2goe2Nvbm5lY3RQYXJhbXM6e2hvc3Q6QSxob3N0bmFtZTp0LHByb3RvY29sOm4scG9ydDpyLHZlcnNpb246ZVtrSFRUUENvbnRleHRdPy52ZXJzaW9uLHNlcnZlcm5hbWU6ZVtrU2VydmVyTmFtZV0sbG9jYWxBZGRyZXNzOmVba0xvY2FsQWRkcmVzc119LGNvbm5lY3RvcjplW2tDb25uZWN0b3JdfSk7dHJ5e2NvbnN0IHM9YXdhaXQgbmV3IFByb21pc2UoKGksRSk9PntlW2tDb25uZWN0b3JdKHtob3N0OkEsaG9zdG5hbWU6dCxwcm90b2NvbDpuLHBvcnQ6cixzZXJ2ZXJuYW1lOmVba1NlcnZlck5hbWVdLGxvY2FsQWRkcmVzczplW2tMb2NhbEFkZHJlc3NdfSwoUSxDKT0+e1E/RShRKTppKEMpfSl9KTtpZihlLmRlc3Ryb3llZCl7dXRpbCRmLmRlc3Ryb3kocy5vbihcImVycm9yXCIsKCk9Pnt9KSxuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IpO3JldHVybn1hc3NlcnQkNyhzKTt0cnl7ZVtrSFRUUENvbnRleHRdPXMuYWxwblByb3RvY29sPT09XCJoMlwiP2F3YWl0IGNvbm5lY3RIMihlLHMpOmF3YWl0IGNvbm5lY3RIMShlLHMpfWNhdGNoKGkpe3Rocm93IHMuZGVzdHJveSgpLm9uKFwiZXJyb3JcIiwoKT0+e30pLGl9ZVtrQ29ubmVjdGluZ109ITEsc1trQ291bnRlcl09MCxzW2tNYXhSZXF1ZXN0c109ZVtrTWF4UmVxdWVzdHNdLHNba0NsaWVudCQxXT1lLHNba0Vycm9yXT1udWxsLGNoYW5uZWxzLmNvbm5lY3RlZC5oYXNTdWJzY3JpYmVycyYmY2hhbm5lbHMuY29ubmVjdGVkLnB1Ymxpc2goe2Nvbm5lY3RQYXJhbXM6e2hvc3Q6QSxob3N0bmFtZTp0LHByb3RvY29sOm4scG9ydDpyLHZlcnNpb246ZVtrSFRUUENvbnRleHRdPy52ZXJzaW9uLHNlcnZlcm5hbWU6ZVtrU2VydmVyTmFtZV0sbG9jYWxBZGRyZXNzOmVba0xvY2FsQWRkcmVzc119LGNvbm5lY3RvcjplW2tDb25uZWN0b3JdLHNvY2tldDpzfSksZS5lbWl0KFwiY29ubmVjdFwiLGVba1VybCQyXSxbZV0pfWNhdGNoKHMpe2lmKGUuZGVzdHJveWVkKXJldHVybjtpZihlW2tDb25uZWN0aW5nXT0hMSxjaGFubmVscy5jb25uZWN0RXJyb3IuaGFzU3Vic2NyaWJlcnMmJmNoYW5uZWxzLmNvbm5lY3RFcnJvci5wdWJsaXNoKHtjb25uZWN0UGFyYW1zOntob3N0OkEsaG9zdG5hbWU6dCxwcm90b2NvbDpuLHBvcnQ6cix2ZXJzaW9uOmVba0hUVFBDb250ZXh0XT8udmVyc2lvbixzZXJ2ZXJuYW1lOmVba1NlcnZlck5hbWVdLGxvY2FsQWRkcmVzczplW2tMb2NhbEFkZHJlc3NdfSxjb25uZWN0b3I6ZVtrQ29ubmVjdG9yXSxlcnJvcjpzfSkscy5jb2RlPT09XCJFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEXCIpZm9yKGFzc2VydCQ3KGVba1J1bm5pbmckM109PT0wKTtlW2tQZW5kaW5nJDJdPjAmJmVba1F1ZXVlJDFdW2Vba1BlbmRpbmdJZHhdXS5zZXJ2ZXJuYW1lPT09ZVtrU2VydmVyTmFtZV07KXtjb25zdCBpPWVba1F1ZXVlJDFdW2Vba1BlbmRpbmdJZHhdKytdO3V0aWwkZi5lcnJvclJlcXVlc3QoZSxpLHMpfWVsc2Ugb25FcnJvcihlLHMpO2UuZW1pdChcImNvbm5lY3Rpb25FcnJvclwiLGVba1VybCQyXSxbZV0scyl9ZVtrUmVzdW1lJDFdKCl9byhjb25uZWN0JDEsXCJjb25uZWN0JDFcIik7ZnVuY3Rpb24gZW1pdERyYWluKGUpe2Vba05lZWREcmFpbiQyXT0wLGUuZW1pdChcImRyYWluXCIsZVtrVXJsJDJdLFtlXSl9byhlbWl0RHJhaW4sXCJlbWl0RHJhaW5cIik7ZnVuY3Rpb24gcmVzdW1lKGUsQSl7ZVtrUmVzdW1pbmddIT09MiYmKGVba1Jlc3VtaW5nXT0yLF9yZXN1bWUoZSxBKSxlW2tSZXN1bWluZ109MCxlW2tSdW5uaW5nSWR4XT4yNTYmJihlW2tRdWV1ZSQxXS5zcGxpY2UoMCxlW2tSdW5uaW5nSWR4XSksZVtrUGVuZGluZ0lkeF0tPWVba1J1bm5pbmdJZHhdLGVba1J1bm5pbmdJZHhdPTApKX1vKHJlc3VtZSxcInJlc3VtZVwiKTtmdW5jdGlvbiBfcmVzdW1lKGUsQSl7Zm9yKDs7KXtpZihlLmRlc3Ryb3llZCl7YXNzZXJ0JDcoZVtrUGVuZGluZyQyXT09PTApO3JldHVybn1pZihlW2tDbG9zZWRSZXNvbHZlJDFdJiYhZVtrU2l6ZSQzXSl7ZVtrQ2xvc2VkUmVzb2x2ZSQxXSgpLGVba0Nsb3NlZFJlc29sdmUkMV09bnVsbDtyZXR1cm59aWYoZVtrSFRUUENvbnRleHRdJiZlW2tIVFRQQ29udGV4dF0ucmVzdW1lKCksZVtrQnVzeSQxXSllW2tOZWVkRHJhaW4kMl09MjtlbHNlIGlmKGVba05lZWREcmFpbiQyXT09PTIpe0E/KGVba05lZWREcmFpbiQyXT0xLHF1ZXVlTWljcm90YXNrKCgpPT5lbWl0RHJhaW4oZSkpKTplbWl0RHJhaW4oZSk7Y29udGludWV9aWYoZVtrUGVuZGluZyQyXT09PTB8fGVba1J1bm5pbmckM10+PShnZXRQaXBlbGluaW5nKGUpfHwxKSlyZXR1cm47Y29uc3QgdD1lW2tRdWV1ZSQxXVtlW2tQZW5kaW5nSWR4XV07aWYoZVtrVXJsJDJdLnByb3RvY29sPT09XCJodHRwczpcIiYmZVtrU2VydmVyTmFtZV0hPT10LnNlcnZlcm5hbWUpe2lmKGVba1J1bm5pbmckM10+MClyZXR1cm47ZVtrU2VydmVyTmFtZV09dC5zZXJ2ZXJuYW1lLGVba0hUVFBDb250ZXh0XT8uZGVzdHJveShuZXcgSW5mb3JtYXRpb25hbEVycm9yKFwic2VydmVybmFtZSBjaGFuZ2VkXCIpLCgpPT57ZVtrSFRUUENvbnRleHRdPW51bGwscmVzdW1lKGUpfSl9aWYoZVtrQ29ubmVjdGluZ10pcmV0dXJuO2lmKCFlW2tIVFRQQ29udGV4dF0pe2Nvbm5lY3QkMShlKTtyZXR1cm59aWYoZVtrSFRUUENvbnRleHRdLmRlc3Ryb3llZHx8ZVtrSFRUUENvbnRleHRdLmJ1c3kodCkpcmV0dXJuOyF0LmFib3J0ZWQmJmVba0hUVFBDb250ZXh0XS53cml0ZSh0KT9lW2tQZW5kaW5nSWR4XSsrOmVba1F1ZXVlJDFdLnNwbGljZShlW2tQZW5kaW5nSWR4XSwxKX19byhfcmVzdW1lLFwiX3Jlc3VtZVwiKTt2YXIgY2xpZW50PUNsaWVudCQzO2NvbnN0IGtTaXplJDI9MjA0OCxrTWFzaz1rU2l6ZSQyLTEsUXQ9Y2xhc3MgUXR7Y29uc3RydWN0b3IoKXt0aGlzLmJvdHRvbT0wLHRoaXMudG9wPTAsdGhpcy5saXN0PW5ldyBBcnJheShrU2l6ZSQyKSx0aGlzLm5leHQ9bnVsbH1pc0VtcHR5KCl7cmV0dXJuIHRoaXMudG9wPT09dGhpcy5ib3R0b219aXNGdWxsKCl7cmV0dXJuKHRoaXMudG9wKzEma01hc2spPT09dGhpcy5ib3R0b219cHVzaChBKXt0aGlzLmxpc3RbdGhpcy50b3BdPUEsdGhpcy50b3A9dGhpcy50b3ArMSZrTWFza31zaGlmdCgpe2NvbnN0IEE9dGhpcy5saXN0W3RoaXMuYm90dG9tXTtyZXR1cm4gQT09PXZvaWQgMD9udWxsOih0aGlzLmxpc3RbdGhpcy5ib3R0b21dPXZvaWQgMCx0aGlzLmJvdHRvbT10aGlzLmJvdHRvbSsxJmtNYXNrLEEpfX07byhRdCxcIkZpeGVkQ2lyY3VsYXJCdWZmZXJcIik7bGV0IEZpeGVkQ2lyY3VsYXJCdWZmZXI9UXQ7dmFyIGZpeGVkUXVldWU9KG1lPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5oZWFkPXRoaXMudGFpbD1uZXcgRml4ZWRDaXJjdWxhckJ1ZmZlcn1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuaGVhZC5pc0VtcHR5KCl9cHVzaChBKXt0aGlzLmhlYWQuaXNGdWxsKCkmJih0aGlzLmhlYWQ9dGhpcy5oZWFkLm5leHQ9bmV3IEZpeGVkQ2lyY3VsYXJCdWZmZXIpLHRoaXMuaGVhZC5wdXNoKEEpfXNoaWZ0KCl7Y29uc3QgQT10aGlzLnRhaWwsdD1BLnNoaWZ0KCk7cmV0dXJuIEEuaXNFbXB0eSgpJiZBLm5leHQhPT1udWxsJiYodGhpcy50YWlsPUEubmV4dCksdH19LG8obWUsXCJGaXhlZFF1ZXVlXCIpLG1lKTtjb25zdHtrRnJlZTprRnJlZSQxLGtDb25uZWN0ZWQ6a0Nvbm5lY3RlZCQzLGtQZW5kaW5nOmtQZW5kaW5nJDEsa1F1ZXVlZDprUXVldWVkJDEsa1J1bm5pbmc6a1J1bm5pbmckMixrU2l6ZTprU2l6ZSQxfT1zeW1ib2xzJDQsa1Bvb2w9U3ltYm9sKFwicG9vbFwiKTtsZXQgUG9vbFN0YXRzJDE9KExlPWNsYXNze2NvbnN0cnVjdG9yKEEpe3RoaXNba1Bvb2xdPUF9Z2V0IGNvbm5lY3RlZCgpe3JldHVybiB0aGlzW2tQb29sXVtrQ29ubmVjdGVkJDNdfWdldCBmcmVlKCl7cmV0dXJuIHRoaXNba1Bvb2xdW2tGcmVlJDFdfWdldCBwZW5kaW5nKCl7cmV0dXJuIHRoaXNba1Bvb2xdW2tQZW5kaW5nJDFdfWdldCBxdWV1ZWQoKXtyZXR1cm4gdGhpc1trUG9vbF1ba1F1ZXVlZCQxXX1nZXQgcnVubmluZygpe3JldHVybiB0aGlzW2tQb29sXVtrUnVubmluZyQyXX1nZXQgc2l6ZSgpe3JldHVybiB0aGlzW2tQb29sXVtrU2l6ZSQxXX19LG8oTGUsXCJQb29sU3RhdHNcIiksTGUpO3ZhciBwb29sU3RhdHM9UG9vbFN0YXRzJDE7Y29uc3QgRGlzcGF0Y2hlckJhc2UkMj1kaXNwYXRjaGVyQmFzZSxGaXhlZFF1ZXVlPWZpeGVkUXVldWUse2tDb25uZWN0ZWQ6a0Nvbm5lY3RlZCQyLGtTaXplLGtSdW5uaW5nOmtSdW5uaW5nJDEsa1BlbmRpbmcsa1F1ZXVlZCxrQnVzeSxrRnJlZSxrVXJsOmtVcmwkMSxrQ2xvc2U6a0Nsb3NlJDQsa0Rlc3Ryb3k6a0Rlc3Ryb3kkMixrRGlzcGF0Y2g6a0Rpc3BhdGNoJDF9PXN5bWJvbHMkNCxQb29sU3RhdHM9cG9vbFN0YXRzLGtDbGllbnRzJDI9U3ltYm9sKFwiY2xpZW50c1wiKSxrTmVlZERyYWluJDE9U3ltYm9sKFwibmVlZERyYWluXCIpLGtRdWV1ZT1TeW1ib2woXCJxdWV1ZVwiKSxrQ2xvc2VkUmVzb2x2ZT1TeW1ib2woXCJjbG9zZWQgcmVzb2x2ZVwiKSxrT25EcmFpbiQxPVN5bWJvbChcIm9uRHJhaW5cIiksa09uQ29ubmVjdCQxPVN5bWJvbChcIm9uQ29ubmVjdFwiKSxrT25EaXNjb25uZWN0JDE9U3ltYm9sKFwib25EaXNjb25uZWN0XCIpLGtPbkNvbm5lY3Rpb25FcnJvciQxPVN5bWJvbChcIm9uQ29ubmVjdGlvbkVycm9yXCIpLGtHZXREaXNwYXRjaGVyJDE9U3ltYm9sKFwiZ2V0IGRpc3BhdGNoZXJcIiksa0FkZENsaWVudCQxPVN5bWJvbChcImFkZCBjbGllbnRcIiksa1JlbW92ZUNsaWVudD1TeW1ib2woXCJyZW1vdmUgY2xpZW50XCIpLGtTdGF0cz1TeW1ib2woXCJzdGF0c1wiKTtsZXQgUG9vbEJhc2UkMT0oTWU9Y2xhc3MgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSQye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzW2tRdWV1ZV09bmV3IEZpeGVkUXVldWUsdGhpc1trQ2xpZW50cyQyXT1bXSx0aGlzW2tRdWV1ZWRdPTA7Y29uc3QgQT10aGlzO3RoaXNba09uRHJhaW4kMV09byhmdW5jdGlvbihuLHIpe2NvbnN0IHM9QVtrUXVldWVdO2xldCBpPSExO2Zvcig7IWk7KXtjb25zdCBFPXMuc2hpZnQoKTtpZighRSlicmVhaztBW2tRdWV1ZWRdLS0saT0hdGhpcy5kaXNwYXRjaChFLm9wdHMsRS5oYW5kbGVyKX10aGlzW2tOZWVkRHJhaW4kMV09aSwhdGhpc1trTmVlZERyYWluJDFdJiZBW2tOZWVkRHJhaW4kMV0mJihBW2tOZWVkRHJhaW4kMV09ITEsQS5lbWl0KFwiZHJhaW5cIixuLFtBLC4uLnJdKSksQVtrQ2xvc2VkUmVzb2x2ZV0mJnMuaXNFbXB0eSgpJiZQcm9taXNlLmFsbChBW2tDbGllbnRzJDJdLm1hcChFPT5FLmNsb3NlKCkpKS50aGVuKEFba0Nsb3NlZFJlc29sdmVdKX0sXCJvbkRyYWluXCIpLHRoaXNba09uQ29ubmVjdCQxXT0odCxuKT0+e0EuZW1pdChcImNvbm5lY3RcIix0LFtBLC4uLm5dKX0sdGhpc1trT25EaXNjb25uZWN0JDFdPSh0LG4scik9PntBLmVtaXQoXCJkaXNjb25uZWN0XCIsdCxbQSwuLi5uXSxyKX0sdGhpc1trT25Db25uZWN0aW9uRXJyb3IkMV09KHQsbixyKT0+e0EuZW1pdChcImNvbm5lY3Rpb25FcnJvclwiLHQsW0EsLi4ubl0scil9LHRoaXNba1N0YXRzXT1uZXcgUG9vbFN0YXRzKHRoaXMpfWdldFtrQnVzeV0oKXtyZXR1cm4gdGhpc1trTmVlZERyYWluJDFdfWdldFtrQ29ubmVjdGVkJDJdKCl7cmV0dXJuIHRoaXNba0NsaWVudHMkMl0uZmlsdGVyKEE9PkFba0Nvbm5lY3RlZCQyXSkubGVuZ3RofWdldFtrRnJlZV0oKXtyZXR1cm4gdGhpc1trQ2xpZW50cyQyXS5maWx0ZXIoQT0+QVtrQ29ubmVjdGVkJDJdJiYhQVtrTmVlZERyYWluJDFdKS5sZW5ndGh9Z2V0W2tQZW5kaW5nXSgpe2xldCBBPXRoaXNba1F1ZXVlZF07Zm9yKGNvbnN0e1trUGVuZGluZ106dH1vZiB0aGlzW2tDbGllbnRzJDJdKUErPXQ7cmV0dXJuIEF9Z2V0W2tSdW5uaW5nJDFdKCl7bGV0IEE9MDtmb3IoY29uc3R7W2tSdW5uaW5nJDFdOnR9b2YgdGhpc1trQ2xpZW50cyQyXSlBKz10O3JldHVybiBBfWdldFtrU2l6ZV0oKXtsZXQgQT10aGlzW2tRdWV1ZWRdO2Zvcihjb25zdHtba1NpemVdOnR9b2YgdGhpc1trQ2xpZW50cyQyXSlBKz10O3JldHVybiBBfWdldCBzdGF0cygpe3JldHVybiB0aGlzW2tTdGF0c119YXN5bmNba0Nsb3NlJDRdKCl7cmV0dXJuIHRoaXNba1F1ZXVlXS5pc0VtcHR5KCk/UHJvbWlzZS5hbGwodGhpc1trQ2xpZW50cyQyXS5tYXAoQT0+QS5jbG9zZSgpKSk6bmV3IFByb21pc2UoQT0+e3RoaXNba0Nsb3NlZFJlc29sdmVdPUF9KX1hc3luY1trRGVzdHJveSQyXShBKXtmb3IoOzspe2NvbnN0IHQ9dGhpc1trUXVldWVdLnNoaWZ0KCk7aWYoIXQpYnJlYWs7dC5oYW5kbGVyLm9uRXJyb3IoQSl9cmV0dXJuIFByb21pc2UuYWxsKHRoaXNba0NsaWVudHMkMl0ubWFwKHQ9PnQuZGVzdHJveShBKSkpfVtrRGlzcGF0Y2gkMV0oQSx0KXtjb25zdCBuPXRoaXNba0dldERpc3BhdGNoZXIkMV0oKTtyZXR1cm4gbj9uLmRpc3BhdGNoKEEsdCl8fChuW2tOZWVkRHJhaW4kMV09ITAsdGhpc1trTmVlZERyYWluJDFdPSF0aGlzW2tHZXREaXNwYXRjaGVyJDFdKCkpOih0aGlzW2tOZWVkRHJhaW4kMV09ITAsdGhpc1trUXVldWVdLnB1c2goe29wdHM6QSxoYW5kbGVyOnR9KSx0aGlzW2tRdWV1ZWRdKyspLCF0aGlzW2tOZWVkRHJhaW4kMV19W2tBZGRDbGllbnQkMV0oQSl7cmV0dXJuIEEub24oXCJkcmFpblwiLHRoaXNba09uRHJhaW4kMV0pLm9uKFwiY29ubmVjdFwiLHRoaXNba09uQ29ubmVjdCQxXSkub24oXCJkaXNjb25uZWN0XCIsdGhpc1trT25EaXNjb25uZWN0JDFdKS5vbihcImNvbm5lY3Rpb25FcnJvclwiLHRoaXNba09uQ29ubmVjdGlvbkVycm9yJDFdKSx0aGlzW2tDbGllbnRzJDJdLnB1c2goQSksdGhpc1trTmVlZERyYWluJDFdJiZxdWV1ZU1pY3JvdGFzaygoKT0+e3RoaXNba05lZWREcmFpbiQxXSYmdGhpc1trT25EcmFpbiQxXShBW2tVcmwkMV0sW3RoaXMsQV0pfSksdGhpc31ba1JlbW92ZUNsaWVudF0oQSl7QS5jbG9zZSgoKT0+e2NvbnN0IHQ9dGhpc1trQ2xpZW50cyQyXS5pbmRleE9mKEEpO3QhPT0tMSYmdGhpc1trQ2xpZW50cyQyXS5zcGxpY2UodCwxKX0pLHRoaXNba05lZWREcmFpbiQxXT10aGlzW2tDbGllbnRzJDJdLnNvbWUodD0+IXRba05lZWREcmFpbiQxXSYmdC5jbG9zZWQhPT0hMCYmdC5kZXN0cm95ZWQhPT0hMCl9fSxvKE1lLFwiUG9vbEJhc2VcIiksTWUpO3ZhciBwb29sQmFzZT17UG9vbEJhc2U6UG9vbEJhc2UkMSxrQ2xpZW50czprQ2xpZW50cyQyLGtOZWVkRHJhaW46a05lZWREcmFpbiQxLGtBZGRDbGllbnQ6a0FkZENsaWVudCQxLGtSZW1vdmVDbGllbnQsa0dldERpc3BhdGNoZXI6a0dldERpc3BhdGNoZXIkMX07Y29uc3R7UG9vbEJhc2Usa0NsaWVudHM6a0NsaWVudHMkMSxrTmVlZERyYWluLGtBZGRDbGllbnQsa0dldERpc3BhdGNoZXJ9PXBvb2xCYXNlLENsaWVudCQyPWNsaWVudCx7SW52YWxpZEFyZ3VtZW50RXJyb3I6SW52YWxpZEFyZ3VtZW50RXJyb3IkZH09ZXJyb3JzJDEsdXRpbCRlPXV0aWwkbSx7a1VybCxrSW50ZXJjZXB0b3JzOmtJbnRlcmNlcHRvcnMkMn09c3ltYm9scyQ0LGJ1aWxkQ29ubmVjdG9yJDE9Y29ubmVjdCQyLGtPcHRpb25zJDE9U3ltYm9sKFwib3B0aW9uc1wiKSxrQ29ubmVjdGlvbnM9U3ltYm9sKFwiY29ubmVjdGlvbnNcIiksa0ZhY3RvcnkkMT1TeW1ib2woXCJmYWN0b3J5XCIpO2Z1bmN0aW9uIGRlZmF1bHRGYWN0b3J5JDIoZSxBKXtyZXR1cm4gbmV3IENsaWVudCQyKGUsQSl9byhkZWZhdWx0RmFjdG9yeSQyLFwiZGVmYXVsdEZhY3RvcnkkMlwiKTtsZXQgUG9vbCQzPShZZT1jbGFzcyBleHRlbmRzIFBvb2xCYXNle2NvbnN0cnVjdG9yKEEse2Nvbm5lY3Rpb25zOnQsZmFjdG9yeTpuPWRlZmF1bHRGYWN0b3J5JDIsY29ubmVjdDpyLGNvbm5lY3RUaW1lb3V0OnMsdGxzOmksbWF4Q2FjaGVkU2Vzc2lvbnM6RSxzb2NrZXRQYXRoOlEsYXV0b1NlbGVjdEZhbWlseTpDLGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dDpJLGFsbG93SDI6YSwuLi5mfT17fSl7aWYoc3VwZXIoKSx0IT1udWxsJiYoIU51bWJlci5pc0Zpbml0ZSh0KXx8dDwwKSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkZChcImludmFsaWQgY29ubmVjdGlvbnNcIik7aWYodHlwZW9mIG4hPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkZChcImZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtpZihyIT1udWxsJiZ0eXBlb2YgciE9XCJmdW5jdGlvblwiJiZ0eXBlb2YgciE9XCJvYmplY3RcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkZChcImNvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdFwiKTt0eXBlb2YgciE9XCJmdW5jdGlvblwiJiYocj1idWlsZENvbm5lY3RvciQxKHsuLi5pLG1heENhY2hlZFNlc3Npb25zOkUsYWxsb3dIMjphLHNvY2tldFBhdGg6USx0aW1lb3V0OnMsLi4udXRpbCRlLm5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5JiZDP3thdXRvU2VsZWN0RmFtaWx5OkMsYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0Okl9OnZvaWQgMCwuLi5yfSkpLHRoaXNba0ludGVyY2VwdG9ycyQyXT1mLmludGVyY2VwdG9ycz8uUG9vbCYmQXJyYXkuaXNBcnJheShmLmludGVyY2VwdG9ycy5Qb29sKT9mLmludGVyY2VwdG9ycy5Qb29sOltdLHRoaXNba0Nvbm5lY3Rpb25zXT10fHxudWxsLHRoaXNba1VybF09dXRpbCRlLnBhcnNlT3JpZ2luKEEpLHRoaXNba09wdGlvbnMkMV09ey4uLnV0aWwkZS5kZWVwQ2xvbmUoZiksY29ubmVjdDpyLGFsbG93SDI6YX0sdGhpc1trT3B0aW9ucyQxXS5pbnRlcmNlcHRvcnM9Zi5pbnRlcmNlcHRvcnM/ey4uLmYuaW50ZXJjZXB0b3JzfTp2b2lkIDAsdGhpc1trRmFjdG9yeSQxXT1ufVtrR2V0RGlzcGF0Y2hlcl0oKXtmb3IoY29uc3QgQSBvZiB0aGlzW2tDbGllbnRzJDFdKWlmKCFBW2tOZWVkRHJhaW5dKXJldHVybiBBO2lmKCF0aGlzW2tDb25uZWN0aW9uc118fHRoaXNba0NsaWVudHMkMV0ubGVuZ3RoPHRoaXNba0Nvbm5lY3Rpb25zXSl7Y29uc3QgQT10aGlzW2tGYWN0b3J5JDFdKHRoaXNba1VybF0sdGhpc1trT3B0aW9ucyQxXSk7cmV0dXJuIHRoaXNba0FkZENsaWVudF0oQSksQX19fSxvKFllLFwiUG9vbFwiKSxZZSk7dmFyIHBvb2w9UG9vbCQzO2NvbnN0e0ludmFsaWRBcmd1bWVudEVycm9yOkludmFsaWRBcmd1bWVudEVycm9yJGN9PWVycm9ycyQxLHtrQ2xpZW50cyxrUnVubmluZyxrQ2xvc2U6a0Nsb3NlJDMsa0Rlc3Ryb3k6a0Rlc3Ryb3kkMSxrRGlzcGF0Y2gsa0ludGVyY2VwdG9yczprSW50ZXJjZXB0b3JzJDF9PXN5bWJvbHMkNCxEaXNwYXRjaGVyQmFzZSQxPWRpc3BhdGNoZXJCYXNlLFBvb2wkMj1wb29sLENsaWVudCQxPWNsaWVudCx1dGlsJGQ9dXRpbCRtLGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3I9cmVkaXJlY3RJbnRlcmNlcHRvcixrT25Db25uZWN0PVN5bWJvbChcIm9uQ29ubmVjdFwiKSxrT25EaXNjb25uZWN0PVN5bWJvbChcIm9uRGlzY29ubmVjdFwiKSxrT25Db25uZWN0aW9uRXJyb3I9U3ltYm9sKFwib25Db25uZWN0aW9uRXJyb3JcIiksa01heFJlZGlyZWN0aW9ucz1TeW1ib2woXCJtYXhSZWRpcmVjdGlvbnNcIiksa09uRHJhaW49U3ltYm9sKFwib25EcmFpblwiKSxrRmFjdG9yeT1TeW1ib2woXCJmYWN0b3J5XCIpLGtPcHRpb25zPVN5bWJvbChcIm9wdGlvbnNcIik7ZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkkMShlLEEpe3JldHVybiBBJiZBLmNvbm5lY3Rpb25zPT09MT9uZXcgQ2xpZW50JDEoZSxBKTpuZXcgUG9vbCQyKGUsQSl9byhkZWZhdWx0RmFjdG9yeSQxLFwiZGVmYXVsdEZhY3RvcnkkMVwiKTtsZXQgQWdlbnQkMz0oSmU9Y2xhc3MgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSQxe2NvbnN0cnVjdG9yKHtmYWN0b3J5OkE9ZGVmYXVsdEZhY3RvcnkkMSxtYXhSZWRpcmVjdGlvbnM6dD0wLGNvbm5lY3Q6biwuLi5yfT17fSl7aWYoc3VwZXIoKSx0eXBlb2YgQSE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRjKFwiZmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO2lmKG4hPW51bGwmJnR5cGVvZiBuIT1cImZ1bmN0aW9uXCImJnR5cGVvZiBuIT1cIm9iamVjdFwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRjKFwiY29ubmVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0XCIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHQpfHx0PDApdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGMoXCJtYXhSZWRpcmVjdGlvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtuJiZ0eXBlb2YgbiE9XCJmdW5jdGlvblwiJiYobj17Li4ubn0pLHRoaXNba0ludGVyY2VwdG9ycyQxXT1yLmludGVyY2VwdG9ycz8uQWdlbnQmJkFycmF5LmlzQXJyYXkoci5pbnRlcmNlcHRvcnMuQWdlbnQpP3IuaW50ZXJjZXB0b3JzLkFnZW50OltjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yKHttYXhSZWRpcmVjdGlvbnM6dH0pXSx0aGlzW2tPcHRpb25zXT17Li4udXRpbCRkLmRlZXBDbG9uZShyKSxjb25uZWN0Om59LHRoaXNba09wdGlvbnNdLmludGVyY2VwdG9ycz1yLmludGVyY2VwdG9ycz97Li4uci5pbnRlcmNlcHRvcnN9OnZvaWQgMCx0aGlzW2tNYXhSZWRpcmVjdGlvbnNdPXQsdGhpc1trRmFjdG9yeV09QSx0aGlzW2tDbGllbnRzXT1uZXcgTWFwLHRoaXNba09uRHJhaW5dPShzLGkpPT57dGhpcy5lbWl0KFwiZHJhaW5cIixzLFt0aGlzLC4uLmldKX0sdGhpc1trT25Db25uZWN0XT0ocyxpKT0+e3RoaXMuZW1pdChcImNvbm5lY3RcIixzLFt0aGlzLC4uLmldKX0sdGhpc1trT25EaXNjb25uZWN0XT0ocyxpLEUpPT57dGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiLHMsW3RoaXMsLi4uaV0sRSl9LHRoaXNba09uQ29ubmVjdGlvbkVycm9yXT0ocyxpLEUpPT57dGhpcy5lbWl0KFwiY29ubmVjdGlvbkVycm9yXCIscyxbdGhpcywuLi5pXSxFKX19Z2V0W2tSdW5uaW5nXSgpe2xldCBBPTA7Zm9yKGNvbnN0IHQgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpQSs9dFtrUnVubmluZ107cmV0dXJuIEF9W2tEaXNwYXRjaF0oQSx0KXtsZXQgbjtpZihBLm9yaWdpbiYmKHR5cGVvZiBBLm9yaWdpbj09XCJzdHJpbmdcInx8QS5vcmlnaW4gaW5zdGFuY2VvZiBVUkwpKW49U3RyaW5nKEEub3JpZ2luKTtlbHNlIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRjKFwib3B0cy5vcmlnaW4gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgVVJMLlwiKTtsZXQgcj10aGlzW2tDbGllbnRzXS5nZXQobik7cmV0dXJuIHJ8fChyPXRoaXNba0ZhY3RvcnldKEEub3JpZ2luLHRoaXNba09wdGlvbnNdKS5vbihcImRyYWluXCIsdGhpc1trT25EcmFpbl0pLm9uKFwiY29ubmVjdFwiLHRoaXNba09uQ29ubmVjdF0pLm9uKFwiZGlzY29ubmVjdFwiLHRoaXNba09uRGlzY29ubmVjdF0pLm9uKFwiY29ubmVjdGlvbkVycm9yXCIsdGhpc1trT25Db25uZWN0aW9uRXJyb3JdKSx0aGlzW2tDbGllbnRzXS5zZXQobixyKSksci5kaXNwYXRjaChBLHQpfWFzeW5jW2tDbG9zZSQzXSgpe2NvbnN0IEE9W107Zm9yKGNvbnN0IHQgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpQS5wdXNoKHQuY2xvc2UoKSk7dGhpc1trQ2xpZW50c10uY2xlYXIoKSxhd2FpdCBQcm9taXNlLmFsbChBKX1hc3luY1trRGVzdHJveSQxXShBKXtjb25zdCB0PVtdO2Zvcihjb25zdCBuIG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKXQucHVzaChuLmRlc3Ryb3koQSkpO3RoaXNba0NsaWVudHNdLmNsZWFyKCksYXdhaXQgUHJvbWlzZS5hbGwodCl9fSxvKEplLFwiQWdlbnRcIiksSmUpO3ZhciBhZ2VudD1BZ2VudCQzO2NvbnN0e2tQcm94eSxrQ2xvc2U6a0Nsb3NlJDIsa0Rlc3Ryb3ksa0ludGVyY2VwdG9yc309c3ltYm9scyQ0LHtVUkw6VVJMJDF9PXJlcXVpcmUkJDFfX2RlZmF1bHQsQWdlbnQkMj1hZ2VudCxQb29sJDE9cG9vbCxEaXNwYXRjaGVyQmFzZT1kaXNwYXRjaGVyQmFzZSx7SW52YWxpZEFyZ3VtZW50RXJyb3I6SW52YWxpZEFyZ3VtZW50RXJyb3IkYixSZXF1ZXN0QWJvcnRlZEVycm9yOlJlcXVlc3RBYm9ydGVkRXJyb3IkMyxTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvcn09ZXJyb3JzJDEsYnVpbGRDb25uZWN0b3I9Y29ubmVjdCQyLGtBZ2VudD1TeW1ib2woXCJwcm94eSBhZ2VudFwiKSxrQ2xpZW50PVN5bWJvbChcInByb3h5IGNsaWVudFwiKSxrUHJveHlIZWFkZXJzPVN5bWJvbChcInByb3h5IGhlYWRlcnNcIiksa1JlcXVlc3RUbHM9U3ltYm9sKFwicmVxdWVzdCB0bHMgc2V0dGluZ3NcIiksa1Byb3h5VGxzPVN5bWJvbChcInByb3h5IHRscyBzZXR0aW5nc1wiKSxrQ29ubmVjdEVuZHBvaW50PVN5bWJvbChcImNvbm5lY3QgZW5kcG9pbnQgZnVuY3Rpb25cIik7ZnVuY3Rpb24gZGVmYXVsdFByb3RvY29sUG9ydChlKXtyZXR1cm4gZT09PVwiaHR0cHM6XCI/NDQzOjgwfW8oZGVmYXVsdFByb3RvY29sUG9ydCxcImRlZmF1bHRQcm90b2NvbFBvcnRcIik7ZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkoZSxBKXtyZXR1cm4gbmV3IFBvb2wkMShlLEEpfW8oZGVmYXVsdEZhY3RvcnksXCJkZWZhdWx0RmFjdG9yeVwiKTtsZXQgUHJveHlBZ2VudCQxPShHZT1jbGFzcyBleHRlbmRzIERpc3BhdGNoZXJCYXNle2NvbnN0cnVjdG9yKHQpe3N1cGVyKCk7Q0EodGhpcyxPZSk7aWYoIXR8fHR5cGVvZiB0PT1cIm9iamVjdFwiJiYhKHQgaW5zdGFuY2VvZiBVUkwkMSkmJiF0LnVyaSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkYihcIlByb3h5IHVyaSBpcyBtYW5kYXRvcnlcIik7Y29uc3R7Y2xpZW50RmFjdG9yeTpuPWRlZmF1bHRGYWN0b3J5fT10O2lmKHR5cGVvZiBuIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGIoXCJQcm94eSBvcHRzLmNsaWVudEZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtjb25zdCByPWtBKHRoaXMsT2UsUnQpLmNhbGwodGhpcyx0KSx7aHJlZjpzLG9yaWdpbjppLHBvcnQ6RSxwcm90b2NvbDpRLHVzZXJuYW1lOkMscGFzc3dvcmQ6SSxob3N0bmFtZTphfT1yO2lmKHRoaXNba1Byb3h5XT17dXJpOnMscHJvdG9jb2w6UX0sdGhpc1trSW50ZXJjZXB0b3JzXT10LmludGVyY2VwdG9ycz8uUHJveHlBZ2VudCYmQXJyYXkuaXNBcnJheSh0LmludGVyY2VwdG9ycy5Qcm94eUFnZW50KT90LmludGVyY2VwdG9ycy5Qcm94eUFnZW50OltdLHRoaXNba1JlcXVlc3RUbHNdPXQucmVxdWVzdFRscyx0aGlzW2tQcm94eVRsc109dC5wcm94eVRscyx0aGlzW2tQcm94eUhlYWRlcnNdPXQuaGVhZGVyc3x8e30sdC5hdXRoJiZ0LnRva2VuKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciRiKFwib3B0cy5hdXRoIGNhbm5vdCBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggb3B0cy50b2tlblwiKTt0LmF1dGg/dGhpc1trUHJveHlIZWFkZXJzXVtcInByb3h5LWF1dGhvcml6YXRpb25cIl09YEJhc2ljICR7dC5hdXRofWA6dC50b2tlbj90aGlzW2tQcm94eUhlYWRlcnNdW1wicHJveHktYXV0aG9yaXphdGlvblwiXT10LnRva2VuOkMmJkkmJih0aGlzW2tQcm94eUhlYWRlcnNdW1wicHJveHktYXV0aG9yaXphdGlvblwiXT1gQmFzaWMgJHtCdWZmZXIuZnJvbShgJHtkZWNvZGVVUklDb21wb25lbnQoQyl9OiR7ZGVjb2RlVVJJQ29tcG9uZW50KEkpfWApLnRvU3RyaW5nKFwiYmFzZTY0XCIpfWApO2NvbnN0IGY9YnVpbGRDb25uZWN0b3Ioey4uLnQucHJveHlUbHN9KTt0aGlzW2tDb25uZWN0RW5kcG9pbnRdPWJ1aWxkQ29ubmVjdG9yKHsuLi50LnJlcXVlc3RUbHN9KSx0aGlzW2tDbGllbnRdPW4ocix7Y29ubmVjdDpmfSksdGhpc1trQWdlbnRdPW5ldyBBZ2VudCQyKHsuLi50LGNvbm5lY3Q6YXN5bmMoaCxMKT0+e2xldCBjPWguaG9zdDtoLnBvcnR8fChjKz1gOiR7ZGVmYXVsdFByb3RvY29sUG9ydChoLnByb3RvY29sKX1gKTt0cnl7Y29uc3R7c29ja2V0Omwsc3RhdHVzQ29kZTpTfT1hd2FpdCB0aGlzW2tDbGllbnRdLmNvbm5lY3Qoe29yaWdpbjppLHBvcnQ6RSxwYXRoOmMsc2lnbmFsOmguc2lnbmFsLGhlYWRlcnM6ey4uLnRoaXNba1Byb3h5SGVhZGVyc10saG9zdDpoLmhvc3R9LHNlcnZlcm5hbWU6dGhpc1trUHJveHlUbHNdPy5zZXJ2ZXJuYW1lfHxhfSk7aWYoUyE9PTIwMCYmKGwub24oXCJlcnJvclwiLCgpPT57fSkuZGVzdHJveSgpLEwobmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IkMyhgUHJveHkgcmVzcG9uc2UgKCR7U30pICE9PSAyMDAgd2hlbiBIVFRQIFR1bm5lbGluZ2ApKSksaC5wcm90b2NvbCE9PVwiaHR0cHM6XCIpe0wobnVsbCxsKTtyZXR1cm59bGV0IGs7dGhpc1trUmVxdWVzdFRsc10/az10aGlzW2tSZXF1ZXN0VGxzXS5zZXJ2ZXJuYW1lOms9aC5zZXJ2ZXJuYW1lLHRoaXNba0Nvbm5lY3RFbmRwb2ludF0oey4uLmgsc2VydmVybmFtZTprLGh0dHBTb2NrZXQ6bH0sTCl9Y2F0Y2gobCl7bC5jb2RlPT09XCJFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEXCI/TChuZXcgU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3IobCkpOkwobCl9fX0pfWRpc3BhdGNoKHQsbil7Y29uc3Qgcj1idWlsZEhlYWRlcnModC5oZWFkZXJzKTtpZih0aHJvd0lmUHJveHlBdXRoSXNTZW50KHIpLHImJiEoXCJob3N0XCJpbiByKSYmIShcIkhvc3RcImluIHIpKXtjb25zdHtob3N0OnN9PW5ldyBVUkwkMSh0Lm9yaWdpbik7ci5ob3N0PXN9cmV0dXJuIHRoaXNba0FnZW50XS5kaXNwYXRjaCh7Li4udCxoZWFkZXJzOnJ9LG4pfWFzeW5jW2tDbG9zZSQyXSgpe2F3YWl0IHRoaXNba0FnZW50XS5jbG9zZSgpLGF3YWl0IHRoaXNba0NsaWVudF0uY2xvc2UoKX1hc3luY1trRGVzdHJveV0oKXthd2FpdCB0aGlzW2tBZ2VudF0uZGVzdHJveSgpLGF3YWl0IHRoaXNba0NsaWVudF0uZGVzdHJveSgpfX0sT2U9bmV3IFdlYWtTZXQsUnQ9byhmdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PVwic3RyaW5nXCI/bmV3IFVSTCQxKHQpOnQgaW5zdGFuY2VvZiBVUkwkMT90Om5ldyBVUkwkMSh0LnVyaSl9LFwiI2dldFVybFwiKSxvKEdlLFwiUHJveHlBZ2VudFwiKSxHZSk7ZnVuY3Rpb24gYnVpbGRIZWFkZXJzKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpe2NvbnN0IEE9e307Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kz0yKUFbZVt0XV09ZVt0KzFdO3JldHVybiBBfXJldHVybiBlfW8oYnVpbGRIZWFkZXJzLFwiYnVpbGRIZWFkZXJzXCIpO2Z1bmN0aW9uIHRocm93SWZQcm94eUF1dGhJc1NlbnQoZSl7aWYoZSYmT2JqZWN0LmtleXMoZSkuZmluZCh0PT50LnRvTG93ZXJDYXNlKCk9PT1cInByb3h5LWF1dGhvcml6YXRpb25cIikpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGIoXCJQcm94eS1BdXRob3JpemF0aW9uIHNob3VsZCBiZSBzZW50IGluIFByb3h5QWdlbnQgY29uc3RydWN0b3JcIil9byh0aHJvd0lmUHJveHlBdXRoSXNTZW50LFwidGhyb3dJZlByb3h5QXV0aElzU2VudFwiKTt2YXIgcHJveHlBZ2VudD1Qcm94eUFnZW50JDEsYXBpJDE9e30sYXBpUmVxdWVzdD17ZXhwb3J0czp7fX07Y29uc3QgYXNzZXJ0JDY9cmVxdWlyZSQkMF9fZGVmYXVsdCx7UmVhZGFibGU6UmVhZGFibGUkMn09U3RyZWFtX19kZWZhdWx0LHtSZXF1ZXN0QWJvcnRlZEVycm9yOlJlcXVlc3RBYm9ydGVkRXJyb3IkMixOb3RTdXBwb3J0ZWRFcnJvcixJbnZhbGlkQXJndW1lbnRFcnJvcjpJbnZhbGlkQXJndW1lbnRFcnJvciRhLEFib3J0RXJyb3J9PWVycm9ycyQxLHV0aWwkYz11dGlsJG0se1JlYWRhYmxlU3RyZWFtRnJvbX09dXRpbCRtLGtDb25zdW1lPVN5bWJvbChcImtDb25zdW1lXCIpLGtSZWFkaW5nPVN5bWJvbChcImtSZWFkaW5nXCIpLGtCb2R5PVN5bWJvbChcImtCb2R5XCIpLGtBYm9ydD1TeW1ib2woXCJrQWJvcnRcIiksa0NvbnRlbnRUeXBlPVN5bWJvbChcImtDb250ZW50VHlwZVwiKSxrQ29udGVudExlbmd0aCQxPVN5bWJvbChcImtDb250ZW50TGVuZ3RoXCIpLG5vb3A9bygoKT0+e30sXCJub29wXCIpLEV0PWNsYXNzIEV0IGV4dGVuZHMgUmVhZGFibGUkMntjb25zdHJ1Y3Rvcih7cmVzdW1lOkEsYWJvcnQ6dCxjb250ZW50VHlwZTpuPVwiXCIsY29udGVudExlbmd0aDpyLGhpZ2hXYXRlck1hcms6cz02NCoxMDI0fSl7c3VwZXIoe2F1dG9EZXN0cm95OiEwLHJlYWQ6QSxoaWdoV2F0ZXJNYXJrOnN9KSx0aGlzLl9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkPSExLHRoaXNba0Fib3J0XT10LHRoaXNba0NvbnN1bWVdPW51bGwsdGhpc1trQm9keV09bnVsbCx0aGlzW2tDb250ZW50VHlwZV09bix0aGlzW2tDb250ZW50TGVuZ3RoJDFdPXIsdGhpc1trUmVhZGluZ109ITF9ZGVzdHJveShBKXtyZXR1cm4hQSYmIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCYmKEE9bmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IkMiksQSYmdGhpc1trQWJvcnRdKCksc3VwZXIuZGVzdHJveShBKX1fZGVzdHJveShBLHQpe3F1ZXVlTWljcm90YXNrKCgpPT57dChBKX0pfW9uKEEsLi4udCl7cmV0dXJuKEE9PT1cImRhdGFcInx8QT09PVwicmVhZGFibGVcIikmJih0aGlzW2tSZWFkaW5nXT0hMCksc3VwZXIub24oQSwuLi50KX1hZGRMaXN0ZW5lcihBLC4uLnQpe3JldHVybiB0aGlzLm9uKEEsLi4udCl9b2ZmKEEsLi4udCl7Y29uc3Qgbj1zdXBlci5vZmYoQSwuLi50KTtyZXR1cm4oQT09PVwiZGF0YVwifHxBPT09XCJyZWFkYWJsZVwiKSYmKHRoaXNba1JlYWRpbmddPXRoaXMubGlzdGVuZXJDb3VudChcImRhdGFcIik+MHx8dGhpcy5saXN0ZW5lckNvdW50KFwicmVhZGFibGVcIik+MCksbn1yZW1vdmVMaXN0ZW5lcihBLC4uLnQpe3JldHVybiB0aGlzLm9mZihBLC4uLnQpfXB1c2goQSl7cmV0dXJuIHRoaXNba0NvbnN1bWVdJiZBIT09bnVsbD8oY29uc3VtZVB1c2godGhpc1trQ29uc3VtZV0sQSksdGhpc1trUmVhZGluZ10/c3VwZXIucHVzaChBKTohMCk6c3VwZXIucHVzaChBKX1hc3luYyB0ZXh0KCl7cmV0dXJuIGNvbnN1bWUodGhpcyxcInRleHRcIil9YXN5bmMganNvbigpe3JldHVybiBjb25zdW1lKHRoaXMsXCJqc29uXCIpfWFzeW5jIGJsb2IoKXtyZXR1cm4gY29uc3VtZSh0aGlzLFwiYmxvYlwiKX1hc3luYyBhcnJheUJ1ZmZlcigpe3JldHVybiBjb25zdW1lKHRoaXMsXCJhcnJheUJ1ZmZlclwiKX1hc3luYyBmb3JtRGF0YSgpe3Rocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcn1nZXQgYm9keVVzZWQoKXtyZXR1cm4gdXRpbCRjLmlzRGlzdHVyYmVkKHRoaXMpfWdldCBib2R5KCl7cmV0dXJuIHRoaXNba0JvZHldfHwodGhpc1trQm9keV09UmVhZGFibGVTdHJlYW1Gcm9tKHRoaXMpLHRoaXNba0NvbnN1bWVdJiYodGhpc1trQm9keV0uZ2V0UmVhZGVyKCksYXNzZXJ0JDYodGhpc1trQm9keV0ubG9ja2VkKSkpLHRoaXNba0JvZHldfWFzeW5jIGR1bXAoQSl7bGV0IHQ9TnVtYmVyLmlzRmluaXRlKEE/LmxpbWl0KT9BLmxpbWl0OjEzMTA3Mjtjb25zdCBuPUE/LnNpZ25hbDtpZihuIT1udWxsJiYodHlwZW9mIG4hPVwib2JqZWN0XCJ8fCEoXCJhYm9ydGVkXCJpbiBuKSkpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJGEoXCJzaWduYWwgbXVzdCBiZSBhbiBBYm9ydFNpZ25hbFwiKTtyZXR1cm4gbj8udGhyb3dJZkFib3J0ZWQoKSx0aGlzLl9yZWFkYWJsZVN0YXRlLmNsb3NlRW1pdHRlZD9udWxsOmF3YWl0IG5ldyBQcm9taXNlKChyLHMpPT57dGhpc1trQ29udGVudExlbmd0aCQxXT50JiZ0aGlzLmRlc3Ryb3kobmV3IEFib3J0RXJyb3IpO2NvbnN0IGk9bygoKT0+e3RoaXMuZGVzdHJveShuLnJlYXNvbj8/bmV3IEFib3J0RXJyb3IpfSxcIm9uQWJvcnRcIik7bj8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsaSksdGhpcy5vbihcImNsb3NlXCIsZnVuY3Rpb24oKXtuPy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIixpKSxuPy5hYm9ydGVkP3Mobi5yZWFzb24/P25ldyBBYm9ydEVycm9yKTpyKG51bGwpfSkub24oXCJlcnJvclwiLG5vb3ApLm9uKFwiZGF0YVwiLGZ1bmN0aW9uKEUpe3QtPUUubGVuZ3RoLHQ8PTAmJnRoaXMuZGVzdHJveSgpfSkucmVzdW1lKCl9KX19O28oRXQsXCJCb2R5UmVhZGFibGVcIik7bGV0IEJvZHlSZWFkYWJsZT1FdDtmdW5jdGlvbiBpc0xvY2tlZChlKXtyZXR1cm4gZVtrQm9keV0mJmVba0JvZHldLmxvY2tlZD09PSEwfHxlW2tDb25zdW1lXX1vKGlzTG9ja2VkLFwiaXNMb2NrZWRcIik7ZnVuY3Rpb24gaXNVbnVzYWJsZShlKXtyZXR1cm4gdXRpbCRjLmlzRGlzdHVyYmVkKGUpfHxpc0xvY2tlZChlKX1vKGlzVW51c2FibGUsXCJpc1VudXNhYmxlXCIpO2FzeW5jIGZ1bmN0aW9uIGNvbnN1bWUoZSxBKXtyZXR1cm4gYXNzZXJ0JDYoIWVba0NvbnN1bWVdKSxuZXcgUHJvbWlzZSgodCxuKT0+e2lmKGlzVW51c2FibGUoZSkpe2NvbnN0IHI9ZS5fcmVhZGFibGVTdGF0ZTtyLmRlc3Ryb3llZCYmci5jbG9zZUVtaXR0ZWQ9PT0hMT9lLm9uKFwiZXJyb3JcIixzPT57bihzKX0pLm9uKFwiY2xvc2VcIiwoKT0+e24obmV3IFR5cGVFcnJvcihcInVudXNhYmxlXCIpKX0pOm4oci5lcnJvcmVkPz9uZXcgVHlwZUVycm9yKFwidW51c2FibGVcIikpfWVsc2UgcXVldWVNaWNyb3Rhc2soKCk9PntlW2tDb25zdW1lXT17dHlwZTpBLHN0cmVhbTplLHJlc29sdmU6dCxyZWplY3Q6bixsZW5ndGg6MCxib2R5OltdfSxlLm9uKFwiZXJyb3JcIixmdW5jdGlvbihyKXtjb25zdW1lRmluaXNoKHRoaXNba0NvbnN1bWVdLHIpfSkub24oXCJjbG9zZVwiLGZ1bmN0aW9uKCl7dGhpc1trQ29uc3VtZV0uYm9keSE9PW51bGwmJmNvbnN1bWVGaW5pc2godGhpc1trQ29uc3VtZV0sbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IkMil9KSxjb25zdW1lU3RhcnQoZVtrQ29uc3VtZV0pfSl9KX1vKGNvbnN1bWUsXCJjb25zdW1lXCIpO2Z1bmN0aW9uIGNvbnN1bWVTdGFydChlKXtpZihlLmJvZHk9PT1udWxsKXJldHVybjtjb25zdHtfcmVhZGFibGVTdGF0ZTpBfT1lLnN0cmVhbTtpZihBLmJ1ZmZlckluZGV4KXtjb25zdCB0PUEuYnVmZmVySW5kZXgsbj1BLmJ1ZmZlci5sZW5ndGg7Zm9yKGxldCByPXQ7cjxuO3IrKyljb25zdW1lUHVzaChlLEEuYnVmZmVyW3JdKX1lbHNlIGZvcihjb25zdCB0IG9mIEEuYnVmZmVyKWNvbnN1bWVQdXNoKGUsdCk7Zm9yKEEuZW5kRW1pdHRlZD9jb25zdW1lRW5kKHRoaXNba0NvbnN1bWVdKTplLnN0cmVhbS5vbihcImVuZFwiLGZ1bmN0aW9uKCl7Y29uc3VtZUVuZCh0aGlzW2tDb25zdW1lXSl9KSxlLnN0cmVhbS5yZXN1bWUoKTtlLnN0cmVhbS5yZWFkKCkhPW51bGw7KTt9byhjb25zdW1lU3RhcnQsXCJjb25zdW1lU3RhcnRcIik7ZnVuY3Rpb24gY2h1bmtzRGVjb2RlJDEoZSxBKXtpZihlLmxlbmd0aD09PTB8fEE9PT0wKXJldHVyblwiXCI7Y29uc3QgdD1lLmxlbmd0aD09PTE/ZVswXTpCdWZmZXIuY29uY2F0KGUsQSksbj10Lmxlbmd0aCxyPW4+MiYmdFswXT09PTIzOSYmdFsxXT09PTE4NyYmdFsyXT09PTE5MT8zOjA7cmV0dXJuIHQudXRmOFNsaWNlKHIsbil9byhjaHVua3NEZWNvZGUkMSxcImNodW5rc0RlY29kZSQxXCIpO2Z1bmN0aW9uIGNvbnN1bWVFbmQoZSl7Y29uc3R7dHlwZTpBLGJvZHk6dCxyZXNvbHZlOm4sc3RyZWFtOnIsbGVuZ3RoOnN9PWU7dHJ5e2lmKEE9PT1cInRleHRcIiluKGNodW5rc0RlY29kZSQxKHQscykpO2Vsc2UgaWYoQT09PVwianNvblwiKW4oSlNPTi5wYXJzZShjaHVua3NEZWNvZGUkMSh0LHMpKSk7ZWxzZSBpZihBPT09XCJhcnJheUJ1ZmZlclwiKXtjb25zdCBpPW5ldyBVaW50OEFycmF5KHMpO2xldCBFPTA7Zm9yKGNvbnN0IFEgb2YgdClpLnNldChRLEUpLEUrPVEuYnl0ZUxlbmd0aDtuKGkuYnVmZmVyKX1lbHNlIEE9PT1cImJsb2JcIiYmbihuZXcgQmxvYih0LHt0eXBlOnJba0NvbnRlbnRUeXBlXX0pKTtjb25zdW1lRmluaXNoKGUpfWNhdGNoKGkpe3IuZGVzdHJveShpKX19byhjb25zdW1lRW5kLFwiY29uc3VtZUVuZFwiKTtmdW5jdGlvbiBjb25zdW1lUHVzaChlLEEpe2UubGVuZ3RoKz1BLmxlbmd0aCxlLmJvZHkucHVzaChBKX1vKGNvbnN1bWVQdXNoLFwiY29uc3VtZVB1c2hcIik7ZnVuY3Rpb24gY29uc3VtZUZpbmlzaChlLEEpe2UuYm9keSE9PW51bGwmJihBP2UucmVqZWN0KEEpOmUucmVzb2x2ZSgpLGUudHlwZT1udWxsLGUuc3RyZWFtPW51bGwsZS5yZXNvbHZlPW51bGwsZS5yZWplY3Q9bnVsbCxlLmxlbmd0aD0wLGUuYm9keT1udWxsKX1vKGNvbnN1bWVGaW5pc2gsXCJjb25zdW1lRmluaXNoXCIpO3ZhciByZWFkYWJsZT17UmVhZGFibGU6Qm9keVJlYWRhYmxlLGNodW5rc0RlY29kZTpjaHVua3NEZWNvZGUkMX07Y29uc3QgYXNzZXJ0JDU9cmVxdWlyZSQkMF9fZGVmYXVsdCx7UmVzcG9uc2VTdGF0dXNDb2RlRXJyb3J9PWVycm9ycyQxLHtjaHVua3NEZWNvZGV9PXJlYWRhYmxlLENIVU5LX0xJTUlUPTEyOCoxMDI0O2FzeW5jIGZ1bmN0aW9uIGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayQyKHtjYWxsYmFjazplLGJvZHk6QSxjb250ZW50VHlwZTp0LHN0YXR1c0NvZGU6bixzdGF0dXNNZXNzYWdlOnIsaGVhZGVyczpzfSl7YXNzZXJ0JDUoQSk7bGV0IGk9W10sRT0wO2ZvciBhd2FpdChjb25zdCBhIG9mIEEpaWYoaS5wdXNoKGEpLEUrPWEubGVuZ3RoLEU+Q0hVTktfTElNSVQpe2k9bnVsbDticmVha31jb25zdCBRPWBSZXNwb25zZSBzdGF0dXMgY29kZSAke259JHtyP2A6ICR7cn1gOlwiXCJ9YDtpZihuPT09MjA0fHwhdHx8IWkpe3F1ZXVlTWljcm90YXNrKCgpPT5lKG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihRLG4scykpKTtyZXR1cm59Y29uc3QgQz1FcnJvci5zdGFja1RyYWNlTGltaXQ7RXJyb3Iuc3RhY2tUcmFjZUxpbWl0PTA7bGV0IEk7dHJ5e2lzQ29udGVudFR5cGVBcHBsaWNhdGlvbkpzb24odCk/ST1KU09OLnBhcnNlKGNodW5rc0RlY29kZShpLEUpKTppc0NvbnRlbnRUeXBlVGV4dCh0KSYmKEk9Y2h1bmtzRGVjb2RlKGksRSkpfWNhdGNoe31maW5hbGx5e0Vycm9yLnN0YWNrVHJhY2VMaW1pdD1DfXF1ZXVlTWljcm90YXNrKCgpPT5lKG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihRLG4scyxJKSkpfW8oZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrJDIsXCJnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2skMlwiKTtjb25zdCBpc0NvbnRlbnRUeXBlQXBwbGljYXRpb25Kc29uPW8oZT0+ZS5sZW5ndGg+MTUmJmVbMTFdPT09XCIvXCImJmVbMF09PT1cImFcIiYmZVsxXT09PVwicFwiJiZlWzJdPT09XCJwXCImJmVbM109PT1cImxcIiYmZVs0XT09PVwiaVwiJiZlWzVdPT09XCJjXCImJmVbNl09PT1cImFcIiYmZVs3XT09PVwidFwiJiZlWzhdPT09XCJpXCImJmVbOV09PT1cIm9cIiYmZVsxMF09PT1cIm5cIiYmZVsxMl09PT1cImpcIiYmZVsxM109PT1cInNcIiYmZVsxNF09PT1cIm9cIiYmZVsxNV09PT1cIm5cIixcImlzQ29udGVudFR5cGVBcHBsaWNhdGlvbkpzb25cIiksaXNDb250ZW50VHlwZVRleHQ9byhlPT5lLmxlbmd0aD40JiZlWzRdPT09XCIvXCImJmVbMF09PT1cInRcIiYmZVsxXT09PVwiZVwiJiZlWzJdPT09XCJ4XCImJmVbM109PT1cInRcIixcImlzQ29udGVudFR5cGVUZXh0XCIpO3ZhciB1dGlsJGI9e2dldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjazpnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2skMixpc0NvbnRlbnRUeXBlQXBwbGljYXRpb25Kc29uLGlzQ29udGVudFR5cGVUZXh0fTtjb25zdHthZGRBYm9ydExpc3RlbmVyfT11dGlsJG0se1JlcXVlc3RBYm9ydGVkRXJyb3I6UmVxdWVzdEFib3J0ZWRFcnJvciQxfT1lcnJvcnMkMSxrTGlzdGVuZXI9U3ltYm9sKFwia0xpc3RlbmVyXCIpLGtTaWduYWw9U3ltYm9sKFwia1NpZ25hbFwiKTtmdW5jdGlvbiBhYm9ydChlKXtlLmFib3J0P2UuYWJvcnQoZVtrU2lnbmFsXT8ucmVhc29uKTplLnJlYXNvbj1lW2tTaWduYWxdPy5yZWFzb24/P25ldyBSZXF1ZXN0QWJvcnRlZEVycm9yJDEscmVtb3ZlU2lnbmFsJDUoZSl9byhhYm9ydCxcImFib3J0XCIpO2Z1bmN0aW9uIGFkZFNpZ25hbCQ1KGUsQSl7aWYoZS5yZWFzb249bnVsbCxlW2tTaWduYWxdPW51bGwsZVtrTGlzdGVuZXJdPW51bGwsISFBKXtpZihBLmFib3J0ZWQpe2Fib3J0KGUpO3JldHVybn1lW2tTaWduYWxdPUEsZVtrTGlzdGVuZXJdPSgpPT57YWJvcnQoZSl9LGFkZEFib3J0TGlzdGVuZXIoZVtrU2lnbmFsXSxlW2tMaXN0ZW5lcl0pfX1vKGFkZFNpZ25hbCQ1LFwiYWRkU2lnbmFsJDVcIik7ZnVuY3Rpb24gcmVtb3ZlU2lnbmFsJDUoZSl7ZVtrU2lnbmFsXSYmKFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiaW4gZVtrU2lnbmFsXT9lW2tTaWduYWxdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLGVba0xpc3RlbmVyXSk6ZVtrU2lnbmFsXS5yZW1vdmVMaXN0ZW5lcihcImFib3J0XCIsZVtrTGlzdGVuZXJdKSxlW2tTaWduYWxdPW51bGwsZVtrTGlzdGVuZXJdPW51bGwpfW8ocmVtb3ZlU2lnbmFsJDUsXCJyZW1vdmVTaWduYWwkNVwiKTt2YXIgYWJvcnRTaWduYWw9e2FkZFNpZ25hbDphZGRTaWduYWwkNSxyZW1vdmVTaWduYWw6cmVtb3ZlU2lnbmFsJDV9O2NvbnN0IGFzc2VydCQ0PXJlcXVpcmUkJDBfX2RlZmF1bHQse1JlYWRhYmxlOlJlYWRhYmxlJDF9PXJlYWRhYmxlLHtJbnZhbGlkQXJndW1lbnRFcnJvcjpJbnZhbGlkQXJndW1lbnRFcnJvciQ5fT1lcnJvcnMkMSx1dGlsJGE9dXRpbCRtLHtnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2s6Z2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrJDF9PXV0aWwkYix7QXN5bmNSZXNvdXJjZTpBc3luY1Jlc291cmNlJDR9PXJlcXVpcmUkJDVfX2RlZmF1bHQkMSx7YWRkU2lnbmFsOmFkZFNpZ25hbCQ0LHJlbW92ZVNpZ25hbDpyZW1vdmVTaWduYWwkNH09YWJvcnRTaWduYWwsZ3Q9Y2xhc3MgZ3QgZXh0ZW5kcyBBc3luY1Jlc291cmNlJDR7Y29uc3RydWN0b3IoQSx0KXtpZighQXx8dHlwZW9mIEEhPVwib2JqZWN0XCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJDkoXCJpbnZhbGlkIG9wdHNcIik7Y29uc3R7c2lnbmFsOm4sbWV0aG9kOnIsb3BhcXVlOnMsYm9keTppLG9uSW5mbzpFLHJlc3BvbnNlSGVhZGVyczpRLHRocm93T25FcnJvcjpDLGhpZ2hXYXRlck1hcms6SX09QTt0cnl7aWYodHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkOShcImludmFsaWQgY2FsbGJhY2tcIik7aWYoSSYmKHR5cGVvZiBJIT1cIm51bWJlclwifHxJPDApKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQ5KFwiaW52YWxpZCBoaWdoV2F0ZXJNYXJrXCIpO2lmKG4mJnR5cGVvZiBuLm9uIT1cImZ1bmN0aW9uXCImJnR5cGVvZiBuLmFkZEV2ZW50TGlzdGVuZXIhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkOShcInNpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldFwiKTtpZihyPT09XCJDT05ORUNUXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJDkoXCJpbnZhbGlkIG1ldGhvZFwiKTtpZihFJiZ0eXBlb2YgRSE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQ5KFwiaW52YWxpZCBvbkluZm8gY2FsbGJhY2tcIik7c3VwZXIoXCJVTkRJQ0lfUkVRVUVTVFwiKX1jYXRjaChhKXt0aHJvdyB1dGlsJGEuaXNTdHJlYW0oaSkmJnV0aWwkYS5kZXN0cm95KGkub24oXCJlcnJvclwiLHV0aWwkYS5ub3ApLGEpLGF9dGhpcy5yZXNwb25zZUhlYWRlcnM9UXx8bnVsbCx0aGlzLm9wYXF1ZT1zfHxudWxsLHRoaXMuY2FsbGJhY2s9dCx0aGlzLnJlcz1udWxsLHRoaXMuYWJvcnQ9bnVsbCx0aGlzLmJvZHk9aSx0aGlzLnRyYWlsZXJzPXt9LHRoaXMuY29udGV4dD1udWxsLHRoaXMub25JbmZvPUV8fG51bGwsdGhpcy50aHJvd09uRXJyb3I9Qyx0aGlzLmhpZ2hXYXRlck1hcms9SSx1dGlsJGEuaXNTdHJlYW0oaSkmJmkub24oXCJlcnJvclwiLGE9Pnt0aGlzLm9uRXJyb3IoYSl9KSxhZGRTaWduYWwkNCh0aGlzLG4pfW9uQ29ubmVjdChBLHQpe2lmKHRoaXMucmVhc29uKXtBKHRoaXMucmVhc29uKTtyZXR1cm59YXNzZXJ0JDQodGhpcy5jYWxsYmFjayksdGhpcy5hYm9ydD1BLHRoaXMuY29udGV4dD10fW9uSGVhZGVycyhBLHQsbixyKXtjb25zdHtjYWxsYmFjazpzLG9wYXF1ZTppLGFib3J0OkUsY29udGV4dDpRLHJlc3BvbnNlSGVhZGVyczpDLGhpZ2hXYXRlck1hcms6SX09dGhpcyxhPUM9PT1cInJhd1wiP3V0aWwkYS5wYXJzZVJhd0hlYWRlcnModCk6dXRpbCRhLnBhcnNlSGVhZGVycyh0KTtpZihBPDIwMCl7dGhpcy5vbkluZm8mJnRoaXMub25JbmZvKHtzdGF0dXNDb2RlOkEsaGVhZGVyczphfSk7cmV0dXJufWNvbnN0IGY9Qz09PVwicmF3XCI/dXRpbCRhLnBhcnNlSGVhZGVycyh0KTphLGg9ZltcImNvbnRlbnQtdHlwZVwiXSxMPWZbXCJjb250ZW50LWxlbmd0aFwiXSxjPW5ldyBSZWFkYWJsZSQxKHtyZXN1bWU6bixhYm9ydDpFLGNvbnRlbnRUeXBlOmgsY29udGVudExlbmd0aDpMLGhpZ2hXYXRlck1hcms6SX0pO3RoaXMuY2FsbGJhY2s9bnVsbCx0aGlzLnJlcz1jLHMhPT1udWxsJiYodGhpcy50aHJvd09uRXJyb3ImJkE+PTQwMD90aGlzLnJ1bkluQXN5bmNTY29wZShnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2skMSxudWxsLHtjYWxsYmFjazpzLGJvZHk6Yyxjb250ZW50VHlwZTpoLHN0YXR1c0NvZGU6QSxzdGF0dXNNZXNzYWdlOnIsaGVhZGVyczphfSk6dGhpcy5ydW5JbkFzeW5jU2NvcGUocyxudWxsLG51bGwse3N0YXR1c0NvZGU6QSxoZWFkZXJzOmEsdHJhaWxlcnM6dGhpcy50cmFpbGVycyxvcGFxdWU6aSxib2R5OmMsY29udGV4dDpRfSkpfW9uRGF0YShBKXtjb25zdHtyZXM6dH09dGhpcztyZXR1cm4gdC5wdXNoKEEpfW9uQ29tcGxldGUoQSl7Y29uc3R7cmVzOnR9PXRoaXM7cmVtb3ZlU2lnbmFsJDQodGhpcyksdXRpbCRhLnBhcnNlSGVhZGVycyhBLHRoaXMudHJhaWxlcnMpLHQucHVzaChudWxsKX1vbkVycm9yKEEpe2NvbnN0e3Jlczp0LGNhbGxiYWNrOm4sYm9keTpyLG9wYXF1ZTpzfT10aGlzO3JlbW92ZVNpZ25hbCQ0KHRoaXMpLG4mJih0aGlzLmNhbGxiYWNrPW51bGwscXVldWVNaWNyb3Rhc2soKCk9Pnt0aGlzLnJ1bkluQXN5bmNTY29wZShuLG51bGwsQSx7b3BhcXVlOnN9KX0pKSx0JiYodGhpcy5yZXM9bnVsbCxxdWV1ZU1pY3JvdGFzaygoKT0+e3V0aWwkYS5kZXN0cm95KHQsQSl9KSksciYmKHRoaXMuYm9keT1udWxsLHV0aWwkYS5kZXN0cm95KHIsQSkpfX07byhndCxcIlJlcXVlc3RIYW5kbGVyXCIpO2xldCBSZXF1ZXN0SGFuZGxlcj1ndDtmdW5jdGlvbiByZXF1ZXN0JDEoZSxBKXtpZihBPT09dm9pZCAwKXJldHVybiBuZXcgUHJvbWlzZSgodCxuKT0+e3JlcXVlc3QkMS5jYWxsKHRoaXMsZSwocixzKT0+cj9uKHIpOnQocykpfSk7dHJ5e3RoaXMuZGlzcGF0Y2goZSxuZXcgUmVxdWVzdEhhbmRsZXIoZSxBKSl9Y2F0Y2godCl7aWYodHlwZW9mIEEhPVwiZnVuY3Rpb25cIil0aHJvdyB0O2NvbnN0IG49ZT8ub3BhcXVlO3F1ZXVlTWljcm90YXNrKCgpPT5BKHQse29wYXF1ZTpufSkpfX1vKHJlcXVlc3QkMSxcInJlcXVlc3QkMVwiKSxhcGlSZXF1ZXN0LmV4cG9ydHM9cmVxdWVzdCQxLGFwaVJlcXVlc3QuZXhwb3J0cy5SZXF1ZXN0SGFuZGxlcj1SZXF1ZXN0SGFuZGxlcjt2YXIgYXBpUmVxdWVzdEV4cG9ydHM9YXBpUmVxdWVzdC5leHBvcnRzO2NvbnN0IGFzc2VydCQzPXJlcXVpcmUkJDBfX2RlZmF1bHQse2ZpbmlzaGVkLFBhc3NUaHJvdWdoOlBhc3NUaHJvdWdoJDF9PVN0cmVhbV9fZGVmYXVsdCx7SW52YWxpZEFyZ3VtZW50RXJyb3I6SW52YWxpZEFyZ3VtZW50RXJyb3IkOCxJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcjpJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciQxfT1lcnJvcnMkMSx1dGlsJDk9dXRpbCRtLHtnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2t9PXV0aWwkYix7QXN5bmNSZXNvdXJjZTpBc3luY1Jlc291cmNlJDN9PXJlcXVpcmUkJDVfX2RlZmF1bHQkMSx7YWRkU2lnbmFsOmFkZFNpZ25hbCQzLHJlbW92ZVNpZ25hbDpyZW1vdmVTaWduYWwkM309YWJvcnRTaWduYWwsQnQ9Y2xhc3MgQnQgZXh0ZW5kcyBBc3luY1Jlc291cmNlJDN7Y29uc3RydWN0b3IoQSx0LG4pe2lmKCFBfHx0eXBlb2YgQSE9XCJvYmplY3RcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkOChcImludmFsaWQgb3B0c1wiKTtjb25zdHtzaWduYWw6cixtZXRob2Q6cyxvcGFxdWU6aSxib2R5OkUsb25JbmZvOlEscmVzcG9uc2VIZWFkZXJzOkMsdGhyb3dPbkVycm9yOkl9PUE7dHJ5e2lmKHR5cGVvZiBuIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJDgoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO2lmKHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJDgoXCJpbnZhbGlkIGZhY3RvcnlcIik7aWYociYmdHlwZW9mIHIub24hPVwiZnVuY3Rpb25cIiYmdHlwZW9mIHIuYWRkRXZlbnRMaXN0ZW5lciE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQ4KFwic2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0XCIpO2lmKHM9PT1cIkNPTk5FQ1RcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkOChcImludmFsaWQgbWV0aG9kXCIpO2lmKFEmJnR5cGVvZiBRIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJDgoXCJpbnZhbGlkIG9uSW5mbyBjYWxsYmFja1wiKTtzdXBlcihcIlVORElDSV9TVFJFQU1cIil9Y2F0Y2goYSl7dGhyb3cgdXRpbCQ5LmlzU3RyZWFtKEUpJiZ1dGlsJDkuZGVzdHJveShFLm9uKFwiZXJyb3JcIix1dGlsJDkubm9wKSxhKSxhfXRoaXMucmVzcG9uc2VIZWFkZXJzPUN8fG51bGwsdGhpcy5vcGFxdWU9aXx8bnVsbCx0aGlzLmZhY3Rvcnk9dCx0aGlzLmNhbGxiYWNrPW4sdGhpcy5yZXM9bnVsbCx0aGlzLmFib3J0PW51bGwsdGhpcy5jb250ZXh0PW51bGwsdGhpcy50cmFpbGVycz1udWxsLHRoaXMuYm9keT1FLHRoaXMub25JbmZvPVF8fG51bGwsdGhpcy50aHJvd09uRXJyb3I9SXx8ITEsdXRpbCQ5LmlzU3RyZWFtKEUpJiZFLm9uKFwiZXJyb3JcIixhPT57dGhpcy5vbkVycm9yKGEpfSksYWRkU2lnbmFsJDModGhpcyxyKX1vbkNvbm5lY3QoQSx0KXtpZih0aGlzLnJlYXNvbil7QSh0aGlzLnJlYXNvbik7cmV0dXJufWFzc2VydCQzKHRoaXMuY2FsbGJhY2spLHRoaXMuYWJvcnQ9QSx0aGlzLmNvbnRleHQ9dH1vbkhlYWRlcnMoQSx0LG4scil7Y29uc3R7ZmFjdG9yeTpzLG9wYXF1ZTppLGNvbnRleHQ6RSxjYWxsYmFjazpRLHJlc3BvbnNlSGVhZGVyczpDfT10aGlzLEk9Qz09PVwicmF3XCI/dXRpbCQ5LnBhcnNlUmF3SGVhZGVycyh0KTp1dGlsJDkucGFyc2VIZWFkZXJzKHQpO2lmKEE8MjAwKXt0aGlzLm9uSW5mbyYmdGhpcy5vbkluZm8oe3N0YXR1c0NvZGU6QSxoZWFkZXJzOkl9KTtyZXR1cm59dGhpcy5mYWN0b3J5PW51bGw7bGV0IGE7aWYodGhpcy50aHJvd09uRXJyb3ImJkE+PTQwMCl7Y29uc3QgTD0oQz09PVwicmF3XCI/dXRpbCQ5LnBhcnNlSGVhZGVycyh0KTpJKVtcImNvbnRlbnQtdHlwZVwiXTthPW5ldyBQYXNzVGhyb3VnaCQxLHRoaXMuY2FsbGJhY2s9bnVsbCx0aGlzLnJ1bkluQXN5bmNTY29wZShnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2ssbnVsbCx7Y2FsbGJhY2s6USxib2R5OmEsY29udGVudFR5cGU6TCxzdGF0dXNDb2RlOkEsc3RhdHVzTWVzc2FnZTpyLGhlYWRlcnM6SX0pfWVsc2V7aWYocz09PW51bGwpcmV0dXJuO2lmKGE9dGhpcy5ydW5JbkFzeW5jU2NvcGUocyxudWxsLHtzdGF0dXNDb2RlOkEsaGVhZGVyczpJLG9wYXF1ZTppLGNvbnRleHQ6RX0pLCFhfHx0eXBlb2YgYS53cml0ZSE9XCJmdW5jdGlvblwifHx0eXBlb2YgYS5lbmQhPVwiZnVuY3Rpb25cInx8dHlwZW9mIGEub24hPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgSW52YWxpZFJldHVyblZhbHVlRXJyb3IkMShcImV4cGVjdGVkIFdyaXRhYmxlXCIpO2ZpbmlzaGVkKGEse3JlYWRhYmxlOiExfSxoPT57Y29uc3R7Y2FsbGJhY2s6TCxyZXM6YyxvcGFxdWU6bCx0cmFpbGVyczpTLGFib3J0Omt9PXRoaXM7dGhpcy5yZXM9bnVsbCwoaHx8IWMucmVhZGFibGUpJiZ1dGlsJDkuZGVzdHJveShjLGgpLHRoaXMuY2FsbGJhY2s9bnVsbCx0aGlzLnJ1bkluQXN5bmNTY29wZShMLG51bGwsaHx8bnVsbCx7b3BhcXVlOmwsdHJhaWxlcnM6U30pLGgmJmsoKX0pfXJldHVybiBhLm9uKFwiZHJhaW5cIixuKSx0aGlzLnJlcz1hLChhLndyaXRhYmxlTmVlZERyYWluIT09dm9pZCAwP2Eud3JpdGFibGVOZWVkRHJhaW46YS5fd3JpdGFibGVTdGF0ZT8ubmVlZERyYWluKSE9PSEwfW9uRGF0YShBKXtjb25zdHtyZXM6dH09dGhpcztyZXR1cm4gdD90LndyaXRlKEEpOiEwfW9uQ29tcGxldGUoQSl7Y29uc3R7cmVzOnR9PXRoaXM7cmVtb3ZlU2lnbmFsJDModGhpcyksdCYmKHRoaXMudHJhaWxlcnM9dXRpbCQ5LnBhcnNlSGVhZGVycyhBKSx0LmVuZCgpKX1vbkVycm9yKEEpe2NvbnN0e3Jlczp0LGNhbGxiYWNrOm4sb3BhcXVlOnIsYm9keTpzfT10aGlzO3JlbW92ZVNpZ25hbCQzKHRoaXMpLHRoaXMuZmFjdG9yeT1udWxsLHQ/KHRoaXMucmVzPW51bGwsdXRpbCQ5LmRlc3Ryb3kodCxBKSk6biYmKHRoaXMuY2FsbGJhY2s9bnVsbCxxdWV1ZU1pY3JvdGFzaygoKT0+e3RoaXMucnVuSW5Bc3luY1Njb3BlKG4sbnVsbCxBLHtvcGFxdWU6cn0pfSkpLHMmJih0aGlzLmJvZHk9bnVsbCx1dGlsJDkuZGVzdHJveShzLEEpKX19O28oQnQsXCJTdHJlYW1IYW5kbGVyXCIpO2xldCBTdHJlYW1IYW5kbGVyPUJ0O2Z1bmN0aW9uIHN0cmVhbShlLEEsdCl7aWYodD09PXZvaWQgMClyZXR1cm4gbmV3IFByb21pc2UoKG4scik9PntzdHJlYW0uY2FsbCh0aGlzLGUsQSwocyxpKT0+cz9yKHMpOm4oaSkpfSk7dHJ5e3RoaXMuZGlzcGF0Y2goZSxuZXcgU3RyZWFtSGFuZGxlcihlLEEsdCkpfWNhdGNoKG4pe2lmKHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgbjtjb25zdCByPWU/Lm9wYXF1ZTtxdWV1ZU1pY3JvdGFzaygoKT0+dChuLHtvcGFxdWU6cn0pKX19byhzdHJlYW0sXCJzdHJlYW1cIik7dmFyIGFwaVN0cmVhbT1zdHJlYW07Y29uc3R7UmVhZGFibGUsRHVwbGV4LFBhc3NUaHJvdWdofT1TdHJlYW1fX2RlZmF1bHQse0ludmFsaWRBcmd1bWVudEVycm9yOkludmFsaWRBcmd1bWVudEVycm9yJDcsSW52YWxpZFJldHVyblZhbHVlRXJyb3IsUmVxdWVzdEFib3J0ZWRFcnJvcn09ZXJyb3JzJDEsdXRpbCQ4PXV0aWwkbSx7QXN5bmNSZXNvdXJjZTpBc3luY1Jlc291cmNlJDJ9PXJlcXVpcmUkJDVfX2RlZmF1bHQkMSx7YWRkU2lnbmFsOmFkZFNpZ25hbCQyLHJlbW92ZVNpZ25hbDpyZW1vdmVTaWduYWwkMn09YWJvcnRTaWduYWwsYXNzZXJ0JDI9cmVxdWlyZSQkMF9fZGVmYXVsdCxrUmVzdW1lPVN5bWJvbChcInJlc3VtZVwiKSxDdD1jbGFzcyBDdCBleHRlbmRzIFJlYWRhYmxle2NvbnN0cnVjdG9yKCl7c3VwZXIoe2F1dG9EZXN0cm95OiEwfSksdGhpc1trUmVzdW1lXT1udWxsfV9yZWFkKCl7Y29uc3R7W2tSZXN1bWVdOkF9PXRoaXM7QSYmKHRoaXNba1Jlc3VtZV09bnVsbCxBKCkpfV9kZXN0cm95KEEsdCl7dGhpcy5fcmVhZCgpLHQoQSl9fTtvKEN0LFwiUGlwZWxpbmVSZXF1ZXN0XCIpO2xldCBQaXBlbGluZVJlcXVlc3Q9Q3Q7Y29uc3QgSXQ9Y2xhc3MgSXQgZXh0ZW5kcyBSZWFkYWJsZXtjb25zdHJ1Y3RvcihBKXtzdXBlcih7YXV0b0Rlc3Ryb3k6ITB9KSx0aGlzW2tSZXN1bWVdPUF9X3JlYWQoKXt0aGlzW2tSZXN1bWVdKCl9X2Rlc3Ryb3koQSx0KXshQSYmIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCYmKEE9bmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IpLHQoQSl9fTtvKEl0LFwiUGlwZWxpbmVSZXNwb25zZVwiKTtsZXQgUGlwZWxpbmVSZXNwb25zZT1JdDtjb25zdCBhdD1jbGFzcyBhdCBleHRlbmRzIEFzeW5jUmVzb3VyY2UkMntjb25zdHJ1Y3RvcihBLHQpe2lmKCFBfHx0eXBlb2YgQSE9XCJvYmplY3RcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkNyhcImludmFsaWQgb3B0c1wiKTtpZih0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQ3KFwiaW52YWxpZCBoYW5kbGVyXCIpO2NvbnN0e3NpZ25hbDpuLG1ldGhvZDpyLG9wYXF1ZTpzLG9uSW5mbzppLHJlc3BvbnNlSGVhZGVyczpFfT1BO2lmKG4mJnR5cGVvZiBuLm9uIT1cImZ1bmN0aW9uXCImJnR5cGVvZiBuLmFkZEV2ZW50TGlzdGVuZXIhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkNyhcInNpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldFwiKTtpZihyPT09XCJDT05ORUNUXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJDcoXCJpbnZhbGlkIG1ldGhvZFwiKTtpZihpJiZ0eXBlb2YgaSE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQ3KFwiaW52YWxpZCBvbkluZm8gY2FsbGJhY2tcIik7c3VwZXIoXCJVTkRJQ0lfUElQRUxJTkVcIiksdGhpcy5vcGFxdWU9c3x8bnVsbCx0aGlzLnJlc3BvbnNlSGVhZGVycz1FfHxudWxsLHRoaXMuaGFuZGxlcj10LHRoaXMuYWJvcnQ9bnVsbCx0aGlzLmNvbnRleHQ9bnVsbCx0aGlzLm9uSW5mbz1pfHxudWxsLHRoaXMucmVxPW5ldyBQaXBlbGluZVJlcXVlc3QoKS5vbihcImVycm9yXCIsdXRpbCQ4Lm5vcCksdGhpcy5yZXQ9bmV3IER1cGxleCh7cmVhZGFibGVPYmplY3RNb2RlOkEub2JqZWN0TW9kZSxhdXRvRGVzdHJveTohMCxyZWFkOigpPT57Y29uc3R7Ym9keTpRfT10aGlzO1E/LnJlc3VtZSYmUS5yZXN1bWUoKX0sd3JpdGU6KFEsQyxJKT0+e2NvbnN0e3JlcTphfT10aGlzO2EucHVzaChRLEMpfHxhLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZD9JKCk6YVtrUmVzdW1lXT1JfSxkZXN0cm95OihRLEMpPT57Y29uc3R7Ym9keTpJLHJlcTphLHJlczpmLHJldDpoLGFib3J0Okx9PXRoaXM7IVEmJiFoLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQmJihRPW5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKSxMJiZRJiZMKCksdXRpbCQ4LmRlc3Ryb3koSSxRKSx1dGlsJDguZGVzdHJveShhLFEpLHV0aWwkOC5kZXN0cm95KGYsUSkscmVtb3ZlU2lnbmFsJDIodGhpcyksQyhRKX19KS5vbihcInByZWZpbmlzaFwiLCgpPT57Y29uc3R7cmVxOlF9PXRoaXM7US5wdXNoKG51bGwpfSksdGhpcy5yZXM9bnVsbCxhZGRTaWduYWwkMih0aGlzLG4pfW9uQ29ubmVjdChBLHQpe2NvbnN0e3JldDpuLHJlczpyfT10aGlzO2lmKHRoaXMucmVhc29uKXtBKHRoaXMucmVhc29uKTtyZXR1cm59YXNzZXJ0JDIoIXIsXCJwaXBlbGluZSBjYW5ub3QgYmUgcmV0cmllZFwiKSxhc3NlcnQkMighbi5kZXN0cm95ZWQpLHRoaXMuYWJvcnQ9QSx0aGlzLmNvbnRleHQ9dH1vbkhlYWRlcnMoQSx0LG4pe2NvbnN0e29wYXF1ZTpyLGhhbmRsZXI6cyxjb250ZXh0Oml9PXRoaXM7aWYoQTwyMDApe2lmKHRoaXMub25JbmZvKXtjb25zdCBRPXRoaXMucmVzcG9uc2VIZWFkZXJzPT09XCJyYXdcIj91dGlsJDgucGFyc2VSYXdIZWFkZXJzKHQpOnV0aWwkOC5wYXJzZUhlYWRlcnModCk7dGhpcy5vbkluZm8oe3N0YXR1c0NvZGU6QSxoZWFkZXJzOlF9KX1yZXR1cm59dGhpcy5yZXM9bmV3IFBpcGVsaW5lUmVzcG9uc2Uobik7bGV0IEU7dHJ5e3RoaXMuaGFuZGxlcj1udWxsO2NvbnN0IFE9dGhpcy5yZXNwb25zZUhlYWRlcnM9PT1cInJhd1wiP3V0aWwkOC5wYXJzZVJhd0hlYWRlcnModCk6dXRpbCQ4LnBhcnNlSGVhZGVycyh0KTtFPXRoaXMucnVuSW5Bc3luY1Njb3BlKHMsbnVsbCx7c3RhdHVzQ29kZTpBLGhlYWRlcnM6USxvcGFxdWU6cixib2R5OnRoaXMucmVzLGNvbnRleHQ6aX0pfWNhdGNoKFEpe3Rocm93IHRoaXMucmVzLm9uKFwiZXJyb3JcIix1dGlsJDgubm9wKSxRfWlmKCFFfHx0eXBlb2YgRS5vbiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcihcImV4cGVjdGVkIFJlYWRhYmxlXCIpO0Uub24oXCJkYXRhXCIsUT0+e2NvbnN0e3JldDpDLGJvZHk6SX09dGhpczshQy5wdXNoKFEpJiZJLnBhdXNlJiZJLnBhdXNlKCl9KS5vbihcImVycm9yXCIsUT0+e2NvbnN0e3JldDpDfT10aGlzO3V0aWwkOC5kZXN0cm95KEMsUSl9KS5vbihcImVuZFwiLCgpPT57Y29uc3R7cmV0OlF9PXRoaXM7US5wdXNoKG51bGwpfSkub24oXCJjbG9zZVwiLCgpPT57Y29uc3R7cmV0OlF9PXRoaXM7US5fcmVhZGFibGVTdGF0ZS5lbmRlZHx8dXRpbCQ4LmRlc3Ryb3koUSxuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcil9KSx0aGlzLmJvZHk9RX1vbkRhdGEoQSl7Y29uc3R7cmVzOnR9PXRoaXM7cmV0dXJuIHQucHVzaChBKX1vbkNvbXBsZXRlKEEpe2NvbnN0e3Jlczp0fT10aGlzO3QucHVzaChudWxsKX1vbkVycm9yKEEpe2NvbnN0e3JldDp0fT10aGlzO3RoaXMuaGFuZGxlcj1udWxsLHV0aWwkOC5kZXN0cm95KHQsQSl9fTtvKGF0LFwiUGlwZWxpbmVIYW5kbGVyXCIpO2xldCBQaXBlbGluZUhhbmRsZXI9YXQ7ZnVuY3Rpb24gcGlwZWxpbmUoZSxBKXt0cnl7Y29uc3QgdD1uZXcgUGlwZWxpbmVIYW5kbGVyKGUsQSk7cmV0dXJuIHRoaXMuZGlzcGF0Y2goey4uLmUsYm9keTp0LnJlcX0sdCksdC5yZXR9Y2F0Y2godCl7cmV0dXJuIG5ldyBQYXNzVGhyb3VnaCgpLmRlc3Ryb3kodCl9fW8ocGlwZWxpbmUsXCJwaXBlbGluZVwiKTt2YXIgYXBpUGlwZWxpbmU9cGlwZWxpbmU7Y29uc3R7SW52YWxpZEFyZ3VtZW50RXJyb3I6SW52YWxpZEFyZ3VtZW50RXJyb3IkNixTb2NrZXRFcnJvcjpTb2NrZXRFcnJvciQxfT1lcnJvcnMkMSx7QXN5bmNSZXNvdXJjZTpBc3luY1Jlc291cmNlJDF9PXJlcXVpcmUkJDVfX2RlZmF1bHQkMSx1dGlsJDc9dXRpbCRtLHthZGRTaWduYWw6YWRkU2lnbmFsJDEscmVtb3ZlU2lnbmFsOnJlbW92ZVNpZ25hbCQxfT1hYm9ydFNpZ25hbCxhc3NlcnQkMT1yZXF1aXJlJCQwX19kZWZhdWx0LGN0PWNsYXNzIGN0IGV4dGVuZHMgQXN5bmNSZXNvdXJjZSQxe2NvbnN0cnVjdG9yKEEsdCl7aWYoIUF8fHR5cGVvZiBBIT1cIm9iamVjdFwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQ2KFwiaW52YWxpZCBvcHRzXCIpO2lmKHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJDYoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO2NvbnN0e3NpZ25hbDpuLG9wYXF1ZTpyLHJlc3BvbnNlSGVhZGVyczpzfT1BO2lmKG4mJnR5cGVvZiBuLm9uIT1cImZ1bmN0aW9uXCImJnR5cGVvZiBuLmFkZEV2ZW50TGlzdGVuZXIhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkNihcInNpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldFwiKTtzdXBlcihcIlVORElDSV9VUEdSQURFXCIpLHRoaXMucmVzcG9uc2VIZWFkZXJzPXN8fG51bGwsdGhpcy5vcGFxdWU9cnx8bnVsbCx0aGlzLmNhbGxiYWNrPXQsdGhpcy5hYm9ydD1udWxsLHRoaXMuY29udGV4dD1udWxsLGFkZFNpZ25hbCQxKHRoaXMsbil9b25Db25uZWN0KEEsdCl7aWYodGhpcy5yZWFzb24pe0EodGhpcy5yZWFzb24pO3JldHVybn1hc3NlcnQkMSh0aGlzLmNhbGxiYWNrKSx0aGlzLmFib3J0PUEsdGhpcy5jb250ZXh0PW51bGx9b25IZWFkZXJzKCl7dGhyb3cgbmV3IFNvY2tldEVycm9yJDEoXCJiYWQgdXBncmFkZVwiLG51bGwpfW9uVXBncmFkZShBLHQsbil7Y29uc3R7Y2FsbGJhY2s6cixvcGFxdWU6cyxjb250ZXh0Oml9PXRoaXM7YXNzZXJ0JDEuc3RyaWN0RXF1YWwoQSwxMDEpLHJlbW92ZVNpZ25hbCQxKHRoaXMpLHRoaXMuY2FsbGJhY2s9bnVsbDtjb25zdCBFPXRoaXMucmVzcG9uc2VIZWFkZXJzPT09XCJyYXdcIj91dGlsJDcucGFyc2VSYXdIZWFkZXJzKHQpOnV0aWwkNy5wYXJzZUhlYWRlcnModCk7dGhpcy5ydW5JbkFzeW5jU2NvcGUocixudWxsLG51bGwse2hlYWRlcnM6RSxzb2NrZXQ6bixvcGFxdWU6cyxjb250ZXh0Oml9KX1vbkVycm9yKEEpe2NvbnN0e2NhbGxiYWNrOnQsb3BhcXVlOm59PXRoaXM7cmVtb3ZlU2lnbmFsJDEodGhpcyksdCYmKHRoaXMuY2FsbGJhY2s9bnVsbCxxdWV1ZU1pY3JvdGFzaygoKT0+e3RoaXMucnVuSW5Bc3luY1Njb3BlKHQsbnVsbCxBLHtvcGFxdWU6bn0pfSkpfX07byhjdCxcIlVwZ3JhZGVIYW5kbGVyXCIpO2xldCBVcGdyYWRlSGFuZGxlcj1jdDtmdW5jdGlvbiB1cGdyYWRlKGUsQSl7aWYoQT09PXZvaWQgMClyZXR1cm4gbmV3IFByb21pc2UoKHQsbik9Pnt1cGdyYWRlLmNhbGwodGhpcyxlLChyLHMpPT5yP24ocik6dChzKSl9KTt0cnl7Y29uc3QgdD1uZXcgVXBncmFkZUhhbmRsZXIoZSxBKTt0aGlzLmRpc3BhdGNoKHsuLi5lLG1ldGhvZDplLm1ldGhvZHx8XCJHRVRcIix1cGdyYWRlOmUucHJvdG9jb2x8fFwiV2Vic29ja2V0XCJ9LHQpfWNhdGNoKHQpe2lmKHR5cGVvZiBBIT1cImZ1bmN0aW9uXCIpdGhyb3cgdDtjb25zdCBuPWU/Lm9wYXF1ZTtxdWV1ZU1pY3JvdGFzaygoKT0+QSh0LHtvcGFxdWU6bn0pKX19byh1cGdyYWRlLFwidXBncmFkZVwiKTt2YXIgYXBpVXBncmFkZT11cGdyYWRlO2NvbnN0IGFzc2VydD1yZXF1aXJlJCQwX19kZWZhdWx0LHtBc3luY1Jlc291cmNlfT1yZXF1aXJlJCQ1X19kZWZhdWx0JDEse0ludmFsaWRBcmd1bWVudEVycm9yOkludmFsaWRBcmd1bWVudEVycm9yJDUsU29ja2V0RXJyb3J9PWVycm9ycyQxLHV0aWwkNj11dGlsJG0se2FkZFNpZ25hbCxyZW1vdmVTaWduYWx9PWFib3J0U2lnbmFsLGh0PWNsYXNzIGh0IGV4dGVuZHMgQXN5bmNSZXNvdXJjZXtjb25zdHJ1Y3RvcihBLHQpe2lmKCFBfHx0eXBlb2YgQSE9XCJvYmplY3RcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkNShcImludmFsaWQgb3B0c1wiKTtpZih0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQ1KFwiaW52YWxpZCBjYWxsYmFja1wiKTtjb25zdHtzaWduYWw6bixvcGFxdWU6cixyZXNwb25zZUhlYWRlcnM6c309QTtpZihuJiZ0eXBlb2Ygbi5vbiE9XCJmdW5jdGlvblwiJiZ0eXBlb2Ygbi5hZGRFdmVudExpc3RlbmVyIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJDUoXCJzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXRcIik7c3VwZXIoXCJVTkRJQ0lfQ09OTkVDVFwiKSx0aGlzLm9wYXF1ZT1yfHxudWxsLHRoaXMucmVzcG9uc2VIZWFkZXJzPXN8fG51bGwsdGhpcy5jYWxsYmFjaz10LHRoaXMuYWJvcnQ9bnVsbCxhZGRTaWduYWwodGhpcyxuKX1vbkNvbm5lY3QoQSx0KXtpZih0aGlzLnJlYXNvbil7QSh0aGlzLnJlYXNvbik7cmV0dXJufWFzc2VydCh0aGlzLmNhbGxiYWNrKSx0aGlzLmFib3J0PUEsdGhpcy5jb250ZXh0PXR9b25IZWFkZXJzKCl7dGhyb3cgbmV3IFNvY2tldEVycm9yKFwiYmFkIGNvbm5lY3RcIixudWxsKX1vblVwZ3JhZGUoQSx0LG4pe2NvbnN0e2NhbGxiYWNrOnIsb3BhcXVlOnMsY29udGV4dDppfT10aGlzO3JlbW92ZVNpZ25hbCh0aGlzKSx0aGlzLmNhbGxiYWNrPW51bGw7bGV0IEU9dDtFIT1udWxsJiYoRT10aGlzLnJlc3BvbnNlSGVhZGVycz09PVwicmF3XCI/dXRpbCQ2LnBhcnNlUmF3SGVhZGVycyh0KTp1dGlsJDYucGFyc2VIZWFkZXJzKHQpKSx0aGlzLnJ1bkluQXN5bmNTY29wZShyLG51bGwsbnVsbCx7c3RhdHVzQ29kZTpBLGhlYWRlcnM6RSxzb2NrZXQ6bixvcGFxdWU6cyxjb250ZXh0Oml9KX1vbkVycm9yKEEpe2NvbnN0e2NhbGxiYWNrOnQsb3BhcXVlOm59PXRoaXM7cmVtb3ZlU2lnbmFsKHRoaXMpLHQmJih0aGlzLmNhbGxiYWNrPW51bGwscXVldWVNaWNyb3Rhc2soKCk9Pnt0aGlzLnJ1bkluQXN5bmNTY29wZSh0LG51bGwsQSx7b3BhcXVlOm59KX0pKX19O28oaHQsXCJDb25uZWN0SGFuZGxlclwiKTtsZXQgQ29ubmVjdEhhbmRsZXI9aHQ7ZnVuY3Rpb24gY29ubmVjdChlLEEpe2lmKEE9PT12b2lkIDApcmV0dXJuIG5ldyBQcm9taXNlKCh0LG4pPT57Y29ubmVjdC5jYWxsKHRoaXMsZSwocixzKT0+cj9uKHIpOnQocykpfSk7dHJ5e2NvbnN0IHQ9bmV3IENvbm5lY3RIYW5kbGVyKGUsQSk7dGhpcy5kaXNwYXRjaCh7Li4uZSxtZXRob2Q6XCJDT05ORUNUXCJ9LHQpfWNhdGNoKHQpe2lmKHR5cGVvZiBBIT1cImZ1bmN0aW9uXCIpdGhyb3cgdDtjb25zdCBuPWU/Lm9wYXF1ZTtxdWV1ZU1pY3JvdGFzaygoKT0+QSh0LHtvcGFxdWU6bn0pKX19byhjb25uZWN0LFwiY29ubmVjdFwiKTt2YXIgYXBpQ29ubmVjdD1jb25uZWN0O2FwaSQxLnJlcXVlc3Q9YXBpUmVxdWVzdEV4cG9ydHMsYXBpJDEuc3RyZWFtPWFwaVN0cmVhbSxhcGkkMS5waXBlbGluZT1hcGlQaXBlbGluZSxhcGkkMS51cGdyYWRlPWFwaVVwZ3JhZGUsYXBpJDEuY29ubmVjdD1hcGlDb25uZWN0O2NvbnN0e1VuZGljaUVycm9yfT1lcnJvcnMkMTtsZXQgTW9ja05vdE1hdGNoZWRFcnJvciQxPShBZT1jbGFzcyBleHRlbmRzIFVuZGljaUVycm9ye2NvbnN0cnVjdG9yKEEpe3N1cGVyKEEpLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsQWUpLHRoaXMubmFtZT1cIk1vY2tOb3RNYXRjaGVkRXJyb3JcIix0aGlzLm1lc3NhZ2U9QXx8XCJUaGUgcmVxdWVzdCBkb2VzIG5vdCBtYXRjaCBhbnkgcmVnaXN0ZXJlZCBtb2NrIGRpc3BhdGNoZXNcIix0aGlzLmNvZGU9XCJVTkRfTU9DS19FUlJfTU9DS19OT1RfTUFUQ0hFRFwifX0sbyhBZSxcIk1vY2tOb3RNYXRjaGVkRXJyb3JcIiksQWUpO3ZhciBtb2NrRXJyb3JzPXtNb2NrTm90TWF0Y2hlZEVycm9yOk1vY2tOb3RNYXRjaGVkRXJyb3IkMX0sbW9ja1N5bWJvbHM9e2tBZ2VudDpTeW1ib2woXCJhZ2VudFwiKSxrT3B0aW9uczpTeW1ib2woXCJvcHRpb25zXCIpLGtGYWN0b3J5OlN5bWJvbChcImZhY3RvcnlcIiksa0Rpc3BhdGNoZXM6U3ltYm9sKFwiZGlzcGF0Y2hlc1wiKSxrRGlzcGF0Y2hLZXk6U3ltYm9sKFwiZGlzcGF0Y2gga2V5XCIpLGtEZWZhdWx0SGVhZGVyczpTeW1ib2woXCJkZWZhdWx0IGhlYWRlcnNcIiksa0RlZmF1bHRUcmFpbGVyczpTeW1ib2woXCJkZWZhdWx0IHRyYWlsZXJzXCIpLGtDb250ZW50TGVuZ3RoOlN5bWJvbChcImNvbnRlbnQgbGVuZ3RoXCIpLGtNb2NrQWdlbnQ6U3ltYm9sKFwibW9jayBhZ2VudFwiKSxrTW9ja0FnZW50U2V0OlN5bWJvbChcIm1vY2sgYWdlbnQgc2V0XCIpLGtNb2NrQWdlbnRHZXQ6U3ltYm9sKFwibW9jayBhZ2VudCBnZXRcIiksa01vY2tEaXNwYXRjaDpTeW1ib2woXCJtb2NrIGRpc3BhdGNoXCIpLGtDbG9zZTpTeW1ib2woXCJjbG9zZVwiKSxrT3JpZ2luYWxDbG9zZTpTeW1ib2woXCJvcmlnaW5hbCBhZ2VudCBjbG9zZVwiKSxrT3JpZ2luOlN5bWJvbChcIm9yaWdpblwiKSxrSXNNb2NrQWN0aXZlOlN5bWJvbChcImlzIG1vY2sgYWN0aXZlXCIpLGtOZXRDb25uZWN0OlN5bWJvbChcIm5ldCBjb25uZWN0XCIpLGtHZXROZXRDb25uZWN0OlN5bWJvbChcImdldCBuZXQgY29ubmVjdFwiKSxrQ29ubmVjdGVkOlN5bWJvbChcImNvbm5lY3RlZFwiKX07Y29uc3R7TW9ja05vdE1hdGNoZWRFcnJvcn09bW9ja0Vycm9ycyx7a0Rpc3BhdGNoZXM6a0Rpc3BhdGNoZXMkMyxrTW9ja0FnZW50OmtNb2NrQWdlbnQkMixrT3JpZ2luYWxEaXNwYXRjaDprT3JpZ2luYWxEaXNwYXRjaCQyLGtPcmlnaW46a09yaWdpbiQyLGtHZXROZXRDb25uZWN0fT1tb2NrU3ltYm9scyx7YnVpbGRVUkw6YnVpbGRVUkwkMX09dXRpbCRtLHtTVEFUVVNfQ09ERVN9PWh0dHBfX2RlZmF1bHQse3R5cGVzOntpc1Byb21pc2V9fT1yZXF1aXJlJCQwX19kZWZhdWx0JDE7ZnVuY3Rpb24gbWF0Y2hWYWx1ZShlLEEpe3JldHVybiB0eXBlb2YgZT09XCJzdHJpbmdcIj9lPT09QTplIGluc3RhbmNlb2YgUmVnRXhwP2UudGVzdChBKTp0eXBlb2YgZT09XCJmdW5jdGlvblwiP2UoQSk9PT0hMDohMX1vKG1hdGNoVmFsdWUsXCJtYXRjaFZhbHVlXCIpO2Z1bmN0aW9uIGxvd2VyQ2FzZUVudHJpZXMoZSl7cmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhlKS5tYXAoKFtBLHRdKT0+W0EudG9Mb2NhbGVMb3dlckNhc2UoKSx0XSkpfW8obG93ZXJDYXNlRW50cmllcyxcImxvd2VyQ2FzZUVudHJpZXNcIik7ZnVuY3Rpb24gZ2V0SGVhZGVyQnlOYW1lKGUsQSl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kz0yKWlmKGVbdF0udG9Mb2NhbGVMb3dlckNhc2UoKT09PUEudG9Mb2NhbGVMb3dlckNhc2UoKSlyZXR1cm4gZVt0KzFdO3JldHVybn1lbHNlIHJldHVybiB0eXBlb2YgZS5nZXQ9PVwiZnVuY3Rpb25cIj9lLmdldChBKTpsb3dlckNhc2VFbnRyaWVzKGUpW0EudG9Mb2NhbGVMb3dlckNhc2UoKV19byhnZXRIZWFkZXJCeU5hbWUsXCJnZXRIZWFkZXJCeU5hbWVcIik7ZnVuY3Rpb24gYnVpbGRIZWFkZXJzRnJvbUFycmF5KGUpe2NvbnN0IEE9ZS5zbGljZSgpLHQ9W107Zm9yKGxldCBuPTA7bjxBLmxlbmd0aDtuKz0yKXQucHVzaChbQVtuXSxBW24rMV1dKTtyZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHQpfW8oYnVpbGRIZWFkZXJzRnJvbUFycmF5LFwiYnVpbGRIZWFkZXJzRnJvbUFycmF5XCIpO2Z1bmN0aW9uIG1hdGNoSGVhZGVycyhlLEEpe2lmKHR5cGVvZiBlLmhlYWRlcnM9PVwiZnVuY3Rpb25cIilyZXR1cm4gQXJyYXkuaXNBcnJheShBKSYmKEE9YnVpbGRIZWFkZXJzRnJvbUFycmF5KEEpKSxlLmhlYWRlcnMoQT9sb3dlckNhc2VFbnRyaWVzKEEpOnt9KTtpZih0eXBlb2YgZS5oZWFkZXJzPlwidVwiKXJldHVybiEwO2lmKHR5cGVvZiBBIT1cIm9iamVjdFwifHx0eXBlb2YgZS5oZWFkZXJzIT1cIm9iamVjdFwiKXJldHVybiExO2Zvcihjb25zdFt0LG5db2YgT2JqZWN0LmVudHJpZXMoZS5oZWFkZXJzKSl7Y29uc3Qgcj1nZXRIZWFkZXJCeU5hbWUoQSx0KTtpZighbWF0Y2hWYWx1ZShuLHIpKXJldHVybiExfXJldHVybiEwfW8obWF0Y2hIZWFkZXJzLFwibWF0Y2hIZWFkZXJzXCIpO2Z1bmN0aW9uIHNhZmVVcmwoZSl7aWYodHlwZW9mIGUhPVwic3RyaW5nXCIpcmV0dXJuIGU7Y29uc3QgQT1lLnNwbGl0KFwiP1wiKTtpZihBLmxlbmd0aCE9PTIpcmV0dXJuIGU7Y29uc3QgdD1uZXcgVVJMU2VhcmNoUGFyYW1zKEEucG9wKCkpO3JldHVybiB0LnNvcnQoKSxbLi4uQSx0LnRvU3RyaW5nKCldLmpvaW4oXCI/XCIpfW8oc2FmZVVybCxcInNhZmVVcmxcIik7ZnVuY3Rpb24gbWF0Y2hLZXkoZSx7cGF0aDpBLG1ldGhvZDp0LGJvZHk6bixoZWFkZXJzOnJ9KXtjb25zdCBzPW1hdGNoVmFsdWUoZS5wYXRoLEEpLGk9bWF0Y2hWYWx1ZShlLm1ldGhvZCx0KSxFPXR5cGVvZiBlLmJvZHk8XCJ1XCI/bWF0Y2hWYWx1ZShlLmJvZHksbik6ITAsUT1tYXRjaEhlYWRlcnMoZSxyKTtyZXR1cm4gcyYmaSYmRSYmUX1vKG1hdGNoS2V5LFwibWF0Y2hLZXlcIik7ZnVuY3Rpb24gZ2V0UmVzcG9uc2VEYXRhJDEoZSl7cmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihlKT9lOnR5cGVvZiBlPT1cIm9iamVjdFwiP0pTT04uc3RyaW5naWZ5KGUpOmUudG9TdHJpbmcoKX1vKGdldFJlc3BvbnNlRGF0YSQxLFwiZ2V0UmVzcG9uc2VEYXRhJDFcIik7ZnVuY3Rpb24gZ2V0TW9ja0Rpc3BhdGNoKGUsQSl7Y29uc3QgdD1BLnF1ZXJ5P2J1aWxkVVJMJDEoQS5wYXRoLEEucXVlcnkpOkEucGF0aCxuPXR5cGVvZiB0PT1cInN0cmluZ1wiP3NhZmVVcmwodCk6dDtsZXQgcj1lLmZpbHRlcigoe2NvbnN1bWVkOnN9KT0+IXMpLmZpbHRlcigoe3BhdGg6c30pPT5tYXRjaFZhbHVlKHNhZmVVcmwocyksbikpO2lmKHIubGVuZ3RoPT09MCl0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgcGF0aCAnJHtufSdgKTtpZihyPXIuZmlsdGVyKCh7bWV0aG9kOnN9KT0+bWF0Y2hWYWx1ZShzLEEubWV0aG9kKSksci5sZW5ndGg9PT0wKXRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGBNb2NrIGRpc3BhdGNoIG5vdCBtYXRjaGVkIGZvciBtZXRob2QgJyR7QS5tZXRob2R9JyBvbiBwYXRoICcke259J2ApO2lmKHI9ci5maWx0ZXIoKHtib2R5OnN9KT0+dHlwZW9mIHM8XCJ1XCI/bWF0Y2hWYWx1ZShzLEEuYm9keSk6ITApLHIubGVuZ3RoPT09MCl0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgYm9keSAnJHtBLmJvZHl9JyBvbiBwYXRoICcke259J2ApO2lmKHI9ci5maWx0ZXIocz0+bWF0Y2hIZWFkZXJzKHMsQS5oZWFkZXJzKSksci5sZW5ndGg9PT0wKXtjb25zdCBzPXR5cGVvZiBBLmhlYWRlcnM9PVwib2JqZWN0XCI/SlNPTi5zdHJpbmdpZnkoQS5oZWFkZXJzKTpBLmhlYWRlcnM7dGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIGhlYWRlcnMgJyR7c30nIG9uIHBhdGggJyR7bn0nYCl9cmV0dXJuIHJbMF19byhnZXRNb2NrRGlzcGF0Y2gsXCJnZXRNb2NrRGlzcGF0Y2hcIik7ZnVuY3Rpb24gYWRkTW9ja0Rpc3BhdGNoJDEoZSxBLHQpe2NvbnN0IG49e3RpbWVzSW52b2tlZDowLHRpbWVzOjEscGVyc2lzdDohMSxjb25zdW1lZDohMX0scj10eXBlb2YgdD09XCJmdW5jdGlvblwiP3tjYWxsYmFjazp0fTp7Li4udH0scz17Li4ubiwuLi5BLHBlbmRpbmc6ITAsZGF0YTp7ZXJyb3I6bnVsbCwuLi5yfX07cmV0dXJuIGUucHVzaChzKSxzfW8oYWRkTW9ja0Rpc3BhdGNoJDEsXCJhZGRNb2NrRGlzcGF0Y2gkMVwiKTtmdW5jdGlvbiBkZWxldGVNb2NrRGlzcGF0Y2goZSxBKXtjb25zdCB0PWUuZmluZEluZGV4KG49Pm4uY29uc3VtZWQ/bWF0Y2hLZXkobixBKTohMSk7dCE9PS0xJiZlLnNwbGljZSh0LDEpfW8oZGVsZXRlTW9ja0Rpc3BhdGNoLFwiZGVsZXRlTW9ja0Rpc3BhdGNoXCIpO2Z1bmN0aW9uIGJ1aWxkS2V5JDEoZSl7Y29uc3R7cGF0aDpBLG1ldGhvZDp0LGJvZHk6bixoZWFkZXJzOnIscXVlcnk6c309ZTtyZXR1cm57cGF0aDpBLG1ldGhvZDp0LGJvZHk6bixoZWFkZXJzOnIscXVlcnk6c319byhidWlsZEtleSQxLFwiYnVpbGRLZXkkMVwiKTtmdW5jdGlvbiBnZW5lcmF0ZUtleVZhbHVlcyhlKXtjb25zdCBBPU9iamVjdC5rZXlzKGUpLHQ9W107Zm9yKGxldCBuPTA7bjxBLmxlbmd0aDsrK24pe2NvbnN0IHI9QVtuXSxzPWVbcl0saT1CdWZmZXIuZnJvbShgJHtyfWApO2lmKEFycmF5LmlzQXJyYXkocykpZm9yKGxldCBFPTA7RTxzLmxlbmd0aDsrK0UpdC5wdXNoKGksQnVmZmVyLmZyb20oYCR7c1tFXX1gKSk7ZWxzZSB0LnB1c2goaSxCdWZmZXIuZnJvbShgJHtzfWApKX1yZXR1cm4gdH1vKGdlbmVyYXRlS2V5VmFsdWVzLFwiZ2VuZXJhdGVLZXlWYWx1ZXNcIik7ZnVuY3Rpb24gZ2V0U3RhdHVzVGV4dChlKXtyZXR1cm4gU1RBVFVTX0NPREVTW2VdfHxcInVua25vd25cIn1vKGdldFN0YXR1c1RleHQsXCJnZXRTdGF0dXNUZXh0XCIpO2FzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlKGUpe2NvbnN0IEE9W107Zm9yIGF3YWl0KGNvbnN0IHQgb2YgZSlBLnB1c2godCk7cmV0dXJuIEJ1ZmZlci5jb25jYXQoQSkudG9TdHJpbmcoXCJ1dGY4XCIpfW8oZ2V0UmVzcG9uc2UsXCJnZXRSZXNwb25zZVwiKTtmdW5jdGlvbiBtb2NrRGlzcGF0Y2goZSxBKXtjb25zdCB0PWJ1aWxkS2V5JDEoZSksbj1nZXRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlcyQzXSx0KTtuLnRpbWVzSW52b2tlZCsrLG4uZGF0YS5jYWxsYmFjayYmKG4uZGF0YT17Li4ubi5kYXRhLC4uLm4uZGF0YS5jYWxsYmFjayhlKX0pO2NvbnN0e2RhdGE6e3N0YXR1c0NvZGU6cixkYXRhOnMsaGVhZGVyczppLHRyYWlsZXJzOkUsZXJyb3I6UX0sZGVsYXk6QyxwZXJzaXN0Okl9PW4se3RpbWVzSW52b2tlZDphLHRpbWVzOmZ9PW47aWYobi5jb25zdW1lZD0hSSYmYT49ZixuLnBlbmRpbmc9YTxmLFEhPT1udWxsKXJldHVybiBkZWxldGVNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlcyQzXSx0KSxBLm9uRXJyb3IoUSksITA7dHlwZW9mIEM9PVwibnVtYmVyXCImJkM+MD9zZXRUaW1lb3V0KCgpPT57aCh0aGlzW2tEaXNwYXRjaGVzJDNdKX0sQyk6aCh0aGlzW2tEaXNwYXRjaGVzJDNdKTtmdW5jdGlvbiBoKGMsbD1zKXtjb25zdCBTPUFycmF5LmlzQXJyYXkoZS5oZWFkZXJzKT9idWlsZEhlYWRlcnNGcm9tQXJyYXkoZS5oZWFkZXJzKTplLmhlYWRlcnMsaz10eXBlb2YgbD09XCJmdW5jdGlvblwiP2woey4uLmUsaGVhZGVyczpTfSk6bDtpZihpc1Byb21pc2Uoaykpe2sudGhlbihCPT5oKGMsQikpO3JldHVybn1jb25zdCB3PWdldFJlc3BvbnNlRGF0YSQxKGspLFU9Z2VuZXJhdGVLZXlWYWx1ZXMoaSksTT1nZW5lcmF0ZUtleVZhbHVlcyhFKTtBLm9uQ29ubmVjdD8uKEI9PkEub25FcnJvcihCKSxudWxsKSxBLm9uSGVhZGVycz8uKHIsVSxMLGdldFN0YXR1c1RleHQocikpLEEub25EYXRhPy4oQnVmZmVyLmZyb20odykpLEEub25Db21wbGV0ZT8uKE0pLGRlbGV0ZU1vY2tEaXNwYXRjaChjLHQpfW8oaCxcImhhbmRsZVJlcGx5XCIpO2Z1bmN0aW9uIEwoKXt9cmV0dXJuIG8oTCxcInJlc3VtZVwiKSwhMH1vKG1vY2tEaXNwYXRjaCxcIm1vY2tEaXNwYXRjaFwiKTtmdW5jdGlvbiBidWlsZE1vY2tEaXNwYXRjaCQyKCl7Y29uc3QgZT10aGlzW2tNb2NrQWdlbnQkMl0sQT10aGlzW2tPcmlnaW4kMl0sdD10aGlzW2tPcmlnaW5hbERpc3BhdGNoJDJdO3JldHVybiBvKGZ1bmN0aW9uKHIscyl7aWYoZS5pc01vY2tBY3RpdmUpdHJ5e21vY2tEaXNwYXRjaC5jYWxsKHRoaXMscixzKX1jYXRjaChpKXtpZihpIGluc3RhbmNlb2YgTW9ja05vdE1hdGNoZWRFcnJvcil7Y29uc3QgRT1lW2tHZXROZXRDb25uZWN0XSgpO2lmKEU9PT0hMSl0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgJHtpLm1lc3NhZ2V9OiBzdWJzZXF1ZW50IHJlcXVlc3QgdG8gb3JpZ2luICR7QX0gd2FzIG5vdCBhbGxvd2VkIChuZXQuY29ubmVjdCBkaXNhYmxlZClgKTtpZihjaGVja05ldENvbm5lY3QoRSxBKSl0LmNhbGwodGhpcyxyLHMpO2Vsc2UgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYCR7aS5tZXNzYWdlfTogc3Vic2VxdWVudCByZXF1ZXN0IHRvIG9yaWdpbiAke0F9IHdhcyBub3QgYWxsb3dlZCAobmV0LmNvbm5lY3QgaXMgbm90IGVuYWJsZWQgZm9yIHRoaXMgb3JpZ2luKWApfWVsc2UgdGhyb3cgaX1lbHNlIHQuY2FsbCh0aGlzLHIscyl9LFwiZGlzcGF0Y2hcIil9byhidWlsZE1vY2tEaXNwYXRjaCQyLFwiYnVpbGRNb2NrRGlzcGF0Y2gkMlwiKTtmdW5jdGlvbiBjaGVja05ldENvbm5lY3QoZSxBKXtjb25zdCB0PW5ldyBVUkwoQSk7cmV0dXJuIGU9PT0hMD8hMDohIShBcnJheS5pc0FycmF5KGUpJiZlLnNvbWUobj0+bWF0Y2hWYWx1ZShuLHQuaG9zdCkpKX1vKGNoZWNrTmV0Q29ubmVjdCxcImNoZWNrTmV0Q29ubmVjdFwiKTtmdW5jdGlvbiBidWlsZE1vY2tPcHRpb25zKGUpe2lmKGUpe2NvbnN0e2FnZW50OkEsLi4udH09ZTtyZXR1cm4gdH19byhidWlsZE1vY2tPcHRpb25zLFwiYnVpbGRNb2NrT3B0aW9uc1wiKTt2YXIgbW9ja1V0aWxzPXtnZXRSZXNwb25zZURhdGE6Z2V0UmVzcG9uc2VEYXRhJDEsZ2V0TW9ja0Rpc3BhdGNoLGFkZE1vY2tEaXNwYXRjaDphZGRNb2NrRGlzcGF0Y2gkMSxkZWxldGVNb2NrRGlzcGF0Y2gsYnVpbGRLZXk6YnVpbGRLZXkkMSxnZW5lcmF0ZUtleVZhbHVlcyxtYXRjaFZhbHVlLGdldFJlc3BvbnNlLGdldFN0YXR1c1RleHQsbW9ja0Rpc3BhdGNoLGJ1aWxkTW9ja0Rpc3BhdGNoOmJ1aWxkTW9ja0Rpc3BhdGNoJDIsY2hlY2tOZXRDb25uZWN0LGJ1aWxkTW9ja09wdGlvbnMsZ2V0SGVhZGVyQnlOYW1lLGJ1aWxkSGVhZGVyc0Zyb21BcnJheX0sbW9ja0ludGVyY2VwdG9yPXt9O2NvbnN0e2dldFJlc3BvbnNlRGF0YSxidWlsZEtleSxhZGRNb2NrRGlzcGF0Y2h9PW1vY2tVdGlscyx7a0Rpc3BhdGNoZXM6a0Rpc3BhdGNoZXMkMixrRGlzcGF0Y2hLZXksa0RlZmF1bHRIZWFkZXJzLGtEZWZhdWx0VHJhaWxlcnMsa0NvbnRlbnRMZW5ndGgsa01vY2tEaXNwYXRjaH09bW9ja1N5bWJvbHMse0ludmFsaWRBcmd1bWVudEVycm9yOkludmFsaWRBcmd1bWVudEVycm9yJDR9PWVycm9ycyQxLHtidWlsZFVSTH09dXRpbCRtLGx0PWNsYXNzIGx0e2NvbnN0cnVjdG9yKEEpe3RoaXNba01vY2tEaXNwYXRjaF09QX1kZWxheShBKXtpZih0eXBlb2YgQSE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoQSl8fEE8PTApdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJDQoXCJ3YWl0SW5NcyBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciA+IDBcIik7cmV0dXJuIHRoaXNba01vY2tEaXNwYXRjaF0uZGVsYXk9QSx0aGlzfXBlcnNpc3QoKXtyZXR1cm4gdGhpc1trTW9ja0Rpc3BhdGNoXS5wZXJzaXN0PSEwLHRoaXN9dGltZXMoQSl7aWYodHlwZW9mIEEhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKEEpfHxBPD0wKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQ0KFwicmVwZWF0VGltZXMgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgPiAwXCIpO3JldHVybiB0aGlzW2tNb2NrRGlzcGF0Y2hdLnRpbWVzPUEsdGhpc319O28obHQsXCJNb2NrU2NvcGVcIik7bGV0IE1vY2tTY29wZT1sdCxNb2NrSW50ZXJjZXB0b3IkMj0oVGU9Y2xhc3N7Y29uc3RydWN0b3IoQSx0KXtpZih0eXBlb2YgQSE9XCJvYmplY3RcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkNChcIm9wdHMgbXVzdCBiZSBhbiBvYmplY3RcIik7aWYodHlwZW9mIEEucGF0aD5cInVcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkNChcIm9wdHMucGF0aCBtdXN0IGJlIGRlZmluZWRcIik7aWYodHlwZW9mIEEubWV0aG9kPlwidVwiJiYoQS5tZXRob2Q9XCJHRVRcIiksdHlwZW9mIEEucGF0aD09XCJzdHJpbmdcIilpZihBLnF1ZXJ5KUEucGF0aD1idWlsZFVSTChBLnBhdGgsQS5xdWVyeSk7ZWxzZXtjb25zdCBuPW5ldyBVUkwoQS5wYXRoLFwiZGF0YTovL1wiKTtBLnBhdGg9bi5wYXRobmFtZStuLnNlYXJjaH10eXBlb2YgQS5tZXRob2Q9PVwic3RyaW5nXCImJihBLm1ldGhvZD1BLm1ldGhvZC50b1VwcGVyQ2FzZSgpKSx0aGlzW2tEaXNwYXRjaEtleV09YnVpbGRLZXkoQSksdGhpc1trRGlzcGF0Y2hlcyQyXT10LHRoaXNba0RlZmF1bHRIZWFkZXJzXT17fSx0aGlzW2tEZWZhdWx0VHJhaWxlcnNdPXt9LHRoaXNba0NvbnRlbnRMZW5ndGhdPSExfWNyZWF0ZU1vY2tTY29wZURpc3BhdGNoRGF0YSh7c3RhdHVzQ29kZTpBLGRhdGE6dCxyZXNwb25zZU9wdGlvbnM6bn0pe2NvbnN0IHI9Z2V0UmVzcG9uc2VEYXRhKHQpLHM9dGhpc1trQ29udGVudExlbmd0aF0/e1wiY29udGVudC1sZW5ndGhcIjpyLmxlbmd0aH06e30saT17Li4udGhpc1trRGVmYXVsdEhlYWRlcnNdLC4uLnMsLi4ubi5oZWFkZXJzfSxFPXsuLi50aGlzW2tEZWZhdWx0VHJhaWxlcnNdLC4uLm4udHJhaWxlcnN9O3JldHVybntzdGF0dXNDb2RlOkEsZGF0YTp0LGhlYWRlcnM6aSx0cmFpbGVyczpFfX12YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyhBKXtpZih0eXBlb2YgQS5zdGF0dXNDb2RlPlwidVwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQ0KFwic3RhdHVzQ29kZSBtdXN0IGJlIGRlZmluZWRcIik7aWYodHlwZW9mIEEucmVzcG9uc2VPcHRpb25zIT1cIm9iamVjdFwifHxBLnJlc3BvbnNlT3B0aW9ucz09PW51bGwpdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yJDQoXCJyZXNwb25zZU9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RcIil9cmVwbHkoQSl7aWYodHlwZW9mIEE9PVwiZnVuY3Rpb25cIil7Y29uc3Qgcz1vKEU9Pntjb25zdCBRPUEoRSk7aWYodHlwZW9mIFEhPVwib2JqZWN0XCJ8fFE9PT1udWxsKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQ0KFwicmVwbHkgb3B0aW9ucyBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBvYmplY3RcIik7Y29uc3QgQz17ZGF0YTpcIlwiLHJlc3BvbnNlT3B0aW9uczp7fSwuLi5RfTtyZXR1cm4gdGhpcy52YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyhDKSx7Li4udGhpcy5jcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEoQyl9fSxcIndyYXBwZWREZWZhdWx0c0NhbGxiYWNrXCIpLGk9YWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXMkMl0sdGhpc1trRGlzcGF0Y2hLZXldLHMpO3JldHVybiBuZXcgTW9ja1Njb3BlKGkpfWNvbnN0IHQ9e3N0YXR1c0NvZGU6QSxkYXRhOmFyZ3VtZW50c1sxXT09PXZvaWQgMD9cIlwiOmFyZ3VtZW50c1sxXSxyZXNwb25zZU9wdGlvbnM6YXJndW1lbnRzWzJdPT09dm9pZCAwP3t9OmFyZ3VtZW50c1syXX07dGhpcy52YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyh0KTtjb25zdCBuPXRoaXMuY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhKHQpLHI9YWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXMkMl0sdGhpc1trRGlzcGF0Y2hLZXldLG4pO3JldHVybiBuZXcgTW9ja1Njb3BlKHIpfXJlcGx5V2l0aEVycm9yKEEpe2lmKHR5cGVvZiBBPlwidVwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQ0KFwiZXJyb3IgbXVzdCBiZSBkZWZpbmVkXCIpO2NvbnN0IHQ9YWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXMkMl0sdGhpc1trRGlzcGF0Y2hLZXldLHtlcnJvcjpBfSk7cmV0dXJuIG5ldyBNb2NrU2NvcGUodCl9ZGVmYXVsdFJlcGx5SGVhZGVycyhBKXtpZih0eXBlb2YgQT5cInVcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IkNChcImhlYWRlcnMgbXVzdCBiZSBkZWZpbmVkXCIpO3JldHVybiB0aGlzW2tEZWZhdWx0SGVhZGVyc109QSx0aGlzfWRlZmF1bHRSZXBseVRyYWlsZXJzKEEpe2lmKHR5cGVvZiBBPlwidVwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQ0KFwidHJhaWxlcnMgbXVzdCBiZSBkZWZpbmVkXCIpO3JldHVybiB0aGlzW2tEZWZhdWx0VHJhaWxlcnNdPUEsdGhpc31yZXBseUNvbnRlbnRMZW5ndGgoKXtyZXR1cm4gdGhpc1trQ29udGVudExlbmd0aF09ITAsdGhpc319LG8oVGUsXCJNb2NrSW50ZXJjZXB0b3JcIiksVGUpO21vY2tJbnRlcmNlcHRvci5Nb2NrSW50ZXJjZXB0b3I9TW9ja0ludGVyY2VwdG9yJDIsbW9ja0ludGVyY2VwdG9yLk1vY2tTY29wZT1Nb2NrU2NvcGU7Y29uc3R7cHJvbWlzaWZ5OnByb21pc2lmeSQxfT1yZXF1aXJlJCQwX19kZWZhdWx0JDEsQ2xpZW50PWNsaWVudCx7YnVpbGRNb2NrRGlzcGF0Y2g6YnVpbGRNb2NrRGlzcGF0Y2gkMX09bW9ja1V0aWxzLHtrRGlzcGF0Y2hlczprRGlzcGF0Y2hlcyQxLGtNb2NrQWdlbnQ6a01vY2tBZ2VudCQxLGtDbG9zZTprQ2xvc2UkMSxrT3JpZ2luYWxDbG9zZTprT3JpZ2luYWxDbG9zZSQxLGtPcmlnaW46a09yaWdpbiQxLGtPcmlnaW5hbERpc3BhdGNoOmtPcmlnaW5hbERpc3BhdGNoJDEsa0Nvbm5lY3RlZDprQ29ubmVjdGVkJDF9PW1vY2tTeW1ib2xzLHtNb2NrSW50ZXJjZXB0b3I6TW9ja0ludGVyY2VwdG9yJDF9PW1vY2tJbnRlcmNlcHRvcixTeW1ib2xzJDE9c3ltYm9scyQ0LHtJbnZhbGlkQXJndW1lbnRFcnJvcjpJbnZhbGlkQXJndW1lbnRFcnJvciQzfT1lcnJvcnMkMSx1dD1jbGFzcyB1dCBleHRlbmRzIENsaWVudHtjb25zdHJ1Y3RvcihBLHQpe2lmKHN1cGVyKEEsdCksIXR8fCF0LmFnZW50fHx0eXBlb2YgdC5hZ2VudC5kaXNwYXRjaCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQzKFwiQXJndW1lbnQgb3B0cy5hZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudFwiKTt0aGlzW2tNb2NrQWdlbnQkMV09dC5hZ2VudCx0aGlzW2tPcmlnaW4kMV09QSx0aGlzW2tEaXNwYXRjaGVzJDFdPVtdLHRoaXNba0Nvbm5lY3RlZCQxXT0xLHRoaXNba09yaWdpbmFsRGlzcGF0Y2gkMV09dGhpcy5kaXNwYXRjaCx0aGlzW2tPcmlnaW5hbENsb3NlJDFdPXRoaXMuY2xvc2UuYmluZCh0aGlzKSx0aGlzLmRpc3BhdGNoPWJ1aWxkTW9ja0Rpc3BhdGNoJDEuY2FsbCh0aGlzKSx0aGlzLmNsb3NlPXRoaXNba0Nsb3NlJDFdfWdldFtTeW1ib2xzJDEua0Nvbm5lY3RlZF0oKXtyZXR1cm4gdGhpc1trQ29ubmVjdGVkJDFdfWludGVyY2VwdChBKXtyZXR1cm4gbmV3IE1vY2tJbnRlcmNlcHRvciQxKEEsdGhpc1trRGlzcGF0Y2hlcyQxXSl9YXN5bmNba0Nsb3NlJDFdKCl7YXdhaXQgcHJvbWlzaWZ5JDEodGhpc1trT3JpZ2luYWxDbG9zZSQxXSkoKSx0aGlzW2tDb25uZWN0ZWQkMV09MCx0aGlzW2tNb2NrQWdlbnQkMV1bU3ltYm9scyQxLmtDbGllbnRzXS5kZWxldGUodGhpc1trT3JpZ2luJDFdKX19O28odXQsXCJNb2NrQ2xpZW50XCIpO2xldCBNb2NrQ2xpZW50PXV0O2NvbnN0e3Byb21pc2lmeX09cmVxdWlyZSQkMF9fZGVmYXVsdCQxLFBvb2w9cG9vbCx7YnVpbGRNb2NrRGlzcGF0Y2h9PW1vY2tVdGlscyx7a0Rpc3BhdGNoZXMsa01vY2tBZ2VudCxrQ2xvc2Usa09yaWdpbmFsQ2xvc2Usa09yaWdpbixrT3JpZ2luYWxEaXNwYXRjaCxrQ29ubmVjdGVkfT1tb2NrU3ltYm9scyx7TW9ja0ludGVyY2VwdG9yfT1tb2NrSW50ZXJjZXB0b3IsU3ltYm9scz1zeW1ib2xzJDQse0ludmFsaWRBcmd1bWVudEVycm9yOkludmFsaWRBcmd1bWVudEVycm9yJDJ9PWVycm9ycyQxLGR0PWNsYXNzIGR0IGV4dGVuZHMgUG9vbHtjb25zdHJ1Y3RvcihBLHQpe2lmKHN1cGVyKEEsdCksIXR8fCF0LmFnZW50fHx0eXBlb2YgdC5hZ2VudC5kaXNwYXRjaCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQyKFwiQXJndW1lbnQgb3B0cy5hZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudFwiKTt0aGlzW2tNb2NrQWdlbnRdPXQuYWdlbnQsdGhpc1trT3JpZ2luXT1BLHRoaXNba0Rpc3BhdGNoZXNdPVtdLHRoaXNba0Nvbm5lY3RlZF09MSx0aGlzW2tPcmlnaW5hbERpc3BhdGNoXT10aGlzLmRpc3BhdGNoLHRoaXNba09yaWdpbmFsQ2xvc2VdPXRoaXMuY2xvc2UuYmluZCh0aGlzKSx0aGlzLmRpc3BhdGNoPWJ1aWxkTW9ja0Rpc3BhdGNoLmNhbGwodGhpcyksdGhpcy5jbG9zZT10aGlzW2tDbG9zZV19Z2V0W1N5bWJvbHMua0Nvbm5lY3RlZF0oKXtyZXR1cm4gdGhpc1trQ29ubmVjdGVkXX1pbnRlcmNlcHQoQSl7cmV0dXJuIG5ldyBNb2NrSW50ZXJjZXB0b3IoQSx0aGlzW2tEaXNwYXRjaGVzXSl9YXN5bmNba0Nsb3NlXSgpe2F3YWl0IHByb21pc2lmeSh0aGlzW2tPcmlnaW5hbENsb3NlXSkoKSx0aGlzW2tDb25uZWN0ZWRdPTAsdGhpc1trTW9ja0FnZW50XVtTeW1ib2xzLmtDbGllbnRzXS5kZWxldGUodGhpc1trT3JpZ2luXSl9fTtvKGR0LFwiTW9ja1Bvb2xcIik7bGV0IE1vY2tQb29sPWR0O3Byb2Nlc3MudmVyc2lvbnMuaWN1LHByb2Nlc3MudmVyc2lvbnMuaWN1O2NvbnN0IGdsb2JhbERpc3BhdGNoZXI9U3ltYm9sLmZvcihcInVuZGljaS5nbG9iYWxEaXNwYXRjaGVyLjFcIikse0ludmFsaWRBcmd1bWVudEVycm9yOkludmFsaWRBcmd1bWVudEVycm9yJDF9PWVycm9ycyQxLEFnZW50JDE9YWdlbnQ7Z2V0R2xvYmFsRGlzcGF0Y2hlciQxKCk9PT12b2lkIDAmJnNldEdsb2JhbERpc3BhdGNoZXIkMShuZXcgQWdlbnQkMSk7ZnVuY3Rpb24gc2V0R2xvYmFsRGlzcGF0Y2hlciQxKGUpe2lmKCFlfHx0eXBlb2YgZS5kaXNwYXRjaCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvciQxKFwiQXJndW1lbnQgYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnRcIik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsZ2xvYmFsRGlzcGF0Y2hlcix7dmFsdWU6ZSx3cml0YWJsZTohMCxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMX0pfW8oc2V0R2xvYmFsRGlzcGF0Y2hlciQxLFwic2V0R2xvYmFsRGlzcGF0Y2hlciQxXCIpO2Z1bmN0aW9uIGdldEdsb2JhbERpc3BhdGNoZXIkMSgpe3JldHVybiBnbG9iYWxUaGlzW2dsb2JhbERpc3BhdGNoZXJdfW8oZ2V0R2xvYmFsRGlzcGF0Y2hlciQxLFwiZ2V0R2xvYmFsRGlzcGF0Y2hlciQxXCIpO3ZhciBnbG9iYWw9e3NldEdsb2JhbERpc3BhdGNoZXI6c2V0R2xvYmFsRGlzcGF0Y2hlciQxLGdldEdsb2JhbERpc3BhdGNoZXI6Z2V0R2xvYmFsRGlzcGF0Y2hlciQxfSxoZWFkZXJzLGhhc1JlcXVpcmVkSGVhZGVycztmdW5jdGlvbiByZXF1aXJlSGVhZGVycygpe2lmKGhhc1JlcXVpcmVkSGVhZGVycylyZXR1cm4gaGVhZGVycztoYXNSZXF1aXJlZEhlYWRlcnM9MTtjb25zdHtrSGVhZGVyc0xpc3Q6ZSxrQ29uc3RydWN0OkF9PXN5bWJvbHMkNCx7a0d1YXJkOnR9PXJlcXVpcmVTeW1ib2xzJDMoKSx7a0VudW1lcmFibGVQcm9wZXJ0eTpufT11dGlsJG0se2l0ZXJhdG9yTWl4aW46cixpc1ZhbGlkSGVhZGVyTmFtZTpzLGlzVmFsaWRIZWFkZXJWYWx1ZTppfT1yZXF1aXJlVXRpbCQ1KCkse3dlYmlkbDpFfT1yZXF1aXJlV2ViaWRsKCksUT1yZXF1aXJlJCQwX19kZWZhdWx0LEM9cmVxdWlyZSQkMF9fZGVmYXVsdCQxLEk9U3ltYm9sKFwiaGVhZGVycyBtYXBcIiksYT1TeW1ib2woXCJoZWFkZXJzIG1hcCBzb3J0ZWRcIik7ZnVuY3Rpb24gZihNKXtyZXR1cm4gTT09PTEwfHxNPT09MTN8fE09PT05fHxNPT09MzJ9byhmLFwiaXNIVFRQV2hpdGVTcGFjZUNoYXJDb2RlXCIpO2Z1bmN0aW9uIGgoTSl7bGV0IEI9MCxEPU0ubGVuZ3RoO2Zvcig7RD5CJiZmKE0uY2hhckNvZGVBdChELTEpKTspLS1EO2Zvcig7RD5CJiZmKE0uY2hhckNvZGVBdChCKSk7KSsrQjtyZXR1cm4gQj09PTAmJkQ9PT1NLmxlbmd0aD9NOk0uc3Vic3RyaW5nKEIsRCl9byhoLFwiaGVhZGVyVmFsdWVOb3JtYWxpemVcIik7ZnVuY3Rpb24gTChNLEIpe2lmKEFycmF5LmlzQXJyYXkoQikpZm9yKGxldCBEPTA7RDxCLmxlbmd0aDsrK0Qpe2NvbnN0IEc9QltEXTtpZihHLmxlbmd0aCE9PTIpdGhyb3cgRS5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJIZWFkZXJzIGNvbnN0cnVjdG9yXCIsbWVzc2FnZTpgZXhwZWN0ZWQgbmFtZS92YWx1ZSBwYWlyIHRvIGJlIGxlbmd0aCAyLCBmb3VuZCAke0cubGVuZ3RofS5gfSk7YyhNLEdbMF0sR1sxXSl9ZWxzZSBpZih0eXBlb2YgQj09XCJvYmplY3RcIiYmQiE9PW51bGwpe2NvbnN0IEQ9T2JqZWN0LmtleXMoQik7Zm9yKGxldCBHPTA7RzxELmxlbmd0aDsrK0cpYyhNLERbR10sQltEW0ddXSl9ZWxzZSB0aHJvdyBFLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtwcmVmaXg6XCJIZWFkZXJzIGNvbnN0cnVjdG9yXCIsYXJndW1lbnQ6XCJBcmd1bWVudCAxXCIsdHlwZXM6W1wic2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+XCIsXCJyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz5cIl19KX1vKEwsXCJmaWxsXCIpO2Z1bmN0aW9uIGMoTSxCLEQpe2lmKEQ9aChEKSxzKEIpKXtpZighaShEKSl0aHJvdyBFLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe3ByZWZpeDpcIkhlYWRlcnMuYXBwZW5kXCIsdmFsdWU6RCx0eXBlOlwiaGVhZGVyIHZhbHVlXCJ9KX1lbHNlIHRocm93IEUuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7cHJlZml4OlwiSGVhZGVycy5hcHBlbmRcIix2YWx1ZTpCLHR5cGU6XCJoZWFkZXIgbmFtZVwifSk7aWYoTVt0XT09PVwiaW1tdXRhYmxlXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcImltbXV0YWJsZVwiKTtyZXR1cm4gTVt0XSxNW2VdLmFwcGVuZChCLEQsITEpfW8oYyxcImFwcGVuZEhlYWRlclwiKTtmdW5jdGlvbiBsKE0sQil7cmV0dXJuIE1bMF08QlswXT8tMToxfW8obCxcImNvbXBhcmVIZWFkZXJOYW1lXCIpO2NvbnN0IHc9Y2xhc3Mgd3tjb25zdHJ1Y3RvcihCKXtOQSh0aGlzLFwiY29va2llc1wiLG51bGwpO0IgaW5zdGFuY2VvZiB3Pyh0aGlzW0ldPW5ldyBNYXAoQltJXSksdGhpc1thXT1CW2FdLHRoaXMuY29va2llcz1CLmNvb2tpZXM9PT1udWxsP251bGw6Wy4uLkIuY29va2llc10pOih0aGlzW0ldPW5ldyBNYXAoQiksdGhpc1thXT1udWxsKX1jb250YWlucyhCLEQpe3JldHVybiB0aGlzW0ldLmhhcyhEP0I6Qi50b0xvd2VyQ2FzZSgpKX1jbGVhcigpe3RoaXNbSV0uY2xlYXIoKSx0aGlzW2FdPW51bGwsdGhpcy5jb29raWVzPW51bGx9YXBwZW5kKEIsRCxHKXt0aGlzW2FdPW51bGw7Y29uc3QgZz1HP0I6Qi50b0xvd2VyQ2FzZSgpLGQ9dGhpc1tJXS5nZXQoZyk7aWYoZCl7Y29uc3QgRj1nPT09XCJjb29raWVcIj9cIjsgXCI6XCIsIFwiO3RoaXNbSV0uc2V0KGcse25hbWU6ZC5uYW1lLHZhbHVlOmAke2QudmFsdWV9JHtGfSR7RH1gfSl9ZWxzZSB0aGlzW0ldLnNldChnLHtuYW1lOkIsdmFsdWU6RH0pO2c9PT1cInNldC1jb29raWVcIiYmKHRoaXMuY29va2llcz8/KHRoaXMuY29va2llcz1bXSkpLnB1c2goRCl9c2V0KEIsRCxHKXt0aGlzW2FdPW51bGw7Y29uc3QgZz1HP0I6Qi50b0xvd2VyQ2FzZSgpO2c9PT1cInNldC1jb29raWVcIiYmKHRoaXMuY29va2llcz1bRF0pLHRoaXNbSV0uc2V0KGcse25hbWU6Qix2YWx1ZTpEfSl9ZGVsZXRlKEIsRCl7dGhpc1thXT1udWxsLER8fChCPUIudG9Mb3dlckNhc2UoKSksQj09PVwic2V0LWNvb2tpZVwiJiYodGhpcy5jb29raWVzPW51bGwpLHRoaXNbSV0uZGVsZXRlKEIpfWdldChCLEQpe3JldHVybiB0aGlzW0ldLmdldChEP0I6Qi50b0xvd2VyQ2FzZSgpKT8udmFsdWU/P251bGx9KltTeW1ib2wuaXRlcmF0b3JdKCl7Zm9yKGNvbnN0ezA6QiwxOnt2YWx1ZTpEfX1vZiB0aGlzW0ldKXlpZWxkW0IsRF19Z2V0IGVudHJpZXMoKXtjb25zdCBCPXt9O2lmKHRoaXNbSV0uc2l6ZSlmb3IoY29uc3R7bmFtZTpELHZhbHVlOkd9b2YgdGhpc1tJXS52YWx1ZXMoKSlCW0RdPUc7cmV0dXJuIEJ9dG9Tb3J0ZWRBcnJheSgpe2NvbnN0IEI9dGhpc1tJXS5zaXplLEQ9bmV3IEFycmF5KEIpO2lmKEI8PTMyKXtpZihCPT09MClyZXR1cm4gRDtjb25zdCBHPXRoaXNbSV1bU3ltYm9sLml0ZXJhdG9yXSgpLGc9Ry5uZXh0KCkudmFsdWU7RFswXT1bZ1swXSxnWzFdLnZhbHVlXSxRKGdbMV0udmFsdWUhPT1udWxsKTtmb3IobGV0IGQ9MSxGPTAsTj0wLHU9MCxiPTAsbSxUO2Q8QjsrK2Qpe2ZvcihUPUcubmV4dCgpLnZhbHVlLG09RFtkXT1bVFswXSxUWzFdLnZhbHVlXSxRKG1bMV0hPT1udWxsKSx1PTAsTj1kO3U8TjspYj11KyhOLXU+PjEpLERbYl1bMF08PW1bMF0/dT1iKzE6Tj1iO2lmKGQhPT1iKXtmb3IoRj1kO0Y+dTspRFtGXT1EWy0tRl07RFt1XT1tfX1pZighRy5uZXh0KCkuZG9uZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5yZWFjaGFibGVcIik7cmV0dXJuIER9ZWxzZXtsZXQgRz0wO2Zvcihjb25zdHswOmcsMTp7dmFsdWU6ZH19b2YgdGhpc1tJXSlEW0crK109W2csZF0sUShkIT09bnVsbCk7cmV0dXJuIEQuc29ydChsKX19fTtvKHcsXCJIZWFkZXJzTGlzdFwiKTtsZXQgUz13O2NvbnN0IFU9Y2xhc3MgVXtjb25zdHJ1Y3RvcihCPXZvaWQgMCl7QiE9PUEmJih0aGlzW2VdPW5ldyBTLHRoaXNbdF09XCJub25lXCIsQiE9PXZvaWQgMCYmKEI9RS5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0KEIpLEwodGhpcyxCKSkpfWFwcGVuZChCLEQpe3JldHVybiBFLmJyYW5kQ2hlY2sodGhpcyxVKSxFLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLDIse2hlYWRlcjpcIkhlYWRlcnMuYXBwZW5kXCJ9KSxCPUUuY29udmVydGVycy5CeXRlU3RyaW5nKEIpLEQ9RS5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcoRCksYyh0aGlzLEIsRCl9ZGVsZXRlKEIpe2lmKEUuYnJhbmRDaGVjayh0aGlzLFUpLEUuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMSx7aGVhZGVyOlwiSGVhZGVycy5kZWxldGVcIn0pLEI9RS5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcoQiksIXMoQikpdGhyb3cgRS5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtwcmVmaXg6XCJIZWFkZXJzLmRlbGV0ZVwiLHZhbHVlOkIsdHlwZTpcImhlYWRlciBuYW1lXCJ9KTtpZih0aGlzW3RdPT09XCJpbW11dGFibGVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW1tdXRhYmxlXCIpO3RoaXNbdF0sdGhpc1tlXS5jb250YWlucyhCLCExKSYmdGhpc1tlXS5kZWxldGUoQiwhMSl9Z2V0KEIpe2lmKEUuYnJhbmRDaGVjayh0aGlzLFUpLEUuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMSx7aGVhZGVyOlwiSGVhZGVycy5nZXRcIn0pLEI9RS5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcoQiksIXMoQikpdGhyb3cgRS5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtwcmVmaXg6XCJIZWFkZXJzLmdldFwiLHZhbHVlOkIsdHlwZTpcImhlYWRlciBuYW1lXCJ9KTtyZXR1cm4gdGhpc1tlXS5nZXQoQiwhMSl9aGFzKEIpe2lmKEUuYnJhbmRDaGVjayh0aGlzLFUpLEUuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMSx7aGVhZGVyOlwiSGVhZGVycy5oYXNcIn0pLEI9RS5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcoQiksIXMoQikpdGhyb3cgRS5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtwcmVmaXg6XCJIZWFkZXJzLmhhc1wiLHZhbHVlOkIsdHlwZTpcImhlYWRlciBuYW1lXCJ9KTtyZXR1cm4gdGhpc1tlXS5jb250YWlucyhCLCExKX1zZXQoQixEKXtpZihFLmJyYW5kQ2hlY2sodGhpcyxVKSxFLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLDIse2hlYWRlcjpcIkhlYWRlcnMuc2V0XCJ9KSxCPUUuY29udmVydGVycy5CeXRlU3RyaW5nKEIpLEQ9RS5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcoRCksRD1oKEQpLHMoQikpe2lmKCFpKEQpKXRocm93IEUuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7cHJlZml4OlwiSGVhZGVycy5zZXRcIix2YWx1ZTpELHR5cGU6XCJoZWFkZXIgdmFsdWVcIn0pfWVsc2UgdGhyb3cgRS5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtwcmVmaXg6XCJIZWFkZXJzLnNldFwiLHZhbHVlOkIsdHlwZTpcImhlYWRlciBuYW1lXCJ9KTtpZih0aGlzW3RdPT09XCJpbW11dGFibGVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW1tdXRhYmxlXCIpO3RoaXNbdF0sdGhpc1tlXS5zZXQoQixELCExKX1nZXRTZXRDb29raWUoKXtFLmJyYW5kQ2hlY2sodGhpcyxVKTtjb25zdCBCPXRoaXNbZV0uY29va2llcztyZXR1cm4gQj9bLi4uQl06W119Z2V0W2FdKCl7aWYodGhpc1tlXVthXSlyZXR1cm4gdGhpc1tlXVthXTtjb25zdCBCPVtdLEQ9dGhpc1tlXS50b1NvcnRlZEFycmF5KCksRz10aGlzW2VdLmNvb2tpZXM7aWYoRz09PW51bGx8fEcubGVuZ3RoPT09MSlyZXR1cm4gdGhpc1tlXVthXT1EO2ZvcihsZXQgZz0wO2c8RC5sZW5ndGg7KytnKXtjb25zdHswOmQsMTpGfT1EW2ddO2lmKGQ9PT1cInNldC1jb29raWVcIilmb3IobGV0IE49MDtOPEcubGVuZ3RoOysrTilCLnB1c2goW2QsR1tOXV0pO2Vsc2UgQi5wdXNoKFtkLEZdKX1yZXR1cm4gdGhpc1tlXVthXT1CfVtDLmluc3BlY3QuY3VzdG9tXShCLEQpe3JldHVybiBELmRlcHRoPz8oRC5kZXB0aD1CKSxgSGVhZGVycyAke0MuZm9ybWF0V2l0aE9wdGlvbnMoRCx0aGlzW2VdLmVudHJpZXMpfWB9fTtvKFUsXCJIZWFkZXJzXCIpO2xldCBrPVU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShrLnByb3RvdHlwZSxDLmluc3BlY3QuY3VzdG9tLHtlbnVtZXJhYmxlOiExfSkscihcIkhlYWRlcnNcIixrLGEsMCwxKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhrLnByb3RvdHlwZSx7YXBwZW5kOm4sZGVsZXRlOm4sZ2V0Om4saGFzOm4sc2V0Om4sZ2V0U2V0Q29va2llOm4sW1N5bWJvbC50b1N0cmluZ1RhZ106e3ZhbHVlOlwiSGVhZGVyc1wiLGNvbmZpZ3VyYWJsZTohMH19KSxFLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQ9ZnVuY3Rpb24oTSl7aWYoRS51dGlsLlR5cGUoTSk9PT1cIk9iamVjdFwiKXtjb25zdCBCPVJlZmxlY3QuZ2V0KE0sU3ltYm9sLml0ZXJhdG9yKTtyZXR1cm4gdHlwZW9mIEI9PVwiZnVuY3Rpb25cIj9FLmNvbnZlcnRlcnNbXCJzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj5cIl0oTSxCLmJpbmQoTSkpOkUuY29udmVydGVyc1tcInJlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPlwiXShNKX10aHJvdyBFLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtwcmVmaXg6XCJIZWFkZXJzIGNvbnN0cnVjdG9yXCIsYXJndW1lbnQ6XCJBcmd1bWVudCAxXCIsdHlwZXM6W1wic2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+XCIsXCJyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz5cIl19KX0saGVhZGVycz17ZmlsbDpMLGNvbXBhcmVIZWFkZXJOYW1lOmwsSGVhZGVyczprLEhlYWRlcnNMaXN0OlN9LGhlYWRlcnN9byhyZXF1aXJlSGVhZGVycyxcInJlcXVpcmVIZWFkZXJzXCIpO3ZhciByZXNwb25zZSxoYXNSZXF1aXJlZFJlc3BvbnNlO2Z1bmN0aW9uIHJlcXVpcmVSZXNwb25zZSgpe2lmKGhhc1JlcXVpcmVkUmVzcG9uc2UpcmV0dXJuIHJlc3BvbnNlO2hhc1JlcXVpcmVkUmVzcG9uc2U9MTtjb25zdHtIZWFkZXJzOmUsSGVhZGVyc0xpc3Q6QSxmaWxsOnR9PXJlcXVpcmVIZWFkZXJzKCkse2V4dHJhY3RCb2R5Om4sY2xvbmVCb2R5OnIsbWl4aW5Cb2R5OnN9PXJlcXVpcmVCb2R5KCksaT11dGlsJG0sRT1yZXF1aXJlJCQwX19kZWZhdWx0JDEse2tFbnVtZXJhYmxlUHJvcGVydHk6UX09aSx7aXNWYWxpZFJlYXNvblBocmFzZTpDLGlzQ2FuY2VsbGVkOkksaXNBYm9ydGVkOmEsaXNCbG9iTGlrZTpmLHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZzpoLGlzRXJyb3JMaWtlOkwsaXNvbW9ycGhpY0VuY29kZTpjfT1yZXF1aXJlVXRpbCQ1KCkse3JlZGlyZWN0U3RhdHVzU2V0OmwsbnVsbEJvZHlTdGF0dXM6U309cmVxdWlyZUNvbnN0YW50cyQyKCkse2tTdGF0ZTprLGtIZWFkZXJzOncsa0d1YXJkOlUsa1JlYWxtOk19PXJlcXVpcmVTeW1ib2xzJDMoKSx7d2ViaWRsOkJ9PXJlcXVpcmVXZWJpZGwoKSx7Rm9ybURhdGE6RH09cmVxdWlyZUZvcm1kYXRhKCkse2dldEdsb2JhbE9yaWdpbjpHfT1yZXF1aXJlR2xvYmFsKCkse1VSTFNlcmlhbGl6ZXI6Z309cmVxdWlyZURhdGFVcmwoKSx7a0hlYWRlcnNMaXN0OmQsa0NvbnN0cnVjdDpGfT1zeW1ib2xzJDQsTj1yZXF1aXJlJCQwX19kZWZhdWx0LHt0eXBlczp1fT1yZXF1aXJlJCQwX19kZWZhdWx0JDEsYj1uZXcgVGV4dEVuY29kZXIoXCJ1dGYtOFwiKSwkPWNsYXNzICR7c3RhdGljIGVycm9yKCl7Y29uc3QgcT17c2V0dGluZ3NPYmplY3Q6e319O3JldHVybiBYKFooKSxcImltbXV0YWJsZVwiLHEpfXN0YXRpYyBqc29uKHEsej17fSl7Qi5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6XCJSZXNwb25zZS5qc29uXCJ9KSx6IT09bnVsbCYmKHo9Qi5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdCh6KSk7Y29uc3QgckE9Yi5lbmNvZGUoaChxKSksaUE9bihyQSksZ0E9e3NldHRpbmdzT2JqZWN0Ont9fSxCQT1YKHYoe30pLFwicmVzcG9uc2VcIixnQSk7cmV0dXJuIGFBKEJBLHose2JvZHk6aUFbMF0sdHlwZTpcImFwcGxpY2F0aW9uL2pzb25cIn0pLEJBfXN0YXRpYyByZWRpcmVjdChxLHo9MzAyKXtjb25zdCByQT17c2V0dGluZ3NPYmplY3Q6e319O0IuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMSx7aGVhZGVyOlwiUmVzcG9uc2UucmVkaXJlY3RcIn0pLHE9Qi5jb252ZXJ0ZXJzLlVTVlN0cmluZyhxKSx6PUIuY29udmVydGVyc1tcInVuc2lnbmVkIHNob3J0XCJdKHopO2xldCBpQTt0cnl7aUE9bmV3IFVSTChxLEcoKSl9Y2F0Y2goc0Epe3Rocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBVUkwgZnJvbSAke3F9YCx7Y2F1c2U6c0F9KX1pZighbC5oYXMoeikpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgc3RhdHVzIGNvZGUgJHt6fWApO2NvbnN0IGdBPVgodih7fSksXCJpbW11dGFibGVcIixyQSk7Z0Fba10uc3RhdHVzPXo7Y29uc3QgQkE9YyhnKGlBKSk7cmV0dXJuIGdBW2tdLmhlYWRlcnNMaXN0LmFwcGVuZChcImxvY2F0aW9uXCIsQkEsITApLGdBfWNvbnN0cnVjdG9yKHE9bnVsbCx6PXt9KXtpZihxPT09RilyZXR1cm47cSE9PW51bGwmJihxPUIuY29udmVydGVycy5Cb2R5SW5pdChxKSksej1CLmNvbnZlcnRlcnMuUmVzcG9uc2VJbml0KHopLHRoaXNbTV09e3NldHRpbmdzT2JqZWN0Ont9fSx0aGlzW2tdPXYoe30pLHRoaXNbd109bmV3IGUoRiksdGhpc1t3XVtVXT1cInJlc3BvbnNlXCIsdGhpc1t3XVtkXT10aGlzW2tdLmhlYWRlcnNMaXN0LHRoaXNbd11bTV09dGhpc1tNXTtsZXQgckE9bnVsbDtpZihxIT1udWxsKXtjb25zdFtpQSxnQV09bihxKTtyQT17Ym9keTppQSx0eXBlOmdBfX1hQSh0aGlzLHosckEpfWdldCB0eXBlKCl7cmV0dXJuIEIuYnJhbmRDaGVjayh0aGlzLCQpLHRoaXNba10udHlwZX1nZXQgdXJsKCl7Qi5icmFuZENoZWNrKHRoaXMsJCk7Y29uc3QgcT10aGlzW2tdLnVybExpc3Qsej1xW3EubGVuZ3RoLTFdPz9udWxsO3JldHVybiB6PT09bnVsbD9cIlwiOmcoeiwhMCl9Z2V0IHJlZGlyZWN0ZWQoKXtyZXR1cm4gQi5icmFuZENoZWNrKHRoaXMsJCksdGhpc1trXS51cmxMaXN0Lmxlbmd0aD4xfWdldCBzdGF0dXMoKXtyZXR1cm4gQi5icmFuZENoZWNrKHRoaXMsJCksdGhpc1trXS5zdGF0dXN9Z2V0IG9rKCl7cmV0dXJuIEIuYnJhbmRDaGVjayh0aGlzLCQpLHRoaXNba10uc3RhdHVzPj0yMDAmJnRoaXNba10uc3RhdHVzPD0yOTl9Z2V0IHN0YXR1c1RleHQoKXtyZXR1cm4gQi5icmFuZENoZWNrKHRoaXMsJCksdGhpc1trXS5zdGF0dXNUZXh0fWdldCBoZWFkZXJzKCl7cmV0dXJuIEIuYnJhbmRDaGVjayh0aGlzLCQpLHRoaXNbd119Z2V0IGJvZHkoKXtyZXR1cm4gQi5icmFuZENoZWNrKHRoaXMsJCksdGhpc1trXS5ib2R5P3RoaXNba10uYm9keS5zdHJlYW06bnVsbH1nZXQgYm9keVVzZWQoKXtyZXR1cm4gQi5icmFuZENoZWNrKHRoaXMsJCksISF0aGlzW2tdLmJvZHkmJmkuaXNEaXN0dXJiZWQodGhpc1trXS5ib2R5LnN0cmVhbSl9Y2xvbmUoKXtpZihCLmJyYW5kQ2hlY2sodGhpcywkKSx0aGlzLmJvZHlVc2VkfHx0aGlzLmJvZHk/LmxvY2tlZCl0aHJvdyBCLmVycm9ycy5leGNlcHRpb24oe2hlYWRlcjpcIlJlc3BvbnNlLmNsb25lXCIsbWVzc2FnZTpcIkJvZHkgaGFzIGFscmVhZHkgYmVlbiBjb25zdW1lZC5cIn0pO2NvbnN0IHE9VCh0aGlzW2tdKTtyZXR1cm4gWChxLHRoaXNbd11bVV0sdGhpc1tNXSl9W0UuaW5zcGVjdC5jdXN0b21dKHEseil7ei5kZXB0aD09PW51bGwmJih6LmRlcHRoPTIpLHouY29sb3JzPz8oei5jb2xvcnM9ITApO2NvbnN0IHJBPXtzdGF0dXM6dGhpcy5zdGF0dXMsc3RhdHVzVGV4dDp0aGlzLnN0YXR1c1RleHQsaGVhZGVyczp0aGlzLmhlYWRlcnMsYm9keTp0aGlzLmJvZHksYm9keVVzZWQ6dGhpcy5ib2R5VXNlZCxvazp0aGlzLm9rLHJlZGlyZWN0ZWQ6dGhpcy5yZWRpcmVjdGVkLHR5cGU6dGhpcy50eXBlLHVybDp0aGlzLnVybH07cmV0dXJuYFJlc3BvbnNlICR7RS5mb3JtYXRXaXRoT3B0aW9ucyh6LHJBKX1gfX07bygkLFwiUmVzcG9uc2VcIik7bGV0IG09JDtzKG0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG0ucHJvdG90eXBlLHt0eXBlOlEsdXJsOlEsc3RhdHVzOlEsb2s6USxyZWRpcmVjdGVkOlEsc3RhdHVzVGV4dDpRLGhlYWRlcnM6USxjbG9uZTpRLGJvZHk6USxib2R5VXNlZDpRLFtTeW1ib2wudG9TdHJpbmdUYWddOnt2YWx1ZTpcIlJlc3BvbnNlXCIsY29uZmlndXJhYmxlOiEwfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG0se2pzb246USxyZWRpcmVjdDpRLGVycm9yOlF9KTtmdW5jdGlvbiBUKFYpe2lmKFYuaW50ZXJuYWxSZXNwb25zZSlyZXR1cm4gSyhUKFYuaW50ZXJuYWxSZXNwb25zZSksVi50eXBlKTtjb25zdCBxPXYoey4uLlYsYm9keTpudWxsfSk7cmV0dXJuIFYuYm9keSE9bnVsbCYmKHEuYm9keT1yKFYuYm9keSkpLHF9byhULFwiY2xvbmVSZXNwb25zZVwiKTtmdW5jdGlvbiB2KFYpe3JldHVybnthYm9ydGVkOiExLHJhbmdlUmVxdWVzdGVkOiExLHRpbWluZ0FsbG93UGFzc2VkOiExLHJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzOiExLHR5cGU6XCJkZWZhdWx0XCIsc3RhdHVzOjIwMCx0aW1pbmdJbmZvOm51bGwsY2FjaGVTdGF0ZTpcIlwiLHN0YXR1c1RleHQ6XCJcIiwuLi5WLGhlYWRlcnNMaXN0OlY/LmhlYWRlcnNMaXN0P25ldyBBKFY/LmhlYWRlcnNMaXN0KTpuZXcgQSx1cmxMaXN0OlY/LnVybExpc3Q/Wy4uLlYudXJsTGlzdF06W119fW8odixcIm1ha2VSZXNwb25zZVwiKTtmdW5jdGlvbiBaKFYpe2NvbnN0IHE9TChWKTtyZXR1cm4gdih7dHlwZTpcImVycm9yXCIsc3RhdHVzOjAsZXJyb3I6cT9WOm5ldyBFcnJvcihWJiZTdHJpbmcoVikpLGFib3J0ZWQ6ViYmVi5uYW1lPT09XCJBYm9ydEVycm9yXCJ9KX1vKFosXCJtYWtlTmV0d29ya0Vycm9yXCIpO2Z1bmN0aW9uIFAoVil7cmV0dXJuIFYudHlwZT09PVwiZXJyb3JcIiYmVi5zdGF0dXM9PT0wfW8oUCxcImlzTmV0d29ya0Vycm9yXCIpO2Z1bmN0aW9uIEFBKFYscSl7cmV0dXJuIHE9e2ludGVybmFsUmVzcG9uc2U6ViwuLi5xfSxuZXcgUHJveHkoVix7Z2V0KHosckEpe3JldHVybiByQSBpbiBxP3FbckFdOnpbckFdfSxzZXQoeixyQSxpQSl7cmV0dXJuIE4oIShyQSBpbiBxKSkseltyQV09aUEsITB9fSl9byhBQSxcIm1ha2VGaWx0ZXJlZFJlc3BvbnNlXCIpO2Z1bmN0aW9uIEsoVixxKXtpZihxPT09XCJiYXNpY1wiKXJldHVybiBBQShWLHt0eXBlOlwiYmFzaWNcIixoZWFkZXJzTGlzdDpWLmhlYWRlcnNMaXN0fSk7aWYocT09PVwiY29yc1wiKXJldHVybiBBQShWLHt0eXBlOlwiY29yc1wiLGhlYWRlcnNMaXN0OlYuaGVhZGVyc0xpc3R9KTtpZihxPT09XCJvcGFxdWVcIilyZXR1cm4gQUEoVix7dHlwZTpcIm9wYXF1ZVwiLHVybExpc3Q6T2JqZWN0LmZyZWV6ZShbXSksc3RhdHVzOjAsc3RhdHVzVGV4dDpcIlwiLGJvZHk6bnVsbH0pO2lmKHE9PT1cIm9wYXF1ZXJlZGlyZWN0XCIpcmV0dXJuIEFBKFYse3R5cGU6XCJvcGFxdWVyZWRpcmVjdFwiLHN0YXR1czowLHN0YXR1c1RleHQ6XCJcIixoZWFkZXJzTGlzdDpbXSxib2R5Om51bGx9KTtOKCExKX1vKEssXCJmaWx0ZXJSZXNwb25zZVwiKTtmdW5jdGlvbiB0QShWLHE9bnVsbCl7cmV0dXJuIE4oSShWKSksYShWKT9aKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbihcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIsXCJBYm9ydEVycm9yXCIpLHtjYXVzZTpxfSkpOlooT2JqZWN0LmFzc2lnbihuZXcgRE9NRXhjZXB0aW9uKFwiUmVxdWVzdCB3YXMgY2FuY2VsbGVkLlwiKSx7Y2F1c2U6cX0pKX1vKHRBLFwibWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yXCIpO2Z1bmN0aW9uIGFBKFYscSx6KXtpZihxLnN0YXR1cyE9PW51bGwmJihxLnN0YXR1czwyMDB8fHEuc3RhdHVzPjU5OSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luaXRbXCJzdGF0dXNcIl0gbXVzdCBiZSBpbiB0aGUgcmFuZ2Ugb2YgMjAwIHRvIDU5OSwgaW5jbHVzaXZlLicpO2lmKFwic3RhdHVzVGV4dFwiaW4gcSYmcS5zdGF0dXNUZXh0IT1udWxsJiYhQyhTdHJpbmcocS5zdGF0dXNUZXh0KSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzVGV4dFwiKTtpZihcInN0YXR1c1wiaW4gcSYmcS5zdGF0dXMhPW51bGwmJihWW2tdLnN0YXR1cz1xLnN0YXR1cyksXCJzdGF0dXNUZXh0XCJpbiBxJiZxLnN0YXR1c1RleHQhPW51bGwmJihWW2tdLnN0YXR1c1RleHQ9cS5zdGF0dXNUZXh0KSxcImhlYWRlcnNcImluIHEmJnEuaGVhZGVycyE9bnVsbCYmdChWW3ddLHEuaGVhZGVycykseil7aWYoUy5pbmNsdWRlcyhWLnN0YXR1cykpdGhyb3cgQi5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJSZXNwb25zZSBjb25zdHJ1Y3RvclwiLG1lc3NhZ2U6YEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgJHtWLnN0YXR1c31gfSk7VltrXS5ib2R5PXouYm9keSx6LnR5cGUhPW51bGwmJiFWW2tdLmhlYWRlcnNMaXN0LmNvbnRhaW5zKFwiY29udGVudC10eXBlXCIsITApJiZWW2tdLmhlYWRlcnNMaXN0LmFwcGVuZChcImNvbnRlbnQtdHlwZVwiLHoudHlwZSwhMCl9fW8oYUEsXCJpbml0aWFsaXplUmVzcG9uc2VcIik7ZnVuY3Rpb24gWChWLHEseil7Y29uc3QgckE9bmV3IG0oRik7cmV0dXJuIHJBW2tdPVYsckFbTV09eixyQVt3XT1uZXcgZShGKSxyQVt3XVtkXT1WLmhlYWRlcnNMaXN0LHJBW3ddW1VdPXEsckFbd11bTV09eixyQX1yZXR1cm4gbyhYLFwiZnJvbUlubmVyUmVzcG9uc2VcIiksQi5jb252ZXJ0ZXJzLlJlYWRhYmxlU3RyZWFtPUIuaW50ZXJmYWNlQ29udmVydGVyKFJlYWRhYmxlU3RyZWFtKSxCLmNvbnZlcnRlcnMuRm9ybURhdGE9Qi5pbnRlcmZhY2VDb252ZXJ0ZXIoRCksQi5jb252ZXJ0ZXJzLlVSTFNlYXJjaFBhcmFtcz1CLmludGVyZmFjZUNvbnZlcnRlcihVUkxTZWFyY2hQYXJhbXMpLEIuY29udmVydGVycy5YTUxIdHRwUmVxdWVzdEJvZHlJbml0PWZ1bmN0aW9uKFYpe3JldHVybiB0eXBlb2YgVj09XCJzdHJpbmdcIj9CLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpOmYoVik/Qi5jb252ZXJ0ZXJzLkJsb2IoVix7c3RyaWN0OiExfSk6QXJyYXlCdWZmZXIuaXNWaWV3KFYpfHx1LmlzQXJyYXlCdWZmZXIoVik/Qi5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShWKTppLmlzRm9ybURhdGFMaWtlKFYpP0IuY29udmVydGVycy5Gb3JtRGF0YShWLHtzdHJpY3Q6ITF9KTpWIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zP0IuY29udmVydGVycy5VUkxTZWFyY2hQYXJhbXMoVik6Qi5jb252ZXJ0ZXJzLkRPTVN0cmluZyhWKX0sQi5jb252ZXJ0ZXJzLkJvZHlJbml0PWZ1bmN0aW9uKFYpe3JldHVybiBWIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0/Qi5jb252ZXJ0ZXJzLlJlYWRhYmxlU3RyZWFtKFYpOlY/LltTeW1ib2wuYXN5bmNJdGVyYXRvcl0/VjpCLmNvbnZlcnRlcnMuWE1MSHR0cFJlcXVlc3RCb2R5SW5pdChWKX0sQi5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdD1CLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW3trZXk6XCJzdGF0dXNcIixjb252ZXJ0ZXI6Qi5jb252ZXJ0ZXJzW1widW5zaWduZWQgc2hvcnRcIl0sZGVmYXVsdFZhbHVlOjIwMH0se2tleTpcInN0YXR1c1RleHRcIixjb252ZXJ0ZXI6Qi5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcsZGVmYXVsdFZhbHVlOlwiXCJ9LHtrZXk6XCJoZWFkZXJzXCIsY29udmVydGVyOkIuY29udmVydGVycy5IZWFkZXJzSW5pdH1dKSxyZXNwb25zZT17aXNOZXR3b3JrRXJyb3I6UCxtYWtlTmV0d29ya0Vycm9yOlosbWFrZVJlc3BvbnNlOnYsbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yOnRBLGZpbHRlclJlc3BvbnNlOkssUmVzcG9uc2U6bSxjbG9uZVJlc3BvbnNlOlQsZnJvbUlubmVyUmVzcG9uc2U6WH0scmVzcG9uc2V9byhyZXF1aXJlUmVzcG9uc2UsXCJyZXF1aXJlUmVzcG9uc2VcIik7dmFyIGRpc3BhdGNoZXJXZWFrcmVmLGhhc1JlcXVpcmVkRGlzcGF0Y2hlcldlYWtyZWY7ZnVuY3Rpb24gcmVxdWlyZURpc3BhdGNoZXJXZWFrcmVmKCl7aWYoaGFzUmVxdWlyZWREaXNwYXRjaGVyV2Vha3JlZilyZXR1cm4gZGlzcGF0Y2hlcldlYWtyZWY7aGFzUmVxdWlyZWREaXNwYXRjaGVyV2Vha3JlZj0xO2NvbnN0e2tDb25uZWN0ZWQ6ZSxrU2l6ZTpBfT1zeW1ib2xzJDQscj1jbGFzcyBye2NvbnN0cnVjdG9yKEUpe3RoaXMudmFsdWU9RX1kZXJlZigpe3JldHVybiB0aGlzLnZhbHVlW2VdPT09MCYmdGhpcy52YWx1ZVtBXT09PTA/dm9pZCAwOnRoaXMudmFsdWV9fTtvKHIsXCJDb21wYXRXZWFrUmVmXCIpO2xldCB0PXI7Y29uc3Qgcz1jbGFzcyBze2NvbnN0cnVjdG9yKEUpe3RoaXMuZmluYWxpemVyPUV9cmVnaXN0ZXIoRSxRKXtFLm9uJiZFLm9uKFwiZGlzY29ubmVjdFwiLCgpPT57RVtlXT09PTAmJkVbQV09PT0wJiZ0aGlzLmZpbmFsaXplcihRKX0pfXVucmVnaXN0ZXIoRSl7fX07byhzLFwiQ29tcGF0RmluYWxpemVyXCIpO2xldCBuPXM7cmV0dXJuIGRpc3BhdGNoZXJXZWFrcmVmPW8oZnVuY3Rpb24oKXtyZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9WOF9DT1ZFUkFHRT97V2Vha1JlZjp0LEZpbmFsaXphdGlvblJlZ2lzdHJ5Om59OntXZWFrUmVmLEZpbmFsaXphdGlvblJlZ2lzdHJ5fX0sXCJkaXNwYXRjaGVyV2Vha3JlZlwiKSxkaXNwYXRjaGVyV2Vha3JlZn1vKHJlcXVpcmVEaXNwYXRjaGVyV2Vha3JlZixcInJlcXVpcmVEaXNwYXRjaGVyV2Vha3JlZlwiKTt2YXIgcmVxdWVzdCxoYXNSZXF1aXJlZFJlcXVlc3Q7ZnVuY3Rpb24gcmVxdWlyZVJlcXVlc3QoKXtpZihoYXNSZXF1aXJlZFJlcXVlc3QpcmV0dXJuIHJlcXVlc3Q7aGFzUmVxdWlyZWRSZXF1ZXN0PTE7Y29uc3R7ZXh0cmFjdEJvZHk6ZSxtaXhpbkJvZHk6QSxjbG9uZUJvZHk6dH09cmVxdWlyZUJvZHkoKSx7SGVhZGVyczpuLGZpbGw6cixIZWFkZXJzTGlzdDpzfT1yZXF1aXJlSGVhZGVycygpLHtGaW5hbGl6YXRpb25SZWdpc3RyeTppfT1yZXF1aXJlRGlzcGF0Y2hlcldlYWtyZWYoKSgpLEU9dXRpbCRtLFE9cmVxdWlyZSQkMF9fZGVmYXVsdCQxLHtpc1ZhbGlkSFRUUFRva2VuOkMsc2FtZU9yaWdpbjpJLG5vcm1hbGl6ZU1ldGhvZDphLG1ha2VQb2xpY3lDb250YWluZXI6Zixub3JtYWxpemVNZXRob2RSZWNvcmQ6aH09cmVxdWlyZVV0aWwkNSgpLHtmb3JiaWRkZW5NZXRob2RzU2V0OkwsY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0OmMscmVmZXJyZXJQb2xpY3k6bCxyZXF1ZXN0UmVkaXJlY3Q6UyxyZXF1ZXN0TW9kZTprLHJlcXVlc3RDcmVkZW50aWFsczp3LHJlcXVlc3RDYWNoZTpVLHJlcXVlc3REdXBsZXg6TX09cmVxdWlyZUNvbnN0YW50cyQyKCkse2tFbnVtZXJhYmxlUHJvcGVydHk6Qn09RSx7a0hlYWRlcnM6RCxrU2lnbmFsOkcsa1N0YXRlOmcsa0d1YXJkOmQsa1JlYWxtOkYsa0Rpc3BhdGNoZXI6Tn09cmVxdWlyZVN5bWJvbHMkMygpLHt3ZWJpZGw6dX09cmVxdWlyZVdlYmlkbCgpLHtnZXRHbG9iYWxPcmlnaW46Yn09cmVxdWlyZUdsb2JhbCgpLHtVUkxTZXJpYWxpemVyOm19PXJlcXVpcmVEYXRhVXJsKCkse2tIZWFkZXJzTGlzdDpULGtDb25zdHJ1Y3Q6dn09c3ltYm9scyQ0LFo9cmVxdWlyZSQkMF9fZGVmYXVsdCx7Z2V0TWF4TGlzdGVuZXJzOlAsc2V0TWF4TGlzdGVuZXJzOkFBLGdldEV2ZW50TGlzdGVuZXJzOkssZGVmYXVsdE1heExpc3RlbmVyczp0QX09cmVxdWlyZSQkMF9fZGVmYXVsdCQzLGFBPVN5bWJvbChcImFib3J0Q29udHJvbGxlclwiKSxYPW5ldyBpKCh7c2lnbmFsOmdBLGFib3J0OkJBfSk9PntnQS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIixCQSl9KTtsZXQgJD0hMTtjb25zdCBpQT1jbGFzcyBpQXtjb25zdHJ1Y3RvcihCQSxzQT17fSl7aWYoQkE9PT12KXJldHVybjt1LmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLDEse2hlYWRlcjpcIlJlcXVlc3QgY29uc3RydWN0b3JcIn0pLEJBPXUuY29udmVydGVycy5SZXF1ZXN0SW5mbyhCQSksc0E9dS5jb252ZXJ0ZXJzLlJlcXVlc3RJbml0KHNBKSx0aGlzW0ZdPXtzZXR0aW5nc09iamVjdDp7YmFzZVVybDpiKCksZ2V0IG9yaWdpbigpe3JldHVybiB0aGlzLmJhc2VVcmw/Lm9yaWdpbn0scG9saWN5Q29udGFpbmVyOmYoKX19O2xldCBlQT1udWxsLHlBPW51bGw7Y29uc3QgV0E9dGhpc1tGXS5zZXR0aW5nc09iamVjdC5iYXNlVXJsO2xldCB3QT1udWxsO2lmKHR5cGVvZiBCQT09XCJzdHJpbmdcIil7dGhpc1tOXT1zQS5kaXNwYXRjaGVyO2xldCBJQTt0cnl7SUE9bmV3IFVSTChCQSxXQSl9Y2F0Y2goaEEpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgVVJMIGZyb20gXCIrQkEse2NhdXNlOmhBfSl9aWYoSUEudXNlcm5hbWV8fElBLnBhc3N3b3JkKXRocm93IG5ldyBUeXBlRXJyb3IoXCJSZXF1ZXN0IGNhbm5vdCBiZSBjb25zdHJ1Y3RlZCBmcm9tIGEgVVJMIHRoYXQgaW5jbHVkZXMgY3JlZGVudGlhbHM6IFwiK0JBKTtlQT1xKHt1cmxMaXN0OltJQV19KSx5QT1cImNvcnNcIn1lbHNlIHRoaXNbTl09c0EuZGlzcGF0Y2hlcnx8QkFbTl0sWihCQSBpbnN0YW5jZW9mIGlBKSxlQT1CQVtnXSx3QT1CQVtHXTtjb25zdCBxQT10aGlzW0ZdLnNldHRpbmdzT2JqZWN0Lm9yaWdpbjtsZXQgTUE9XCJjbGllbnRcIjtpZihlQS53aW5kb3c/LmNvbnN0cnVjdG9yPy5uYW1lPT09XCJFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0XCImJkkoZUEud2luZG93LHFBKSYmKE1BPWVBLndpbmRvdyksc0Eud2luZG93IT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoYCd3aW5kb3cnIG9wdGlvbiAnJHtNQX0nIG11c3QgYmUgbnVsbGApO1wid2luZG93XCJpbiBzQSYmKE1BPVwibm8td2luZG93XCIpLGVBPXEoe21ldGhvZDplQS5tZXRob2QsaGVhZGVyc0xpc3Q6ZUEuaGVhZGVyc0xpc3QsdW5zYWZlUmVxdWVzdDplQS51bnNhZmVSZXF1ZXN0LGNsaWVudDp0aGlzW0ZdLnNldHRpbmdzT2JqZWN0LHdpbmRvdzpNQSxwcmlvcml0eTplQS5wcmlvcml0eSxvcmlnaW46ZUEub3JpZ2luLHJlZmVycmVyOmVBLnJlZmVycmVyLHJlZmVycmVyUG9saWN5OmVBLnJlZmVycmVyUG9saWN5LG1vZGU6ZUEubW9kZSxjcmVkZW50aWFsczplQS5jcmVkZW50aWFscyxjYWNoZTplQS5jYWNoZSxyZWRpcmVjdDplQS5yZWRpcmVjdCxpbnRlZ3JpdHk6ZUEuaW50ZWdyaXR5LGtlZXBhbGl2ZTplQS5rZWVwYWxpdmUscmVsb2FkTmF2aWdhdGlvbjplQS5yZWxvYWROYXZpZ2F0aW9uLGhpc3RvcnlOYXZpZ2F0aW9uOmVBLmhpc3RvcnlOYXZpZ2F0aW9uLHVybExpc3Q6Wy4uLmVBLnVybExpc3RdfSk7Y29uc3QgSEE9T2JqZWN0LmtleXMoc0EpLmxlbmd0aCE9PTA7aWYoSEEmJihlQS5tb2RlPT09XCJuYXZpZ2F0ZVwiJiYoZUEubW9kZT1cInNhbWUtb3JpZ2luXCIpLGVBLnJlbG9hZE5hdmlnYXRpb249ITEsZUEuaGlzdG9yeU5hdmlnYXRpb249ITEsZUEub3JpZ2luPVwiY2xpZW50XCIsZUEucmVmZXJyZXI9XCJjbGllbnRcIixlQS5yZWZlcnJlclBvbGljeT1cIlwiLGVBLnVybD1lQS51cmxMaXN0W2VBLnVybExpc3QubGVuZ3RoLTFdLGVBLnVybExpc3Q9W2VBLnVybF0pLHNBLnJlZmVycmVyIT09dm9pZCAwKXtjb25zdCBJQT1zQS5yZWZlcnJlcjtpZihJQT09PVwiXCIpZUEucmVmZXJyZXI9XCJuby1yZWZlcnJlclwiO2Vsc2V7bGV0IGhBO3RyeXtoQT1uZXcgVVJMKElBLFdBKX1jYXRjaChTQSl7dGhyb3cgbmV3IFR5cGVFcnJvcihgUmVmZXJyZXIgXCIke0lBfVwiIGlzIG5vdCBhIHZhbGlkIFVSTC5gLHtjYXVzZTpTQX0pfWhBLnByb3RvY29sPT09XCJhYm91dDpcIiYmaEEuaG9zdG5hbWU9PT1cImNsaWVudFwifHxxQSYmIUkoaEEsdGhpc1tGXS5zZXR0aW5nc09iamVjdC5iYXNlVXJsKT9lQS5yZWZlcnJlcj1cImNsaWVudFwiOmVBLnJlZmVycmVyPWhBfX1zQS5yZWZlcnJlclBvbGljeSE9PXZvaWQgMCYmKGVBLnJlZmVycmVyUG9saWN5PXNBLnJlZmVycmVyUG9saWN5KTtsZXQgcEE7aWYoc0EubW9kZSE9PXZvaWQgMD9wQT1zQS5tb2RlOnBBPXlBLHBBPT09XCJuYXZpZ2F0ZVwiKXRocm93IHUuZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOlwiUmVxdWVzdCBjb25zdHJ1Y3RvclwiLG1lc3NhZ2U6XCJpbnZhbGlkIHJlcXVlc3QgbW9kZSBuYXZpZ2F0ZS5cIn0pO2lmKHBBIT1udWxsJiYoZUEubW9kZT1wQSksc0EuY3JlZGVudGlhbHMhPT12b2lkIDAmJihlQS5jcmVkZW50aWFscz1zQS5jcmVkZW50aWFscyksc0EuY2FjaGUhPT12b2lkIDAmJihlQS5jYWNoZT1zQS5jYWNoZSksZUEuY2FjaGU9PT1cIm9ubHktaWYtY2FjaGVkXCImJmVBLm1vZGUhPT1cInNhbWUtb3JpZ2luXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvbmx5LWlmLWNhY2hlZCcgY2FuIGJlIHNldCBvbmx5IHdpdGggJ3NhbWUtb3JpZ2luJyBtb2RlXCIpO2lmKHNBLnJlZGlyZWN0IT09dm9pZCAwJiYoZUEucmVkaXJlY3Q9c0EucmVkaXJlY3QpLHNBLmludGVncml0eSE9bnVsbCYmKGVBLmludGVncml0eT1TdHJpbmcoc0EuaW50ZWdyaXR5KSksc0Eua2VlcGFsaXZlIT09dm9pZCAwJiYoZUEua2VlcGFsaXZlPSEhc0Eua2VlcGFsaXZlKSxzQS5tZXRob2QhPT12b2lkIDApe2xldCBJQT1zQS5tZXRob2Q7Y29uc3QgaEE9aFtJQV07aWYoaEEhPT12b2lkIDApZUEubWV0aG9kPWhBO2Vsc2V7aWYoIUMoSUEpKXRocm93IG5ldyBUeXBlRXJyb3IoYCcke0lBfScgaXMgbm90IGEgdmFsaWQgSFRUUCBtZXRob2QuYCk7aWYoTC5oYXMoSUEudG9VcHBlckNhc2UoKSkpdGhyb3cgbmV3IFR5cGVFcnJvcihgJyR7SUF9JyBIVFRQIG1ldGhvZCBpcyB1bnN1cHBvcnRlZC5gKTtJQT1hKElBKSxlQS5tZXRob2Q9SUF9ISQmJmVBLm1ldGhvZD09PVwicGF0Y2hcIiYmKHByb2Nlc3MuZW1pdFdhcm5pbmcoXCJVc2luZyBgcGF0Y2hgIGlzIGhpZ2hseSBsaWtlbHkgdG8gcmVzdWx0IGluIGEgYDQwNSBNZXRob2QgTm90IEFsbG93ZWRgLiBgUEFUQ0hgIGlzIG11Y2ggbW9yZSBsaWtlbHkgdG8gc3VjY2VlZC5cIix7Y29kZTpcIlVORElDSS1GRVRDSC1wYXRjaFwifSksJD0hMCl9c0Euc2lnbmFsIT09dm9pZCAwJiYod0E9c0Euc2lnbmFsKSx0aGlzW2ddPWVBO2NvbnN0IFlBPW5ldyBBYm9ydENvbnRyb2xsZXI7aWYodGhpc1tHXT1ZQS5zaWduYWwsdGhpc1tHXVtGXT10aGlzW0ZdLHdBIT1udWxsKXtpZighd0F8fHR5cGVvZiB3QS5hYm9ydGVkIT1cImJvb2xlYW5cInx8dHlwZW9mIHdBLmFkZEV2ZW50TGlzdGVuZXIhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IG1lbWJlciBzaWduYWwgaXMgbm90IG9mIHR5cGUgQWJvcnRTaWduYWwuXCIpO2lmKHdBLmFib3J0ZWQpWUEuYWJvcnQod0EucmVhc29uKTtlbHNle3RoaXNbYUFdPVlBO2NvbnN0IElBPW5ldyBXZWFrUmVmKFlBKSxoQT1vKGZ1bmN0aW9uKCl7Y29uc3QgU0E9SUEuZGVyZWYoKTtTQSE9PXZvaWQgMCYmKFgudW5yZWdpc3RlcihoQSksdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIixoQSksU0EuYWJvcnQodGhpcy5yZWFzb24pKX0sXCJhYm9ydFwiKTt0cnl7KHR5cGVvZiBQPT1cImZ1bmN0aW9uXCImJlAod0EpPT09dEF8fEsod0EsXCJhYm9ydFwiKS5sZW5ndGg+PXRBKSYmQUEoMTAwLHdBKX1jYXRjaHt9RS5hZGRBYm9ydExpc3RlbmVyKHdBLGhBKSxYLnJlZ2lzdGVyKFlBLHtzaWduYWw6d0EsYWJvcnQ6aEF9LGhBKX19aWYodGhpc1tEXT1uZXcgbih2KSx0aGlzW0RdW1RdPWVBLmhlYWRlcnNMaXN0LHRoaXNbRF1bZF09XCJyZXF1ZXN0XCIsdGhpc1tEXVtGXT10aGlzW0ZdLHBBPT09XCJuby1jb3JzXCIpe2lmKCFjLmhhcyhlQS5tZXRob2QpKXRocm93IG5ldyBUeXBlRXJyb3IoYCcke2VBLm1ldGhvZH0gaXMgdW5zdXBwb3J0ZWQgaW4gbm8tY29ycyBtb2RlLmApO3RoaXNbRF1bZF09XCJyZXF1ZXN0LW5vLWNvcnNcIn1pZihIQSl7Y29uc3QgSUE9dGhpc1tEXVtUXSxoQT1zQS5oZWFkZXJzIT09dm9pZCAwP3NBLmhlYWRlcnM6bmV3IHMoSUEpO2lmKElBLmNsZWFyKCksaEEgaW5zdGFuY2VvZiBzKXtmb3IoY29uc3RbU0EsUEFdb2YgaEEpSUEuYXBwZW5kKFNBLFBBKTtJQS5jb29raWVzPWhBLmNvb2tpZXN9ZWxzZSByKHRoaXNbRF0saEEpfWNvbnN0IFVBPUJBIGluc3RhbmNlb2YgaUE/QkFbZ10uYm9keTpudWxsO2lmKChzQS5ib2R5IT1udWxsfHxVQSE9bnVsbCkmJihlQS5tZXRob2Q9PT1cIkdFVFwifHxlQS5tZXRob2Q9PT1cIkhFQURcIikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJlcXVlc3Qgd2l0aCBHRVQvSEVBRCBtZXRob2QgY2Fubm90IGhhdmUgYm9keS5cIik7bGV0IEpBPW51bGw7aWYoc0EuYm9keSE9bnVsbCl7Y29uc3RbSUEsaEFdPWUoc0EuYm9keSxlQS5rZWVwYWxpdmUpO0pBPUlBLGhBJiYhdGhpc1tEXVtUXS5jb250YWlucyhcImNvbnRlbnQtdHlwZVwiLCEwKSYmdGhpc1tEXS5hcHBlbmQoXCJjb250ZW50LXR5cGVcIixoQSl9Y29uc3QgVkE9SkE/P1VBO2lmKFZBIT1udWxsJiZWQS5zb3VyY2U9PW51bGwpe2lmKEpBIT1udWxsJiZzQS5kdXBsZXg9PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJlcXVlc3RJbml0OiBkdXBsZXggb3B0aW9uIGlzIHJlcXVpcmVkIHdoZW4gc2VuZGluZyBhIGJvZHkuXCIpO2lmKGVBLm1vZGUhPT1cInNhbWUtb3JpZ2luXCImJmVBLm1vZGUhPT1cImNvcnNcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdJZiByZXF1ZXN0IGlzIG1hZGUgZnJvbSBSZWFkYWJsZVN0cmVhbSwgbW9kZSBzaG91bGQgYmUgXCJzYW1lLW9yaWdpblwiIG9yIFwiY29yc1wiJyk7ZUEudXNlQ09SU1ByZWZsaWdodEZsYWc9ITB9bGV0IE9BPVZBO2lmKEpBPT1udWxsJiZVQSE9bnVsbCl7aWYoRS5pc0Rpc3R1cmJlZChVQS5zdHJlYW0pfHxVQS5zdHJlYW0ubG9ja2VkKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29uc3RydWN0IGEgUmVxdWVzdCB3aXRoIGEgUmVxdWVzdCBvYmplY3QgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCIpO2NvbnN0IElBPW5ldyBUcmFuc2Zvcm1TdHJlYW07VUEuc3RyZWFtLnBpcGVUaHJvdWdoKElBKSxPQT17c291cmNlOlVBLnNvdXJjZSxsZW5ndGg6VUEubGVuZ3RoLHN0cmVhbTpJQS5yZWFkYWJsZX19dGhpc1tnXS5ib2R5PU9BfWdldCBtZXRob2QoKXtyZXR1cm4gdS5icmFuZENoZWNrKHRoaXMsaUEpLHRoaXNbZ10ubWV0aG9kfWdldCB1cmwoKXtyZXR1cm4gdS5icmFuZENoZWNrKHRoaXMsaUEpLG0odGhpc1tnXS51cmwpfWdldCBoZWFkZXJzKCl7cmV0dXJuIHUuYnJhbmRDaGVjayh0aGlzLGlBKSx0aGlzW0RdfWdldCBkZXN0aW5hdGlvbigpe3JldHVybiB1LmJyYW5kQ2hlY2sodGhpcyxpQSksdGhpc1tnXS5kZXN0aW5hdGlvbn1nZXQgcmVmZXJyZXIoKXtyZXR1cm4gdS5icmFuZENoZWNrKHRoaXMsaUEpLHRoaXNbZ10ucmVmZXJyZXI9PT1cIm5vLXJlZmVycmVyXCI/XCJcIjp0aGlzW2ddLnJlZmVycmVyPT09XCJjbGllbnRcIj9cImFib3V0OmNsaWVudFwiOnRoaXNbZ10ucmVmZXJyZXIudG9TdHJpbmcoKX1nZXQgcmVmZXJyZXJQb2xpY3koKXtyZXR1cm4gdS5icmFuZENoZWNrKHRoaXMsaUEpLHRoaXNbZ10ucmVmZXJyZXJQb2xpY3l9Z2V0IG1vZGUoKXtyZXR1cm4gdS5icmFuZENoZWNrKHRoaXMsaUEpLHRoaXNbZ10ubW9kZX1nZXQgY3JlZGVudGlhbHMoKXtyZXR1cm4gdGhpc1tnXS5jcmVkZW50aWFsc31nZXQgY2FjaGUoKXtyZXR1cm4gdS5icmFuZENoZWNrKHRoaXMsaUEpLHRoaXNbZ10uY2FjaGV9Z2V0IHJlZGlyZWN0KCl7cmV0dXJuIHUuYnJhbmRDaGVjayh0aGlzLGlBKSx0aGlzW2ddLnJlZGlyZWN0fWdldCBpbnRlZ3JpdHkoKXtyZXR1cm4gdS5icmFuZENoZWNrKHRoaXMsaUEpLHRoaXNbZ10uaW50ZWdyaXR5fWdldCBrZWVwYWxpdmUoKXtyZXR1cm4gdS5icmFuZENoZWNrKHRoaXMsaUEpLHRoaXNbZ10ua2VlcGFsaXZlfWdldCBpc1JlbG9hZE5hdmlnYXRpb24oKXtyZXR1cm4gdS5icmFuZENoZWNrKHRoaXMsaUEpLHRoaXNbZ10ucmVsb2FkTmF2aWdhdGlvbn1nZXQgaXNIaXN0b3J5TmF2aWdhdGlvbigpe3JldHVybiB1LmJyYW5kQ2hlY2sodGhpcyxpQSksdGhpc1tnXS5oaXN0b3J5TmF2aWdhdGlvbn1nZXQgc2lnbmFsKCl7cmV0dXJuIHUuYnJhbmRDaGVjayh0aGlzLGlBKSx0aGlzW0ddfWdldCBib2R5KCl7cmV0dXJuIHUuYnJhbmRDaGVjayh0aGlzLGlBKSx0aGlzW2ddLmJvZHk/dGhpc1tnXS5ib2R5LnN0cmVhbTpudWxsfWdldCBib2R5VXNlZCgpe3JldHVybiB1LmJyYW5kQ2hlY2sodGhpcyxpQSksISF0aGlzW2ddLmJvZHkmJkUuaXNEaXN0dXJiZWQodGhpc1tnXS5ib2R5LnN0cmVhbSl9Z2V0IGR1cGxleCgpe3JldHVybiB1LmJyYW5kQ2hlY2sodGhpcyxpQSksXCJoYWxmXCJ9Y2xvbmUoKXtpZih1LmJyYW5kQ2hlY2sodGhpcyxpQSksdGhpcy5ib2R5VXNlZHx8dGhpcy5ib2R5Py5sb2NrZWQpdGhyb3cgbmV3IFR5cGVFcnJvcihcInVudXNhYmxlXCIpO2NvbnN0IEJBPXoodGhpc1tnXSksc0E9bmV3IEFib3J0Q29udHJvbGxlcjtyZXR1cm4gdGhpcy5zaWduYWwuYWJvcnRlZD9zQS5hYm9ydCh0aGlzLnNpZ25hbC5yZWFzb24pOkUuYWRkQWJvcnRMaXN0ZW5lcih0aGlzLnNpZ25hbCwoKT0+e3NBLmFib3J0KHRoaXMuc2lnbmFsLnJlYXNvbil9KSxyQShCQSxzQS5zaWduYWwsdGhpc1tEXVtkXSx0aGlzW0ZdKX1bUS5pbnNwZWN0LmN1c3RvbV0oQkEsc0Epe3NBLmRlcHRoPT09bnVsbCYmKHNBLmRlcHRoPTIpLHNBLmNvbG9ycz8/KHNBLmNvbG9ycz0hMCk7Y29uc3QgZUE9e21ldGhvZDp0aGlzLm1ldGhvZCx1cmw6dGhpcy51cmwsaGVhZGVyczp0aGlzLmhlYWRlcnMsZGVzdGluYXRpb246dGhpcy5kZXN0aW5hdGlvbixyZWZlcnJlcjp0aGlzLnJlZmVycmVyLHJlZmVycmVyUG9saWN5OnRoaXMucmVmZXJyZXJQb2xpY3ksbW9kZTp0aGlzLm1vZGUsY3JlZGVudGlhbHM6dGhpcy5jcmVkZW50aWFscyxjYWNoZTp0aGlzLmNhY2hlLHJlZGlyZWN0OnRoaXMucmVkaXJlY3QsaW50ZWdyaXR5OnRoaXMuaW50ZWdyaXR5LGtlZXBhbGl2ZTp0aGlzLmtlZXBhbGl2ZSxpc1JlbG9hZE5hdmlnYXRpb246dGhpcy5pc1JlbG9hZE5hdmlnYXRpb24saXNIaXN0b3J5TmF2aWdhdGlvbjp0aGlzLmlzSGlzdG9yeU5hdmlnYXRpb24sc2lnbmFsOnRoaXMuc2lnbmFsfTtyZXR1cm5gUmVxdWVzdCAke1EuZm9ybWF0V2l0aE9wdGlvbnMoc0EsZUEpfWB9fTtvKGlBLFwiUmVxdWVzdFwiKTtsZXQgVj1pQTtBKFYpO2Z1bmN0aW9uIHEoZ0Epe2NvbnN0IEJBPXttZXRob2Q6XCJHRVRcIixsb2NhbFVSTHNPbmx5OiExLHVuc2FmZVJlcXVlc3Q6ITEsYm9keTpudWxsLGNsaWVudDpudWxsLHJlc2VydmVkQ2xpZW50Om51bGwscmVwbGFjZXNDbGllbnRJZDpcIlwiLHdpbmRvdzpcImNsaWVudFwiLGtlZXBhbGl2ZTohMSxzZXJ2aWNlV29ya2VyczpcImFsbFwiLGluaXRpYXRvcjpcIlwiLGRlc3RpbmF0aW9uOlwiXCIscHJpb3JpdHk6bnVsbCxvcmlnaW46XCJjbGllbnRcIixwb2xpY3lDb250YWluZXI6XCJjbGllbnRcIixyZWZlcnJlcjpcImNsaWVudFwiLHJlZmVycmVyUG9saWN5OlwiXCIsbW9kZTpcIm5vLWNvcnNcIix1c2VDT1JTUHJlZmxpZ2h0RmxhZzohMSxjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCIsdXNlQ3JlZGVudGlhbHM6ITEsY2FjaGU6XCJkZWZhdWx0XCIscmVkaXJlY3Q6XCJmb2xsb3dcIixpbnRlZ3JpdHk6XCJcIixjcnlwdG9HcmFwaGljc05vbmNlTWV0YWRhdGE6XCJcIixwYXJzZXJNZXRhZGF0YTpcIlwiLHJlbG9hZE5hdmlnYXRpb246ITEsaGlzdG9yeU5hdmlnYXRpb246ITEsdXNlckFjdGl2YXRpb246ITEsdGFpbnRlZE9yaWdpbjohMSxyZWRpcmVjdENvdW50OjAscmVzcG9uc2VUYWludGluZzpcImJhc2ljXCIscHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb246ITEsZG9uZTohMSx0aW1pbmdBbGxvd0ZhaWxlZDohMSwuLi5nQSxoZWFkZXJzTGlzdDpnQS5oZWFkZXJzTGlzdD9uZXcgcyhnQS5oZWFkZXJzTGlzdCk6bmV3IHN9O3JldHVybiBCQS51cmw9QkEudXJsTGlzdFswXSxCQX1vKHEsXCJtYWtlUmVxdWVzdFwiKTtmdW5jdGlvbiB6KGdBKXtjb25zdCBCQT1xKHsuLi5nQSxib2R5Om51bGx9KTtyZXR1cm4gZ0EuYm9keSE9bnVsbCYmKEJBLmJvZHk9dChnQS5ib2R5KSksQkF9byh6LFwiY2xvbmVSZXF1ZXN0XCIpO2Z1bmN0aW9uIHJBKGdBLEJBLHNBLGVBKXtjb25zdCB5QT1uZXcgVih2KTtyZXR1cm4geUFbZ109Z0EseUFbRl09ZUEseUFbR109QkEseUFbR11bRl09ZUEseUFbRF09bmV3IG4odikseUFbRF1bVF09Z0EuaGVhZGVyc0xpc3QseUFbRF1bZF09c0EseUFbRF1bRl09ZUEseUF9cmV0dXJuIG8ockEsXCJmcm9tSW5uZXJSZXF1ZXN0XCIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFYucHJvdG90eXBlLHttZXRob2Q6Qix1cmw6QixoZWFkZXJzOkIscmVkaXJlY3Q6QixjbG9uZTpCLHNpZ25hbDpCLGR1cGxleDpCLGRlc3RpbmF0aW9uOkIsYm9keTpCLGJvZHlVc2VkOkIsaXNIaXN0b3J5TmF2aWdhdGlvbjpCLGlzUmVsb2FkTmF2aWdhdGlvbjpCLGtlZXBhbGl2ZTpCLGludGVncml0eTpCLGNhY2hlOkIsY3JlZGVudGlhbHM6QixhdHRyaWJ1dGU6QixyZWZlcnJlclBvbGljeTpCLHJlZmVycmVyOkIsbW9kZTpCLFtTeW1ib2wudG9TdHJpbmdUYWddOnt2YWx1ZTpcIlJlcXVlc3RcIixjb25maWd1cmFibGU6ITB9fSksdS5jb252ZXJ0ZXJzLlJlcXVlc3Q9dS5pbnRlcmZhY2VDb252ZXJ0ZXIoViksdS5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvPWZ1bmN0aW9uKGdBKXtyZXR1cm4gdHlwZW9mIGdBPT1cInN0cmluZ1wiP3UuY29udmVydGVycy5VU1ZTdHJpbmcoZ0EpOmdBIGluc3RhbmNlb2YgVj91LmNvbnZlcnRlcnMuUmVxdWVzdChnQSk6dS5jb252ZXJ0ZXJzLlVTVlN0cmluZyhnQSl9LHUuY29udmVydGVycy5BYm9ydFNpZ25hbD11LmludGVyZmFjZUNvbnZlcnRlcihBYm9ydFNpZ25hbCksdS5jb252ZXJ0ZXJzLlJlcXVlc3RJbml0PXUuZGljdGlvbmFyeUNvbnZlcnRlcihbe2tleTpcIm1ldGhvZFwiLGNvbnZlcnRlcjp1LmNvbnZlcnRlcnMuQnl0ZVN0cmluZ30se2tleTpcImhlYWRlcnNcIixjb252ZXJ0ZXI6dS5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0fSx7a2V5OlwiYm9keVwiLGNvbnZlcnRlcjp1Lm51bGxhYmxlQ29udmVydGVyKHUuY29udmVydGVycy5Cb2R5SW5pdCl9LHtrZXk6XCJyZWZlcnJlclwiLGNvbnZlcnRlcjp1LmNvbnZlcnRlcnMuVVNWU3RyaW5nfSx7a2V5OlwicmVmZXJyZXJQb2xpY3lcIixjb252ZXJ0ZXI6dS5jb252ZXJ0ZXJzLkRPTVN0cmluZyxhbGxvd2VkVmFsdWVzOmx9LHtrZXk6XCJtb2RlXCIsY29udmVydGVyOnUuY29udmVydGVycy5ET01TdHJpbmcsYWxsb3dlZFZhbHVlczprfSx7a2V5OlwiY3JlZGVudGlhbHNcIixjb252ZXJ0ZXI6dS5jb252ZXJ0ZXJzLkRPTVN0cmluZyxhbGxvd2VkVmFsdWVzOnd9LHtrZXk6XCJjYWNoZVwiLGNvbnZlcnRlcjp1LmNvbnZlcnRlcnMuRE9NU3RyaW5nLGFsbG93ZWRWYWx1ZXM6VX0se2tleTpcInJlZGlyZWN0XCIsY29udmVydGVyOnUuY29udmVydGVycy5ET01TdHJpbmcsYWxsb3dlZFZhbHVlczpTfSx7a2V5OlwiaW50ZWdyaXR5XCIsY29udmVydGVyOnUuY29udmVydGVycy5ET01TdHJpbmd9LHtrZXk6XCJrZWVwYWxpdmVcIixjb252ZXJ0ZXI6dS5jb252ZXJ0ZXJzLmJvb2xlYW59LHtrZXk6XCJzaWduYWxcIixjb252ZXJ0ZXI6dS5udWxsYWJsZUNvbnZlcnRlcihnQT0+dS5jb252ZXJ0ZXJzLkFib3J0U2lnbmFsKGdBLHtzdHJpY3Q6ITF9KSl9LHtrZXk6XCJ3aW5kb3dcIixjb252ZXJ0ZXI6dS5jb252ZXJ0ZXJzLmFueX0se2tleTpcImR1cGxleFwiLGNvbnZlcnRlcjp1LmNvbnZlcnRlcnMuRE9NU3RyaW5nLGFsbG93ZWRWYWx1ZXM6TX0se2tleTpcImRpc3BhdGNoZXJcIixjb252ZXJ0ZXI6dS5jb252ZXJ0ZXJzLmFueX1dKSxyZXF1ZXN0PXtSZXF1ZXN0OlYsbWFrZVJlcXVlc3Q6cSxmcm9tSW5uZXJSZXF1ZXN0OnJBLGNsb25lUmVxdWVzdDp6fSxyZXF1ZXN0fW8ocmVxdWlyZVJlcXVlc3QsXCJyZXF1aXJlUmVxdWVzdFwiKTt2YXIgZmV0Y2hfMSxoYXNSZXF1aXJlZEZldGNoO2Z1bmN0aW9uIHJlcXVpcmVGZXRjaCgpe2lmKGhhc1JlcXVpcmVkRmV0Y2gpcmV0dXJuIGZldGNoXzE7aGFzUmVxdWlyZWRGZXRjaD0xO2NvbnN0e21ha2VOZXR3b3JrRXJyb3I6ZSxtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3I6QSxmaWx0ZXJSZXNwb25zZTp0LG1ha2VSZXNwb25zZTpuLGZyb21Jbm5lclJlc3BvbnNlOnJ9PXJlcXVpcmVSZXNwb25zZSgpLHtIZWFkZXJzTGlzdDpzfT1yZXF1aXJlSGVhZGVycygpLHtSZXF1ZXN0OmksY2xvbmVSZXF1ZXN0OkV9PXJlcXVpcmVSZXF1ZXN0KCksUT16bGliX19kZWZhdWx0LHtieXRlc01hdGNoOkMsbWFrZVBvbGljeUNvbnRhaW5lcjpJLGNsb25lUG9saWN5Q29udGFpbmVyOmEscmVxdWVzdEJhZFBvcnQ6ZixUQU9DaGVjazpoLGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXI6TCxyZXNwb25zZUxvY2F0aW9uVVJMOmMscmVxdWVzdEN1cnJlbnRVUkw6bCxzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0OlMsdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMOmssY3JlYXRlT3BhcXVlVGltaW5nSW5mbzp3LGFwcGVuZEZldGNoTWV0YWRhdGE6VSxjb3JzQ2hlY2s6TSxjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2s6QixkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyOkQsY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWU6RyxjcmVhdGVEZWZlcnJlZFByb21pc2U6Zyxpc0Jsb2JMaWtlOmQsc2FtZU9yaWdpbjpGLGlzQ2FuY2VsbGVkOk4saXNBYm9ydGVkOnUsaXNFcnJvckxpa2U6YixmdWxseVJlYWRCb2R5Om0scmVhZGFibGVTdHJlYW1DbG9zZTpULGlzb21vcnBoaWNFbmNvZGU6dix1cmxJc0xvY2FsOlosdXJsSXNIdHRwSHR0cHNTY2hlbWU6UCx1cmxIYXNIdHRwc1NjaGVtZTpBQSxjbGFtcEFuZENvYXJzZW5Db25uZWN0aW9uVGltaW5nSW5mbzpLLHNpbXBsZVJhbmdlSGVhZGVyVmFsdWU6dEEsYnVpbGRDb250ZW50UmFuZ2U6YUEsY3JlYXRlSW5mbGF0ZTpYLGV4dHJhY3RNaW1lVHlwZTokfT1yZXF1aXJlVXRpbCQ1KCkse2tTdGF0ZTpWLGtEaXNwYXRjaGVyOnF9PXJlcXVpcmVTeW1ib2xzJDMoKSx6PXJlcXVpcmUkJDBfX2RlZmF1bHQse3NhZmVseUV4dHJhY3RCb2R5OnJBLGV4dHJhY3RCb2R5OmlBfT1yZXF1aXJlQm9keSgpLHtyZWRpcmVjdFN0YXR1c1NldDpnQSxudWxsQm9keVN0YXR1czpCQSxzYWZlTWV0aG9kc1NldDpzQSxyZXF1ZXN0Qm9keUhlYWRlcjplQSxzdWJyZXNvdXJjZVNldDp5QX09cmVxdWlyZUNvbnN0YW50cyQyKCksV0E9cmVxdWlyZSQkMF9fZGVmYXVsdCQzLHtSZWFkYWJsZTp3QSxwaXBlbGluZTpxQX09U3RyZWFtX19kZWZhdWx0LHthZGRBYm9ydExpc3RlbmVyOk1BLGlzRXJyb3JlZDpIQSxpc1JlYWRhYmxlOnBBLG5vZGVNYWpvcjpZQSxub2RlTWlub3I6VUEsYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZTpKQX09dXRpbCRtLHtkYXRhVVJMUHJvY2Vzc29yOlZBLHNlcmlhbGl6ZUFNaW1lVHlwZTpPQSxtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlOklBfT1yZXF1aXJlRGF0YVVybCgpLHtnZXRHbG9iYWxEaXNwYXRjaGVyOmhBfT1nbG9iYWwse3dlYmlkbDpTQX09cmVxdWlyZVdlYmlkbCgpLHtTVEFUVVNfQ09ERVM6UEF9PWh0dHBfX2RlZmF1bHQsUGU9W1wiR0VUXCIsXCJIRUFEXCJdLGVlPXR5cGVvZiBfX1VORElDSV9JU19OT0RFX188XCJ1XCJ8fHR5cGVvZiBlc2J1aWxkRGV0ZWN0aW9uPFwidVwiP1wibm9kZVwiOlwidW5kaWNpXCI7bGV0IFpBO2NvbnN0IG5BPWNsYXNzIG5BIGV4dGVuZHMgV0F7Y29uc3RydWN0b3IoTyl7c3VwZXIoKSx0aGlzLmRpc3BhdGNoZXI9Tyx0aGlzLmNvbm5lY3Rpb249bnVsbCx0aGlzLmR1bXA9ITEsdGhpcy5zdGF0ZT1cIm9uZ29pbmdcIn10ZXJtaW5hdGUoTyl7dGhpcy5zdGF0ZT09PVwib25nb2luZ1wiJiYodGhpcy5zdGF0ZT1cInRlcm1pbmF0ZWRcIix0aGlzLmNvbm5lY3Rpb24/LmRlc3Ryb3koTyksdGhpcy5lbWl0KFwidGVybWluYXRlZFwiLE8pKX1hYm9ydChPKXt0aGlzLnN0YXRlPT09XCJvbmdvaW5nXCImJih0aGlzLnN0YXRlPVwiYWJvcnRlZFwiLE98fChPPW5ldyBET01FeGNlcHRpb24oXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiLFwiQWJvcnRFcnJvclwiKSksdGhpcy5zZXJpYWxpemVkQWJvcnRSZWFzb249Tyx0aGlzLmNvbm5lY3Rpb24/LmRlc3Ryb3koTyksdGhpcy5lbWl0KFwidGVybWluYXRlZFwiLE8pKX19O28obkEsXCJGZXRjaFwiKTtsZXQgWEE9bkE7ZnVuY3Rpb24gWmUoUixPPXZvaWQgMCl7U0EuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMSx7aGVhZGVyOlwiZ2xvYmFsVGhpcy5mZXRjaFwifSk7Y29uc3QgSD1nKCk7bGV0IEo7dHJ5e0o9bmV3IGkoUixPKX1jYXRjaChvQSl7cmV0dXJuIEgucmVqZWN0KG9BKSxILnByb21pc2V9Y29uc3QgXz1KW1ZdO2lmKEouc2lnbmFsLmFib3J0ZWQpcmV0dXJuIHRlKEgsXyxudWxsLEouc2lnbmFsLnJlYXNvbiksSC5wcm9taXNlO18uY2xpZW50Lmdsb2JhbE9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWU9PT1cIlNlcnZpY2VXb3JrZXJHbG9iYWxTY29wZVwiJiYoXy5zZXJ2aWNlV29ya2Vycz1cIm5vbmVcIik7bGV0IFFBPW51bGw7Y29uc3QgbEE9bnVsbDtsZXQgdUE9ITEsY0E9bnVsbDtyZXR1cm4gTUEoSi5zaWduYWwsKCk9Pnt1QT0hMCx6KGNBIT1udWxsKSxjQS5hYm9ydChKLnNpZ25hbC5yZWFzb24pLHRlKEgsXyxRQSxKLnNpZ25hbC5yZWFzb24pfSksY0E9VmUoe3JlcXVlc3Q6Xyxwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHk6byhvQT0+S0Eob0EsXCJmZXRjaFwiKSxcImhhbmRsZUZldGNoRG9uZVwiKSxwcm9jZXNzUmVzcG9uc2U6byhvQT0+e2lmKCF1QSl7aWYob0EuYWJvcnRlZCl7dGUoSCxfLFFBLGNBLnNlcmlhbGl6ZWRBYm9ydFJlYXNvbik7cmV0dXJufWlmKG9BLnR5cGU9PT1cImVycm9yXCIpe0gucmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJmZXRjaCBmYWlsZWRcIix7Y2F1c2U6b0EuZXJyb3J9KSk7cmV0dXJufVFBPXIob0EsXCJpbW11dGFibGVcIixsQSksSC5yZXNvbHZlKFFBKX19LFwicHJvY2Vzc1Jlc3BvbnNlXCIpLGRpc3BhdGNoZXI6SltxXX0pLEgucHJvbWlzZX1vKFplLFwiZmV0Y2hcIik7ZnVuY3Rpb24gS0EoUixPPVwib3RoZXJcIil7aWYoUi50eXBlPT09XCJlcnJvclwiJiZSLmFib3J0ZWR8fCFSLnVybExpc3Q/Lmxlbmd0aClyZXR1cm47Y29uc3QgSD1SLnVybExpc3RbMF07bGV0IEo9Ui50aW1pbmdJbmZvLF89Ui5jYWNoZVN0YXRlO1AoSCkmJkohPT1udWxsJiYoUi50aW1pbmdBbGxvd1Bhc3NlZHx8KEo9dyh7c3RhcnRUaW1lOkouc3RhcnRUaW1lfSksXz1cIlwiKSxKLmVuZFRpbWU9RygpLFIudGltaW5nSW5mbz1KLEhlKEosSC5ocmVmLE8sZ2xvYmFsVGhpcyxfKSl9byhLQSxcImZpbmFsaXplQW5kUmVwb3J0VGltaW5nXCIpO2NvbnN0IEhlPVlBPjE4fHxZQT09PTE4JiZVQT49Mj9wZXJmb3JtYW5jZS5tYXJrUmVzb3VyY2VUaW1pbmc6KCk9Pnt9O2Z1bmN0aW9uIHRlKFIsTyxILEope2lmKFIucmVqZWN0KEopLE8uYm9keSE9bnVsbCYmcEEoTy5ib2R5Py5zdHJlYW0pJiZPLmJvZHkuc3RyZWFtLmNhbmNlbChKKS5jYXRjaCh4PT57aWYoeC5jb2RlIT09XCJFUlJfSU5WQUxJRF9TVEFURVwiKXRocm93IHh9KSxIPT1udWxsKXJldHVybjtjb25zdCBfPUhbVl07Xy5ib2R5IT1udWxsJiZwQShfLmJvZHk/LnN0cmVhbSkmJl8uYm9keS5zdHJlYW0uY2FuY2VsKEopLmNhdGNoKHg9PntpZih4LmNvZGUhPT1cIkVSUl9JTlZBTElEX1NUQVRFXCIpdGhyb3cgeH0pfW8odGUsXCJhYm9ydEZldGNoXCIpO2Z1bmN0aW9uIFZlKHtyZXF1ZXN0OlIscHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGg6Tyxwcm9jZXNzUmVxdWVzdEVuZE9mQm9keTpILHByb2Nlc3NSZXNwb25zZTpKLHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keTpfLHByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5OngsdXNlUGFyYWxsZWxRdWV1ZTpRQT0hMSxkaXNwYXRjaGVyOmxBPWhBKCl9KXt6KGxBKTtsZXQgdUE9bnVsbCxjQT0hMTtSLmNsaWVudCE9bnVsbCYmKHVBPVIuY2xpZW50Lmdsb2JhbE9iamVjdCxjQT1SLmNsaWVudC5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSk7Y29uc3QgZkE9RyhjQSksbUE9dyh7c3RhcnRUaW1lOmZBfSksb0E9e2NvbnRyb2xsZXI6bmV3IFhBKGxBKSxyZXF1ZXN0OlIsdGltaW5nSW5mbzptQSxwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aDpPLHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5OkgscHJvY2Vzc1Jlc3BvbnNlOkoscHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHk6eCxwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHk6Xyx0YXNrRGVzdGluYXRpb246dUEsY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHk6Y0F9O3JldHVybiB6KCFSLmJvZHl8fFIuYm9keS5zdHJlYW0pLFIud2luZG93PT09XCJjbGllbnRcIiYmKFIud2luZG93PVIuY2xpZW50Py5nbG9iYWxPYmplY3Q/LmNvbnN0cnVjdG9yPy5uYW1lPT09XCJXaW5kb3dcIj9SLmNsaWVudDpcIm5vLXdpbmRvd1wiKSxSLm9yaWdpbj09PVwiY2xpZW50XCImJihSLm9yaWdpbj1SLmNsaWVudD8ub3JpZ2luKSxSLnBvbGljeUNvbnRhaW5lcj09PVwiY2xpZW50XCImJihSLmNsaWVudCE9bnVsbD9SLnBvbGljeUNvbnRhaW5lcj1hKFIuY2xpZW50LnBvbGljeUNvbnRhaW5lcik6Ui5wb2xpY3lDb250YWluZXI9SSgpKSxSLmhlYWRlcnNMaXN0LmNvbnRhaW5zKFwiYWNjZXB0XCIsITApfHxSLmhlYWRlcnNMaXN0LmFwcGVuZChcImFjY2VwdFwiLFwiKi8qXCIsITApLFIuaGVhZGVyc0xpc3QuY29udGFpbnMoXCJhY2NlcHQtbGFuZ3VhZ2VcIiwhMCl8fFIuaGVhZGVyc0xpc3QuYXBwZW5kKFwiYWNjZXB0LWxhbmd1YWdlXCIsXCIqXCIsITApLFIucHJpb3JpdHkseUEuaGFzKFIuZGVzdGluYXRpb24pLHJlKG9BKS5jYXRjaChSQT0+e29BLmNvbnRyb2xsZXIudGVybWluYXRlKFJBKX0pLG9BLmNvbnRyb2xsZXJ9byhWZSxcImZldGNoaW5nXCIpO2FzeW5jIGZ1bmN0aW9uIHJlKFIsTz0hMSl7Y29uc3QgSD1SLnJlcXVlc3Q7bGV0IEo9bnVsbDtpZihILmxvY2FsVVJMc09ubHkmJiFaKGwoSCkpJiYoSj1lKFwibG9jYWwgVVJMcyBvbmx5XCIpKSxrKEgpLGYoSCk9PT1cImJsb2NrZWRcIiYmKEo9ZShcImJhZCBwb3J0XCIpKSxILnJlZmVycmVyUG9saWN5PT09XCJcIiYmKEgucmVmZXJyZXJQb2xpY3k9SC5wb2xpY3lDb250YWluZXIucmVmZXJyZXJQb2xpY3kpLEgucmVmZXJyZXIhPT1cIm5vLXJlZmVycmVyXCImJihILnJlZmVycmVyPUQoSCkpLEo9PT1udWxsJiYoSj1hd2FpdChhc3luYygpPT57Y29uc3QgeD1sKEgpO3JldHVybiBGKHgsSC51cmwpJiZILnJlc3BvbnNlVGFpbnRpbmc9PT1cImJhc2ljXCJ8fHgucHJvdG9jb2w9PT1cImRhdGE6XCJ8fEgubW9kZT09PVwibmF2aWdhdGVcInx8SC5tb2RlPT09XCJ3ZWJzb2NrZXRcIj8oSC5yZXNwb25zZVRhaW50aW5nPVwiYmFzaWNcIixhd2FpdCB2ZShSKSk6SC5tb2RlPT09XCJzYW1lLW9yaWdpblwiP2UoJ3JlcXVlc3QgbW9kZSBjYW5ub3QgYmUgXCJzYW1lLW9yaWdpblwiJyk6SC5tb2RlPT09XCJuby1jb3JzXCI/SC5yZWRpcmVjdCE9PVwiZm9sbG93XCI/ZSgncmVkaXJlY3QgbW9kZSBjYW5ub3QgYmUgXCJmb2xsb3dcIiBmb3IgXCJuby1jb3JzXCIgcmVxdWVzdCcpOihILnJlc3BvbnNlVGFpbnRpbmc9XCJvcGFxdWVcIixhd2FpdCB2ZShSKSk6UChsKEgpKT8oSC5yZXNwb25zZVRhaW50aW5nPVwiY29yc1wiLGF3YWl0IHkoUikpOmUoXCJVUkwgc2NoZW1lIG11c3QgYmUgYSBIVFRQKFMpIHNjaGVtZVwiKX0pKCkpLE8pcmV0dXJuIEo7Si5zdGF0dXMhPT0wJiYhSi5pbnRlcm5hbFJlc3BvbnNlJiYoSC5yZXNwb25zZVRhaW50aW5nLEgucmVzcG9uc2VUYWludGluZz09PVwiYmFzaWNcIj9KPXQoSixcImJhc2ljXCIpOkgucmVzcG9uc2VUYWludGluZz09PVwiY29yc1wiP0o9dChKLFwiY29yc1wiKTpILnJlc3BvbnNlVGFpbnRpbmc9PT1cIm9wYXF1ZVwiP0o9dChKLFwib3BhcXVlXCIpOnooITEpKTtsZXQgXz1KLnN0YXR1cz09PTA/SjpKLmludGVybmFsUmVzcG9uc2U7aWYoXy51cmxMaXN0Lmxlbmd0aD09PTAmJl8udXJsTGlzdC5wdXNoKC4uLkgudXJsTGlzdCksSC50aW1pbmdBbGxvd0ZhaWxlZHx8KEoudGltaW5nQWxsb3dQYXNzZWQ9ITApLEoudHlwZT09PVwib3BhcXVlXCImJl8uc3RhdHVzPT09MjA2JiZfLnJhbmdlUmVxdWVzdGVkJiYhSC5oZWFkZXJzLmNvbnRhaW5zKFwicmFuZ2VcIiwhMCkmJihKPV89ZSgpKSxKLnN0YXR1cyE9PTAmJihILm1ldGhvZD09PVwiSEVBRFwifHxILm1ldGhvZD09PVwiQ09OTkVDVFwifHxCQS5pbmNsdWRlcyhfLnN0YXR1cykpJiYoXy5ib2R5PW51bGwsUi5jb250cm9sbGVyLmR1bXA9ITApLEguaW50ZWdyaXR5KXtjb25zdCB4PW8obEE9PnZBKFIsZShsQSkpLFwicHJvY2Vzc0JvZHlFcnJvclwiKTtpZihILnJlc3BvbnNlVGFpbnRpbmc9PT1cIm9wYXF1ZVwifHxKLmJvZHk9PW51bGwpe3goSi5lcnJvcik7cmV0dXJufWNvbnN0IFFBPW8obEE9PntpZighQyhsQSxILmludGVncml0eSkpe3goXCJpbnRlZ3JpdHkgbWlzbWF0Y2hcIik7cmV0dXJufUouYm9keT1yQShsQSlbMF0sdkEoUixKKX0sXCJwcm9jZXNzQm9keVwiKTthd2FpdCBtKEouYm9keSxRQSx4KX1lbHNlIHZBKFIsSil9byhyZSxcIm1haW5GZXRjaFwiKTtmdW5jdGlvbiB2ZShSKXtpZihOKFIpJiZSLnJlcXVlc3QucmVkaXJlY3RDb3VudD09PTApcmV0dXJuIFByb21pc2UucmVzb2x2ZShBKFIpKTtjb25zdHtyZXF1ZXN0Ok99PVIse3Byb3RvY29sOkh9PWwoTyk7c3dpdGNoKEgpe2Nhc2VcImFib3V0OlwiOnJldHVybiBQcm9taXNlLnJlc29sdmUoZShcImFib3V0IHNjaGVtZSBpcyBub3Qgc3VwcG9ydGVkXCIpKTtjYXNlXCJibG9iOlwiOntaQXx8KFpBPXJlcXVpcmUkJDZfX2RlZmF1bHQucmVzb2x2ZU9iamVjdFVSTCk7Y29uc3QgSj1sKE8pO2lmKEouc2VhcmNoLmxlbmd0aCE9PTApcmV0dXJuIFByb21pc2UucmVzb2x2ZShlKFwiTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS5cIikpO2NvbnN0IF89WkEoSi50b1N0cmluZygpKTtpZihPLm1ldGhvZCE9PVwiR0VUXCJ8fCFkKF8pKXJldHVybiBQcm9taXNlLnJlc29sdmUoZShcImludmFsaWQgbWV0aG9kXCIpKTtjb25zdCB4PW4oKSxRQT1fLnNpemUsbEE9dihgJHtRQX1gKSx1QT1fLnR5cGU7aWYoTy5oZWFkZXJzTGlzdC5jb250YWlucyhcInJhbmdlXCIsITApKXt4LnJhbmdlUmVxdWVzdGVkPSEwO2NvbnN0IGNBPU8uaGVhZGVyc0xpc3QuZ2V0KFwicmFuZ2VcIiwhMCksZkE9dEEoY0EsITApO2lmKGZBPT09XCJmYWlsdXJlXCIpcmV0dXJuIFByb21pc2UucmVzb2x2ZShlKFwiZmFpbGVkIHRvIGZldGNoIHRoZSBkYXRhIFVSTFwiKSk7bGV0e3JhbmdlU3RhcnRWYWx1ZTptQSxyYW5nZUVuZFZhbHVlOm9BfT1mQTtpZihtQT09PW51bGwpbUE9UUEtb0Esb0E9bUErb0EtMTtlbHNle2lmKG1BPj1RQSlyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUoXCJSYW5nZSBzdGFydCBpcyBncmVhdGVyIHRoYW4gdGhlIGJsb2IncyBzaXplLlwiKSk7KG9BPT09bnVsbHx8b0E+PVFBKSYmKG9BPVFBLTEpfWNvbnN0IFJBPV8uc2xpY2UobUEsb0EsdUEpLGJBPWlBKFJBKTt4LmJvZHk9YkFbMF07Y29uc3QgZEE9dihgJHtSQS5zaXplfWApLEdBPWFBKG1BLG9BLFFBKTt4LnN0YXR1cz0yMDYseC5zdGF0dXNUZXh0PVwiUGFydGlhbCBDb250ZW50XCIseC5oZWFkZXJzTGlzdC5zZXQoXCJjb250ZW50LWxlbmd0aFwiLGRBLCEwKSx4LmhlYWRlcnNMaXN0LnNldChcImNvbnRlbnQtdHlwZVwiLHVBLCEwKSx4LmhlYWRlcnNMaXN0LnNldChcImNvbnRlbnQtcmFuZ2VcIixHQSwhMCl9ZWxzZXtjb25zdCBjQT1pQShfKTt4LnN0YXR1c1RleHQ9XCJPS1wiLHguYm9keT1jQVswXSx4LmhlYWRlcnNMaXN0LnNldChcImNvbnRlbnQtbGVuZ3RoXCIsbEEsITApLHguaGVhZGVyc0xpc3Quc2V0KFwiY29udGVudC10eXBlXCIsdUEsITApfXJldHVybiBQcm9taXNlLnJlc29sdmUoeCl9Y2FzZVwiZGF0YTpcIjp7Y29uc3QgSj1sKE8pLF89VkEoSik7aWYoXz09PVwiZmFpbHVyZVwiKXJldHVybiBQcm9taXNlLnJlc29sdmUoZShcImZhaWxlZCB0byBmZXRjaCB0aGUgZGF0YSBVUkxcIikpO2NvbnN0IHg9T0EoXy5taW1lVHlwZSk7cmV0dXJuIFByb21pc2UucmVzb2x2ZShuKHtzdGF0dXNUZXh0OlwiT0tcIixoZWFkZXJzTGlzdDpbW1wiY29udGVudC10eXBlXCIse25hbWU6XCJDb250ZW50LVR5cGVcIix2YWx1ZTp4fV1dLGJvZHk6ckEoXy5ib2R5KVswXX0pKX1jYXNlXCJmaWxlOlwiOnJldHVybiBQcm9taXNlLnJlc29sdmUoZShcIm5vdCBpbXBsZW1lbnRlZC4uLiB5ZXQuLi5cIikpO2Nhc2VcImh0dHA6XCI6Y2FzZVwiaHR0cHM6XCI6cmV0dXJuIHkoUikuY2F0Y2goSj0+ZShKKSk7ZGVmYXVsdDpyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUoXCJ1bmtub3duIHNjaGVtZVwiKSl9fW8odmUsXCJzY2hlbWVGZXRjaFwiKTtmdW5jdGlvbiBYZShSLE8pe1IucmVxdWVzdC5kb25lPSEwLFIucHJvY2Vzc1Jlc3BvbnNlRG9uZSE9bnVsbCYmcXVldWVNaWNyb3Rhc2soKCk9PlIucHJvY2Vzc1Jlc3BvbnNlRG9uZShPKSl9byhYZSxcImZpbmFsaXplUmVzcG9uc2VcIik7ZnVuY3Rpb24gdkEoUixPKXtsZXQgSD1SLnRpbWluZ0luZm87Y29uc3QgSj1vKCgpPT57Y29uc3QgeD1EYXRlLm5vdygpO1IucmVxdWVzdC5kZXN0aW5hdGlvbj09PVwiZG9jdW1lbnRcIiYmKFIuY29udHJvbGxlci5mdWxsVGltaW5nSW5mbz1IKSxSLmNvbnRyb2xsZXIucmVwb3J0VGltaW5nU3RlcHM9KCk9PntpZihSLnJlcXVlc3QudXJsLnByb3RvY29sIT09XCJodHRwczpcIilyZXR1cm47SC5lbmRUaW1lPXg7bGV0IGxBPU8uY2FjaGVTdGF0ZTtjb25zdCB1QT1PLmJvZHlJbmZvO08udGltaW5nQWxsb3dQYXNzZWR8fChIPXcoSCksbEE9XCJcIik7bGV0IGNBPTA7aWYoUi5yZXF1ZXN0Lm1vZGUhPT1cIm5hdmlnYXRvclwifHwhTy5oYXNDcm9zc09yaWdpblJlZGlyZWN0cyl7Y0E9Ty5zdGF0dXM7Y29uc3QgZkE9JChPLmhlYWRlcnNMaXN0KTtmQSE9PVwiZmFpbHVyZVwiJiYodUEuY29udGVudFR5cGU9SUEoZkEpKX1SLnJlcXVlc3QuaW5pdGlhdG9yVHlwZSE9bnVsbCYmSGUoSCxSLnJlcXVlc3QudXJsLmhyZWYsUi5yZXF1ZXN0LmluaXRpYXRvclR5cGUsZ2xvYmFsVGhpcyxsQSx1QSxjQSl9O2NvbnN0IFFBPW8oKCk9PntSLnJlcXVlc3QuZG9uZT0hMCxSLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSE9bnVsbCYmcXVldWVNaWNyb3Rhc2soKCk9PlIucHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5KE8pKSxSLnJlcXVlc3QuaW5pdGlhdG9yVHlwZSE9bnVsbCYmUi5jb250cm9sbGVyLnJlcG9ydFRpbWluZ1N0ZXBzKCl9LFwicHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5VGFza1wiKTtxdWV1ZU1pY3JvdGFzaygoKT0+UUEoKSl9LFwicHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5XCIpO1IucHJvY2Vzc1Jlc3BvbnNlIT1udWxsJiZxdWV1ZU1pY3JvdGFzaygoKT0+Ui5wcm9jZXNzUmVzcG9uc2UoTykpO2NvbnN0IF89Ty50eXBlPT09XCJlcnJvclwiP086Ty5pbnRlcm5hbFJlc3BvbnNlPz9PO2lmKF8uYm9keT09bnVsbClKKCk7ZWxzZXtjb25zdCB4PW5ldyBUcmFuc2Zvcm1TdHJlYW0oe3N0YXJ0KCl7fSx0cmFuc2Zvcm0obEEsdUEpe3VBLmVucXVldWUobEEpfSxmbHVzaDpKfSk7Xy5ib2R5LnN0cmVhbS5waXBlVGhyb3VnaCh4KTtjb25zdCBRQT1uZXcgUmVhZGFibGVTdHJlYW0oe3JlYWRhYmxlU3RyZWFtOngucmVhZGFibGUsYXN5bmMgc3RhcnQoKXt0aGlzLl9ib2R5UmVhZGVyPXRoaXMucmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCl9LGFzeW5jIHB1bGwobEEpe2Zvcig7bEEuZGVzaXJlZFNpemU+PTA7KXtjb25zdHtkb25lOnVBLHZhbHVlOmNBfT1hd2FpdCB0aGlzLl9ib2R5UmVhZGVyLnJlYWQoKTtpZih1QSl7cXVldWVNaWNyb3Rhc2soKCk9PlQobEEpKTticmVha31sQS5lbnF1ZXVlKGNBKX19LHR5cGU6XCJieXRlc1wifSk7Xy5ib2R5LnN0cmVhbT1RQX19byh2QSxcImZldGNoRmluYWxlXCIpO2FzeW5jIGZ1bmN0aW9uIHkoUil7Y29uc3QgTz1SLnJlcXVlc3Q7bGV0IEg9bnVsbCxKPW51bGw7Y29uc3QgXz1SLnRpbWluZ0luZm87aWYoTy5zZXJ2aWNlV29ya2VycyxIPT09bnVsbCl7aWYoTy5yZWRpcmVjdD09PVwiZm9sbG93XCImJihPLnNlcnZpY2VXb3JrZXJzPVwibm9uZVwiKSxKPUg9YXdhaXQgVyhSKSxPLnJlc3BvbnNlVGFpbnRpbmc9PT1cImNvcnNcIiYmTShPLEgpPT09XCJmYWlsdXJlXCIpcmV0dXJuIGUoXCJjb3JzIGZhaWx1cmVcIik7aChPLEgpPT09XCJmYWlsdXJlXCImJihPLnRpbWluZ0FsbG93RmFpbGVkPSEwKX1yZXR1cm4oTy5yZXNwb25zZVRhaW50aW5nPT09XCJvcGFxdWVcInx8SC50eXBlPT09XCJvcGFxdWVcIikmJkIoTy5vcmlnaW4sTy5jbGllbnQsTy5kZXN0aW5hdGlvbixKKT09PVwiYmxvY2tlZFwiP2UoXCJibG9ja2VkXCIpOihnQS5oYXMoSi5zdGF0dXMpJiYoTy5yZWRpcmVjdCE9PVwibWFudWFsXCImJlIuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3kodm9pZCAwLCExKSxPLnJlZGlyZWN0PT09XCJlcnJvclwiP0g9ZShcInVuZXhwZWN0ZWQgcmVkaXJlY3RcIik6Ty5yZWRpcmVjdD09PVwibWFudWFsXCI/SD1KOk8ucmVkaXJlY3Q9PT1cImZvbGxvd1wiP0g9YXdhaXQgWShSLEgpOnooITEpKSxILnRpbWluZ0luZm89XyxIKX1vKHksXCJodHRwRmV0Y2hcIik7ZnVuY3Rpb24gWShSLE8pe2NvbnN0IEg9Ui5yZXF1ZXN0LEo9Ty5pbnRlcm5hbFJlc3BvbnNlP08uaW50ZXJuYWxSZXNwb25zZTpPO2xldCBfO3RyeXtpZihfPWMoSixsKEgpLmhhc2gpLF89PW51bGwpcmV0dXJuIE99Y2F0Y2goUUEpe3JldHVybiBQcm9taXNlLnJlc29sdmUoZShRQSkpfWlmKCFQKF8pKXJldHVybiBQcm9taXNlLnJlc29sdmUoZShcIlVSTCBzY2hlbWUgbXVzdCBiZSBhIEhUVFAoUykgc2NoZW1lXCIpKTtpZihILnJlZGlyZWN0Q291bnQ9PT0yMClyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUoXCJyZWRpcmVjdCBjb3VudCBleGNlZWRlZFwiKSk7aWYoSC5yZWRpcmVjdENvdW50Kz0xLEgubW9kZT09PVwiY29yc1wiJiYoXy51c2VybmFtZXx8Xy5wYXNzd29yZCkmJiFGKEgsXykpcmV0dXJuIFByb21pc2UucmVzb2x2ZShlKCdjcm9zcyBvcmlnaW4gbm90IGFsbG93ZWQgZm9yIHJlcXVlc3QgbW9kZSBcImNvcnNcIicpKTtpZihILnJlc3BvbnNlVGFpbnRpbmc9PT1cImNvcnNcIiYmKF8udXNlcm5hbWV8fF8ucGFzc3dvcmQpKXJldHVybiBQcm9taXNlLnJlc29sdmUoZSgnVVJMIGNhbm5vdCBjb250YWluIGNyZWRlbnRpYWxzIGZvciByZXF1ZXN0IG1vZGUgXCJjb3JzXCInKSk7aWYoSi5zdGF0dXMhPT0zMDMmJkguYm9keSE9bnVsbCYmSC5ib2R5LnNvdXJjZT09bnVsbClyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUoKSk7aWYoWzMwMSwzMDJdLmluY2x1ZGVzKEouc3RhdHVzKSYmSC5tZXRob2Q9PT1cIlBPU1RcInx8Si5zdGF0dXM9PT0zMDMmJiFQZS5pbmNsdWRlcyhILm1ldGhvZCkpe0gubWV0aG9kPVwiR0VUXCIsSC5ib2R5PW51bGw7Zm9yKGNvbnN0IFFBIG9mIGVBKUguaGVhZGVyc0xpc3QuZGVsZXRlKFFBKX1GKGwoSCksXyl8fChILmhlYWRlcnNMaXN0LmRlbGV0ZShcImF1dGhvcml6YXRpb25cIiwhMCksSC5oZWFkZXJzTGlzdC5kZWxldGUoXCJwcm94eS1hdXRob3JpemF0aW9uXCIsITApLEguaGVhZGVyc0xpc3QuZGVsZXRlKFwiY29va2llXCIsITApLEguaGVhZGVyc0xpc3QuZGVsZXRlKFwiaG9zdFwiLCEwKSksSC5ib2R5IT1udWxsJiYoeihILmJvZHkuc291cmNlIT1udWxsKSxILmJvZHk9ckEoSC5ib2R5LnNvdXJjZSlbMF0pO2NvbnN0IHg9Ui50aW1pbmdJbmZvO3JldHVybiB4LnJlZGlyZWN0RW5kVGltZT14LnBvc3RSZWRpcmVjdFN0YXJ0VGltZT1HKFIuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpLHgucmVkaXJlY3RTdGFydFRpbWU9PT0wJiYoeC5yZWRpcmVjdFN0YXJ0VGltZT14LnN0YXJ0VGltZSksSC51cmxMaXN0LnB1c2goXyksUyhILEopLHJlKFIsITApfW8oWSxcImh0dHBSZWRpcmVjdEZldGNoXCIpO2FzeW5jIGZ1bmN0aW9uIFcoUixPPSExLEg9ITEpe2NvbnN0IEo9Ui5yZXF1ZXN0O2xldCBfPW51bGwseD1udWxsLFFBPW51bGw7Si53aW5kb3c9PT1cIm5vLXdpbmRvd1wiJiZKLnJlZGlyZWN0PT09XCJlcnJvclwiPyhfPVIseD1KKTooeD1FKEopLF89ey4uLlJ9LF8ucmVxdWVzdD14KTtjb25zdCBsQT1KLmNyZWRlbnRpYWxzPT09XCJpbmNsdWRlXCJ8fEouY3JlZGVudGlhbHM9PT1cInNhbWUtb3JpZ2luXCImJkoucmVzcG9uc2VUYWludGluZz09PVwiYmFzaWNcIix1QT14LmJvZHk/eC5ib2R5Lmxlbmd0aDpudWxsO2xldCBjQT1udWxsO2lmKHguYm9keT09bnVsbCYmW1wiUE9TVFwiLFwiUFVUXCJdLmluY2x1ZGVzKHgubWV0aG9kKSYmKGNBPVwiMFwiKSx1QSE9bnVsbCYmKGNBPXYoYCR7dUF9YCkpLGNBIT1udWxsJiZ4LmhlYWRlcnNMaXN0LmFwcGVuZChcImNvbnRlbnQtbGVuZ3RoXCIsY0EsITApLHVBIT1udWxsJiZ4LmtlZXBhbGl2ZSx4LnJlZmVycmVyIGluc3RhbmNlb2YgVVJMJiZ4LmhlYWRlcnNMaXN0LmFwcGVuZChcInJlZmVyZXJcIix2KHgucmVmZXJyZXIuaHJlZiksITApLEwoeCksVSh4KSx4LmhlYWRlcnNMaXN0LmNvbnRhaW5zKFwidXNlci1hZ2VudFwiLCEwKXx8eC5oZWFkZXJzTGlzdC5hcHBlbmQoXCJ1c2VyLWFnZW50XCIsZWUpLHguY2FjaGU9PT1cImRlZmF1bHRcIiYmKHguaGVhZGVyc0xpc3QuY29udGFpbnMoXCJpZi1tb2RpZmllZC1zaW5jZVwiLCEwKXx8eC5oZWFkZXJzTGlzdC5jb250YWlucyhcImlmLW5vbmUtbWF0Y2hcIiwhMCl8fHguaGVhZGVyc0xpc3QuY29udGFpbnMoXCJpZi11bm1vZGlmaWVkLXNpbmNlXCIsITApfHx4LmhlYWRlcnNMaXN0LmNvbnRhaW5zKFwiaWYtbWF0Y2hcIiwhMCl8fHguaGVhZGVyc0xpc3QuY29udGFpbnMoXCJpZi1yYW5nZVwiLCEwKSkmJih4LmNhY2hlPVwibm8tc3RvcmVcIikseC5jYWNoZT09PVwibm8tY2FjaGVcIiYmIXgucHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb24mJiF4LmhlYWRlcnNMaXN0LmNvbnRhaW5zKFwiY2FjaGUtY29udHJvbFwiLCEwKSYmeC5oZWFkZXJzTGlzdC5hcHBlbmQoXCJjYWNoZS1jb250cm9sXCIsXCJtYXgtYWdlPTBcIiwhMCksKHguY2FjaGU9PT1cIm5vLXN0b3JlXCJ8fHguY2FjaGU9PT1cInJlbG9hZFwiKSYmKHguaGVhZGVyc0xpc3QuY29udGFpbnMoXCJwcmFnbWFcIiwhMCl8fHguaGVhZGVyc0xpc3QuYXBwZW5kKFwicHJhZ21hXCIsXCJuby1jYWNoZVwiLCEwKSx4LmhlYWRlcnNMaXN0LmNvbnRhaW5zKFwiY2FjaGUtY29udHJvbFwiLCEwKXx8eC5oZWFkZXJzTGlzdC5hcHBlbmQoXCJjYWNoZS1jb250cm9sXCIsXCJuby1jYWNoZVwiLCEwKSkseC5oZWFkZXJzTGlzdC5jb250YWlucyhcInJhbmdlXCIsITApJiZ4LmhlYWRlcnNMaXN0LmFwcGVuZChcImFjY2VwdC1lbmNvZGluZ1wiLFwiaWRlbnRpdHlcIiwhMCkseC5oZWFkZXJzTGlzdC5jb250YWlucyhcImFjY2VwdC1lbmNvZGluZ1wiLCEwKXx8KEFBKGwoeCkpP3guaGVhZGVyc0xpc3QuYXBwZW5kKFwiYWNjZXB0LWVuY29kaW5nXCIsXCJiciwgZ3ppcCwgZGVmbGF0ZVwiLCEwKTp4LmhlYWRlcnNMaXN0LmFwcGVuZChcImFjY2VwdC1lbmNvZGluZ1wiLFwiZ3ppcCwgZGVmbGF0ZVwiLCEwKSkseC5oZWFkZXJzTGlzdC5kZWxldGUoXCJob3N0XCIsITApLHguY2FjaGU9XCJuby1zdG9yZVwiLHgubW9kZSE9PVwibm8tc3RvcmVcIiYmeC5tb2RlLFFBPT1udWxsKXtpZih4Lm1vZGU9PT1cIm9ubHktaWYtY2FjaGVkXCIpcmV0dXJuIGUoXCJvbmx5IGlmIGNhY2hlZFwiKTtjb25zdCBmQT1hd2FpdCBqKF8sbEEsSCk7IXNBLmhhcyh4Lm1ldGhvZCkmJmZBLnN0YXR1cz49MjAwJiZmQS5zdGF0dXM8PTM5OSxRQT09bnVsbCYmKFFBPWZBKX1pZihRQS51cmxMaXN0PVsuLi54LnVybExpc3RdLHguaGVhZGVyc0xpc3QuY29udGFpbnMoXCJyYW5nZVwiLCEwKSYmKFFBLnJhbmdlUmVxdWVzdGVkPSEwKSxRQS5yZXF1ZXN0SW5jbHVkZXNDcmVkZW50aWFscz1sQSxRQS5zdGF0dXM9PT00MDcpcmV0dXJuIEoud2luZG93PT09XCJuby13aW5kb3dcIj9lKCk6TihSKT9BKFIpOmUoXCJwcm94eSBhdXRoZW50aWNhdGlvbiByZXF1aXJlZFwiKTtpZihRQS5zdGF0dXM9PT00MjEmJiFIJiYoSi5ib2R5PT1udWxsfHxKLmJvZHkuc291cmNlIT1udWxsKSl7aWYoTihSKSlyZXR1cm4gQShSKTtSLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KCksUUE9YXdhaXQgVyhSLE8sITApfXJldHVybiBRQX1vKFcsXCJodHRwTmV0d29ya09yQ2FjaGVGZXRjaFwiKTthc3luYyBmdW5jdGlvbiBqKFIsTz0hMSxIPSExKXt6KCFSLmNvbnRyb2xsZXIuY29ubmVjdGlvbnx8Ui5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveWVkKSxSLmNvbnRyb2xsZXIuY29ubmVjdGlvbj17YWJvcnQ6bnVsbCxkZXN0cm95ZWQ6ITEsZGVzdHJveShvQSxSQT0hMCl7dGhpcy5kZXN0cm95ZWR8fCh0aGlzLmRlc3Ryb3llZD0hMCxSQSYmdGhpcy5hYm9ydD8uKG9BPz9uZXcgRE9NRXhjZXB0aW9uKFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIixcIkFib3J0RXJyb3JcIikpKX19O2NvbnN0IEo9Ui5yZXF1ZXN0O2xldCBfPW51bGw7Y29uc3QgeD1SLnRpbWluZ0luZm87Si5jYWNoZT1cIm5vLXN0b3JlXCIsSi5tb2RlO2xldCBRQT1udWxsO2lmKEouYm9keT09bnVsbCYmUi5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSlxdWV1ZU1pY3JvdGFzaygoKT0+Ui5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSgpKTtlbHNlIGlmKEouYm9keSE9bnVsbCl7Y29uc3Qgb0E9byhhc3luYyBmdW5jdGlvbiooZEEpe04oUil8fCh5aWVsZCBkQSxSLnByb2Nlc3NSZXF1ZXN0Qm9keUNodW5rTGVuZ3RoPy4oZEEuYnl0ZUxlbmd0aCkpfSxcInByb2Nlc3NCb2R5Q2h1bmtcIiksUkE9bygoKT0+e04oUil8fFIucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkmJlIucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkoKX0sXCJwcm9jZXNzRW5kT2ZCb2R5XCIpLGJBPW8oZEE9PntOKFIpfHwoZEEubmFtZT09PVwiQWJvcnRFcnJvclwiP1IuY29udHJvbGxlci5hYm9ydCgpOlIuY29udHJvbGxlci50ZXJtaW5hdGUoZEEpKX0sXCJwcm9jZXNzQm9keUVycm9yXCIpO1FBPWFzeW5jIGZ1bmN0aW9uKigpe3RyeXtmb3IgYXdhaXQoY29uc3QgZEEgb2YgSi5ib2R5LnN0cmVhbSl5aWVsZCpvQShkQSk7UkEoKX1jYXRjaChkQSl7YkEoZEEpfX0oKX10cnl7Y29uc3R7Ym9keTpvQSxzdGF0dXM6UkEsc3RhdHVzVGV4dDpiQSxoZWFkZXJzTGlzdDpkQSxzb2NrZXQ6R0F9PWF3YWl0IG1BKHtib2R5OlFBfSk7aWYoR0EpXz1uKHtzdGF0dXM6UkEsc3RhdHVzVGV4dDpiQSxoZWFkZXJzTGlzdDpkQSxzb2NrZXQ6R0F9KTtlbHNle2NvbnN0IERBPW9BW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1IuY29udHJvbGxlci5uZXh0PSgpPT5EQS5uZXh0KCksXz1uKHtzdGF0dXM6UkEsc3RhdHVzVGV4dDpiQSxoZWFkZXJzTGlzdDpkQX0pfX1jYXRjaChvQSl7cmV0dXJuIG9BLm5hbWU9PT1cIkFib3J0RXJyb3JcIj8oUi5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpLEEoUixvQSkpOmUob0EpfWNvbnN0IGxBPW8oYXN5bmMoKT0+e2F3YWl0IFIuY29udHJvbGxlci5yZXN1bWUoKX0sXCJwdWxsQWxnb3JpdGhtXCIpLHVBPW8ob0E9PntSLmNvbnRyb2xsZXIuYWJvcnQob0EpfSxcImNhbmNlbEFsZ29yaXRobVwiKSxjQT1uZXcgUmVhZGFibGVTdHJlYW0oe2FzeW5jIHN0YXJ0KG9BKXtSLmNvbnRyb2xsZXIuY29udHJvbGxlcj1vQX0sYXN5bmMgcHVsbChvQSl7YXdhaXQgbEEoKX0sYXN5bmMgY2FuY2VsKG9BKXthd2FpdCB1QShvQSl9LHR5cGU6XCJieXRlc1wifSk7Xy5ib2R5PXtzdHJlYW06Y0Esc291cmNlOm51bGwsbGVuZ3RoOm51bGx9LFIuY29udHJvbGxlci5vbkFib3J0ZWQ9ZkEsUi5jb250cm9sbGVyLm9uKFwidGVybWluYXRlZFwiLGZBKSxSLmNvbnRyb2xsZXIucmVzdW1lPWFzeW5jKCk9Pntmb3IoOzspe2xldCBvQSxSQTt0cnl7Y29uc3R7ZG9uZTpkQSx2YWx1ZTpHQX09YXdhaXQgUi5jb250cm9sbGVyLm5leHQoKTtpZih1KFIpKWJyZWFrO29BPWRBP3ZvaWQgMDpHQX1jYXRjaChkQSl7Ui5jb250cm9sbGVyLmVuZGVkJiYheC5lbmNvZGVkQm9keVNpemU/b0E9dm9pZCAwOihvQT1kQSxSQT0hMCl9aWYob0E9PT12b2lkIDApe1QoUi5jb250cm9sbGVyLmNvbnRyb2xsZXIpLFhlKFIsXyk7cmV0dXJufWlmKHguZGVjb2RlZEJvZHlTaXplKz1vQT8uYnl0ZUxlbmd0aD8/MCxSQSl7Ui5jb250cm9sbGVyLnRlcm1pbmF0ZShvQSk7cmV0dXJufWNvbnN0IGJBPW5ldyBVaW50OEFycmF5KG9BKTtpZihiQS5ieXRlTGVuZ3RoJiZSLmNvbnRyb2xsZXIuY29udHJvbGxlci5lbnF1ZXVlKGJBKSxIQShjQSkpe1IuY29udHJvbGxlci50ZXJtaW5hdGUoKTtyZXR1cm59aWYoUi5jb250cm9sbGVyLmNvbnRyb2xsZXIuZGVzaXJlZFNpemU8PTApcmV0dXJufX07ZnVuY3Rpb24gZkEob0Epe3UoUik/KF8uYWJvcnRlZD0hMCxwQShjQSkmJlIuY29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKFIuY29udHJvbGxlci5zZXJpYWxpemVkQWJvcnRSZWFzb24pKTpwQShjQSkmJlIuY29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKG5ldyBUeXBlRXJyb3IoXCJ0ZXJtaW5hdGVkXCIse2NhdXNlOmIob0EpP29BOnZvaWQgMH0pKSxSLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KCl9cmV0dXJuIG8oZkEsXCJvbkFib3J0ZWRcIiksXztmdW5jdGlvbiBtQSh7Ym9keTpvQX0pe2NvbnN0IFJBPWwoSiksYkE9Ui5jb250cm9sbGVyLmRpc3BhdGNoZXI7cmV0dXJuIG5ldyBQcm9taXNlKChkQSxHQSk9PmJBLmRpc3BhdGNoKHtwYXRoOlJBLnBhdGhuYW1lK1JBLnNlYXJjaCxvcmlnaW46UkEub3JpZ2luLG1ldGhvZDpKLm1ldGhvZCxib2R5OmJBLmlzTW9ja0FjdGl2ZT9KLmJvZHkmJihKLmJvZHkuc291cmNlfHxKLmJvZHkuc3RyZWFtKTpvQSxoZWFkZXJzOkouaGVhZGVyc0xpc3QuZW50cmllcyxtYXhSZWRpcmVjdGlvbnM6MCx1cGdyYWRlOkoubW9kZT09PVwid2Vic29ja2V0XCI/XCJ3ZWJzb2NrZXRcIjp2b2lkIDB9LHtib2R5Om51bGwsYWJvcnQ6bnVsbCxvbkNvbm5lY3QoREEpe2NvbnN0e2Nvbm5lY3Rpb246RkF9PVIuY29udHJvbGxlcjt4LmZpbmFsQ29ubmVjdGlvblRpbWluZ0luZm89Syh2b2lkIDAseC5wb3N0UmVkaXJlY3RTdGFydFRpbWUsUi5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSksRkEuZGVzdHJveWVkP0RBKG5ldyBET01FeGNlcHRpb24oXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiLFwiQWJvcnRFcnJvclwiKSk6KFIuY29udHJvbGxlci5vbihcInRlcm1pbmF0ZWRcIixEQSksdGhpcy5hYm9ydD1GQS5hYm9ydD1EQSkseC5maW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lPUcoUi5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSl9LG9uUmVzcG9uc2VTdGFydGVkKCl7eC5maW5hbE5ldHdvcmtSZXNwb25zZVN0YXJ0VGltZT1HKFIuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpfSxvbkhlYWRlcnMoREEsRkEsS2UseGUpe2lmKERBPDIwMClyZXR1cm47bGV0IFRBPVtdLGZ0PVwiXCI7Y29uc3QgV2U9bmV3IHM7aWYoQXJyYXkuaXNBcnJheShGQSkpe2ZvcihsZXQgTEE9MDtMQTxGQS5sZW5ndGg7TEErPTIpV2UuYXBwZW5kKEpBKEZBW0xBXSksRkFbTEErMV0udG9TdHJpbmcoXCJsYXRpbjFcIiksITApO2NvbnN0IGpBPVdlLmdldChcImNvbnRlbnQtZW5jb2RpbmdcIiwhMCk7akEmJihUQT1qQS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiLFwiKS5tYXAoTEE9PkxBLnRyaW0oKSkpLGZ0PVdlLmdldChcImxvY2F0aW9uXCIsITApfXRoaXMuYm9keT1uZXcgd0Eoe3JlYWQ6S2V9KTtjb25zdCB6QT1bXSxOdD1mdCYmSi5yZWRpcmVjdD09PVwiZm9sbG93XCImJmdBLmhhcyhEQSk7aWYoSi5tZXRob2QhPT1cIkhFQURcIiYmSi5tZXRob2QhPT1cIkNPTk5FQ1RcIiYmIUJBLmluY2x1ZGVzKERBKSYmIU50KWZvcihsZXQgakE9MDtqQTxUQS5sZW5ndGg7KytqQSl7Y29uc3QgTEE9VEFbakFdO2lmKExBPT09XCJ4LWd6aXBcInx8TEE9PT1cImd6aXBcIil6QS5wdXNoKFEuY3JlYXRlR3VuemlwKHtmbHVzaDpRLmNvbnN0YW50cy5aX1NZTkNfRkxVU0gsZmluaXNoRmx1c2g6US5jb25zdGFudHMuWl9TWU5DX0ZMVVNIfSkpO2Vsc2UgaWYoTEE9PT1cImRlZmxhdGVcIil6QS5wdXNoKFgoKSk7ZWxzZSBpZihMQT09PVwiYnJcIil6QS5wdXNoKFEuY3JlYXRlQnJvdGxpRGVjb21wcmVzcygpKTtlbHNle3pBLmxlbmd0aD0wO2JyZWFrfX1yZXR1cm4gZEEoe3N0YXR1czpEQSxzdGF0dXNUZXh0OnhlLGhlYWRlcnNMaXN0OldlLGJvZHk6ekEubGVuZ3RoP3FBKHRoaXMuYm9keSwuLi56QSwoKT0+e30pOnRoaXMuYm9keS5vbihcImVycm9yXCIsKCk9Pnt9KX0pLCEwfSxvbkRhdGEoREEpe2lmKFIuY29udHJvbGxlci5kdW1wKXJldHVybjtjb25zdCBGQT1EQTtyZXR1cm4geC5lbmNvZGVkQm9keVNpemUrPUZBLmJ5dGVMZW5ndGgsdGhpcy5ib2R5LnB1c2goRkEpfSxvbkNvbXBsZXRlKCl7dGhpcy5hYm9ydCYmUi5jb250cm9sbGVyLm9mZihcInRlcm1pbmF0ZWRcIix0aGlzLmFib3J0KSxSLmNvbnRyb2xsZXIub25BYm9ydGVkJiZSLmNvbnRyb2xsZXIub2ZmKFwidGVybWluYXRlZFwiLFIuY29udHJvbGxlci5vbkFib3J0ZWQpLFIuY29udHJvbGxlci5lbmRlZD0hMCx0aGlzLmJvZHkucHVzaChudWxsKX0sb25FcnJvcihEQSl7dGhpcy5hYm9ydCYmUi5jb250cm9sbGVyLm9mZihcInRlcm1pbmF0ZWRcIix0aGlzLmFib3J0KSx0aGlzLmJvZHk/LmRlc3Ryb3koREEpLFIuY29udHJvbGxlci50ZXJtaW5hdGUoREEpLEdBKERBKX0sb25VcGdyYWRlKERBLEZBLEtlKXtpZihEQSE9PTEwMSlyZXR1cm47Y29uc3QgeGU9bmV3IHM7Zm9yKGxldCBUQT0wO1RBPEZBLmxlbmd0aDtUQSs9Mil4ZS5hcHBlbmQoSkEoRkFbVEFdKSxGQVtUQSsxXS50b1N0cmluZyhcImxhdGluMVwiKSwhMCk7cmV0dXJuIGRBKHtzdGF0dXM6REEsc3RhdHVzVGV4dDpQQVtEQV0saGVhZGVyc0xpc3Q6eGUsc29ja2V0OktlfSksITB9fSkpfW8obUEsXCJkaXNwYXRjaFwiKX1yZXR1cm4gbyhqLFwiaHR0cE5ldHdvcmtGZXRjaFwiKSxmZXRjaF8xPXtmZXRjaDpaZSxGZXRjaDpYQSxmZXRjaGluZzpWZSxmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZzpLQX0sZmV0Y2hfMX1vKHJlcXVpcmVGZXRjaCxcInJlcXVpcmVGZXRjaFwiKTt2YXIgc3ltYm9scyQyLGhhc1JlcXVpcmVkU3ltYm9scyQyO2Z1bmN0aW9uIHJlcXVpcmVTeW1ib2xzJDIoKXtyZXR1cm4gaGFzUmVxdWlyZWRTeW1ib2xzJDJ8fChoYXNSZXF1aXJlZFN5bWJvbHMkMj0xLHN5bWJvbHMkMj17a1N0YXRlOlN5bWJvbChcIkZpbGVSZWFkZXIgc3RhdGVcIiksa1Jlc3VsdDpTeW1ib2woXCJGaWxlUmVhZGVyIHJlc3VsdFwiKSxrRXJyb3I6U3ltYm9sKFwiRmlsZVJlYWRlciBlcnJvclwiKSxrTGFzdFByb2dyZXNzRXZlbnRGaXJlZDpTeW1ib2woXCJGaWxlUmVhZGVyIGxhc3QgcHJvZ3Jlc3MgZXZlbnQgZmlyZWQgdGltZXN0YW1wXCIpLGtFdmVudHM6U3ltYm9sKFwiRmlsZVJlYWRlciBldmVudHNcIiksa0Fib3J0ZWQ6U3ltYm9sKFwiRmlsZVJlYWRlciBhYm9ydGVkXCIpfSksc3ltYm9scyQyfW8ocmVxdWlyZVN5bWJvbHMkMixcInJlcXVpcmVTeW1ib2xzJDJcIik7dmFyIHByb2dyZXNzZXZlbnQsaGFzUmVxdWlyZWRQcm9ncmVzc2V2ZW50O2Z1bmN0aW9uIHJlcXVpcmVQcm9ncmVzc2V2ZW50KCl7aWYoaGFzUmVxdWlyZWRQcm9ncmVzc2V2ZW50KXJldHVybiBwcm9ncmVzc2V2ZW50O2hhc1JlcXVpcmVkUHJvZ3Jlc3NldmVudD0xO2NvbnN0e3dlYmlkbDplfT1yZXF1aXJlV2ViaWRsKCksQT1TeW1ib2woXCJQcm9ncmVzc0V2ZW50IHN0YXRlXCIpLG49Y2xhc3MgbiBleHRlbmRzIEV2ZW50e2NvbnN0cnVjdG9yKHMsaT17fSl7cz1lLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHMpLGk9ZS5jb252ZXJ0ZXJzLlByb2dyZXNzRXZlbnRJbml0KGk/P3t9KSxzdXBlcihzLGkpLHRoaXNbQV09e2xlbmd0aENvbXB1dGFibGU6aS5sZW5ndGhDb21wdXRhYmxlLGxvYWRlZDppLmxvYWRlZCx0b3RhbDppLnRvdGFsfX1nZXQgbGVuZ3RoQ29tcHV0YWJsZSgpe3JldHVybiBlLmJyYW5kQ2hlY2sodGhpcyxuKSx0aGlzW0FdLmxlbmd0aENvbXB1dGFibGV9Z2V0IGxvYWRlZCgpe3JldHVybiBlLmJyYW5kQ2hlY2sodGhpcyxuKSx0aGlzW0FdLmxvYWRlZH1nZXQgdG90YWwoKXtyZXR1cm4gZS5icmFuZENoZWNrKHRoaXMsbiksdGhpc1tBXS50b3RhbH19O28obixcIlByb2dyZXNzRXZlbnRcIik7bGV0IHQ9bjtyZXR1cm4gZS5jb252ZXJ0ZXJzLlByb2dyZXNzRXZlbnRJbml0PWUuZGljdGlvbmFyeUNvbnZlcnRlcihbe2tleTpcImxlbmd0aENvbXB1dGFibGVcIixjb252ZXJ0ZXI6ZS5jb252ZXJ0ZXJzLmJvb2xlYW4sZGVmYXVsdFZhbHVlOiExfSx7a2V5OlwibG9hZGVkXCIsY29udmVydGVyOmUuY29udmVydGVyc1tcInVuc2lnbmVkIGxvbmcgbG9uZ1wiXSxkZWZhdWx0VmFsdWU6MH0se2tleTpcInRvdGFsXCIsY29udmVydGVyOmUuY29udmVydGVyc1tcInVuc2lnbmVkIGxvbmcgbG9uZ1wiXSxkZWZhdWx0VmFsdWU6MH0se2tleTpcImJ1YmJsZXNcIixjb252ZXJ0ZXI6ZS5jb252ZXJ0ZXJzLmJvb2xlYW4sZGVmYXVsdFZhbHVlOiExfSx7a2V5OlwiY2FuY2VsYWJsZVwiLGNvbnZlcnRlcjplLmNvbnZlcnRlcnMuYm9vbGVhbixkZWZhdWx0VmFsdWU6ITF9LHtrZXk6XCJjb21wb3NlZFwiLGNvbnZlcnRlcjplLmNvbnZlcnRlcnMuYm9vbGVhbixkZWZhdWx0VmFsdWU6ITF9XSkscHJvZ3Jlc3NldmVudD17UHJvZ3Jlc3NFdmVudDp0fSxwcm9ncmVzc2V2ZW50fW8ocmVxdWlyZVByb2dyZXNzZXZlbnQsXCJyZXF1aXJlUHJvZ3Jlc3NldmVudFwiKTt2YXIgZW5jb2RpbmcsaGFzUmVxdWlyZWRFbmNvZGluZztmdW5jdGlvbiByZXF1aXJlRW5jb2RpbmcoKXtpZihoYXNSZXF1aXJlZEVuY29kaW5nKXJldHVybiBlbmNvZGluZztoYXNSZXF1aXJlZEVuY29kaW5nPTE7ZnVuY3Rpb24gZShBKXtpZighQSlyZXR1cm5cImZhaWx1cmVcIjtzd2l0Y2goQS50cmltKCkudG9Mb3dlckNhc2UoKSl7Y2FzZVwidW5pY29kZS0xLTEtdXRmLThcIjpjYXNlXCJ1bmljb2RlMTF1dGY4XCI6Y2FzZVwidW5pY29kZTIwdXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZVwidXRmOFwiOmNhc2VcIngtdW5pY29kZTIwdXRmOFwiOnJldHVyblwiVVRGLThcIjtjYXNlXCI4NjZcIjpjYXNlXCJjcDg2NlwiOmNhc2VcImNzaWJtODY2XCI6Y2FzZVwiaWJtODY2XCI6cmV0dXJuXCJJQk04NjZcIjtjYXNlXCJjc2lzb2xhdGluMlwiOmNhc2VcImlzby04ODU5LTJcIjpjYXNlXCJpc28taXItMTAxXCI6Y2FzZVwiaXNvODg1OS0yXCI6Y2FzZVwiaXNvODg1OTJcIjpjYXNlXCJpc29fODg1OS0yXCI6Y2FzZVwiaXNvXzg4NTktMjoxOTg3XCI6Y2FzZVwibDJcIjpjYXNlXCJsYXRpbjJcIjpyZXR1cm5cIklTTy04ODU5LTJcIjtjYXNlXCJjc2lzb2xhdGluM1wiOmNhc2VcImlzby04ODU5LTNcIjpjYXNlXCJpc28taXItMTA5XCI6Y2FzZVwiaXNvODg1OS0zXCI6Y2FzZVwiaXNvODg1OTNcIjpjYXNlXCJpc29fODg1OS0zXCI6Y2FzZVwiaXNvXzg4NTktMzoxOTg4XCI6Y2FzZVwibDNcIjpjYXNlXCJsYXRpbjNcIjpyZXR1cm5cIklTTy04ODU5LTNcIjtjYXNlXCJjc2lzb2xhdGluNFwiOmNhc2VcImlzby04ODU5LTRcIjpjYXNlXCJpc28taXItMTEwXCI6Y2FzZVwiaXNvODg1OS00XCI6Y2FzZVwiaXNvODg1OTRcIjpjYXNlXCJpc29fODg1OS00XCI6Y2FzZVwiaXNvXzg4NTktNDoxOTg4XCI6Y2FzZVwibDRcIjpjYXNlXCJsYXRpbjRcIjpyZXR1cm5cIklTTy04ODU5LTRcIjtjYXNlXCJjc2lzb2xhdGluY3lyaWxsaWNcIjpjYXNlXCJjeXJpbGxpY1wiOmNhc2VcImlzby04ODU5LTVcIjpjYXNlXCJpc28taXItMTQ0XCI6Y2FzZVwiaXNvODg1OS01XCI6Y2FzZVwiaXNvODg1OTVcIjpjYXNlXCJpc29fODg1OS01XCI6Y2FzZVwiaXNvXzg4NTktNToxOTg4XCI6cmV0dXJuXCJJU08tODg1OS01XCI7Y2FzZVwiYXJhYmljXCI6Y2FzZVwiYXNtby03MDhcIjpjYXNlXCJjc2lzbzg4NTk2ZVwiOmNhc2VcImNzaXNvODg1OTZpXCI6Y2FzZVwiY3Npc29sYXRpbmFyYWJpY1wiOmNhc2VcImVjbWEtMTE0XCI6Y2FzZVwiaXNvLTg4NTktNlwiOmNhc2VcImlzby04ODU5LTYtZVwiOmNhc2VcImlzby04ODU5LTYtaVwiOmNhc2VcImlzby1pci0xMjdcIjpjYXNlXCJpc284ODU5LTZcIjpjYXNlXCJpc284ODU5NlwiOmNhc2VcImlzb184ODU5LTZcIjpjYXNlXCJpc29fODg1OS02OjE5ODdcIjpyZXR1cm5cIklTTy04ODU5LTZcIjtjYXNlXCJjc2lzb2xhdGluZ3JlZWtcIjpjYXNlXCJlY21hLTExOFwiOmNhc2VcImVsb3RfOTI4XCI6Y2FzZVwiZ3JlZWtcIjpjYXNlXCJncmVlazhcIjpjYXNlXCJpc28tODg1OS03XCI6Y2FzZVwiaXNvLWlyLTEyNlwiOmNhc2VcImlzbzg4NTktN1wiOmNhc2VcImlzbzg4NTk3XCI6Y2FzZVwiaXNvXzg4NTktN1wiOmNhc2VcImlzb184ODU5LTc6MTk4N1wiOmNhc2VcInN1bl9ldV9ncmVla1wiOnJldHVyblwiSVNPLTg4NTktN1wiO2Nhc2VcImNzaXNvODg1OThlXCI6Y2FzZVwiY3Npc29sYXRpbmhlYnJld1wiOmNhc2VcImhlYnJld1wiOmNhc2VcImlzby04ODU5LThcIjpjYXNlXCJpc28tODg1OS04LWVcIjpjYXNlXCJpc28taXItMTM4XCI6Y2FzZVwiaXNvODg1OS04XCI6Y2FzZVwiaXNvODg1OThcIjpjYXNlXCJpc29fODg1OS04XCI6Y2FzZVwiaXNvXzg4NTktODoxOTg4XCI6Y2FzZVwidmlzdWFsXCI6cmV0dXJuXCJJU08tODg1OS04XCI7Y2FzZVwiY3Npc284ODU5OGlcIjpjYXNlXCJpc28tODg1OS04LWlcIjpjYXNlXCJsb2dpY2FsXCI6cmV0dXJuXCJJU08tODg1OS04LUlcIjtjYXNlXCJjc2lzb2xhdGluNlwiOmNhc2VcImlzby04ODU5LTEwXCI6Y2FzZVwiaXNvLWlyLTE1N1wiOmNhc2VcImlzbzg4NTktMTBcIjpjYXNlXCJpc284ODU5MTBcIjpjYXNlXCJsNlwiOmNhc2VcImxhdGluNlwiOnJldHVyblwiSVNPLTg4NTktMTBcIjtjYXNlXCJpc28tODg1OS0xM1wiOmNhc2VcImlzbzg4NTktMTNcIjpjYXNlXCJpc284ODU5MTNcIjpyZXR1cm5cIklTTy04ODU5LTEzXCI7Y2FzZVwiaXNvLTg4NTktMTRcIjpjYXNlXCJpc284ODU5LTE0XCI6Y2FzZVwiaXNvODg1OTE0XCI6cmV0dXJuXCJJU08tODg1OS0xNFwiO2Nhc2VcImNzaXNvbGF0aW45XCI6Y2FzZVwiaXNvLTg4NTktMTVcIjpjYXNlXCJpc284ODU5LTE1XCI6Y2FzZVwiaXNvODg1OTE1XCI6Y2FzZVwiaXNvXzg4NTktMTVcIjpjYXNlXCJsOVwiOnJldHVyblwiSVNPLTg4NTktMTVcIjtjYXNlXCJpc28tODg1OS0xNlwiOnJldHVyblwiSVNPLTg4NTktMTZcIjtjYXNlXCJjc2tvaThyXCI6Y2FzZVwia29pXCI6Y2FzZVwia29pOFwiOmNhc2VcImtvaTgtclwiOmNhc2VcImtvaThfclwiOnJldHVyblwiS09JOC1SXCI7Y2FzZVwia29pOC1ydVwiOmNhc2VcImtvaTgtdVwiOnJldHVyblwiS09JOC1VXCI7Y2FzZVwiY3NtYWNpbnRvc2hcIjpjYXNlXCJtYWNcIjpjYXNlXCJtYWNpbnRvc2hcIjpjYXNlXCJ4LW1hYy1yb21hblwiOnJldHVyblwibWFjaW50b3NoXCI7Y2FzZVwiaXNvLTg4NTktMTFcIjpjYXNlXCJpc284ODU5LTExXCI6Y2FzZVwiaXNvODg1OTExXCI6Y2FzZVwidGlzLTYyMFwiOmNhc2VcIndpbmRvd3MtODc0XCI6cmV0dXJuXCJ3aW5kb3dzLTg3NFwiO2Nhc2VcImNwMTI1MFwiOmNhc2VcIndpbmRvd3MtMTI1MFwiOmNhc2VcIngtY3AxMjUwXCI6cmV0dXJuXCJ3aW5kb3dzLTEyNTBcIjtjYXNlXCJjcDEyNTFcIjpjYXNlXCJ3aW5kb3dzLTEyNTFcIjpjYXNlXCJ4LWNwMTI1MVwiOnJldHVyblwid2luZG93cy0xMjUxXCI7Y2FzZVwiYW5zaV94My40LTE5NjhcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImNwMTI1MlwiOmNhc2VcImNwODE5XCI6Y2FzZVwiY3Npc29sYXRpbjFcIjpjYXNlXCJpYm04MTlcIjpjYXNlXCJpc28tODg1OS0xXCI6Y2FzZVwiaXNvLWlyLTEwMFwiOmNhc2VcImlzbzg4NTktMVwiOmNhc2VcImlzbzg4NTkxXCI6Y2FzZVwiaXNvXzg4NTktMVwiOmNhc2VcImlzb184ODU5LTE6MTk4N1wiOmNhc2VcImwxXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwidXMtYXNjaWlcIjpjYXNlXCJ3aW5kb3dzLTEyNTJcIjpjYXNlXCJ4LWNwMTI1MlwiOnJldHVyblwid2luZG93cy0xMjUyXCI7Y2FzZVwiY3AxMjUzXCI6Y2FzZVwid2luZG93cy0xMjUzXCI6Y2FzZVwieC1jcDEyNTNcIjpyZXR1cm5cIndpbmRvd3MtMTI1M1wiO2Nhc2VcImNwMTI1NFwiOmNhc2VcImNzaXNvbGF0aW41XCI6Y2FzZVwiaXNvLTg4NTktOVwiOmNhc2VcImlzby1pci0xNDhcIjpjYXNlXCJpc284ODU5LTlcIjpjYXNlXCJpc284ODU5OVwiOmNhc2VcImlzb184ODU5LTlcIjpjYXNlXCJpc29fODg1OS05OjE5ODlcIjpjYXNlXCJsNVwiOmNhc2VcImxhdGluNVwiOmNhc2VcIndpbmRvd3MtMTI1NFwiOmNhc2VcIngtY3AxMjU0XCI6cmV0dXJuXCJ3aW5kb3dzLTEyNTRcIjtjYXNlXCJjcDEyNTVcIjpjYXNlXCJ3aW5kb3dzLTEyNTVcIjpjYXNlXCJ4LWNwMTI1NVwiOnJldHVyblwid2luZG93cy0xMjU1XCI7Y2FzZVwiY3AxMjU2XCI6Y2FzZVwid2luZG93cy0xMjU2XCI6Y2FzZVwieC1jcDEyNTZcIjpyZXR1cm5cIndpbmRvd3MtMTI1NlwiO2Nhc2VcImNwMTI1N1wiOmNhc2VcIndpbmRvd3MtMTI1N1wiOmNhc2VcIngtY3AxMjU3XCI6cmV0dXJuXCJ3aW5kb3dzLTEyNTdcIjtjYXNlXCJjcDEyNThcIjpjYXNlXCJ3aW5kb3dzLTEyNThcIjpjYXNlXCJ4LWNwMTI1OFwiOnJldHVyblwid2luZG93cy0xMjU4XCI7Y2FzZVwieC1tYWMtY3lyaWxsaWNcIjpjYXNlXCJ4LW1hYy11a3JhaW5pYW5cIjpyZXR1cm5cIngtbWFjLWN5cmlsbGljXCI7Y2FzZVwiY2hpbmVzZVwiOmNhc2VcImNzZ2IyMzEyXCI6Y2FzZVwiY3Npc281OGdiMjMxMjgwXCI6Y2FzZVwiZ2IyMzEyXCI6Y2FzZVwiZ2JfMjMxMlwiOmNhc2VcImdiXzIzMTItODBcIjpjYXNlXCJnYmtcIjpjYXNlXCJpc28taXItNThcIjpjYXNlXCJ4LWdia1wiOnJldHVyblwiR0JLXCI7Y2FzZVwiZ2IxODAzMFwiOnJldHVyblwiZ2IxODAzMFwiO2Nhc2VcImJpZzVcIjpjYXNlXCJiaWc1LWhrc2NzXCI6Y2FzZVwiY24tYmlnNVwiOmNhc2VcImNzYmlnNVwiOmNhc2VcIngteC1iaWc1XCI6cmV0dXJuXCJCaWc1XCI7Y2FzZVwiY3NldWNwa2RmbXRqYXBhbmVzZVwiOmNhc2VcImV1Yy1qcFwiOmNhc2VcIngtZXVjLWpwXCI6cmV0dXJuXCJFVUMtSlBcIjtjYXNlXCJjc2lzbzIwMjJqcFwiOmNhc2VcImlzby0yMDIyLWpwXCI6cmV0dXJuXCJJU08tMjAyMi1KUFwiO2Nhc2VcImNzc2hpZnRqaXNcIjpjYXNlXCJtczkzMlwiOmNhc2VcIm1zX2thbmppXCI6Y2FzZVwic2hpZnQtamlzXCI6Y2FzZVwic2hpZnRfamlzXCI6Y2FzZVwic2ppc1wiOmNhc2VcIndpbmRvd3MtMzFqXCI6Y2FzZVwieC1zamlzXCI6cmV0dXJuXCJTaGlmdF9KSVNcIjtjYXNlXCJjc2V1Y2tyXCI6Y2FzZVwiY3Nrc2M1NjAxMTk4N1wiOmNhc2VcImV1Yy1rclwiOmNhc2VcImlzby1pci0xNDlcIjpjYXNlXCJrb3JlYW5cIjpjYXNlXCJrc19jXzU2MDEtMTk4N1wiOmNhc2VcImtzX2NfNTYwMS0xOTg5XCI6Y2FzZVwia3NjNTYwMVwiOmNhc2VcImtzY181NjAxXCI6Y2FzZVwid2luZG93cy05NDlcIjpyZXR1cm5cIkVVQy1LUlwiO2Nhc2VcImNzaXNvMjAyMmtyXCI6Y2FzZVwiaHotZ2ItMjMxMlwiOmNhc2VcImlzby0yMDIyLWNuXCI6Y2FzZVwiaXNvLTIwMjItY24tZXh0XCI6Y2FzZVwiaXNvLTIwMjIta3JcIjpjYXNlXCJyZXBsYWNlbWVudFwiOnJldHVyblwicmVwbGFjZW1lbnRcIjtjYXNlXCJ1bmljb2RlZmZmZVwiOmNhc2VcInV0Zi0xNmJlXCI6cmV0dXJuXCJVVEYtMTZCRVwiO2Nhc2VcImNzdW5pY29kZVwiOmNhc2VcImlzby0xMDY0Ni11Y3MtMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidW5pY29kZVwiOmNhc2VcInVuaWNvZGVmZWZmXCI6Y2FzZVwidXRmLTE2XCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm5cIlVURi0xNkxFXCI7Y2FzZVwieC11c2VyLWRlZmluZWRcIjpyZXR1cm5cIngtdXNlci1kZWZpbmVkXCI7ZGVmYXVsdDpyZXR1cm5cImZhaWx1cmVcIn19cmV0dXJuIG8oZSxcImdldEVuY29kaW5nXCIpLGVuY29kaW5nPXtnZXRFbmNvZGluZzplfSxlbmNvZGluZ31vKHJlcXVpcmVFbmNvZGluZyxcInJlcXVpcmVFbmNvZGluZ1wiKTt2YXIgdXRpbCQ1LGhhc1JlcXVpcmVkVXRpbCQ0O2Z1bmN0aW9uIHJlcXVpcmVVdGlsJDQoKXtpZihoYXNSZXF1aXJlZFV0aWwkNClyZXR1cm4gdXRpbCQ1O2hhc1JlcXVpcmVkVXRpbCQ0PTE7Y29uc3R7a1N0YXRlOmUsa0Vycm9yOkEsa1Jlc3VsdDp0LGtBYm9ydGVkOm4sa0xhc3RQcm9ncmVzc0V2ZW50RmlyZWQ6cn09cmVxdWlyZVN5bWJvbHMkMigpLHtQcm9ncmVzc0V2ZW50OnN9PXJlcXVpcmVQcm9ncmVzc2V2ZW50KCkse2dldEVuY29kaW5nOml9PXJlcXVpcmVFbmNvZGluZygpLHtzZXJpYWxpemVBTWltZVR5cGU6RSxwYXJzZU1JTUVUeXBlOlF9PXJlcXVpcmVEYXRhVXJsKCkse3R5cGVzOkN9PXJlcXVpcmUkJDBfX2RlZmF1bHQkMSx7U3RyaW5nRGVjb2RlcjpJfT1yZXF1aXJlJCQ1X19kZWZhdWx0JDIse2J0b2E6YX09cmVxdWlyZSQkNl9fZGVmYXVsdCxmPXtlbnVtZXJhYmxlOiEwLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMX07ZnVuY3Rpb24gaCh3LFUsTSxCKXtpZih3W2VdPT09XCJsb2FkaW5nXCIpdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIkludmFsaWQgc3RhdGVcIixcIkludmFsaWRTdGF0ZUVycm9yXCIpO3dbZV09XCJsb2FkaW5nXCIsd1t0XT1udWxsLHdbQV09bnVsbDtjb25zdCBHPVUuc3RyZWFtKCkuZ2V0UmVhZGVyKCksZz1bXTtsZXQgZD1HLnJlYWQoKSxGPSEwOyhhc3luYygpPT57Zm9yKDshd1tuXTspdHJ5e2NvbnN0e2RvbmU6Tix2YWx1ZTp1fT1hd2FpdCBkO2lmKEYmJiF3W25dJiZxdWV1ZU1pY3JvdGFzaygoKT0+e0woXCJsb2Fkc3RhcnRcIix3KX0pLEY9ITEsIU4mJkMuaXNVaW50OEFycmF5KHUpKWcucHVzaCh1KSwod1tyXT09PXZvaWQgMHx8RGF0ZS5ub3coKS13W3JdPj01MCkmJiF3W25dJiYod1tyXT1EYXRlLm5vdygpLHF1ZXVlTWljcm90YXNrKCgpPT57TChcInByb2dyZXNzXCIsdyl9KSksZD1HLnJlYWQoKTtlbHNlIGlmKE4pe3F1ZXVlTWljcm90YXNrKCgpPT57d1tlXT1cImRvbmVcIjt0cnl7Y29uc3QgYj1jKGcsTSxVLnR5cGUsQik7aWYod1tuXSlyZXR1cm47d1t0XT1iLEwoXCJsb2FkXCIsdyl9Y2F0Y2goYil7d1tBXT1iLEwoXCJlcnJvclwiLHcpfXdbZV0hPT1cImxvYWRpbmdcIiYmTChcImxvYWRlbmRcIix3KX0pO2JyZWFrfX1jYXRjaChOKXtpZih3W25dKXJldHVybjtxdWV1ZU1pY3JvdGFzaygoKT0+e3dbZV09XCJkb25lXCIsd1tBXT1OLEwoXCJlcnJvclwiLHcpLHdbZV0hPT1cImxvYWRpbmdcIiYmTChcImxvYWRlbmRcIix3KX0pO2JyZWFrfX0pKCl9byhoLFwicmVhZE9wZXJhdGlvblwiKTtmdW5jdGlvbiBMKHcsVSl7Y29uc3QgTT1uZXcgcyh3LHtidWJibGVzOiExLGNhbmNlbGFibGU6ITF9KTtVLmRpc3BhdGNoRXZlbnQoTSl9byhMLFwiZmlyZUFQcm9ncmVzc0V2ZW50XCIpO2Z1bmN0aW9uIGModyxVLE0sQil7c3dpdGNoKFUpe2Nhc2VcIkRhdGFVUkxcIjp7bGV0IEQ9XCJkYXRhOlwiO2NvbnN0IEc9UShNfHxcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKTtHIT09XCJmYWlsdXJlXCImJihEKz1FKEcpKSxEKz1cIjtiYXNlNjQsXCI7Y29uc3QgZz1uZXcgSShcImxhdGluMVwiKTtmb3IoY29uc3QgZCBvZiB3KUQrPWEoZy53cml0ZShkKSk7cmV0dXJuIEQrPWEoZy5lbmQoKSksRH1jYXNlXCJUZXh0XCI6e2xldCBEPVwiZmFpbHVyZVwiO2lmKEImJihEPWkoQikpLEQ9PT1cImZhaWx1cmVcIiYmTSl7Y29uc3QgRz1RKE0pO0chPT1cImZhaWx1cmVcIiYmKEQ9aShHLnBhcmFtZXRlcnMuZ2V0KFwiY2hhcnNldFwiKSkpfXJldHVybiBEPT09XCJmYWlsdXJlXCImJihEPVwiVVRGLThcIiksbCh3LEQpfWNhc2VcIkFycmF5QnVmZmVyXCI6cmV0dXJuIGsodykuYnVmZmVyO2Nhc2VcIkJpbmFyeVN0cmluZ1wiOntsZXQgRD1cIlwiO2NvbnN0IEc9bmV3IEkoXCJsYXRpbjFcIik7Zm9yKGNvbnN0IGcgb2YgdylEKz1HLndyaXRlKGcpO3JldHVybiBEKz1HLmVuZCgpLER9fX1vKGMsXCJwYWNrYWdlRGF0YVwiKTtmdW5jdGlvbiBsKHcsVSl7Y29uc3QgTT1rKHcpLEI9UyhNKTtsZXQgRD0wO0IhPT1udWxsJiYoVT1CLEQ9Qj09PVwiVVRGLThcIj8zOjIpO2NvbnN0IEc9TS5zbGljZShEKTtyZXR1cm4gbmV3IFRleHREZWNvZGVyKFUpLmRlY29kZShHKX1vKGwsXCJkZWNvZGVcIik7ZnVuY3Rpb24gUyh3KXtjb25zdFtVLE0sQl09dztyZXR1cm4gVT09PTIzOSYmTT09PTE4NyYmQj09PTE5MT9cIlVURi04XCI6VT09PTI1NCYmTT09PTI1NT9cIlVURi0xNkJFXCI6VT09PTI1NSYmTT09PTI1ND9cIlVURi0xNkxFXCI6bnVsbH1vKFMsXCJCT01TbmlmZmluZ1wiKTtmdW5jdGlvbiBrKHcpe2NvbnN0IFU9dy5yZWR1Y2UoKEIsRCk9PkIrRC5ieXRlTGVuZ3RoLDApO2xldCBNPTA7cmV0dXJuIHcucmVkdWNlKChCLEQpPT4oQi5zZXQoRCxNKSxNKz1ELmJ5dGVMZW5ndGgsQiksbmV3IFVpbnQ4QXJyYXkoVSkpfXJldHVybiBvKGssXCJjb21iaW5lQnl0ZVNlcXVlbmNlc1wiKSx1dGlsJDU9e3N0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnM6ZixyZWFkT3BlcmF0aW9uOmgsZmlyZUFQcm9ncmVzc0V2ZW50Okx9LHV0aWwkNX1vKHJlcXVpcmVVdGlsJDQsXCJyZXF1aXJlVXRpbCQ0XCIpO3ZhciBmaWxlcmVhZGVyLGhhc1JlcXVpcmVkRmlsZXJlYWRlcjtmdW5jdGlvbiByZXF1aXJlRmlsZXJlYWRlcigpe2lmKGhhc1JlcXVpcmVkRmlsZXJlYWRlcilyZXR1cm4gZmlsZXJlYWRlcjtoYXNSZXF1aXJlZEZpbGVyZWFkZXI9MTtjb25zdHtzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzOmUscmVhZE9wZXJhdGlvbjpBLGZpcmVBUHJvZ3Jlc3NFdmVudDp0fT1yZXF1aXJlVXRpbCQ0KCkse2tTdGF0ZTpuLGtFcnJvcjpyLGtSZXN1bHQ6cyxrRXZlbnRzOmksa0Fib3J0ZWQ6RX09cmVxdWlyZVN5bWJvbHMkMigpLHt3ZWJpZGw6UX09cmVxdWlyZVdlYmlkbCgpLHtrRW51bWVyYWJsZVByb3BlcnR5OkN9PXV0aWwkbSxhPWNsYXNzIGEgZXh0ZW5kcyBFdmVudFRhcmdldHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpc1tuXT1cImVtcHR5XCIsdGhpc1tzXT1udWxsLHRoaXNbcl09bnVsbCx0aGlzW2ldPXtsb2FkZW5kOm51bGwsZXJyb3I6bnVsbCxhYm9ydDpudWxsLGxvYWQ6bnVsbCxwcm9ncmVzczpudWxsLGxvYWRzdGFydDpudWxsfX1yZWFkQXNBcnJheUJ1ZmZlcihoKXtRLmJyYW5kQ2hlY2sodGhpcyxhKSxRLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLDEse2hlYWRlcjpcIkZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXJcIn0pLGg9US5jb252ZXJ0ZXJzLkJsb2IoaCx7c3RyaWN0OiExfSksQSh0aGlzLGgsXCJBcnJheUJ1ZmZlclwiKX1yZWFkQXNCaW5hcnlTdHJpbmcoaCl7US5icmFuZENoZWNrKHRoaXMsYSksUS5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6XCJGaWxlUmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZ1wifSksaD1RLmNvbnZlcnRlcnMuQmxvYihoLHtzdHJpY3Q6ITF9KSxBKHRoaXMsaCxcIkJpbmFyeVN0cmluZ1wiKX1yZWFkQXNUZXh0KGgsTD12b2lkIDApe1EuYnJhbmRDaGVjayh0aGlzLGEpLFEuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMSx7aGVhZGVyOlwiRmlsZVJlYWRlci5yZWFkQXNUZXh0XCJ9KSxoPVEuY29udmVydGVycy5CbG9iKGgse3N0cmljdDohMX0pLEwhPT12b2lkIDAmJihMPVEuY29udmVydGVycy5ET01TdHJpbmcoTCkpLEEodGhpcyxoLFwiVGV4dFwiLEwpfXJlYWRBc0RhdGFVUkwoaCl7US5icmFuZENoZWNrKHRoaXMsYSksUS5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6XCJGaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkxcIn0pLGg9US5jb252ZXJ0ZXJzLkJsb2IoaCx7c3RyaWN0OiExfSksQSh0aGlzLGgsXCJEYXRhVVJMXCIpfWFib3J0KCl7aWYodGhpc1tuXT09PVwiZW1wdHlcInx8dGhpc1tuXT09PVwiZG9uZVwiKXt0aGlzW3NdPW51bGw7cmV0dXJufXRoaXNbbl09PT1cImxvYWRpbmdcIiYmKHRoaXNbbl09XCJkb25lXCIsdGhpc1tzXT1udWxsKSx0aGlzW0VdPSEwLHQoXCJhYm9ydFwiLHRoaXMpLHRoaXNbbl0hPT1cImxvYWRpbmdcIiYmdChcImxvYWRlbmRcIix0aGlzKX1nZXQgcmVhZHlTdGF0ZSgpe3N3aXRjaChRLmJyYW5kQ2hlY2sodGhpcyxhKSx0aGlzW25dKXtjYXNlXCJlbXB0eVwiOnJldHVybiB0aGlzLkVNUFRZO2Nhc2VcImxvYWRpbmdcIjpyZXR1cm4gdGhpcy5MT0FESU5HO2Nhc2VcImRvbmVcIjpyZXR1cm4gdGhpcy5ET05FfX1nZXQgcmVzdWx0KCl7cmV0dXJuIFEuYnJhbmRDaGVjayh0aGlzLGEpLHRoaXNbc119Z2V0IGVycm9yKCl7cmV0dXJuIFEuYnJhbmRDaGVjayh0aGlzLGEpLHRoaXNbcl19Z2V0IG9ubG9hZGVuZCgpe3JldHVybiBRLmJyYW5kQ2hlY2sodGhpcyxhKSx0aGlzW2ldLmxvYWRlbmR9c2V0IG9ubG9hZGVuZChoKXtRLmJyYW5kQ2hlY2sodGhpcyxhKSx0aGlzW2ldLmxvYWRlbmQmJnRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlbmRcIix0aGlzW2ldLmxvYWRlbmQpLHR5cGVvZiBoPT1cImZ1bmN0aW9uXCI/KHRoaXNbaV0ubG9hZGVuZD1oLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlbmRcIixoKSk6dGhpc1tpXS5sb2FkZW5kPW51bGx9Z2V0IG9uZXJyb3IoKXtyZXR1cm4gUS5icmFuZENoZWNrKHRoaXMsYSksdGhpc1tpXS5lcnJvcn1zZXQgb25lcnJvcihoKXtRLmJyYW5kQ2hlY2sodGhpcyxhKSx0aGlzW2ldLmVycm9yJiZ0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLHRoaXNbaV0uZXJyb3IpLHR5cGVvZiBoPT1cImZ1bmN0aW9uXCI/KHRoaXNbaV0uZXJyb3I9aCx0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGgpKTp0aGlzW2ldLmVycm9yPW51bGx9Z2V0IG9ubG9hZHN0YXJ0KCl7cmV0dXJuIFEuYnJhbmRDaGVjayh0aGlzLGEpLHRoaXNbaV0ubG9hZHN0YXJ0fXNldCBvbmxvYWRzdGFydChoKXtRLmJyYW5kQ2hlY2sodGhpcyxhKSx0aGlzW2ldLmxvYWRzdGFydCYmdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZHN0YXJ0XCIsdGhpc1tpXS5sb2Fkc3RhcnQpLHR5cGVvZiBoPT1cImZ1bmN0aW9uXCI/KHRoaXNbaV0ubG9hZHN0YXJ0PWgsdGhpcy5hZGRFdmVudExpc3RlbmVyKFwibG9hZHN0YXJ0XCIsaCkpOnRoaXNbaV0ubG9hZHN0YXJ0PW51bGx9Z2V0IG9ucHJvZ3Jlc3MoKXtyZXR1cm4gUS5icmFuZENoZWNrKHRoaXMsYSksdGhpc1tpXS5wcm9ncmVzc31zZXQgb25wcm9ncmVzcyhoKXtRLmJyYW5kQ2hlY2sodGhpcyxhKSx0aGlzW2ldLnByb2dyZXNzJiZ0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLHRoaXNbaV0ucHJvZ3Jlc3MpLHR5cGVvZiBoPT1cImZ1bmN0aW9uXCI/KHRoaXNbaV0ucHJvZ3Jlc3M9aCx0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLGgpKTp0aGlzW2ldLnByb2dyZXNzPW51bGx9Z2V0IG9ubG9hZCgpe3JldHVybiBRLmJyYW5kQ2hlY2sodGhpcyxhKSx0aGlzW2ldLmxvYWR9c2V0IG9ubG9hZChoKXtRLmJyYW5kQ2hlY2sodGhpcyxhKSx0aGlzW2ldLmxvYWQmJnRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIix0aGlzW2ldLmxvYWQpLHR5cGVvZiBoPT1cImZ1bmN0aW9uXCI/KHRoaXNbaV0ubG9hZD1oLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixoKSk6dGhpc1tpXS5sb2FkPW51bGx9Z2V0IG9uYWJvcnQoKXtyZXR1cm4gUS5icmFuZENoZWNrKHRoaXMsYSksdGhpc1tpXS5hYm9ydH1zZXQgb25hYm9ydChoKXtRLmJyYW5kQ2hlY2sodGhpcyxhKSx0aGlzW2ldLmFib3J0JiZ0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLHRoaXNbaV0uYWJvcnQpLHR5cGVvZiBoPT1cImZ1bmN0aW9uXCI/KHRoaXNbaV0uYWJvcnQ9aCx0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLGgpKTp0aGlzW2ldLmFib3J0PW51bGx9fTtvKGEsXCJGaWxlUmVhZGVyXCIpO2xldCBJPWE7cmV0dXJuIEkuRU1QVFk9SS5wcm90b3R5cGUuRU1QVFk9MCxJLkxPQURJTkc9SS5wcm90b3R5cGUuTE9BRElORz0xLEkuRE9ORT1JLnByb3RvdHlwZS5ET05FPTIsT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSS5wcm90b3R5cGUse0VNUFRZOmUsTE9BRElORzplLERPTkU6ZSxyZWFkQXNBcnJheUJ1ZmZlcjpDLHJlYWRBc0JpbmFyeVN0cmluZzpDLHJlYWRBc1RleHQ6QyxyZWFkQXNEYXRhVVJMOkMsYWJvcnQ6QyxyZWFkeVN0YXRlOkMscmVzdWx0OkMsZXJyb3I6QyxvbmxvYWRzdGFydDpDLG9ucHJvZ3Jlc3M6QyxvbmxvYWQ6QyxvbmFib3J0OkMsb25lcnJvcjpDLG9ubG9hZGVuZDpDLFtTeW1ib2wudG9TdHJpbmdUYWddOnt2YWx1ZTpcIkZpbGVSZWFkZXJcIix3cml0YWJsZTohMSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH19KSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhJLHtFTVBUWTplLExPQURJTkc6ZSxET05FOmV9KSxmaWxlcmVhZGVyPXtGaWxlUmVhZGVyOkl9LGZpbGVyZWFkZXJ9byhyZXF1aXJlRmlsZXJlYWRlcixcInJlcXVpcmVGaWxlcmVhZGVyXCIpO3ZhciBzeW1ib2xzJDEsaGFzUmVxdWlyZWRTeW1ib2xzJDE7ZnVuY3Rpb24gcmVxdWlyZVN5bWJvbHMkMSgpe3JldHVybiBoYXNSZXF1aXJlZFN5bWJvbHMkMXx8KGhhc1JlcXVpcmVkU3ltYm9scyQxPTEsc3ltYm9scyQxPXtrQ29uc3RydWN0OnN5bWJvbHMkNC5rQ29uc3RydWN0fSksc3ltYm9scyQxfW8ocmVxdWlyZVN5bWJvbHMkMSxcInJlcXVpcmVTeW1ib2xzJDFcIik7dmFyIHV0aWwkNCxoYXNSZXF1aXJlZFV0aWwkMztmdW5jdGlvbiByZXF1aXJlVXRpbCQzKCl7aWYoaGFzUmVxdWlyZWRVdGlsJDMpcmV0dXJuIHV0aWwkNDtoYXNSZXF1aXJlZFV0aWwkMz0xO2NvbnN0IGU9cmVxdWlyZSQkMF9fZGVmYXVsdCx7VVJMU2VyaWFsaXplcjpBfT1yZXF1aXJlRGF0YVVybCgpLHtpc1ZhbGlkSGVhZGVyTmFtZTp0fT1yZXF1aXJlVXRpbCQ1KCk7ZnVuY3Rpb24gbihzLGksRT0hMSl7Y29uc3QgUT1BKHMsRSksQz1BKGksRSk7cmV0dXJuIFE9PT1DfW8obixcInVybEVxdWFsc1wiKTtmdW5jdGlvbiByKHMpe2UocyE9PW51bGwpO2NvbnN0IGk9W107Zm9yKGxldCBFIG9mIHMuc3BsaXQoXCIsXCIpKUU9RS50cmltKCksdChFKSYmaS5wdXNoKEUpO3JldHVybiBpfXJldHVybiBvKHIsXCJnZXRGaWVsZFZhbHVlc1wiKSx1dGlsJDQ9e3VybEVxdWFsczpuLGdldEZpZWxkVmFsdWVzOnJ9LHV0aWwkNH1vKHJlcXVpcmVVdGlsJDMsXCJyZXF1aXJlVXRpbCQzXCIpO3ZhciBjYWNoZSxoYXNSZXF1aXJlZENhY2hlO2Z1bmN0aW9uIHJlcXVpcmVDYWNoZSgpe3ZhciB3LFUscWUsQiwkQSxHLHd0LGQsamU7aWYoaGFzUmVxdWlyZWRDYWNoZSlyZXR1cm4gY2FjaGU7aGFzUmVxdWlyZWRDYWNoZT0xO2NvbnN0e2tDb25zdHJ1Y3Q6ZX09cmVxdWlyZVN5bWJvbHMkMSgpLHt1cmxFcXVhbHM6QSxnZXRGaWVsZFZhbHVlczp0fT1yZXF1aXJlVXRpbCQzKCkse2tFbnVtZXJhYmxlUHJvcGVydHk6bixpc0Rpc3R1cmJlZDpyfT11dGlsJG0se3dlYmlkbDpzfT1yZXF1aXJlV2ViaWRsKCkse1Jlc3BvbnNlOmksY2xvbmVSZXNwb25zZTpFLGZyb21Jbm5lclJlc3BvbnNlOlF9PXJlcXVpcmVSZXNwb25zZSgpLHtSZXF1ZXN0OkMsZnJvbUlubmVyUmVxdWVzdDpJfT1yZXF1aXJlUmVxdWVzdCgpLHtrU3RhdGU6YX09cmVxdWlyZVN5bWJvbHMkMygpLHtmZXRjaGluZzpmfT1yZXF1aXJlRmV0Y2goKSx7dXJsSXNIdHRwSHR0cHNTY2hlbWU6aCxjcmVhdGVEZWZlcnJlZFByb21pc2U6TCxyZWFkQWxsQnl0ZXM6Y309cmVxdWlyZVV0aWwkNSgpLGw9cmVxdWlyZSQkMF9fZGVmYXVsdCxOPWNsYXNzIE57Y29uc3RydWN0b3IoKXtDQSh0aGlzLFUpO0NBKHRoaXMsQik7Q0EodGhpcyxHKTtDQSh0aGlzLGQpO0NBKHRoaXMsdyx2b2lkIDApO2FyZ3VtZW50c1swXSE9PWUmJnMuaWxsZWdhbENvbnN0cnVjdG9yKCksRUEodGhpcyx3LGFyZ3VtZW50c1sxXSl9YXN5bmMgbWF0Y2goYixtPXt9KXtzLmJyYW5kQ2hlY2sodGhpcyxOKSxzLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLDEse2hlYWRlcjpcIkNhY2hlLm1hdGNoXCJ9KSxiPXMuY29udmVydGVycy5SZXF1ZXN0SW5mbyhiKSxtPXMuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhtKTtjb25zdCBUPWtBKHRoaXMsZCxqZSkuY2FsbCh0aGlzLGIsbSwxKTtpZihULmxlbmd0aCE9PTApcmV0dXJuIFRbMF19YXN5bmMgbWF0Y2hBbGwoYj12b2lkIDAsbT17fSl7cmV0dXJuIHMuYnJhbmRDaGVjayh0aGlzLE4pLGIhPT12b2lkIDAmJihiPXMuY29udmVydGVycy5SZXF1ZXN0SW5mbyhiKSksbT1zLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMobSksa0EodGhpcyxkLGplKS5jYWxsKHRoaXMsYixtKX1hc3luYyBhZGQoYil7cy5icmFuZENoZWNrKHRoaXMsTikscy5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6XCJDYWNoZS5hZGRcIn0pLGI9cy5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKGIpO2NvbnN0IG09W2JdO3JldHVybiBhd2FpdCB0aGlzLmFkZEFsbChtKX1hc3luYyBhZGRBbGwoYil7cy5icmFuZENoZWNrKHRoaXMsTikscy5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6XCJDYWNoZS5hZGRBbGxcIn0pO2NvbnN0IG09W10sVD1bXTtmb3IobGV0IFggb2YgYil7aWYoWD09PXZvaWQgMCl0aHJvdyBzLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtwcmVmaXg6XCJDYWNoZS5hZGRBbGxcIixhcmd1bWVudDpcIkFyZ3VtZW50IDFcIix0eXBlczpbXCJ1bmRlZmluZWQgaXMgbm90IGFsbG93ZWRcIl19KTtpZihYPXMuY29udmVydGVycy5SZXF1ZXN0SW5mbyhYKSx0eXBlb2YgWD09XCJzdHJpbmdcIiljb250aW51ZTtjb25zdCAkPVhbYV07aWYoIWgoJC51cmwpfHwkLm1ldGhvZCE9PVwiR0VUXCIpdGhyb3cgcy5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJDYWNoZS5hZGRBbGxcIixtZXNzYWdlOlwiRXhwZWN0ZWQgaHR0cC9zIHNjaGVtZSB3aGVuIG1ldGhvZCBpcyBub3QgR0VULlwifSl9Y29uc3Qgdj1bXTtmb3IoY29uc3QgWCBvZiBiKXtjb25zdCAkPW5ldyBDKFgpW2FdO2lmKCFoKCQudXJsKSl0aHJvdyBzLmVycm9ycy5leGNlcHRpb24oe2hlYWRlcjpcIkNhY2hlLmFkZEFsbFwiLG1lc3NhZ2U6XCJFeHBlY3RlZCBodHRwL3Mgc2NoZW1lLlwifSk7JC5pbml0aWF0b3I9XCJmZXRjaFwiLCQuZGVzdGluYXRpb249XCJzdWJyZXNvdXJjZVwiLFQucHVzaCgkKTtjb25zdCBWPUwoKTt2LnB1c2goZih7cmVxdWVzdDokLHByb2Nlc3NSZXNwb25zZShxKXtpZihxLnR5cGU9PT1cImVycm9yXCJ8fHEuc3RhdHVzPT09MjA2fHxxLnN0YXR1czwyMDB8fHEuc3RhdHVzPjI5OSlWLnJlamVjdChzLmVycm9ycy5leGNlcHRpb24oe2hlYWRlcjpcIkNhY2hlLmFkZEFsbFwiLG1lc3NhZ2U6XCJSZWNlaXZlZCBhbiBpbnZhbGlkIHN0YXR1cyBjb2RlIG9yIHRoZSByZXF1ZXN0IGZhaWxlZC5cIn0pKTtlbHNlIGlmKHEuaGVhZGVyc0xpc3QuY29udGFpbnMoXCJ2YXJ5XCIpKXtjb25zdCB6PXQocS5oZWFkZXJzTGlzdC5nZXQoXCJ2YXJ5XCIpKTtmb3IoY29uc3QgckEgb2YgeilpZihyQT09PVwiKlwiKXtWLnJlamVjdChzLmVycm9ycy5leGNlcHRpb24oe2hlYWRlcjpcIkNhY2hlLmFkZEFsbFwiLG1lc3NhZ2U6XCJpbnZhbGlkIHZhcnkgZmllbGQgdmFsdWVcIn0pKTtmb3IoY29uc3QgaUEgb2YgdilpQS5hYm9ydCgpO3JldHVybn19fSxwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkocSl7aWYocS5hYm9ydGVkKXtWLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKFwiYWJvcnRlZFwiLFwiQWJvcnRFcnJvclwiKSk7cmV0dXJufVYucmVzb2x2ZShxKX19KSksbS5wdXNoKFYucHJvbWlzZSl9Y29uc3QgUD1hd2FpdCBQcm9taXNlLmFsbChtKSxBQT1bXTtsZXQgSz0wO2Zvcihjb25zdCBYIG9mIFApe2NvbnN0ICQ9e3R5cGU6XCJwdXRcIixyZXF1ZXN0OlRbS10scmVzcG9uc2U6WH07QUEucHVzaCgkKSxLKyt9Y29uc3QgdEE9TCgpO2xldCBhQT1udWxsO3RyeXtrQSh0aGlzLFUscWUpLmNhbGwodGhpcyxBQSl9Y2F0Y2goWCl7YUE9WH1yZXR1cm4gcXVldWVNaWNyb3Rhc2soKCk9PnthQT09PW51bGw/dEEucmVzb2x2ZSh2b2lkIDApOnRBLnJlamVjdChhQSl9KSx0QS5wcm9taXNlfWFzeW5jIHB1dChiLG0pe3MuYnJhbmRDaGVjayh0aGlzLE4pLHMuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMix7aGVhZGVyOlwiQ2FjaGUucHV0XCJ9KSxiPXMuY29udmVydGVycy5SZXF1ZXN0SW5mbyhiKSxtPXMuY29udmVydGVycy5SZXNwb25zZShtKTtsZXQgVD1udWxsO2lmKGIgaW5zdGFuY2VvZiBDP1Q9YlthXTpUPW5ldyBDKGIpW2FdLCFoKFQudXJsKXx8VC5tZXRob2QhPT1cIkdFVFwiKXRocm93IHMuZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOlwiQ2FjaGUucHV0XCIsbWVzc2FnZTpcIkV4cGVjdGVkIGFuIGh0dHAvcyBzY2hlbWUgd2hlbiBtZXRob2QgaXMgbm90IEdFVFwifSk7Y29uc3Qgdj1tW2FdO2lmKHYuc3RhdHVzPT09MjA2KXRocm93IHMuZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOlwiQ2FjaGUucHV0XCIsbWVzc2FnZTpcIkdvdCAyMDYgc3RhdHVzXCJ9KTtpZih2LmhlYWRlcnNMaXN0LmNvbnRhaW5zKFwidmFyeVwiKSl7Y29uc3QgJD10KHYuaGVhZGVyc0xpc3QuZ2V0KFwidmFyeVwiKSk7Zm9yKGNvbnN0IFYgb2YgJClpZihWPT09XCIqXCIpdGhyb3cgcy5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJDYWNoZS5wdXRcIixtZXNzYWdlOlwiR290ICogdmFyeSBmaWVsZCB2YWx1ZVwifSl9aWYodi5ib2R5JiYocih2LmJvZHkuc3RyZWFtKXx8di5ib2R5LnN0cmVhbS5sb2NrZWQpKXRocm93IHMuZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOlwiQ2FjaGUucHV0XCIsbWVzc2FnZTpcIlJlc3BvbnNlIGJvZHkgaXMgbG9ja2VkIG9yIGRpc3R1cmJlZFwifSk7Y29uc3QgWj1FKHYpLFA9TCgpO2lmKHYuYm9keSE9bnVsbCl7Y29uc3QgVj12LmJvZHkuc3RyZWFtLmdldFJlYWRlcigpO2MoVikudGhlbihQLnJlc29sdmUsUC5yZWplY3QpfWVsc2UgUC5yZXNvbHZlKHZvaWQgMCk7Y29uc3QgQUE9W10sSz17dHlwZTpcInB1dFwiLHJlcXVlc3Q6VCxyZXNwb25zZTpafTtBQS5wdXNoKEspO2NvbnN0IHRBPWF3YWl0IFAucHJvbWlzZTtaLmJvZHkhPW51bGwmJihaLmJvZHkuc291cmNlPXRBKTtjb25zdCBhQT1MKCk7bGV0IFg9bnVsbDt0cnl7a0EodGhpcyxVLHFlKS5jYWxsKHRoaXMsQUEpfWNhdGNoKCQpe1g9JH1yZXR1cm4gcXVldWVNaWNyb3Rhc2soKCk9PntYPT09bnVsbD9hQS5yZXNvbHZlKCk6YUEucmVqZWN0KFgpfSksYUEucHJvbWlzZX1hc3luYyBkZWxldGUoYixtPXt9KXtzLmJyYW5kQ2hlY2sodGhpcyxOKSxzLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLDEse2hlYWRlcjpcIkNhY2hlLmRlbGV0ZVwifSksYj1zLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8oYiksbT1zLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMobSk7bGV0IFQ9bnVsbDtpZihiIGluc3RhbmNlb2YgQyl7aWYoVD1iW2FdLFQubWV0aG9kIT09XCJHRVRcIiYmIW0uaWdub3JlTWV0aG9kKXJldHVybiExfWVsc2UgbCh0eXBlb2YgYj09XCJzdHJpbmdcIiksVD1uZXcgQyhiKVthXTtjb25zdCB2PVtdLFo9e3R5cGU6XCJkZWxldGVcIixyZXF1ZXN0OlQsb3B0aW9uczptfTt2LnB1c2goWik7Y29uc3QgUD1MKCk7bGV0IEFBPW51bGwsSzt0cnl7Sz1rQSh0aGlzLFUscWUpLmNhbGwodGhpcyx2KX1jYXRjaCh0QSl7QUE9dEF9cmV0dXJuIHF1ZXVlTWljcm90YXNrKCgpPT57QUE9PT1udWxsP1AucmVzb2x2ZSghIUs/Lmxlbmd0aCk6UC5yZWplY3QoQUEpfSksUC5wcm9taXNlfWFzeW5jIGtleXMoYj12b2lkIDAsbT17fSl7cy5icmFuZENoZWNrKHRoaXMsTiksYiE9PXZvaWQgMCYmKGI9cy5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKGIpKSxtPXMuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhtKTtsZXQgVD1udWxsO2lmKGIhPT12b2lkIDApaWYoYiBpbnN0YW5jZW9mIEMpe2lmKFQ9YlthXSxULm1ldGhvZCE9PVwiR0VUXCImJiFtLmlnbm9yZU1ldGhvZClyZXR1cm5bXX1lbHNlIHR5cGVvZiBiPT1cInN0cmluZ1wiJiYoVD1uZXcgQyhiKVthXSk7Y29uc3Qgdj1MKCksWj1bXTtpZihiPT09dm9pZCAwKWZvcihjb25zdCBQIG9mIHAodGhpcyx3KSlaLnB1c2goUFswXSk7ZWxzZXtjb25zdCBQPWtBKHRoaXMsQiwkQSkuY2FsbCh0aGlzLFQsbSk7Zm9yKGNvbnN0IEFBIG9mIFApWi5wdXNoKEFBWzBdKX1yZXR1cm4gcXVldWVNaWNyb3Rhc2soKCk9Pntjb25zdCBQPVtdO2Zvcihjb25zdCBBQSBvZiBaKXtjb25zdCBLPUkoQUEsbmV3IEFib3J0Q29udHJvbGxlcigpLnNpZ25hbCxcImltbXV0YWJsZVwiLHtzZXR0aW5nc09iamVjdDpBQS5jbGllbnR9KTtQLnB1c2goSyl9di5yZXNvbHZlKE9iamVjdC5mcmVlemUoUCkpfSksdi5wcm9taXNlfX07dz1uZXcgV2Vha01hcCxVPW5ldyBXZWFrU2V0LHFlPW8oZnVuY3Rpb24oYil7Y29uc3QgbT1wKHRoaXMsdyksVD1bLi4ubV0sdj1bXSxaPVtdO3RyeXtmb3IoY29uc3QgUCBvZiBiKXtpZihQLnR5cGUhPT1cImRlbGV0ZVwiJiZQLnR5cGUhPT1cInB1dFwiKXRocm93IHMuZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOlwiQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zXCIsbWVzc2FnZTonb3BlcmF0aW9uIHR5cGUgZG9lcyBub3QgbWF0Y2ggXCJkZWxldGVcIiBvciBcInB1dFwiJ30pO2lmKFAudHlwZT09PVwiZGVsZXRlXCImJlAucmVzcG9uc2UhPW51bGwpdGhyb3cgcy5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnNcIixtZXNzYWdlOlwiZGVsZXRlIG9wZXJhdGlvbiBzaG91bGQgbm90IGhhdmUgYW4gYXNzb2NpYXRlZCByZXNwb25zZVwifSk7aWYoa0EodGhpcyxCLCRBKS5jYWxsKHRoaXMsUC5yZXF1ZXN0LFAub3B0aW9ucyx2KS5sZW5ndGgpdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIj8/P1wiLFwiSW52YWxpZFN0YXRlRXJyb3JcIik7bGV0IEFBO2lmKFAudHlwZT09PVwiZGVsZXRlXCIpe2lmKEFBPWtBKHRoaXMsQiwkQSkuY2FsbCh0aGlzLFAucmVxdWVzdCxQLm9wdGlvbnMpLEFBLmxlbmd0aD09PTApcmV0dXJuW107Zm9yKGNvbnN0IEsgb2YgQUEpe2NvbnN0IHRBPW0uaW5kZXhPZihLKTtsKHRBIT09LTEpLG0uc3BsaWNlKHRBLDEpfX1lbHNlIGlmKFAudHlwZT09PVwicHV0XCIpe2lmKFAucmVzcG9uc2U9PW51bGwpdGhyb3cgcy5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnNcIixtZXNzYWdlOlwicHV0IG9wZXJhdGlvbiBzaG91bGQgaGF2ZSBhbiBhc3NvY2lhdGVkIHJlc3BvbnNlXCJ9KTtjb25zdCBLPVAucmVxdWVzdDtpZighaChLLnVybCkpdGhyb3cgcy5lcnJvcnMuZXhjZXB0aW9uKHtoZWFkZXI6XCJDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnNcIixtZXNzYWdlOlwiZXhwZWN0ZWQgaHR0cCBvciBodHRwcyBzY2hlbWVcIn0pO2lmKEsubWV0aG9kIT09XCJHRVRcIil0aHJvdyBzLmVycm9ycy5leGNlcHRpb24oe2hlYWRlcjpcIkNhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9uc1wiLG1lc3NhZ2U6XCJub3QgZ2V0IG1ldGhvZFwifSk7aWYoUC5vcHRpb25zIT1udWxsKXRocm93IHMuZXJyb3JzLmV4Y2VwdGlvbih7aGVhZGVyOlwiQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zXCIsbWVzc2FnZTpcIm9wdGlvbnMgbXVzdCBub3QgYmUgZGVmaW5lZFwifSk7QUE9a0EodGhpcyxCLCRBKS5jYWxsKHRoaXMsUC5yZXF1ZXN0KTtmb3IoY29uc3QgdEEgb2YgQUEpe2NvbnN0IGFBPW0uaW5kZXhPZih0QSk7bChhQSE9PS0xKSxtLnNwbGljZShhQSwxKX1tLnB1c2goW1AucmVxdWVzdCxQLnJlc3BvbnNlXSksdi5wdXNoKFtQLnJlcXVlc3QsUC5yZXNwb25zZV0pfVoucHVzaChbUC5yZXF1ZXN0LFAucmVzcG9uc2VdKX1yZXR1cm4gWn1jYXRjaChQKXt0aHJvdyBwKHRoaXMsdykubGVuZ3RoPTAsRUEodGhpcyx3LFQpLFB9fSxcIiNiYXRjaENhY2hlT3BlcmF0aW9uc1wiKSxCPW5ldyBXZWFrU2V0LCRBPW8oZnVuY3Rpb24oYixtLFQpe2NvbnN0IHY9W10sWj1UPz9wKHRoaXMsdyk7Zm9yKGNvbnN0IFAgb2YgWil7Y29uc3RbQUEsS109UDtrQSh0aGlzLEcsd3QpLmNhbGwodGhpcyxiLEFBLEssbSkmJnYucHVzaChQKX1yZXR1cm4gdn0sXCIjcXVlcnlDYWNoZVwiKSxHPW5ldyBXZWFrU2V0LHd0PW8oZnVuY3Rpb24oYixtLFQ9bnVsbCx2KXtjb25zdCBaPW5ldyBVUkwoYi51cmwpLFA9bmV3IFVSTChtLnVybCk7aWYodj8uaWdub3JlU2VhcmNoJiYoUC5zZWFyY2g9XCJcIixaLnNlYXJjaD1cIlwiKSwhQShaLFAsITApKXJldHVybiExO2lmKFQ9PW51bGx8fHY/Lmlnbm9yZVZhcnl8fCFULmhlYWRlcnNMaXN0LmNvbnRhaW5zKFwidmFyeVwiKSlyZXR1cm4hMDtjb25zdCBBQT10KFQuaGVhZGVyc0xpc3QuZ2V0KFwidmFyeVwiKSk7Zm9yKGNvbnN0IEsgb2YgQUEpe2lmKEs9PT1cIipcIilyZXR1cm4hMTtjb25zdCB0QT1tLmhlYWRlcnNMaXN0LmdldChLKSxhQT1iLmhlYWRlcnNMaXN0LmdldChLKTtpZih0QSE9PWFBKXJldHVybiExfXJldHVybiEwfSxcIiNyZXF1ZXN0TWF0Y2hlc0NhY2hlZEl0ZW1cIiksZD1uZXcgV2Vha1NldCxqZT1vKGZ1bmN0aW9uKGIsbSxUPTEvMCl7bGV0IHY9bnVsbDtpZihiIT09dm9pZCAwKWlmKGIgaW5zdGFuY2VvZiBDKXtpZih2PWJbYV0sdi5tZXRob2QhPT1cIkdFVFwiJiYhbS5pZ25vcmVNZXRob2QpcmV0dXJuW119ZWxzZSB0eXBlb2YgYj09XCJzdHJpbmdcIiYmKHY9bmV3IEMoYilbYV0pO2NvbnN0IFo9W107aWYoYj09PXZvaWQgMClmb3IoY29uc3QgQUEgb2YgcCh0aGlzLHcpKVoucHVzaChBQVsxXSk7ZWxzZXtjb25zdCBBQT1rQSh0aGlzLEIsJEEpLmNhbGwodGhpcyx2LG0pO2Zvcihjb25zdCBLIG9mIEFBKVoucHVzaChLWzFdKX1jb25zdCBQPVtdO2Zvcihjb25zdCBBQSBvZiBaKXtjb25zdCBLPVEoQUEsXCJpbW11dGFibGVcIix7c2V0dGluZ3NPYmplY3Q6e319KTtpZihQLnB1c2goSy5jbG9uZSgpKSxQLmxlbmd0aD49VClicmVha31yZXR1cm4gT2JqZWN0LmZyZWV6ZShQKX0sXCIjaW50ZXJuYWxNYXRjaEFsbFwiKSxvKE4sXCJDYWNoZVwiKTtsZXQgUz1OO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFMucHJvdG90eXBlLHtbU3ltYm9sLnRvU3RyaW5nVGFnXTp7dmFsdWU6XCJDYWNoZVwiLGNvbmZpZ3VyYWJsZTohMH0sbWF0Y2g6bixtYXRjaEFsbDpuLGFkZDpuLGFkZEFsbDpuLHB1dDpuLGRlbGV0ZTpuLGtleXM6bn0pO2NvbnN0IGs9W3trZXk6XCJpZ25vcmVTZWFyY2hcIixjb252ZXJ0ZXI6cy5jb252ZXJ0ZXJzLmJvb2xlYW4sZGVmYXVsdFZhbHVlOiExfSx7a2V5OlwiaWdub3JlTWV0aG9kXCIsY29udmVydGVyOnMuY29udmVydGVycy5ib29sZWFuLGRlZmF1bHRWYWx1ZTohMX0se2tleTpcImlnbm9yZVZhcnlcIixjb252ZXJ0ZXI6cy5jb252ZXJ0ZXJzLmJvb2xlYW4sZGVmYXVsdFZhbHVlOiExfV07cmV0dXJuIHMuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucz1zLmRpY3Rpb25hcnlDb252ZXJ0ZXIoaykscy5jb252ZXJ0ZXJzLk11bHRpQ2FjaGVRdWVyeU9wdGlvbnM9cy5kaWN0aW9uYXJ5Q29udmVydGVyKFsuLi5rLHtrZXk6XCJjYWNoZU5hbWVcIixjb252ZXJ0ZXI6cy5jb252ZXJ0ZXJzLkRPTVN0cmluZ31dKSxzLmNvbnZlcnRlcnMuUmVzcG9uc2U9cy5pbnRlcmZhY2VDb252ZXJ0ZXIoaSkscy5jb252ZXJ0ZXJzW1wic2VxdWVuY2U8UmVxdWVzdEluZm8+XCJdPXMuc2VxdWVuY2VDb252ZXJ0ZXIocy5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKSxjYWNoZT17Q2FjaGU6U30sY2FjaGV9byhyZXF1aXJlQ2FjaGUsXCJyZXF1aXJlQ2FjaGVcIik7dmFyIGNhY2hlc3RvcmFnZSxoYXNSZXF1aXJlZENhY2hlc3RvcmFnZTtmdW5jdGlvbiByZXF1aXJlQ2FjaGVzdG9yYWdlKCl7dmFyIHM7aWYoaGFzUmVxdWlyZWRDYWNoZXN0b3JhZ2UpcmV0dXJuIGNhY2hlc3RvcmFnZTtoYXNSZXF1aXJlZENhY2hlc3RvcmFnZT0xO2NvbnN0e2tDb25zdHJ1Y3Q6ZX09cmVxdWlyZVN5bWJvbHMkMSgpLHtDYWNoZTpBfT1yZXF1aXJlQ2FjaGUoKSx7d2ViaWRsOnR9PXJlcXVpcmVXZWJpZGwoKSx7a0VudW1lcmFibGVQcm9wZXJ0eTpufT11dGlsJG0saT1jbGFzcyBpe2NvbnN0cnVjdG9yKCl7Q0EodGhpcyxzLG5ldyBNYXApO2FyZ3VtZW50c1swXSE9PWUmJnQuaWxsZWdhbENvbnN0cnVjdG9yKCl9YXN5bmMgbWF0Y2goUSxDPXt9KXtpZih0LmJyYW5kQ2hlY2sodGhpcyxpKSx0LmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLDEse2hlYWRlcjpcIkNhY2hlU3RvcmFnZS5tYXRjaFwifSksUT10LmNvbnZlcnRlcnMuUmVxdWVzdEluZm8oUSksQz10LmNvbnZlcnRlcnMuTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyhDKSxDLmNhY2hlTmFtZSE9bnVsbCl7aWYocCh0aGlzLHMpLmhhcyhDLmNhY2hlTmFtZSkpe2NvbnN0IEk9cCh0aGlzLHMpLmdldChDLmNhY2hlTmFtZSk7cmV0dXJuIGF3YWl0IG5ldyBBKGUsSSkubWF0Y2goUSxDKX19ZWxzZSBmb3IoY29uc3QgSSBvZiBwKHRoaXMscykudmFsdWVzKCkpe2NvbnN0IGY9YXdhaXQgbmV3IEEoZSxJKS5tYXRjaChRLEMpO2lmKGYhPT12b2lkIDApcmV0dXJuIGZ9fWFzeW5jIGhhcyhRKXtyZXR1cm4gdC5icmFuZENoZWNrKHRoaXMsaSksdC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6XCJDYWNoZVN0b3JhZ2UuaGFzXCJ9KSxRPXQuY29udmVydGVycy5ET01TdHJpbmcoUSkscCh0aGlzLHMpLmhhcyhRKX1hc3luYyBvcGVuKFEpe2lmKHQuYnJhbmRDaGVjayh0aGlzLGkpLHQuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMSx7aGVhZGVyOlwiQ2FjaGVTdG9yYWdlLm9wZW5cIn0pLFE9dC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhRKSxwKHRoaXMscykuaGFzKFEpKXtjb25zdCBJPXAodGhpcyxzKS5nZXQoUSk7cmV0dXJuIG5ldyBBKGUsSSl9Y29uc3QgQz1bXTtyZXR1cm4gcCh0aGlzLHMpLnNldChRLEMpLG5ldyBBKGUsQyl9YXN5bmMgZGVsZXRlKFEpe3JldHVybiB0LmJyYW5kQ2hlY2sodGhpcyxpKSx0LmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLDEse2hlYWRlcjpcIkNhY2hlU3RvcmFnZS5kZWxldGVcIn0pLFE9dC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhRKSxwKHRoaXMscykuZGVsZXRlKFEpfWFzeW5jIGtleXMoKXtyZXR1cm4gdC5icmFuZENoZWNrKHRoaXMsaSksWy4uLnAodGhpcyxzKS5rZXlzKCldfX07cz1uZXcgV2Vha01hcCxvKGksXCJDYWNoZVN0b3JhZ2VcIik7bGV0IHI9aTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoci5wcm90b3R5cGUse1tTeW1ib2wudG9TdHJpbmdUYWddOnt2YWx1ZTpcIkNhY2hlU3RvcmFnZVwiLGNvbmZpZ3VyYWJsZTohMH0sbWF0Y2g6bixoYXM6bixvcGVuOm4sZGVsZXRlOm4sa2V5czpufSksY2FjaGVzdG9yYWdlPXtDYWNoZVN0b3JhZ2U6cn0sY2FjaGVzdG9yYWdlfW8ocmVxdWlyZUNhY2hlc3RvcmFnZSxcInJlcXVpcmVDYWNoZXN0b3JhZ2VcIik7dmFyIGNvbnN0YW50cyQxLGhhc1JlcXVpcmVkQ29uc3RhbnRzJDE7ZnVuY3Rpb24gcmVxdWlyZUNvbnN0YW50cyQxKCl7cmV0dXJuIGhhc1JlcXVpcmVkQ29uc3RhbnRzJDF8fChoYXNSZXF1aXJlZENvbnN0YW50cyQxPTEsY29uc3RhbnRzJDE9e21heEF0dHJpYnV0ZVZhbHVlU2l6ZToxMDI0LG1heE5hbWVWYWx1ZVBhaXJTaXplOjQwOTZ9KSxjb25zdGFudHMkMX1vKHJlcXVpcmVDb25zdGFudHMkMSxcInJlcXVpcmVDb25zdGFudHMkMVwiKTt2YXIgdXRpbCQzLGhhc1JlcXVpcmVkVXRpbCQyO2Z1bmN0aW9uIHJlcXVpcmVVdGlsJDIoKXtpZihoYXNSZXF1aXJlZFV0aWwkMilyZXR1cm4gdXRpbCQzO2hhc1JlcXVpcmVkVXRpbCQyPTE7Y29uc3QgZT1yZXF1aXJlJCQwX19kZWZhdWx0LHtrSGVhZGVyc0xpc3Q6QX09c3ltYm9scyQ0O2Z1bmN0aW9uIHQoYyl7Zm9yKGxldCBsPTA7bDxjLmxlbmd0aDsrK2wpe2NvbnN0IFM9Yy5jaGFyQ29kZUF0KGwpO2lmKFM+PTAmJlM8PTh8fFM+PTEwJiZTPD0zMXx8Uz09PTEyNylyZXR1cm4hMH1yZXR1cm4hMX1vKHQsXCJpc0NUTEV4Y2x1ZGluZ0h0YWJcIik7ZnVuY3Rpb24gbihjKXtmb3IobGV0IGw9MDtsPGMubGVuZ3RoOysrbCl7Y29uc3QgUz1jLmNoYXJDb2RlQXQobCk7aWYoUzwzM3x8Uz4xMjZ8fFM9PT0zNHx8Uz09PTQwfHxTPT09NDF8fFM9PT02MHx8Uz09PTYyfHxTPT09NjR8fFM9PT00NHx8Uz09PTU5fHxTPT09NTh8fFM9PT05Mnx8Uz09PTQ3fHxTPT09OTF8fFM9PT05M3x8Uz09PTYzfHxTPT09NjF8fFM9PT0xMjN8fFM9PT0xMjUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb29raWUgbmFtZVwiKX19byhuLFwidmFsaWRhdGVDb29raWVOYW1lXCIpO2Z1bmN0aW9uIHIoYyl7bGV0IGw9Yy5sZW5ndGgsUz0wO2lmKGNbMF09PT0nXCInKXtpZihsPT09MXx8Y1tsLTFdIT09J1wiJyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvb2tpZSB2YWx1ZVwiKTstLWwsKytTfWZvcig7UzxsOyl7Y29uc3Qgaz1jLmNoYXJDb2RlQXQoUysrKTtpZihrPDMzfHxrPjEyNnx8az09PTM0fHxrPT09NDR8fGs9PT01OXx8az09PTkyKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29va2llIHZhbHVlXCIpfX1vKHIsXCJ2YWxpZGF0ZUNvb2tpZVZhbHVlXCIpO2Z1bmN0aW9uIHMoYyl7Zm9yKGxldCBsPTA7bDxjLmxlbmd0aDsrK2wpe2NvbnN0IFM9Yy5jaGFyQ29kZUF0KGwpO2lmKFM8MzJ8fFM9PT0xMjd8fFM9PT01OSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvb2tpZSBwYXRoXCIpfX1vKHMsXCJ2YWxpZGF0ZUNvb2tpZVBhdGhcIik7ZnVuY3Rpb24gaShjKXtpZihjLnN0YXJ0c1dpdGgoXCItXCIpfHxjLmVuZHNXaXRoKFwiLlwiKXx8Yy5lbmRzV2l0aChcIi1cIikpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb29raWUgZG9tYWluXCIpfW8oaSxcInZhbGlkYXRlQ29va2llRG9tYWluXCIpO2NvbnN0IEU9W1wiU3VuXCIsXCJNb25cIixcIlR1ZVwiLFwiV2VkXCIsXCJUaHVcIixcIkZyaVwiLFwiU2F0XCJdLFE9W1wiSmFuXCIsXCJGZWJcIixcIk1hclwiLFwiQXByXCIsXCJNYXlcIixcIkp1blwiLFwiSnVsXCIsXCJBdWdcIixcIlNlcFwiLFwiT2N0XCIsXCJOb3ZcIixcIkRlY1wiXSxDPUFycmF5KDYxKS5maWxsKDApLm1hcCgoYyxsKT0+bC50b1N0cmluZygpLnBhZFN0YXJ0KDIsXCIwXCIpKTtmdW5jdGlvbiBJKGMpe3JldHVybiB0eXBlb2YgYz09XCJudW1iZXJcIiYmKGM9bmV3IERhdGUoYykpLGAke0VbYy5nZXRVVENEYXkoKV19LCAke0NbYy5nZXRVVENEYXRlKCldfSAke1FbYy5nZXRVVENNb250aCgpXX0gJHtjLmdldFVUQ0Z1bGxZZWFyKCl9ICR7Q1tjLmdldFVUQ0hvdXJzKCldfToke0NbYy5nZXRVVENNaW51dGVzKCldfToke0NbYy5nZXRVVENTZWNvbmRzKCldfSBHTVRgfW8oSSxcInRvSU1GRGF0ZVwiKTtmdW5jdGlvbiBhKGMpe2lmKGM8MCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvb2tpZSBtYXgtYWdlXCIpfW8oYSxcInZhbGlkYXRlQ29va2llTWF4QWdlXCIpO2Z1bmN0aW9uIGYoYyl7aWYoYy5uYW1lLmxlbmd0aD09PTApcmV0dXJuIG51bGw7bihjLm5hbWUpLHIoYy52YWx1ZSk7Y29uc3QgbD1bYCR7Yy5uYW1lfT0ke2MudmFsdWV9YF07Yy5uYW1lLnN0YXJ0c1dpdGgoXCJfX1NlY3VyZS1cIikmJihjLnNlY3VyZT0hMCksYy5uYW1lLnN0YXJ0c1dpdGgoXCJfX0hvc3QtXCIpJiYoYy5zZWN1cmU9ITAsYy5kb21haW49bnVsbCxjLnBhdGg9XCIvXCIpLGMuc2VjdXJlJiZsLnB1c2goXCJTZWN1cmVcIiksYy5odHRwT25seSYmbC5wdXNoKFwiSHR0cE9ubHlcIiksdHlwZW9mIGMubWF4QWdlPT1cIm51bWJlclwiJiYoYShjLm1heEFnZSksbC5wdXNoKGBNYXgtQWdlPSR7Yy5tYXhBZ2V9YCkpLGMuZG9tYWluJiYoaShjLmRvbWFpbiksbC5wdXNoKGBEb21haW49JHtjLmRvbWFpbn1gKSksYy5wYXRoJiYocyhjLnBhdGgpLGwucHVzaChgUGF0aD0ke2MucGF0aH1gKSksYy5leHBpcmVzJiZjLmV4cGlyZXMudG9TdHJpbmcoKSE9PVwiSW52YWxpZCBEYXRlXCImJmwucHVzaChgRXhwaXJlcz0ke0koYy5leHBpcmVzKX1gKSxjLnNhbWVTaXRlJiZsLnB1c2goYFNhbWVTaXRlPSR7Yy5zYW1lU2l0ZX1gKTtmb3IoY29uc3QgUyBvZiBjLnVucGFyc2VkKXtpZighUy5pbmNsdWRlcyhcIj1cIikpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB1bnBhcnNlZFwiKTtjb25zdFtrLC4uLnddPVMuc3BsaXQoXCI9XCIpO2wucHVzaChgJHtrLnRyaW0oKX09JHt3LmpvaW4oXCI9XCIpfWApfXJldHVybiBsLmpvaW4oXCI7IFwiKX1vKGYsXCJzdHJpbmdpZnlcIik7bGV0IGg7ZnVuY3Rpb24gTChjKXtpZihjW0FdKXJldHVybiBjW0FdO2h8fChoPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoYykuZmluZChTPT5TLmRlc2NyaXB0aW9uPT09XCJoZWFkZXJzIGxpc3RcIiksZShoLFwiSGVhZGVycyBjYW5ub3QgYmUgcGFyc2VkXCIpKTtjb25zdCBsPWNbaF07cmV0dXJuIGUobCksbH1yZXR1cm4gbyhMLFwiZ2V0SGVhZGVyc0xpc3RcIiksdXRpbCQzPXtpc0NUTEV4Y2x1ZGluZ0h0YWI6dCx2YWxpZGF0ZUNvb2tpZU5hbWU6bix2YWxpZGF0ZUNvb2tpZVBhdGg6cyx2YWxpZGF0ZUNvb2tpZVZhbHVlOnIsdG9JTUZEYXRlOkksc3RyaW5naWZ5OmYsZ2V0SGVhZGVyc0xpc3Q6TH0sdXRpbCQzfW8ocmVxdWlyZVV0aWwkMixcInJlcXVpcmVVdGlsJDJcIik7dmFyIHBhcnNlLGhhc1JlcXVpcmVkUGFyc2U7ZnVuY3Rpb24gcmVxdWlyZVBhcnNlKCl7aWYoaGFzUmVxdWlyZWRQYXJzZSlyZXR1cm4gcGFyc2U7aGFzUmVxdWlyZWRQYXJzZT0xO2NvbnN0e21heE5hbWVWYWx1ZVBhaXJTaXplOmUsbWF4QXR0cmlidXRlVmFsdWVTaXplOkF9PXJlcXVpcmVDb25zdGFudHMkMSgpLHtpc0NUTEV4Y2x1ZGluZ0h0YWI6dH09cmVxdWlyZVV0aWwkMigpLHtjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdDpufT1yZXF1aXJlRGF0YVVybCgpLHI9cmVxdWlyZSQkMF9fZGVmYXVsdDtmdW5jdGlvbiBzKEUpe2lmKHQoRSkpcmV0dXJuIG51bGw7bGV0IFE9XCJcIixDPVwiXCIsST1cIlwiLGE9XCJcIjtpZihFLmluY2x1ZGVzKFwiO1wiKSl7Y29uc3QgZj17cG9zaXRpb246MH07UT1uKFwiO1wiLEUsZiksQz1FLnNsaWNlKGYucG9zaXRpb24pfWVsc2UgUT1FO2lmKCFRLmluY2x1ZGVzKFwiPVwiKSlhPVE7ZWxzZXtjb25zdCBmPXtwb3NpdGlvbjowfTtJPW4oXCI9XCIsUSxmKSxhPVEuc2xpY2UoZi5wb3NpdGlvbisxKX1yZXR1cm4gST1JLnRyaW0oKSxhPWEudHJpbSgpLEkubGVuZ3RoK2EubGVuZ3RoPmU/bnVsbDp7bmFtZTpJLHZhbHVlOmEsLi4uaShDKX19byhzLFwicGFyc2VTZXRDb29raWVcIik7ZnVuY3Rpb24gaShFLFE9e30pe2lmKEUubGVuZ3RoPT09MClyZXR1cm4gUTtyKEVbMF09PT1cIjtcIiksRT1FLnNsaWNlKDEpO2xldCBDPVwiXCI7RS5pbmNsdWRlcyhcIjtcIik/KEM9bihcIjtcIixFLHtwb3NpdGlvbjowfSksRT1FLnNsaWNlKEMubGVuZ3RoKSk6KEM9RSxFPVwiXCIpO2xldCBJPVwiXCIsYT1cIlwiO2lmKEMuaW5jbHVkZXMoXCI9XCIpKXtjb25zdCBoPXtwb3NpdGlvbjowfTtJPW4oXCI9XCIsQyxoKSxhPUMuc2xpY2UoaC5wb3NpdGlvbisxKX1lbHNlIEk9QztpZihJPUkudHJpbSgpLGE9YS50cmltKCksYS5sZW5ndGg+QSlyZXR1cm4gaShFLFEpO2NvbnN0IGY9SS50b0xvd2VyQ2FzZSgpO2lmKGY9PT1cImV4cGlyZXNcIil7Y29uc3QgaD1uZXcgRGF0ZShhKTtRLmV4cGlyZXM9aH1lbHNlIGlmKGY9PT1cIm1heC1hZ2VcIil7Y29uc3QgaD1hLmNoYXJDb2RlQXQoMCk7aWYoKGg8NDh8fGg+NTcpJiZhWzBdIT09XCItXCJ8fCEvXlxcZCskLy50ZXN0KGEpKXJldHVybiBpKEUsUSk7Y29uc3QgTD1OdW1iZXIoYSk7US5tYXhBZ2U9TH1lbHNlIGlmKGY9PT1cImRvbWFpblwiKXtsZXQgaD1hO2hbMF09PT1cIi5cIiYmKGg9aC5zbGljZSgxKSksaD1oLnRvTG93ZXJDYXNlKCksUS5kb21haW49aH1lbHNlIGlmKGY9PT1cInBhdGhcIil7bGV0IGg9XCJcIjthLmxlbmd0aD09PTB8fGFbMF0hPT1cIi9cIj9oPVwiL1wiOmg9YSxRLnBhdGg9aH1lbHNlIGlmKGY9PT1cInNlY3VyZVwiKVEuc2VjdXJlPSEwO2Vsc2UgaWYoZj09PVwiaHR0cG9ubHlcIilRLmh0dHBPbmx5PSEwO2Vsc2UgaWYoZj09PVwic2FtZXNpdGVcIil7bGV0IGg9XCJEZWZhdWx0XCI7Y29uc3QgTD1hLnRvTG93ZXJDYXNlKCk7TC5pbmNsdWRlcyhcIm5vbmVcIikmJihoPVwiTm9uZVwiKSxMLmluY2x1ZGVzKFwic3RyaWN0XCIpJiYoaD1cIlN0cmljdFwiKSxMLmluY2x1ZGVzKFwibGF4XCIpJiYoaD1cIkxheFwiKSxRLnNhbWVTaXRlPWh9ZWxzZSBRLnVucGFyc2VkPz8oUS51bnBhcnNlZD1bXSksUS51bnBhcnNlZC5wdXNoKGAke0l9PSR7YX1gKTtyZXR1cm4gaShFLFEpfXJldHVybiBvKGksXCJwYXJzZVVucGFyc2VkQXR0cmlidXRlc1wiKSxwYXJzZT17cGFyc2VTZXRDb29raWU6cyxwYXJzZVVucGFyc2VkQXR0cmlidXRlczppfSxwYXJzZX1vKHJlcXVpcmVQYXJzZSxcInJlcXVpcmVQYXJzZVwiKTt2YXIgY29va2llcyxoYXNSZXF1aXJlZENvb2tpZXM7ZnVuY3Rpb24gcmVxdWlyZUNvb2tpZXMoKXtpZihoYXNSZXF1aXJlZENvb2tpZXMpcmV0dXJuIGNvb2tpZXM7aGFzUmVxdWlyZWRDb29raWVzPTE7Y29uc3R7cGFyc2VTZXRDb29raWU6ZX09cmVxdWlyZVBhcnNlKCkse3N0cmluZ2lmeTpBLGdldEhlYWRlcnNMaXN0OnR9PXJlcXVpcmVVdGlsJDIoKSx7d2ViaWRsOm59PXJlcXVpcmVXZWJpZGwoKSx7SGVhZGVyczpyfT1yZXF1aXJlSGVhZGVycygpO2Z1bmN0aW9uIHMoQyl7bi5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6XCJnZXRDb29raWVzXCJ9KSxuLmJyYW5kQ2hlY2soQyxyLHtzdHJpY3Q6ITF9KTtjb25zdCBJPUMuZ2V0KFwiY29va2llXCIpLGE9e307aWYoIUkpcmV0dXJuIGE7Zm9yKGNvbnN0IGYgb2YgSS5zcGxpdChcIjtcIikpe2NvbnN0W2gsLi4uTF09Zi5zcGxpdChcIj1cIik7YVtoLnRyaW0oKV09TC5qb2luKFwiPVwiKX1yZXR1cm4gYX1vKHMsXCJnZXRDb29raWVzXCIpO2Z1bmN0aW9uIGkoQyxJLGEpe24uYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMix7aGVhZGVyOlwiZGVsZXRlQ29va2llXCJ9KSxuLmJyYW5kQ2hlY2soQyxyLHtzdHJpY3Q6ITF9KSxJPW4uY29udmVydGVycy5ET01TdHJpbmcoSSksYT1uLmNvbnZlcnRlcnMuRGVsZXRlQ29va2llQXR0cmlidXRlcyhhKSxRKEMse25hbWU6SSx2YWx1ZTpcIlwiLGV4cGlyZXM6bmV3IERhdGUoMCksLi4uYX0pfW8oaSxcImRlbGV0ZUNvb2tpZVwiKTtmdW5jdGlvbiBFKEMpe24uYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMSx7aGVhZGVyOlwiZ2V0U2V0Q29va2llc1wifSksbi5icmFuZENoZWNrKEMscix7c3RyaWN0OiExfSk7Y29uc3QgST10KEMpLmNvb2tpZXM7cmV0dXJuIEk/SS5tYXAoYT0+ZShBcnJheS5pc0FycmF5KGEpP2FbMV06YSkpOltdfW8oRSxcImdldFNldENvb2tpZXNcIik7ZnVuY3Rpb24gUShDLEkpe24uYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMix7aGVhZGVyOlwic2V0Q29va2llXCJ9KSxuLmJyYW5kQ2hlY2soQyxyLHtzdHJpY3Q6ITF9KSxJPW4uY29udmVydGVycy5Db29raWUoSSk7Y29uc3QgYT1BKEkpO2EmJkMuYXBwZW5kKFwiU2V0LUNvb2tpZVwiLGEpfXJldHVybiBvKFEsXCJzZXRDb29raWVcIiksbi5jb252ZXJ0ZXJzLkRlbGV0ZUNvb2tpZUF0dHJpYnV0ZXM9bi5kaWN0aW9uYXJ5Q29udmVydGVyKFt7Y29udmVydGVyOm4ubnVsbGFibGVDb252ZXJ0ZXIobi5jb252ZXJ0ZXJzLkRPTVN0cmluZyksa2V5OlwicGF0aFwiLGRlZmF1bHRWYWx1ZTpudWxsfSx7Y29udmVydGVyOm4ubnVsbGFibGVDb252ZXJ0ZXIobi5jb252ZXJ0ZXJzLkRPTVN0cmluZyksa2V5OlwiZG9tYWluXCIsZGVmYXVsdFZhbHVlOm51bGx9XSksbi5jb252ZXJ0ZXJzLkNvb2tpZT1uLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW3tjb252ZXJ0ZXI6bi5jb252ZXJ0ZXJzLkRPTVN0cmluZyxrZXk6XCJuYW1lXCJ9LHtjb252ZXJ0ZXI6bi5jb252ZXJ0ZXJzLkRPTVN0cmluZyxrZXk6XCJ2YWx1ZVwifSx7Y29udmVydGVyOm4ubnVsbGFibGVDb252ZXJ0ZXIoQz0+dHlwZW9mIEM9PVwibnVtYmVyXCI/bi5jb252ZXJ0ZXJzW1widW5zaWduZWQgbG9uZyBsb25nXCJdKEMpOm5ldyBEYXRlKEMpKSxrZXk6XCJleHBpcmVzXCIsZGVmYXVsdFZhbHVlOm51bGx9LHtjb252ZXJ0ZXI6bi5udWxsYWJsZUNvbnZlcnRlcihuLmNvbnZlcnRlcnNbXCJsb25nIGxvbmdcIl0pLGtleTpcIm1heEFnZVwiLGRlZmF1bHRWYWx1ZTpudWxsfSx7Y29udmVydGVyOm4ubnVsbGFibGVDb252ZXJ0ZXIobi5jb252ZXJ0ZXJzLkRPTVN0cmluZyksa2V5OlwiZG9tYWluXCIsZGVmYXVsdFZhbHVlOm51bGx9LHtjb252ZXJ0ZXI6bi5udWxsYWJsZUNvbnZlcnRlcihuLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxrZXk6XCJwYXRoXCIsZGVmYXVsdFZhbHVlOm51bGx9LHtjb252ZXJ0ZXI6bi5udWxsYWJsZUNvbnZlcnRlcihuLmNvbnZlcnRlcnMuYm9vbGVhbiksa2V5Olwic2VjdXJlXCIsZGVmYXVsdFZhbHVlOm51bGx9LHtjb252ZXJ0ZXI6bi5udWxsYWJsZUNvbnZlcnRlcihuLmNvbnZlcnRlcnMuYm9vbGVhbiksa2V5OlwiaHR0cE9ubHlcIixkZWZhdWx0VmFsdWU6bnVsbH0se2NvbnZlcnRlcjpuLmNvbnZlcnRlcnMuVVNWU3RyaW5nLGtleTpcInNhbWVTaXRlXCIsYWxsb3dlZFZhbHVlczpbXCJTdHJpY3RcIixcIkxheFwiLFwiTm9uZVwiXX0se2NvbnZlcnRlcjpuLnNlcXVlbmNlQ29udmVydGVyKG4uY29udmVydGVycy5ET01TdHJpbmcpLGtleTpcInVucGFyc2VkXCIsZGVmYXVsdFZhbHVlOltdfV0pLGNvb2tpZXM9e2dldENvb2tpZXM6cyxkZWxldGVDb29raWU6aSxnZXRTZXRDb29raWVzOkUsc2V0Q29va2llOlF9LGNvb2tpZXN9byhyZXF1aXJlQ29va2llcyxcInJlcXVpcmVDb29raWVzXCIpO3ZhciBldmVudHMsaGFzUmVxdWlyZWRFdmVudHM7ZnVuY3Rpb24gcmVxdWlyZUV2ZW50cygpe3ZhciBFLEMsYTtpZihoYXNSZXF1aXJlZEV2ZW50cylyZXR1cm4gZXZlbnRzO2hhc1JlcXVpcmVkRXZlbnRzPTE7Y29uc3R7d2ViaWRsOmV9PXJlcXVpcmVXZWJpZGwoKSx7a0VudW1lcmFibGVQcm9wZXJ0eTpBfT11dGlsJG0se01lc3NhZ2VQb3J0OnR9PXJlcXVpcmUkJDJfX2RlZmF1bHQsUT1jbGFzcyBRIGV4dGVuZHMgRXZlbnR7Y29uc3RydWN0b3IoYyxsPXt9KXtlLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLDEse2hlYWRlcjpcIk1lc3NhZ2VFdmVudCBjb25zdHJ1Y3RvclwifSksYz1lLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGMpLGw9ZS5jb252ZXJ0ZXJzLk1lc3NhZ2VFdmVudEluaXQobCk7c3VwZXIoYyxsKTtDQSh0aGlzLEUsdm9pZCAwKTtFQSh0aGlzLEUsbCl9Z2V0IGRhdGEoKXtyZXR1cm4gZS5icmFuZENoZWNrKHRoaXMsUSkscCh0aGlzLEUpLmRhdGF9Z2V0IG9yaWdpbigpe3JldHVybiBlLmJyYW5kQ2hlY2sodGhpcyxRKSxwKHRoaXMsRSkub3JpZ2lufWdldCBsYXN0RXZlbnRJZCgpe3JldHVybiBlLmJyYW5kQ2hlY2sodGhpcyxRKSxwKHRoaXMsRSkubGFzdEV2ZW50SWR9Z2V0IHNvdXJjZSgpe3JldHVybiBlLmJyYW5kQ2hlY2sodGhpcyxRKSxwKHRoaXMsRSkuc291cmNlfWdldCBwb3J0cygpe3JldHVybiBlLmJyYW5kQ2hlY2sodGhpcyxRKSxPYmplY3QuaXNGcm96ZW4ocCh0aGlzLEUpLnBvcnRzKXx8T2JqZWN0LmZyZWV6ZShwKHRoaXMsRSkucG9ydHMpLHAodGhpcyxFKS5wb3J0c31pbml0TWVzc2FnZUV2ZW50KGMsbD0hMSxTPSExLGs9bnVsbCx3PVwiXCIsVT1cIlwiLE09bnVsbCxCPVtdKXtyZXR1cm4gZS5icmFuZENoZWNrKHRoaXMsUSksZS5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6XCJNZXNzYWdlRXZlbnQuaW5pdE1lc3NhZ2VFdmVudFwifSksbmV3IFEoYyx7YnViYmxlczpsLGNhbmNlbGFibGU6UyxkYXRhOmssb3JpZ2luOncsbGFzdEV2ZW50SWQ6VSxzb3VyY2U6TSxwb3J0czpCfSl9fTtFPW5ldyBXZWFrTWFwLG8oUSxcIk1lc3NhZ2VFdmVudFwiKTtsZXQgbj1RO2NvbnN0IEk9Y2xhc3MgSSBleHRlbmRzIEV2ZW50e2NvbnN0cnVjdG9yKGMsbD17fSl7ZS5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6XCJDbG9zZUV2ZW50IGNvbnN0cnVjdG9yXCJ9KSxjPWUuY29udmVydGVycy5ET01TdHJpbmcoYyksbD1lLmNvbnZlcnRlcnMuQ2xvc2VFdmVudEluaXQobCk7c3VwZXIoYyxsKTtDQSh0aGlzLEMsdm9pZCAwKTtFQSh0aGlzLEMsbCl9Z2V0IHdhc0NsZWFuKCl7cmV0dXJuIGUuYnJhbmRDaGVjayh0aGlzLEkpLHAodGhpcyxDKS53YXNDbGVhbn1nZXQgY29kZSgpe3JldHVybiBlLmJyYW5kQ2hlY2sodGhpcyxJKSxwKHRoaXMsQykuY29kZX1nZXQgcmVhc29uKCl7cmV0dXJuIGUuYnJhbmRDaGVjayh0aGlzLEkpLHAodGhpcyxDKS5yZWFzb259fTtDPW5ldyBXZWFrTWFwLG8oSSxcIkNsb3NlRXZlbnRcIik7bGV0IHI9STtjb25zdCBmPWNsYXNzIGYgZXh0ZW5kcyBFdmVudHtjb25zdHJ1Y3RvcihjLGwpe2UuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMSx7aGVhZGVyOlwiRXJyb3JFdmVudCBjb25zdHJ1Y3RvclwifSk7c3VwZXIoYyxsKTtDQSh0aGlzLGEsdm9pZCAwKTtjPWUuY29udmVydGVycy5ET01TdHJpbmcoYyksbD1lLmNvbnZlcnRlcnMuRXJyb3JFdmVudEluaXQobD8/e30pLEVBKHRoaXMsYSxsKX1nZXQgbWVzc2FnZSgpe3JldHVybiBlLmJyYW5kQ2hlY2sodGhpcyxmKSxwKHRoaXMsYSkubWVzc2FnZX1nZXQgZmlsZW5hbWUoKXtyZXR1cm4gZS5icmFuZENoZWNrKHRoaXMsZikscCh0aGlzLGEpLmZpbGVuYW1lfWdldCBsaW5lbm8oKXtyZXR1cm4gZS5icmFuZENoZWNrKHRoaXMsZikscCh0aGlzLGEpLmxpbmVub31nZXQgY29sbm8oKXtyZXR1cm4gZS5icmFuZENoZWNrKHRoaXMsZikscCh0aGlzLGEpLmNvbG5vfWdldCBlcnJvcigpe3JldHVybiBlLmJyYW5kQ2hlY2sodGhpcyxmKSxwKHRoaXMsYSkuZXJyb3J9fTthPW5ldyBXZWFrTWFwLG8oZixcIkVycm9yRXZlbnRcIik7bGV0IHM9ZjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuLnByb3RvdHlwZSx7W1N5bWJvbC50b1N0cmluZ1RhZ106e3ZhbHVlOlwiTWVzc2FnZUV2ZW50XCIsY29uZmlndXJhYmxlOiEwfSxkYXRhOkEsb3JpZ2luOkEsbGFzdEV2ZW50SWQ6QSxzb3VyY2U6QSxwb3J0czpBLGluaXRNZXNzYWdlRXZlbnQ6QX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHIucHJvdG90eXBlLHtbU3ltYm9sLnRvU3RyaW5nVGFnXTp7dmFsdWU6XCJDbG9zZUV2ZW50XCIsY29uZmlndXJhYmxlOiEwfSxyZWFzb246QSxjb2RlOkEsd2FzQ2xlYW46QX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHMucHJvdG90eXBlLHtbU3ltYm9sLnRvU3RyaW5nVGFnXTp7dmFsdWU6XCJFcnJvckV2ZW50XCIsY29uZmlndXJhYmxlOiEwfSxtZXNzYWdlOkEsZmlsZW5hbWU6QSxsaW5lbm86QSxjb2xubzpBLGVycm9yOkF9KSxlLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnQ9ZS5pbnRlcmZhY2VDb252ZXJ0ZXIodCksZS5jb252ZXJ0ZXJzW1wic2VxdWVuY2U8TWVzc2FnZVBvcnQ+XCJdPWUuc2VxdWVuY2VDb252ZXJ0ZXIoZS5jb252ZXJ0ZXJzLk1lc3NhZ2VQb3J0KTtjb25zdCBpPVt7a2V5OlwiYnViYmxlc1wiLGNvbnZlcnRlcjplLmNvbnZlcnRlcnMuYm9vbGVhbixkZWZhdWx0VmFsdWU6ITF9LHtrZXk6XCJjYW5jZWxhYmxlXCIsY29udmVydGVyOmUuY29udmVydGVycy5ib29sZWFuLGRlZmF1bHRWYWx1ZTohMX0se2tleTpcImNvbXBvc2VkXCIsY29udmVydGVyOmUuY29udmVydGVycy5ib29sZWFuLGRlZmF1bHRWYWx1ZTohMX1dO3JldHVybiBlLmNvbnZlcnRlcnMuTWVzc2FnZUV2ZW50SW5pdD1lLmRpY3Rpb25hcnlDb252ZXJ0ZXIoWy4uLmkse2tleTpcImRhdGFcIixjb252ZXJ0ZXI6ZS5jb252ZXJ0ZXJzLmFueSxkZWZhdWx0VmFsdWU6bnVsbH0se2tleTpcIm9yaWdpblwiLGNvbnZlcnRlcjplLmNvbnZlcnRlcnMuVVNWU3RyaW5nLGRlZmF1bHRWYWx1ZTpcIlwifSx7a2V5OlwibGFzdEV2ZW50SWRcIixjb252ZXJ0ZXI6ZS5jb252ZXJ0ZXJzLkRPTVN0cmluZyxkZWZhdWx0VmFsdWU6XCJcIn0se2tleTpcInNvdXJjZVwiLGNvbnZlcnRlcjplLm51bGxhYmxlQ29udmVydGVyKGUuY29udmVydGVycy5NZXNzYWdlUG9ydCksZGVmYXVsdFZhbHVlOm51bGx9LHtrZXk6XCJwb3J0c1wiLGNvbnZlcnRlcjplLmNvbnZlcnRlcnNbXCJzZXF1ZW5jZTxNZXNzYWdlUG9ydD5cIl0sZ2V0IGRlZmF1bHRWYWx1ZSgpe3JldHVybltdfX1dKSxlLmNvbnZlcnRlcnMuQ2xvc2VFdmVudEluaXQ9ZS5kaWN0aW9uYXJ5Q29udmVydGVyKFsuLi5pLHtrZXk6XCJ3YXNDbGVhblwiLGNvbnZlcnRlcjplLmNvbnZlcnRlcnMuYm9vbGVhbixkZWZhdWx0VmFsdWU6ITF9LHtrZXk6XCJjb2RlXCIsY29udmVydGVyOmUuY29udmVydGVyc1tcInVuc2lnbmVkIHNob3J0XCJdLGRlZmF1bHRWYWx1ZTowfSx7a2V5OlwicmVhc29uXCIsY29udmVydGVyOmUuY29udmVydGVycy5VU1ZTdHJpbmcsZGVmYXVsdFZhbHVlOlwiXCJ9XSksZS5jb252ZXJ0ZXJzLkVycm9yRXZlbnRJbml0PWUuZGljdGlvbmFyeUNvbnZlcnRlcihbLi4uaSx7a2V5OlwibWVzc2FnZVwiLGNvbnZlcnRlcjplLmNvbnZlcnRlcnMuRE9NU3RyaW5nLGRlZmF1bHRWYWx1ZTpcIlwifSx7a2V5OlwiZmlsZW5hbWVcIixjb252ZXJ0ZXI6ZS5jb252ZXJ0ZXJzLlVTVlN0cmluZyxkZWZhdWx0VmFsdWU6XCJcIn0se2tleTpcImxpbmVub1wiLGNvbnZlcnRlcjplLmNvbnZlcnRlcnNbXCJ1bnNpZ25lZCBsb25nXCJdLGRlZmF1bHRWYWx1ZTowfSx7a2V5OlwiY29sbm9cIixjb252ZXJ0ZXI6ZS5jb252ZXJ0ZXJzW1widW5zaWduZWQgbG9uZ1wiXSxkZWZhdWx0VmFsdWU6MH0se2tleTpcImVycm9yXCIsY29udmVydGVyOmUuY29udmVydGVycy5hbnl9XSksZXZlbnRzPXtNZXNzYWdlRXZlbnQ6bixDbG9zZUV2ZW50OnIsRXJyb3JFdmVudDpzfSxldmVudHN9byhyZXF1aXJlRXZlbnRzLFwicmVxdWlyZUV2ZW50c1wiKTt2YXIgY29uc3RhbnRzLGhhc1JlcXVpcmVkQ29uc3RhbnRzO2Z1bmN0aW9uIHJlcXVpcmVDb25zdGFudHMoKXtpZihoYXNSZXF1aXJlZENvbnN0YW50cylyZXR1cm4gY29uc3RhbnRzO2hhc1JlcXVpcmVkQ29uc3RhbnRzPTE7Y29uc3QgZT1cIjI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMVwiLEE9e2VudW1lcmFibGU6ITAsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiExfSx0PXtDT05ORUNUSU5HOjAsT1BFTjoxLENMT1NJTkc6MixDTE9TRUQ6M30sbj17Tk9UX1NFTlQ6MCxQUk9DRVNTSU5HOjEsU0VOVDoyfSxyPXtDT05USU5VQVRJT046MCxURVhUOjEsQklOQVJZOjIsQ0xPU0U6OCxQSU5HOjksUE9ORzoxMH0scz0yKioxNi0xLGk9e0lORk86MCxQQVlMT0FETEVOR1RIXzE2OjIsUEFZTE9BRExFTkdUSF82NDozLFJFQURfREFUQTo0fSxFPUJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtyZXR1cm4gY29uc3RhbnRzPXt1aWQ6ZSxzZW50Q2xvc2VGcmFtZVN0YXRlOm4sc3RhdGljUHJvcGVydHlEZXNjcmlwdG9yczpBLHN0YXRlczp0LG9wY29kZXM6cixtYXhVbnNpZ25lZDE2Qml0OnMscGFyc2VyU3RhdGVzOmksZW1wdHlCdWZmZXI6RX0sY29uc3RhbnRzfW8ocmVxdWlyZUNvbnN0YW50cyxcInJlcXVpcmVDb25zdGFudHNcIik7dmFyIHN5bWJvbHMsaGFzUmVxdWlyZWRTeW1ib2xzO2Z1bmN0aW9uIHJlcXVpcmVTeW1ib2xzKCl7cmV0dXJuIGhhc1JlcXVpcmVkU3ltYm9sc3x8KGhhc1JlcXVpcmVkU3ltYm9scz0xLHN5bWJvbHM9e2tXZWJTb2NrZXRVUkw6U3ltYm9sKFwidXJsXCIpLGtSZWFkeVN0YXRlOlN5bWJvbChcInJlYWR5IHN0YXRlXCIpLGtDb250cm9sbGVyOlN5bWJvbChcImNvbnRyb2xsZXJcIiksa1Jlc3BvbnNlOlN5bWJvbChcInJlc3BvbnNlXCIpLGtCaW5hcnlUeXBlOlN5bWJvbChcImJpbmFyeSB0eXBlXCIpLGtTZW50Q2xvc2U6U3ltYm9sKFwic2VudCBjbG9zZVwiKSxrUmVjZWl2ZWRDbG9zZTpTeW1ib2woXCJyZWNlaXZlZCBjbG9zZVwiKSxrQnl0ZVBhcnNlcjpTeW1ib2woXCJieXRlIHBhcnNlclwiKX0pLHN5bWJvbHN9byhyZXF1aXJlU3ltYm9scyxcInJlcXVpcmVTeW1ib2xzXCIpO3ZhciB1dGlsJDIsaGFzUmVxdWlyZWRVdGlsJDE7ZnVuY3Rpb24gcmVxdWlyZVV0aWwkMSgpe2lmKGhhc1JlcXVpcmVkVXRpbCQxKXJldHVybiB1dGlsJDI7aGFzUmVxdWlyZWRVdGlsJDE9MTtjb25zdHtrUmVhZHlTdGF0ZTplLGtDb250cm9sbGVyOkEsa1Jlc3BvbnNlOnQsa0JpbmFyeVR5cGU6bixrV2ViU29ja2V0VVJMOnJ9PXJlcXVpcmVTeW1ib2xzKCkse3N0YXRlczpzLG9wY29kZXM6aX09cmVxdWlyZUNvbnN0YW50cygpLHtNZXNzYWdlRXZlbnQ6RSxFcnJvckV2ZW50OlF9PXJlcXVpcmVFdmVudHMoKSx7aXNVdGY4OkN9PXJlcXVpcmUkJDZfX2RlZmF1bHQ7ZnVuY3Rpb24gSShCKXtyZXR1cm4gQltlXT09PXMuQ09OTkVDVElOR31vKEksXCJpc0Nvbm5lY3RpbmdcIik7ZnVuY3Rpb24gYShCKXtyZXR1cm4gQltlXT09PXMuT1BFTn1vKGEsXCJpc0VzdGFibGlzaGVkXCIpO2Z1bmN0aW9uIGYoQil7cmV0dXJuIEJbZV09PT1zLkNMT1NJTkd9byhmLFwiaXNDbG9zaW5nXCIpO2Z1bmN0aW9uIGgoQil7cmV0dXJuIEJbZV09PT1zLkNMT1NFRH1vKGgsXCJpc0Nsb3NlZFwiKTtmdW5jdGlvbiBMKEIsRCxHPUV2ZW50LGc9e30pe2NvbnN0IGQ9bmV3IEcoQixnKTtELmRpc3BhdGNoRXZlbnQoZCl9byhMLFwiZmlyZUV2ZW50XCIpO2Z1bmN0aW9uIGMoQixELEcpe2lmKEJbZV0hPT1zLk9QRU4pcmV0dXJuO2xldCBnO2lmKEQ9PT1pLlRFWFQpdHJ5e2c9TShHKX1jYXRjaHtrKEIsXCJSZWNlaXZlZCBpbnZhbGlkIFVURi04IGluIHRleHQgZnJhbWUuXCIpO3JldHVybn1lbHNlIEQ9PT1pLkJJTkFSWSYmKEJbbl09PT1cImJsb2JcIj9nPW5ldyBCbG9iKFtHXSk6Zz1uZXcgVWludDhBcnJheShHKS5idWZmZXIpO0woXCJtZXNzYWdlXCIsQixFLHtvcmlnaW46QltyXS5vcmlnaW4sZGF0YTpnfSl9byhjLFwid2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkXCIpO2Z1bmN0aW9uIGwoQil7aWYoQi5sZW5ndGg9PT0wKXJldHVybiExO2ZvcihsZXQgRD0wO0Q8Qi5sZW5ndGg7KytEKXtjb25zdCBHPUIuY2hhckNvZGVBdChEKTtpZihHPDMzfHxHPjEyNnx8Rz09PTM0fHxHPT09NDB8fEc9PT00MXx8Rz09PTQ0fHxHPT09NDd8fEc9PT01OHx8Rz09PTU5fHxHPT09NjB8fEc9PT02MXx8Rz09PTYyfHxHPT09NjN8fEc9PT02NHx8Rz09PTkxfHxHPT09OTJ8fEc9PT05M3x8Rz09PTEyM3x8Rz09PTEyNSlyZXR1cm4hMX1yZXR1cm4hMH1vKGwsXCJpc1ZhbGlkU3VicHJvdG9jb2xcIik7ZnVuY3Rpb24gUyhCKXtyZXR1cm4gQj49MWUzJiZCPDEwMTU/QiE9PTEwMDQmJkIhPT0xMDA1JiZCIT09MTAwNjpCPj0zZTMmJkI8PTQ5OTl9byhTLFwiaXNWYWxpZFN0YXR1c0NvZGVcIik7ZnVuY3Rpb24gayhCLEQpe2NvbnN0e1tBXTpHLFt0XTpnfT1CO0cuYWJvcnQoKSxnPy5zb2NrZXQmJiFnLnNvY2tldC5kZXN0cm95ZWQmJmcuc29ja2V0LmRlc3Ryb3koKSxEJiZMKFwiZXJyb3JcIixCLFEse2Vycm9yOm5ldyBFcnJvcihEKX0pfW8oayxcImZhaWxXZWJzb2NrZXRDb25uZWN0aW9uXCIpO2NvbnN0IHc9dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMuaWN1PT1cInN0cmluZ1wiLFU9dz9uZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiLHtmYXRhbDohMH0pOnZvaWQgMDtmdW5jdGlvbiBNKEIpe2lmKHcpcmV0dXJuIFUuZGVjb2RlKEIpO2lmKCFDPy4oQikpdGhyb3cgQ3x8cHJvY2Vzcy5lbWl0V2FybmluZyhcIklDVSBpcyBub3Qgc3VwcG9ydGVkIGFuZCBubyBmYWxsYmFjayBleGlzdHMuIFBsZWFzZSB1cGdyYWRlIHRvIGF0IGxlYXN0IE5vZGUgdjE4LjE0LjAuXCIse2NvZGU6XCJVTkRJQ0ktV1MtTk8tSUNVXCJ9KSxuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB1dGYtOCByZWNlaXZlZC5cIik7cmV0dXJuIEIudG9TdHJpbmcoXCJ1dGYtOFwiKX1yZXR1cm4gbyhNLFwidXRmOERlY29kZVwiKSx1dGlsJDI9e2lzQ29ubmVjdGluZzpJLGlzRXN0YWJsaXNoZWQ6YSxpc0Nsb3Npbmc6Zixpc0Nsb3NlZDpoLGZpcmVFdmVudDpMLGlzVmFsaWRTdWJwcm90b2NvbDpsLGlzVmFsaWRTdGF0dXNDb2RlOlMsZmFpbFdlYnNvY2tldENvbm5lY3Rpb246ayx3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQ6Yyx1dGY4RGVjb2RlOk19LHV0aWwkMn1vKHJlcXVpcmVVdGlsJDEsXCJyZXF1aXJlVXRpbCQxXCIpO3ZhciBjb25uZWN0aW9uLGhhc1JlcXVpcmVkQ29ubmVjdGlvbjtmdW5jdGlvbiByZXF1aXJlQ29ubmVjdGlvbigpe2lmKGhhc1JlcXVpcmVkQ29ubmVjdGlvbilyZXR1cm4gY29ubmVjdGlvbjtoYXNSZXF1aXJlZENvbm5lY3Rpb249MTtjb25zdHt1aWQ6ZSxzdGF0ZXM6QSxzZW50Q2xvc2VGcmFtZVN0YXRlOnR9PXJlcXVpcmVDb25zdGFudHMoKSx7a1JlYWR5U3RhdGU6bixrU2VudENsb3NlOnIsa0J5dGVQYXJzZXI6cyxrUmVjZWl2ZWRDbG9zZTppfT1yZXF1aXJlU3ltYm9scygpLHtmaXJlRXZlbnQ6RSxmYWlsV2Vic29ja2V0Q29ubmVjdGlvbjpRfT1yZXF1aXJlVXRpbCQxKCkse2NoYW5uZWxzOkN9PWRpYWdub3N0aWNzLHtDbG9zZUV2ZW50Okl9PXJlcXVpcmVFdmVudHMoKSx7bWFrZVJlcXVlc3Q6YX09cmVxdWlyZVJlcXVlc3QoKSx7ZmV0Y2hpbmc6Zn09cmVxdWlyZUZldGNoKCkse0hlYWRlcnM6aH09cmVxdWlyZUhlYWRlcnMoKSx7Z2V0RGVjb2RlU3BsaXQ6TH09cmVxdWlyZVV0aWwkNSgpLHtrSGVhZGVyc0xpc3Q6Y309c3ltYm9scyQ0O2xldCBsO3RyeXtsPXJlcXVpcmUoXCJub2RlOmNyeXB0b1wiKX1jYXRjaHt9ZnVuY3Rpb24gUyhNLEIsRCxHLGcpe2NvbnN0IGQ9TTtkLnByb3RvY29sPU0ucHJvdG9jb2w9PT1cIndzOlwiP1wiaHR0cDpcIjpcImh0dHBzOlwiO2NvbnN0IEY9YSh7dXJsTGlzdDpbZF0sc2VydmljZVdvcmtlcnM6XCJub25lXCIscmVmZXJyZXI6XCJuby1yZWZlcnJlclwiLG1vZGU6XCJ3ZWJzb2NrZXRcIixjcmVkZW50aWFsczpcImluY2x1ZGVcIixjYWNoZTpcIm5vLXN0b3JlXCIscmVkaXJlY3Q6XCJlcnJvclwifSk7aWYoZy5oZWFkZXJzKXtjb25zdCBtPW5ldyBoKGcuaGVhZGVycylbY107Ri5oZWFkZXJzTGlzdD1tfWNvbnN0IE49bC5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoXCJiYXNlNjRcIik7Ri5oZWFkZXJzTGlzdC5hcHBlbmQoXCJzZWMtd2Vic29ja2V0LWtleVwiLE4pLEYuaGVhZGVyc0xpc3QuYXBwZW5kKFwic2VjLXdlYnNvY2tldC12ZXJzaW9uXCIsXCIxM1wiKTtmb3IoY29uc3QgbSBvZiBCKUYuaGVhZGVyc0xpc3QuYXBwZW5kKFwic2VjLXdlYnNvY2tldC1wcm90b2NvbFwiLG0pO2NvbnN0IHU9XCJcIjtyZXR1cm4gZih7cmVxdWVzdDpGLHVzZVBhcmFsbGVsUXVldWU6ITAsZGlzcGF0Y2hlcjpnLmRpc3BhdGNoZXIscHJvY2Vzc1Jlc3BvbnNlKG0pe2lmKG0udHlwZT09PVwiZXJyb3JcInx8bS5zdGF0dXMhPT0xMDEpe1EoRCxcIlJlY2VpdmVkIG5ldHdvcmsgZXJyb3Igb3Igbm9uLTEwMSBzdGF0dXMgY29kZS5cIik7cmV0dXJufWlmKEIubGVuZ3RoIT09MCYmIW0uaGVhZGVyc0xpc3QuZ2V0KFwiU2VjLVdlYlNvY2tldC1Qcm90b2NvbFwiKSl7UShELFwiU2VydmVyIGRpZCBub3QgcmVzcG9uZCB3aXRoIHNlbnQgcHJvdG9jb2xzLlwiKTtyZXR1cm59aWYobS5oZWFkZXJzTGlzdC5nZXQoXCJVcGdyYWRlXCIpPy50b0xvd2VyQ2FzZSgpIT09XCJ3ZWJzb2NrZXRcIil7UShELCdTZXJ2ZXIgZGlkIG5vdCBzZXQgVXBncmFkZSBoZWFkZXIgdG8gXCJ3ZWJzb2NrZXRcIi4nKTtyZXR1cm59aWYobS5oZWFkZXJzTGlzdC5nZXQoXCJDb25uZWN0aW9uXCIpPy50b0xvd2VyQ2FzZSgpIT09XCJ1cGdyYWRlXCIpe1EoRCwnU2VydmVyIGRpZCBub3Qgc2V0IENvbm5lY3Rpb24gaGVhZGVyIHRvIFwidXBncmFkZVwiLicpO3JldHVybn1jb25zdCBUPW0uaGVhZGVyc0xpc3QuZ2V0KFwiU2VjLVdlYlNvY2tldC1BY2NlcHRcIiksdj1sLmNyZWF0ZUhhc2goXCJzaGExXCIpLnVwZGF0ZShOK2UpLmRpZ2VzdChcImJhc2U2NFwiKTtpZihUIT09dil7UShELFwiSW5jb3JyZWN0IGhhc2ggcmVjZWl2ZWQgaW4gU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyLlwiKTtyZXR1cm59Y29uc3QgWj1tLmhlYWRlcnNMaXN0LmdldChcIlNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc1wiKTtpZihaIT09bnVsbCYmWiE9PXUpe1EoRCxcIlJlY2VpdmVkIGRpZmZlcmVudCBwZXJtZXNzYWdlLWRlZmxhdGUgdGhhbiB0aGUgb25lIHNldC5cIik7cmV0dXJufWNvbnN0IFA9bS5oZWFkZXJzTGlzdC5nZXQoXCJTZWMtV2ViU29ja2V0LVByb3RvY29sXCIpO2lmKFAhPT1udWxsJiYhTChcInNlYy13ZWJzb2NrZXQtcHJvdG9jb2xcIixGLmhlYWRlcnNMaXN0KS5pbmNsdWRlcyhQKSl7UShELFwiUHJvdG9jb2wgd2FzIG5vdCBzZXQgaW4gdGhlIG9wZW5pbmcgaGFuZHNoYWtlLlwiKTtyZXR1cm59bS5zb2NrZXQub24oXCJkYXRhXCIsayksbS5zb2NrZXQub24oXCJjbG9zZVwiLHcpLG0uc29ja2V0Lm9uKFwiZXJyb3JcIixVKSxDLm9wZW4uaGFzU3Vic2NyaWJlcnMmJkMub3Blbi5wdWJsaXNoKHthZGRyZXNzOm0uc29ja2V0LmFkZHJlc3MoKSxwcm90b2NvbDpQLGV4dGVuc2lvbnM6Wn0pLEcobSl9fSl9byhTLFwiZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvblwiKTtmdW5jdGlvbiBrKE0pe3RoaXMud3Nbc10ud3JpdGUoTSl8fHRoaXMucGF1c2UoKX1vKGssXCJvblNvY2tldERhdGFcIik7ZnVuY3Rpb24gdygpe2NvbnN0e3dzOk19PXRoaXMsQj1NW3JdPT09dC5TRU5UJiZNW2ldO2xldCBEPTEwMDUsRz1cIlwiO2NvbnN0IGc9TVtzXS5jbG9zaW5nSW5mbztnPyhEPWcuY29kZT8/MTAwNSxHPWcucmVhc29uKTpNW3JdIT09dC5TRU5UJiYoRD0xMDA2KSxNW25dPUEuQ0xPU0VELEUoXCJjbG9zZVwiLE0sSSx7d2FzQ2xlYW46Qixjb2RlOkQscmVhc29uOkd9KSxDLmNsb3NlLmhhc1N1YnNjcmliZXJzJiZDLmNsb3NlLnB1Ymxpc2goe3dlYnNvY2tldDpNLGNvZGU6RCxyZWFzb246R30pfW8odyxcIm9uU29ja2V0Q2xvc2VcIik7ZnVuY3Rpb24gVShNKXtjb25zdHt3czpCfT10aGlzO0Jbbl09QS5DTE9TSU5HLEMuc29ja2V0RXJyb3IuaGFzU3Vic2NyaWJlcnMmJkMuc29ja2V0RXJyb3IucHVibGlzaChNKSx0aGlzLmRlc3Ryb3koKX1yZXR1cm4gbyhVLFwib25Tb2NrZXRFcnJvclwiKSxjb25uZWN0aW9uPXtlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uOlN9LGNvbm5lY3Rpb259byhyZXF1aXJlQ29ubmVjdGlvbixcInJlcXVpcmVDb25uZWN0aW9uXCIpO3ZhciBmcmFtZSxoYXNSZXF1aXJlZEZyYW1lO2Z1bmN0aW9uIHJlcXVpcmVGcmFtZSgpe2lmKGhhc1JlcXVpcmVkRnJhbWUpcmV0dXJuIGZyYW1lO2hhc1JlcXVpcmVkRnJhbWU9MTtjb25zdHttYXhVbnNpZ25lZDE2Qml0OmV9PXJlcXVpcmVDb25zdGFudHMoKTtsZXQgQTt0cnl7QT1yZXF1aXJlKFwibm9kZTpjcnlwdG9cIil9Y2F0Y2h7fWNvbnN0IG49Y2xhc3Mgbntjb25zdHJ1Y3RvcihzKXt0aGlzLmZyYW1lRGF0YT1zLHRoaXMubWFza0tleT1BLnJhbmRvbUJ5dGVzKDQpfWNyZWF0ZUZyYW1lKHMpe2NvbnN0IGk9dGhpcy5mcmFtZURhdGE/LmJ5dGVMZW5ndGg/PzA7bGV0IEU9aSxRPTY7aT5lPyhRKz04LEU9MTI3KTppPjEyNSYmKFErPTIsRT0xMjYpO2NvbnN0IEM9QnVmZmVyLmFsbG9jVW5zYWZlKGkrUSk7Q1swXT1DWzFdPTAsQ1swXXw9MTI4LENbMF09KENbMF0mMjQwKStzOy8qISB3cy4gTUlUIExpY2Vuc2UuIEVpbmFyIE90dG8gU3Rhbmd2aWsgPGVpbmFyb3NAZ21haWwuY29tPiAqL0NbUS00XT10aGlzLm1hc2tLZXlbMF0sQ1tRLTNdPXRoaXMubWFza0tleVsxXSxDW1EtMl09dGhpcy5tYXNrS2V5WzJdLENbUS0xXT10aGlzLm1hc2tLZXlbM10sQ1sxXT1FLEU9PT0xMjY/Qy53cml0ZVVJbnQxNkJFKGksMik6RT09PTEyNyYmKENbMl09Q1szXT0wLEMud3JpdGVVSW50QkUoaSw0LDYpKSxDWzFdfD0xMjg7Zm9yKGxldCBJPTA7STxpO0krKylDW1ErSV09dGhpcy5mcmFtZURhdGFbSV1edGhpcy5tYXNrS2V5W0klNF07cmV0dXJuIEN9fTtvKG4sXCJXZWJzb2NrZXRGcmFtZVNlbmRcIik7bGV0IHQ9bjtyZXR1cm4gZnJhbWU9e1dlYnNvY2tldEZyYW1lU2VuZDp0fSxmcmFtZX1vKHJlcXVpcmVGcmFtZSxcInJlcXVpcmVGcmFtZVwiKTt2YXIgcmVjZWl2ZXIsaGFzUmVxdWlyZWRSZWNlaXZlcjtmdW5jdGlvbiByZXF1aXJlUmVjZWl2ZXIoKXt2YXIgUyxrLHcsVSxNO2lmKGhhc1JlcXVpcmVkUmVjZWl2ZXIpcmV0dXJuIHJlY2VpdmVyO2hhc1JlcXVpcmVkUmVjZWl2ZXI9MTtjb25zdHtXcml0YWJsZTplfT1TdHJlYW1fX2RlZmF1bHQse3BhcnNlclN0YXRlczpBLG9wY29kZXM6dCxzdGF0ZXM6bixlbXB0eUJ1ZmZlcjpyLHNlbnRDbG9zZUZyYW1lU3RhdGU6c309cmVxdWlyZUNvbnN0YW50cygpLHtrUmVhZHlTdGF0ZTppLGtTZW50Q2xvc2U6RSxrUmVzcG9uc2U6USxrUmVjZWl2ZWRDbG9zZTpDfT1yZXF1aXJlU3ltYm9scygpLHtjaGFubmVsczpJfT1kaWFnbm9zdGljcyx7aXNWYWxpZFN0YXR1c0NvZGU6YSxmYWlsV2Vic29ja2V0Q29ubmVjdGlvbjpmLHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZDpoLHV0ZjhEZWNvZGU6TH09cmVxdWlyZVV0aWwkMSgpLHtXZWJzb2NrZXRGcmFtZVNlbmQ6Y309cmVxdWlyZUZyYW1lKCksQj1jbGFzcyBCIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihnKXtzdXBlcigpO0NBKHRoaXMsUyxbXSk7Q0EodGhpcyxrLDApO0NBKHRoaXMsdyxBLklORk8pO0NBKHRoaXMsVSx7fSk7Q0EodGhpcyxNLFtdKTt0aGlzLndzPWd9X3dyaXRlKGcsZCxGKXtwKHRoaXMsUykucHVzaChnKSxFQSh0aGlzLGsscCh0aGlzLGspK2cubGVuZ3RoKSx0aGlzLnJ1bihGKX1ydW4oZyl7dmFyIGQ7Zm9yKDs7KXtpZihwKHRoaXMsdyk9PT1BLklORk8pe2lmKHAodGhpcyxrKTwyKXJldHVybiBnKCk7Y29uc3QgRj10aGlzLmNvbnN1bWUoMik7aWYocCh0aGlzLFUpLmZpbj0oRlswXSYxMjgpIT09MCxwKHRoaXMsVSkub3Bjb2RlPUZbMF0mMTUsKGQ9cCh0aGlzLFUpKS5vcmlnaW5hbE9wY29kZT8/KGQub3JpZ2luYWxPcGNvZGU9cCh0aGlzLFUpLm9wY29kZSkscCh0aGlzLFUpLmZyYWdtZW50ZWQ9IXAodGhpcyxVKS5maW4mJnAodGhpcyxVKS5vcGNvZGUhPT10LkNPTlRJTlVBVElPTixwKHRoaXMsVSkuZnJhZ21lbnRlZCYmcCh0aGlzLFUpLm9wY29kZSE9PXQuQklOQVJZJiZwKHRoaXMsVSkub3Bjb2RlIT09dC5URVhUKXtmKHRoaXMud3MsXCJJbnZhbGlkIGZyYW1lIHR5cGUgd2FzIGZyYWdtZW50ZWQuXCIpO3JldHVybn1jb25zdCBOPUZbMV0mMTI3O2lmKE48PTEyNT8ocCh0aGlzLFUpLnBheWxvYWRMZW5ndGg9TixFQSh0aGlzLHcsQS5SRUFEX0RBVEEpKTpOPT09MTI2P0VBKHRoaXMsdyxBLlBBWUxPQURMRU5HVEhfMTYpOk49PT0xMjcmJkVBKHRoaXMsdyxBLlBBWUxPQURMRU5HVEhfNjQpLHAodGhpcyxVKS5mcmFnbWVudGVkJiZOPjEyNSl7Zih0aGlzLndzLFwiRnJhZ21lbnRlZCBmcmFtZSBleGNlZWRlZCAxMjUgYnl0ZXMuXCIpO3JldHVybn1lbHNlIGlmKChwKHRoaXMsVSkub3Bjb2RlPT09dC5QSU5HfHxwKHRoaXMsVSkub3Bjb2RlPT09dC5QT05HfHxwKHRoaXMsVSkub3Bjb2RlPT09dC5DTE9TRSkmJk4+MTI1KXtmKHRoaXMud3MsXCJQYXlsb2FkIGxlbmd0aCBmb3IgY29udHJvbCBmcmFtZSBleGNlZWRlZCAxMjUgYnl0ZXMuXCIpO3JldHVybn1lbHNlIGlmKHAodGhpcyxVKS5vcGNvZGU9PT10LkNMT1NFKXtpZihOPT09MSl7Zih0aGlzLndzLFwiUmVjZWl2ZWQgY2xvc2UgZnJhbWUgd2l0aCBhIDEtYnl0ZSBib2R5LlwiKTtyZXR1cm59Y29uc3QgdT10aGlzLmNvbnN1bWUoTik7aWYocCh0aGlzLFUpLmNsb3NlSW5mbz10aGlzLnBhcnNlQ2xvc2VCb2R5KHUpLHRoaXMud3NbRV0hPT1zLlNFTlQpe2xldCBiPXI7cCh0aGlzLFUpLmNsb3NlSW5mby5jb2RlJiYoYj1CdWZmZXIuYWxsb2NVbnNhZmUoMiksYi53cml0ZVVJbnQxNkJFKHAodGhpcyxVKS5jbG9zZUluZm8uY29kZSwwKSk7Y29uc3QgbT1uZXcgYyhiKTt0aGlzLndzW1FdLnNvY2tldC53cml0ZShtLmNyZWF0ZUZyYW1lKHQuQ0xPU0UpLFQ9PntUfHwodGhpcy53c1tFXT1zLlNFTlQpfSl9dGhpcy53c1tpXT1uLkNMT1NJTkcsdGhpcy53c1tDXT0hMCx0aGlzLmVuZCgpO3JldHVybn1lbHNlIGlmKHAodGhpcyxVKS5vcGNvZGU9PT10LlBJTkcpe2NvbnN0IHU9dGhpcy5jb25zdW1lKE4pO2lmKCF0aGlzLndzW0NdKXtjb25zdCBiPW5ldyBjKHUpO3RoaXMud3NbUV0uc29ja2V0LndyaXRlKGIuY3JlYXRlRnJhbWUodC5QT05HKSksSS5waW5nLmhhc1N1YnNjcmliZXJzJiZJLnBpbmcucHVibGlzaCh7cGF5bG9hZDp1fSl9aWYoRUEodGhpcyx3LEEuSU5GTykscCh0aGlzLGspPjApY29udGludWU7ZygpO3JldHVybn1lbHNlIGlmKHAodGhpcyxVKS5vcGNvZGU9PT10LlBPTkcpe2NvbnN0IHU9dGhpcy5jb25zdW1lKE4pO2lmKEkucG9uZy5oYXNTdWJzY3JpYmVycyYmSS5wb25nLnB1Ymxpc2goe3BheWxvYWQ6dX0pLHAodGhpcyxrKT4wKWNvbnRpbnVlO2coKTtyZXR1cm59fWVsc2UgaWYocCh0aGlzLHcpPT09QS5QQVlMT0FETEVOR1RIXzE2KXtpZihwKHRoaXMsayk8MilyZXR1cm4gZygpO2NvbnN0IEY9dGhpcy5jb25zdW1lKDIpO3AodGhpcyxVKS5wYXlsb2FkTGVuZ3RoPUYucmVhZFVJbnQxNkJFKDApLEVBKHRoaXMsdyxBLlJFQURfREFUQSl9ZWxzZSBpZihwKHRoaXMsdyk9PT1BLlBBWUxPQURMRU5HVEhfNjQpe2lmKHAodGhpcyxrKTw4KXJldHVybiBnKCk7Y29uc3QgRj10aGlzLmNvbnN1bWUoOCksTj1GLnJlYWRVSW50MzJCRSgwKTtpZihOPjIqKjMxLTEpe2YodGhpcy53cyxcIlJlY2VpdmVkIHBheWxvYWQgbGVuZ3RoID4gMl4zMSBieXRlcy5cIik7cmV0dXJufWNvbnN0IHU9Ri5yZWFkVUludDMyQkUoNCk7cCh0aGlzLFUpLnBheWxvYWRMZW5ndGg9KE48PDgpK3UsRUEodGhpcyx3LEEuUkVBRF9EQVRBKX1lbHNlIGlmKHAodGhpcyx3KT09PUEuUkVBRF9EQVRBKXtpZihwKHRoaXMsayk8cCh0aGlzLFUpLnBheWxvYWRMZW5ndGgpcmV0dXJuIGcoKTtpZihwKHRoaXMsayk+PXAodGhpcyxVKS5wYXlsb2FkTGVuZ3RoKXtjb25zdCBGPXRoaXMuY29uc3VtZShwKHRoaXMsVSkucGF5bG9hZExlbmd0aCk7aWYocCh0aGlzLE0pLnB1c2goRiksIXAodGhpcyxVKS5mcmFnbWVudGVkfHxwKHRoaXMsVSkuZmluJiZwKHRoaXMsVSkub3Bjb2RlPT09dC5DT05USU5VQVRJT04pe2NvbnN0IE49QnVmZmVyLmNvbmNhdChwKHRoaXMsTSkpO2godGhpcy53cyxwKHRoaXMsVSkub3JpZ2luYWxPcGNvZGUsTiksRUEodGhpcyxVLHt9KSxwKHRoaXMsTSkubGVuZ3RoPTB9RUEodGhpcyx3LEEuSU5GTyl9fWlmKHAodGhpcyxrKT09PTApe2coKTticmVha319fWNvbnN1bWUoZyl7aWYoZz5wKHRoaXMsaykpcmV0dXJuIG51bGw7aWYoZz09PTApcmV0dXJuIHI7aWYocCh0aGlzLFMpWzBdLmxlbmd0aD09PWcpcmV0dXJuIEVBKHRoaXMsayxwKHRoaXMsayktcCh0aGlzLFMpWzBdLmxlbmd0aCkscCh0aGlzLFMpLnNoaWZ0KCk7Y29uc3QgZD1CdWZmZXIuYWxsb2NVbnNhZmUoZyk7bGV0IEY9MDtmb3IoO0YhPT1nOyl7Y29uc3QgTj1wKHRoaXMsUylbMF0se2xlbmd0aDp1fT1OO2lmKHUrRj09PWcpe2Quc2V0KHAodGhpcyxTKS5zaGlmdCgpLEYpO2JyZWFrfWVsc2UgaWYodStGPmcpe2Quc2V0KE4uc3ViYXJyYXkoMCxnLUYpLEYpLHAodGhpcyxTKVswXT1OLnN1YmFycmF5KGctRik7YnJlYWt9ZWxzZSBkLnNldChwKHRoaXMsUykuc2hpZnQoKSxGKSxGKz1OLmxlbmd0aH1yZXR1cm4gRUEodGhpcyxrLHAodGhpcyxrKS1nKSxkfXBhcnNlQ2xvc2VCb2R5KGcpe2xldCBkO2cubGVuZ3RoPj0yJiYoZD1nLnJlYWRVSW50MTZCRSgwKSk7bGV0IEY9Zy5zdWJhcnJheSgyKTtpZihGWzBdPT09MjM5JiZGWzFdPT09MTg3JiZGWzJdPT09MTkxJiYoRj1GLnN1YmFycmF5KDMpKSxkIT09dm9pZCAwJiYhYShkKSlyZXR1cm4gbnVsbDt0cnl7Rj1MKEYpfWNhdGNoe3JldHVybiBudWxsfXJldHVybntjb2RlOmQscmVhc29uOkZ9fWdldCBjbG9zaW5nSW5mbygpe3JldHVybiBwKHRoaXMsVSkuY2xvc2VJbmZvfX07Uz1uZXcgV2Vha01hcCxrPW5ldyBXZWFrTWFwLHc9bmV3IFdlYWtNYXAsVT1uZXcgV2Vha01hcCxNPW5ldyBXZWFrTWFwLG8oQixcIkJ5dGVQYXJzZXJcIik7bGV0IGw9QjtyZXR1cm4gcmVjZWl2ZXI9e0J5dGVQYXJzZXI6bH0scmVjZWl2ZXJ9byhyZXF1aXJlUmVjZWl2ZXIsXCJyZXF1aXJlUmVjZWl2ZXJcIik7dmFyIHdlYnNvY2tldCxoYXNSZXF1aXJlZFdlYnNvY2tldDtmdW5jdGlvbiByZXF1aXJlV2Vic29ja2V0KCl7dmFyIG0sVCx2LFosUCxrdDtpZihoYXNSZXF1aXJlZFdlYnNvY2tldClyZXR1cm4gd2Vic29ja2V0O2hhc1JlcXVpcmVkV2Vic29ja2V0PTE7Y29uc3R7d2ViaWRsOmV9PXJlcXVpcmVXZWJpZGwoKSx7VVJMU2VyaWFsaXplcjpBfT1yZXF1aXJlRGF0YVVybCgpLHtnZXRHbG9iYWxPcmlnaW46dH09cmVxdWlyZUdsb2JhbCgpLHtzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzOm4sc3RhdGVzOnIsc2VudENsb3NlRnJhbWVTdGF0ZTpzLG9wY29kZXM6aSxlbXB0eUJ1ZmZlcjpFfT1yZXF1aXJlQ29uc3RhbnRzKCkse2tXZWJTb2NrZXRVUkw6USxrUmVhZHlTdGF0ZTpDLGtDb250cm9sbGVyOkksa0JpbmFyeVR5cGU6YSxrUmVzcG9uc2U6ZixrU2VudENsb3NlOmgsa0J5dGVQYXJzZXI6TH09cmVxdWlyZVN5bWJvbHMoKSx7aXNDb25uZWN0aW5nOmMsaXNFc3RhYmxpc2hlZDpsLGlzQ2xvc2VkOlMsaXNDbG9zaW5nOmssaXNWYWxpZFN1YnByb3RvY29sOncsZmFpbFdlYnNvY2tldENvbm5lY3Rpb246VSxmaXJlRXZlbnQ6TX09cmVxdWlyZVV0aWwkMSgpLHtlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uOkJ9PXJlcXVpcmVDb25uZWN0aW9uKCkse1dlYnNvY2tldEZyYW1lU2VuZDpEfT1yZXF1aXJlRnJhbWUoKSx7Qnl0ZVBhcnNlcjpHfT1yZXF1aXJlUmVjZWl2ZXIoKSx7a0VudW1lcmFibGVQcm9wZXJ0eTpnLGlzQmxvYkxpa2U6ZH09dXRpbCRtLHtnZXRHbG9iYWxEaXNwYXRjaGVyOkZ9PWdsb2JhbCx7dHlwZXM6Tn09cmVxdWlyZSQkMF9fZGVmYXVsdCQxO2xldCB1PSExO2NvbnN0IEs9Y2xhc3MgSyBleHRlbmRzIEV2ZW50VGFyZ2V0e2NvbnN0cnVjdG9yKFgsJD1bXSl7c3VwZXIoKTtDQSh0aGlzLFApO0NBKHRoaXMsbSx7b3BlbjpudWxsLGVycm9yOm51bGwsY2xvc2U6bnVsbCxtZXNzYWdlOm51bGx9KTtDQSh0aGlzLFQsMCk7Q0EodGhpcyx2LFwiXCIpO0NBKHRoaXMsWixcIlwiKTtlLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLDEse2hlYWRlcjpcIldlYlNvY2tldCBjb25zdHJ1Y3RvclwifSksdXx8KHU9ITAscHJvY2Vzcy5lbWl0V2FybmluZyhcIldlYlNvY2tldHMgYXJlIGV4cGVyaW1lbnRhbCwgZXhwZWN0IHRoZW0gdG8gY2hhbmdlIGF0IGFueSB0aW1lLlwiLHtjb2RlOlwiVU5ESUNJLVdTXCJ9KSk7Y29uc3QgVj1lLmNvbnZlcnRlcnNbXCJET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiBvciBXZWJTb2NrZXRJbml0XCJdKCQpO1g9ZS5jb252ZXJ0ZXJzLlVTVlN0cmluZyhYKSwkPVYucHJvdG9jb2xzO2NvbnN0IHE9dCgpO2xldCB6O3RyeXt6PW5ldyBVUkwoWCxxKX1jYXRjaChyQSl7dGhyb3cgbmV3IERPTUV4Y2VwdGlvbihyQSxcIlN5bnRheEVycm9yXCIpfWlmKHoucHJvdG9jb2w9PT1cImh0dHA6XCI/ei5wcm90b2NvbD1cIndzOlwiOnoucHJvdG9jb2w9PT1cImh0dHBzOlwiJiYoei5wcm90b2NvbD1cIndzczpcIiksei5wcm90b2NvbCE9PVwid3M6XCImJnoucHJvdG9jb2whPT1cIndzczpcIil0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGBFeHBlY3RlZCBhIHdzOiBvciB3c3M6IHByb3RvY29sLCBnb3QgJHt6LnByb3RvY29sfWAsXCJTeW50YXhFcnJvclwiKTtpZih6Lmhhc2h8fHouaHJlZi5lbmRzV2l0aChcIiNcIikpdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIkdvdCBmcmFnbWVudFwiLFwiU3ludGF4RXJyb3JcIik7aWYodHlwZW9mICQ9PVwic3RyaW5nXCImJigkPVskXSksJC5sZW5ndGghPT1uZXcgU2V0KCQubWFwKHJBPT5yQS50b0xvd2VyQ2FzZSgpKSkuc2l6ZSl0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIHZhbHVlXCIsXCJTeW50YXhFcnJvclwiKTtpZigkLmxlbmd0aD4wJiYhJC5ldmVyeShyQT0+dyhyQSkpKXRocm93IG5ldyBET01FeGNlcHRpb24oXCJJbnZhbGlkIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgdmFsdWVcIixcIlN5bnRheEVycm9yXCIpO3RoaXNbUV09bmV3IFVSTCh6LmhyZWYpLHRoaXNbSV09Qih6LCQsdGhpcyxyQT0+a0EodGhpcyxQLGt0KS5jYWxsKHRoaXMsckEpLFYpLHRoaXNbQ109Sy5DT05ORUNUSU5HLHRoaXNbaF09cy5OT1RfU0VOVCx0aGlzW2FdPVwiYmxvYlwifWNsb3NlKFg9dm9pZCAwLCQ9dm9pZCAwKXtpZihlLmJyYW5kQ2hlY2sodGhpcyxLKSxYIT09dm9pZCAwJiYoWD1lLmNvbnZlcnRlcnNbXCJ1bnNpZ25lZCBzaG9ydFwiXShYLHtjbGFtcDohMH0pKSwkIT09dm9pZCAwJiYoJD1lLmNvbnZlcnRlcnMuVVNWU3RyaW5nKCQpKSxYIT09dm9pZCAwJiZYIT09MWUzJiYoWDwzZTN8fFg+NDk5OSkpdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcImludmFsaWQgY29kZVwiLFwiSW52YWxpZEFjY2Vzc0Vycm9yXCIpO2xldCBWPTA7aWYoJCE9PXZvaWQgMCYmKFY9QnVmZmVyLmJ5dGVMZW5ndGgoJCksVj4xMjMpKXRocm93IG5ldyBET01FeGNlcHRpb24oYFJlYXNvbiBtdXN0IGJlIGxlc3MgdGhhbiAxMjMgYnl0ZXM7IHJlY2VpdmVkICR7Vn1gLFwiU3ludGF4RXJyb3JcIik7aWYoIShrKHRoaXMpfHxTKHRoaXMpKSlpZighbCh0aGlzKSlVKHRoaXMsXCJDb25uZWN0aW9uIHdhcyBjbG9zZWQgYmVmb3JlIGl0IHdhcyBlc3RhYmxpc2hlZC5cIiksdGhpc1tDXT1LLkNMT1NJTkc7ZWxzZSBpZih0aGlzW2hdPT09cy5OT1RfU0VOVCl7dGhpc1toXT1zLlBST0NFU1NJTkc7Y29uc3QgcT1uZXcgRDtYIT09dm9pZCAwJiYkPT09dm9pZCAwPyhxLmZyYW1lRGF0YT1CdWZmZXIuYWxsb2NVbnNhZmUoMikscS5mcmFtZURhdGEud3JpdGVVSW50MTZCRShYLDApKTpYIT09dm9pZCAwJiYkIT09dm9pZCAwPyhxLmZyYW1lRGF0YT1CdWZmZXIuYWxsb2NVbnNhZmUoMitWKSxxLmZyYW1lRGF0YS53cml0ZVVJbnQxNkJFKFgsMCkscS5mcmFtZURhdGEud3JpdGUoJCwyLFwidXRmLThcIikpOnEuZnJhbWVEYXRhPUUsdGhpc1tmXS5zb2NrZXQud3JpdGUocS5jcmVhdGVGcmFtZShpLkNMT1NFKSxyQT0+e3JBfHwodGhpc1toXT1zLlNFTlQpfSksdGhpc1tDXT1yLkNMT1NJTkd9ZWxzZSB0aGlzW0NdPUsuQ0xPU0lOR31zZW5kKFgpe2lmKGUuYnJhbmRDaGVjayh0aGlzLEspLGUuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsMSx7aGVhZGVyOlwiV2ViU29ja2V0LnNlbmRcIn0pLFg9ZS5jb252ZXJ0ZXJzLldlYlNvY2tldFNlbmREYXRhKFgpLGModGhpcykpdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIlNlbnQgYmVmb3JlIGNvbm5lY3RlZC5cIixcIkludmFsaWRTdGF0ZUVycm9yXCIpO2lmKCFsKHRoaXMpfHxrKHRoaXMpKXJldHVybjtjb25zdCAkPXRoaXNbZl0uc29ja2V0O2lmKHR5cGVvZiBYPT1cInN0cmluZ1wiKXtjb25zdCBWPUJ1ZmZlci5mcm9tKFgpLHo9bmV3IEQoVikuY3JlYXRlRnJhbWUoaS5URVhUKTtFQSh0aGlzLFQscCh0aGlzLFQpK1YuYnl0ZUxlbmd0aCksJC53cml0ZSh6LCgpPT57RUEodGhpcyxULHAodGhpcyxUKS1WLmJ5dGVMZW5ndGgpfSl9ZWxzZSBpZihOLmlzQXJyYXlCdWZmZXIoWCkpe2NvbnN0IFY9QnVmZmVyLmZyb20oWCksej1uZXcgRChWKS5jcmVhdGVGcmFtZShpLkJJTkFSWSk7RUEodGhpcyxULHAodGhpcyxUKStWLmJ5dGVMZW5ndGgpLCQud3JpdGUoeiwoKT0+e0VBKHRoaXMsVCxwKHRoaXMsVCktVi5ieXRlTGVuZ3RoKX0pfWVsc2UgaWYoQXJyYXlCdWZmZXIuaXNWaWV3KFgpKXtjb25zdCBWPUJ1ZmZlci5mcm9tKFgsWC5ieXRlT2Zmc2V0LFguYnl0ZUxlbmd0aCksej1uZXcgRChWKS5jcmVhdGVGcmFtZShpLkJJTkFSWSk7RUEodGhpcyxULHAodGhpcyxUKStWLmJ5dGVMZW5ndGgpLCQud3JpdGUoeiwoKT0+e0VBKHRoaXMsVCxwKHRoaXMsVCktVi5ieXRlTGVuZ3RoKX0pfWVsc2UgaWYoZChYKSl7Y29uc3QgVj1uZXcgRDtYLmFycmF5QnVmZmVyKCkudGhlbihxPT57Y29uc3Qgej1CdWZmZXIuZnJvbShxKTtWLmZyYW1lRGF0YT16O2NvbnN0IHJBPVYuY3JlYXRlRnJhbWUoaS5CSU5BUlkpO0VBKHRoaXMsVCxwKHRoaXMsVCkrei5ieXRlTGVuZ3RoKSwkLndyaXRlKHJBLCgpPT57RUEodGhpcyxULHAodGhpcyxUKS16LmJ5dGVMZW5ndGgpfSl9KX19Z2V0IHJlYWR5U3RhdGUoKXtyZXR1cm4gZS5icmFuZENoZWNrKHRoaXMsSyksdGhpc1tDXX1nZXQgYnVmZmVyZWRBbW91bnQoKXtyZXR1cm4gZS5icmFuZENoZWNrKHRoaXMsSykscCh0aGlzLFQpfWdldCB1cmwoKXtyZXR1cm4gZS5icmFuZENoZWNrKHRoaXMsSyksQSh0aGlzW1FdKX1nZXQgZXh0ZW5zaW9ucygpe3JldHVybiBlLmJyYW5kQ2hlY2sodGhpcyxLKSxwKHRoaXMsWil9Z2V0IHByb3RvY29sKCl7cmV0dXJuIGUuYnJhbmRDaGVjayh0aGlzLEspLHAodGhpcyx2KX1nZXQgb25vcGVuKCl7cmV0dXJuIGUuYnJhbmRDaGVjayh0aGlzLEspLHAodGhpcyxtKS5vcGVufXNldCBvbm9wZW4oWCl7ZS5icmFuZENoZWNrKHRoaXMsSykscCh0aGlzLG0pLm9wZW4mJnRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9wZW5cIixwKHRoaXMsbSkub3BlbiksdHlwZW9mIFg9PVwiZnVuY3Rpb25cIj8ocCh0aGlzLG0pLm9wZW49WCx0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsWCkpOnAodGhpcyxtKS5vcGVuPW51bGx9Z2V0IG9uZXJyb3IoKXtyZXR1cm4gZS5icmFuZENoZWNrKHRoaXMsSykscCh0aGlzLG0pLmVycm9yfXNldCBvbmVycm9yKFgpe2UuYnJhbmRDaGVjayh0aGlzLEspLHAodGhpcyxtKS5lcnJvciYmdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixwKHRoaXMsbSkuZXJyb3IpLHR5cGVvZiBYPT1cImZ1bmN0aW9uXCI/KHAodGhpcyxtKS5lcnJvcj1YLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsWCkpOnAodGhpcyxtKS5lcnJvcj1udWxsfWdldCBvbmNsb3NlKCl7cmV0dXJuIGUuYnJhbmRDaGVjayh0aGlzLEspLHAodGhpcyxtKS5jbG9zZX1zZXQgb25jbG9zZShYKXtlLmJyYW5kQ2hlY2sodGhpcyxLKSxwKHRoaXMsbSkuY2xvc2UmJnRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIscCh0aGlzLG0pLmNsb3NlKSx0eXBlb2YgWD09XCJmdW5jdGlvblwiPyhwKHRoaXMsbSkuY2xvc2U9WCx0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLFgpKTpwKHRoaXMsbSkuY2xvc2U9bnVsbH1nZXQgb25tZXNzYWdlKCl7cmV0dXJuIGUuYnJhbmRDaGVjayh0aGlzLEspLHAodGhpcyxtKS5tZXNzYWdlfXNldCBvbm1lc3NhZ2UoWCl7ZS5icmFuZENoZWNrKHRoaXMsSykscCh0aGlzLG0pLm1lc3NhZ2UmJnRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixwKHRoaXMsbSkubWVzc2FnZSksdHlwZW9mIFg9PVwiZnVuY3Rpb25cIj8ocCh0aGlzLG0pLm1lc3NhZ2U9WCx0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsWCkpOnAodGhpcyxtKS5tZXNzYWdlPW51bGx9Z2V0IGJpbmFyeVR5cGUoKXtyZXR1cm4gZS5icmFuZENoZWNrKHRoaXMsSyksdGhpc1thXX1zZXQgYmluYXJ5VHlwZShYKXtlLmJyYW5kQ2hlY2sodGhpcyxLKSxYIT09XCJibG9iXCImJlghPT1cImFycmF5YnVmZmVyXCI/dGhpc1thXT1cImJsb2JcIjp0aGlzW2FdPVh9fTttPW5ldyBXZWFrTWFwLFQ9bmV3IFdlYWtNYXAsdj1uZXcgV2Vha01hcCxaPW5ldyBXZWFrTWFwLFA9bmV3IFdlYWtTZXQsa3Q9byhmdW5jdGlvbihYKXt0aGlzW2ZdPVg7Y29uc3QgJD1uZXcgRyh0aGlzKTskLm9uKFwiZHJhaW5cIixvKGZ1bmN0aW9uKCl7dGhpcy53c1tmXS5zb2NrZXQucmVzdW1lKCl9LFwib25QYXJzZXJEcmFpblwiKSksWC5zb2NrZXQud3M9dGhpcyx0aGlzW0xdPSQsdGhpc1tDXT1yLk9QRU47Y29uc3QgVj1YLmhlYWRlcnNMaXN0LmdldChcInNlYy13ZWJzb2NrZXQtZXh0ZW5zaW9uc1wiKTtWIT09bnVsbCYmRUEodGhpcyxaLFYpO2NvbnN0IHE9WC5oZWFkZXJzTGlzdC5nZXQoXCJzZWMtd2Vic29ja2V0LXByb3RvY29sXCIpO3EhPT1udWxsJiZFQSh0aGlzLHYscSksTShcIm9wZW5cIix0aGlzKX0sXCIjb25Db25uZWN0aW9uRXN0YWJsaXNoZWRcIiksbyhLLFwiV2ViU29ja2V0XCIpO2xldCBiPUs7cmV0dXJuIGIuQ09OTkVDVElORz1iLnByb3RvdHlwZS5DT05ORUNUSU5HPXIuQ09OTkVDVElORyxiLk9QRU49Yi5wcm90b3R5cGUuT1BFTj1yLk9QRU4sYi5DTE9TSU5HPWIucHJvdG90eXBlLkNMT1NJTkc9ci5DTE9TSU5HLGIuQ0xPU0VEPWIucHJvdG90eXBlLkNMT1NFRD1yLkNMT1NFRCxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhiLnByb3RvdHlwZSx7Q09OTkVDVElORzpuLE9QRU46bixDTE9TSU5HOm4sQ0xPU0VEOm4sdXJsOmcscmVhZHlTdGF0ZTpnLGJ1ZmZlcmVkQW1vdW50Omcsb25vcGVuOmcsb25lcnJvcjpnLG9uY2xvc2U6ZyxjbG9zZTpnLG9ubWVzc2FnZTpnLGJpbmFyeVR5cGU6ZyxzZW5kOmcsZXh0ZW5zaW9uczpnLHByb3RvY29sOmcsW1N5bWJvbC50b1N0cmluZ1RhZ106e3ZhbHVlOlwiV2ViU29ja2V0XCIsd3JpdGFibGU6ITEsZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9fSksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYix7Q09OTkVDVElORzpuLE9QRU46bixDTE9TSU5HOm4sQ0xPU0VEOm59KSxlLmNvbnZlcnRlcnNbXCJzZXF1ZW5jZTxET01TdHJpbmc+XCJdPWUuc2VxdWVuY2VDb252ZXJ0ZXIoZS5jb252ZXJ0ZXJzLkRPTVN0cmluZyksZS5jb252ZXJ0ZXJzW1wiRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz5cIl09ZnVuY3Rpb24odEEpe3JldHVybiBlLnV0aWwuVHlwZSh0QSk9PT1cIk9iamVjdFwiJiZTeW1ib2wuaXRlcmF0b3IgaW4gdEE/ZS5jb252ZXJ0ZXJzW1wic2VxdWVuY2U8RE9NU3RyaW5nPlwiXSh0QSk6ZS5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0QSl9LGUuY29udmVydGVycy5XZWJTb2NrZXRJbml0PWUuZGljdGlvbmFyeUNvbnZlcnRlcihbe2tleTpcInByb3RvY29sc1wiLGNvbnZlcnRlcjplLmNvbnZlcnRlcnNbXCJET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPlwiXSxnZXQgZGVmYXVsdFZhbHVlKCl7cmV0dXJuW119fSx7a2V5OlwiZGlzcGF0Y2hlclwiLGNvbnZlcnRlcjp0QT0+dEEsZ2V0IGRlZmF1bHRWYWx1ZSgpe3JldHVybiBGKCl9fSx7a2V5OlwiaGVhZGVyc1wiLGNvbnZlcnRlcjplLm51bGxhYmxlQ29udmVydGVyKGUuY29udmVydGVycy5IZWFkZXJzSW5pdCl9XSksZS5jb252ZXJ0ZXJzW1wiRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4gb3IgV2ViU29ja2V0SW5pdFwiXT1mdW5jdGlvbih0QSl7cmV0dXJuIGUudXRpbC5UeXBlKHRBKT09PVwiT2JqZWN0XCImJiEoU3ltYm9sLml0ZXJhdG9yIGluIHRBKT9lLmNvbnZlcnRlcnMuV2ViU29ja2V0SW5pdCh0QSk6e3Byb3RvY29sczplLmNvbnZlcnRlcnNbXCJET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPlwiXSh0QSl9fSxlLmNvbnZlcnRlcnMuV2ViU29ja2V0U2VuZERhdGE9ZnVuY3Rpb24odEEpe2lmKGUudXRpbC5UeXBlKHRBKT09PVwiT2JqZWN0XCIpe2lmKGQodEEpKXJldHVybiBlLmNvbnZlcnRlcnMuQmxvYih0QSx7c3RyaWN0OiExfSk7aWYoQXJyYXlCdWZmZXIuaXNWaWV3KHRBKXx8Ti5pc0FycmF5QnVmZmVyKHRBKSlyZXR1cm4gZS5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZSh0QSl9cmV0dXJuIGUuY29udmVydGVycy5VU1ZTdHJpbmcodEEpfSx3ZWJzb2NrZXQ9e1dlYlNvY2tldDpifSx3ZWJzb2NrZXR9byhyZXF1aXJlV2Vic29ja2V0LFwicmVxdWlyZVdlYnNvY2tldFwiKTt2YXIgdXRpbCQxLGhhc1JlcXVpcmVkVXRpbDtmdW5jdGlvbiByZXF1aXJlVXRpbCgpe2lmKGhhc1JlcXVpcmVkVXRpbClyZXR1cm4gdXRpbCQxO2hhc1JlcXVpcmVkVXRpbD0xO2Z1bmN0aW9uIGUobil7cmV0dXJuIG4uaW5kZXhPZihcIlxcMFwiKT09PS0xfW8oZSxcImlzVmFsaWRMYXN0RXZlbnRJZFwiKTtmdW5jdGlvbiBBKG4pe2lmKG4ubGVuZ3RoPT09MClyZXR1cm4hMTtmb3IobGV0IHI9MDtyPG4ubGVuZ3RoO3IrKylpZihuLmNoYXJDb2RlQXQocik8NDh8fG4uY2hhckNvZGVBdChyKT41NylyZXR1cm4hMTtyZXR1cm4hMH1vKEEsXCJpc0FTQ0lJTnVtYmVyXCIpO2Z1bmN0aW9uIHQobil7cmV0dXJuIG5ldyBQcm9taXNlKHI9PntzZXRUaW1lb3V0KHIsbikudW5yZWYoKX0pfXJldHVybiBvKHQsXCJkZWxheVwiKSx1dGlsJDE9e2lzVmFsaWRMYXN0RXZlbnRJZDplLGlzQVNDSUlOdW1iZXI6QSxkZWxheTp0fSx1dGlsJDF9byhyZXF1aXJlVXRpbCxcInJlcXVpcmVVdGlsXCIpO3ZhciBldmVudHNvdXJjZVN0cmVhbSxoYXNSZXF1aXJlZEV2ZW50c291cmNlU3RyZWFtO2Z1bmN0aW9uIHJlcXVpcmVFdmVudHNvdXJjZVN0cmVhbSgpe2lmKGhhc1JlcXVpcmVkRXZlbnRzb3VyY2VTdHJlYW0pcmV0dXJuIGV2ZW50c291cmNlU3RyZWFtO2hhc1JlcXVpcmVkRXZlbnRzb3VyY2VTdHJlYW09MTtjb25zdHtUcmFuc2Zvcm06ZX09U3RyZWFtX19kZWZhdWx0LHtpc0FTQ0lJTnVtYmVyOkEsaXNWYWxpZExhc3RFdmVudElkOnR9PXJlcXVpcmVVdGlsKCksbj1bMjM5LDE4NywxOTFdLHI9MTAscz0xMyxpPTU4LEU9MzIsQz1jbGFzcyBDIGV4dGVuZHMgZXtjb25zdHJ1Y3RvcihmPXt9KXtmLnJlYWRhYmxlT2JqZWN0TW9kZT0hMDtzdXBlcihmKTtOQSh0aGlzLFwic3RhdGVcIixudWxsKTtOQSh0aGlzLFwiY2hlY2tCT01cIiwhMCk7TkEodGhpcyxcImNybGZDaGVja1wiLCExKTtOQSh0aGlzLFwiZXZlbnRFbmRDaGVja1wiLCExKTtOQSh0aGlzLFwiYnVmZmVyXCIsbnVsbCk7TkEodGhpcyxcInBvc1wiLDApO05BKHRoaXMsXCJldmVudFwiLHtkYXRhOnZvaWQgMCxldmVudDp2b2lkIDAsaWQ6dm9pZCAwLHJldHJ5OnZvaWQgMH0pO3RoaXMuc3RhdGU9Zi5ldmVudFNvdXJjZVNldHRpbmdzfHx7fSxmLnB1c2gmJih0aGlzLnB1c2g9Zi5wdXNoKX1fdHJhbnNmb3JtKGYsaCxMKXtpZihmLmxlbmd0aD09PTApe0woKTtyZXR1cm59aWYodGhpcy5idWZmZXI/dGhpcy5idWZmZXI9QnVmZmVyLmNvbmNhdChbdGhpcy5idWZmZXIsZl0pOnRoaXMuYnVmZmVyPWYsdGhpcy5jaGVja0JPTSlzd2l0Y2godGhpcy5idWZmZXIubGVuZ3RoKXtjYXNlIDE6aWYodGhpcy5idWZmZXJbMF09PT1uWzBdKXtMKCk7cmV0dXJufXRoaXMuY2hlY2tCT009ITEsTCgpO3JldHVybjtjYXNlIDI6aWYodGhpcy5idWZmZXJbMF09PT1uWzBdJiZ0aGlzLmJ1ZmZlclsxXT09PW5bMV0pe0woKTtyZXR1cm59dGhpcy5jaGVja0JPTT0hMTticmVhaztjYXNlIDM6aWYodGhpcy5idWZmZXJbMF09PT1uWzBdJiZ0aGlzLmJ1ZmZlclsxXT09PW5bMV0mJnRoaXMuYnVmZmVyWzJdPT09blsyXSl7dGhpcy5idWZmZXI9QnVmZmVyLmFsbG9jKDApLHRoaXMuY2hlY2tCT009ITEsTCgpO3JldHVybn10aGlzLmNoZWNrQk9NPSExO2JyZWFrO2RlZmF1bHQ6dGhpcy5idWZmZXJbMF09PT1uWzBdJiZ0aGlzLmJ1ZmZlclsxXT09PW5bMV0mJnRoaXMuYnVmZmVyWzJdPT09blsyXSYmKHRoaXMuYnVmZmVyPXRoaXMuYnVmZmVyLnN1YmFycmF5KDMpKSx0aGlzLmNoZWNrQk9NPSExO2JyZWFrfWZvcig7dGhpcy5wb3M8dGhpcy5idWZmZXIubGVuZ3RoOyl7aWYodGhpcy5ldmVudEVuZENoZWNrKXtpZih0aGlzLmNybGZDaGVjayl7aWYodGhpcy5idWZmZXJbdGhpcy5wb3NdPT09cil7dGhpcy5idWZmZXI9dGhpcy5idWZmZXIuc3ViYXJyYXkodGhpcy5wb3MrMSksdGhpcy5wb3M9MCx0aGlzLmNybGZDaGVjaz0hMTtjb250aW51ZX10aGlzLmNybGZDaGVjaz0hMX1pZih0aGlzLmJ1ZmZlclt0aGlzLnBvc109PT1yfHx0aGlzLmJ1ZmZlclt0aGlzLnBvc109PT1zKXt0aGlzLmJ1ZmZlclt0aGlzLnBvc109PT1zJiYodGhpcy5jcmxmQ2hlY2s9ITApLHRoaXMuYnVmZmVyPXRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMucG9zKzEpLHRoaXMucG9zPTAsKHRoaXMuZXZlbnQuZGF0YSE9PXZvaWQgMHx8dGhpcy5ldmVudC5ldmVudHx8dGhpcy5ldmVudC5pZHx8dGhpcy5ldmVudC5yZXRyeSkmJnRoaXMucHJvY2Vzc0V2ZW50KHRoaXMuZXZlbnQpLHRoaXMuY2xlYXJFdmVudCgpO2NvbnRpbnVlfXRoaXMuZXZlbnRFbmRDaGVjaz0hMTtjb250aW51ZX1pZih0aGlzLmJ1ZmZlclt0aGlzLnBvc109PT1yfHx0aGlzLmJ1ZmZlclt0aGlzLnBvc109PT1zKXt0aGlzLmJ1ZmZlclt0aGlzLnBvc109PT1zJiYodGhpcy5jcmxmQ2hlY2s9ITApLHRoaXMucGFyc2VMaW5lKHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsdGhpcy5wb3MpLHRoaXMuZXZlbnQpLHRoaXMuYnVmZmVyPXRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMucG9zKzEpLHRoaXMucG9zPTAsdGhpcy5ldmVudEVuZENoZWNrPSEwO2NvbnRpbnVlfXRoaXMucG9zKyt9TCgpfXBhcnNlTGluZShmLGgpe2lmKGYubGVuZ3RoPT09MClyZXR1cm47Y29uc3QgTD1mLmluZGV4T2YoaSk7aWYoTD09PTApcmV0dXJuO2xldCBjPVwiXCIsbD1cIlwiO2lmKEwhPT0tMSl7Yz1mLnN1YmFycmF5KDAsTCkudG9TdHJpbmcoXCJ1dGY4XCIpO2xldCBTPUwrMTtmW1NdPT09RSYmKytTLGw9Zi5zdWJhcnJheShTKS50b1N0cmluZyhcInV0ZjhcIil9ZWxzZSBjPWYudG9TdHJpbmcoXCJ1dGY4XCIpLGw9XCJcIjtzd2l0Y2goYyl7Y2FzZVwiZGF0YVwiOmhbY109PT12b2lkIDA/aFtjXT1sOmhbY10rPWBcbiR7bH1gO2JyZWFrO2Nhc2VcInJldHJ5XCI6QShsKSYmKGhbY109bCk7YnJlYWs7Y2FzZVwiaWRcIjp0KGwpJiYoaFtjXT1sKTticmVhaztjYXNlXCJldmVudFwiOmwubGVuZ3RoPjAmJihoW2NdPWwpO2JyZWFrfX1wcm9jZXNzRXZlbnQoZil7Zi5yZXRyeSYmQShmLnJldHJ5KSYmKHRoaXMuc3RhdGUucmVjb25uZWN0aW9uVGltZT1wYXJzZUludChmLnJldHJ5LDEwKSksZi5pZCYmdChmLmlkKSYmKHRoaXMuc3RhdGUubGFzdEV2ZW50SWQ9Zi5pZCksZi5kYXRhIT09dm9pZCAwJiZ0aGlzLnB1c2goe3R5cGU6Zi5ldmVudHx8XCJtZXNzYWdlXCIsb3B0aW9uczp7ZGF0YTpmLmRhdGEsbGFzdEV2ZW50SWQ6dGhpcy5zdGF0ZS5sYXN0RXZlbnRJZCxvcmlnaW46dGhpcy5zdGF0ZS5vcmlnaW59fSl9Y2xlYXJFdmVudCgpe3RoaXMuZXZlbnQ9e2RhdGE6dm9pZCAwLGV2ZW50OnZvaWQgMCxpZDp2b2lkIDAscmV0cnk6dm9pZCAwfX19O28oQyxcIkV2ZW50U291cmNlU3RyZWFtXCIpO2xldCBRPUM7cmV0dXJuIGV2ZW50c291cmNlU3RyZWFtPXtFdmVudFNvdXJjZVN0cmVhbTpRfSxldmVudHNvdXJjZVN0cmVhbX1vKHJlcXVpcmVFdmVudHNvdXJjZVN0cmVhbSxcInJlcXVpcmVFdmVudHNvdXJjZVN0cmVhbVwiKTt2YXIgZXZlbnRzb3VyY2UsaGFzUmVxdWlyZWRFdmVudHNvdXJjZTtmdW5jdGlvbiByZXF1aXJlRXZlbnRzb3VyY2UoKXt2YXIgVSxNLEIsRCxHLGcsZCxGLCRlLHUsX2U7aWYoaGFzUmVxdWlyZWRFdmVudHNvdXJjZSlyZXR1cm4gZXZlbnRzb3VyY2U7aGFzUmVxdWlyZWRFdmVudHNvdXJjZT0xO2NvbnN0e3BpcGVsaW5lOmV9PVN0cmVhbV9fZGVmYXVsdCx7ZmV0Y2hpbmc6QX09cmVxdWlyZUZldGNoKCkse21ha2VSZXF1ZXN0OnR9PXJlcXVpcmVSZXF1ZXN0KCkse2dldEdsb2JhbE9yaWdpbjpufT1yZXF1aXJlR2xvYmFsKCkse3dlYmlkbDpyfT1yZXF1aXJlV2ViaWRsKCkse0V2ZW50U291cmNlU3RyZWFtOnN9PXJlcXVpcmVFdmVudHNvdXJjZVN0cmVhbSgpLHtwYXJzZU1JTUVUeXBlOml9PXJlcXVpcmVEYXRhVXJsKCkse01lc3NhZ2VFdmVudDpFfT1yZXF1aXJlRXZlbnRzKCkse2lzTmV0d29ya0Vycm9yOlF9PXJlcXVpcmVSZXNwb25zZSgpLHtkZWxheTpDfT1yZXF1aXJlVXRpbCgpLHtrRW51bWVyYWJsZVByb3BlcnR5Okl9PXV0aWwkbTtsZXQgYT0hMTtjb25zdCBmPTNlMyxoPTAsTD0xLGM9MixsPVwiYW5vbnltb3VzXCIsUz1cInVzZS1jcmVkZW50aWFsc1wiLG09Y2xhc3MgbSBleHRlbmRzIEV2ZW50VGFyZ2V0e2NvbnN0cnVjdG9yKFosUD17fSl7c3VwZXIoKTtDQSh0aGlzLEYpO0NBKHRoaXMsdSk7Q0EodGhpcyxVLHtvcGVuOm51bGwsZXJyb3I6bnVsbCxtZXNzYWdlOm51bGx9KTtDQSh0aGlzLE0sbnVsbCk7Q0EodGhpcyxCLCExKTtDQSh0aGlzLEQsaCk7Q0EodGhpcyxHLG51bGwpO0NBKHRoaXMsZyxudWxsKTtDQSh0aGlzLGQsbnVsbCk7ci5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywxLHtoZWFkZXI6XCJFdmVudFNvdXJjZSBjb25zdHJ1Y3RvclwifSksYXx8KGE9ITAscHJvY2Vzcy5lbWl0V2FybmluZyhcIkV2ZW50U291cmNlIGlzIGV4cGVyaW1lbnRhbCwgZXhwZWN0IHRoZW0gdG8gY2hhbmdlIGF0IGFueSB0aW1lLlwiLHtjb2RlOlwiVU5ESUNJLUVTXCJ9KSksWj1yLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFopLFA9ci5jb252ZXJ0ZXJzLkV2ZW50U291cmNlSW5pdERpY3QoUCksRUEodGhpcyxkLHtvcmlnaW46bigpLHBvbGljeUNvbnRhaW5lcjp7cmVmZXJyZXJQb2xpY3k6XCJuby1yZWZlcnJlclwifSxsYXN0RXZlbnRJZDpcIlwiLHJlY29ubmVjdGlvblRpbWU6Zn0pO2xldCBBQTt0cnl7QUE9bmV3IFVSTChaLHAodGhpcyxkKS5vcmlnaW4pLHAodGhpcyxkKS5vcmlnaW49QUEub3JpZ2lufWNhdGNoKGFBKXt0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGFBLFwiU3ludGF4RXJyb3JcIil9RUEodGhpcyxNLEFBLmhyZWYpO2xldCBLPWw7UC53aXRoQ3JlZGVudGlhbHMmJihLPVMsRUEodGhpcyxCLCEwKSk7Y29uc3QgdEE9e3JlZGlyZWN0OlwiZm9sbG93XCIsa2VlcGFsaXZlOiEwLG1vZGU6XCJjb3JzXCIsY3JlZGVudGlhbHM6Sz09PVwiYW5vbnltb3VzXCI/XCJzYW1lLW9yaWdpblwiOlwib21pdFwiLHJlZmVycmVyOlwibm8tcmVmZXJyZXJcIn07dEEuY2xpZW50PXAodGhpcyxkKSx0QS5oZWFkZXJzTGlzdD1bW1wiYWNjZXB0XCIse25hbWU6XCJhY2NlcHRcIix2YWx1ZTpcInRleHQvZXZlbnQtc3RyZWFtXCJ9XV0sdEEuY2FjaGU9XCJuby1zdG9yZVwiLHRBLmluaXRpYXRvcj1cIm90aGVyXCIsdEEudXJsTGlzdD1bbmV3IFVSTChwKHRoaXMsTSkpXSxFQSh0aGlzLEcsdCh0QSkpLGtBKHRoaXMsRiwkZSkuY2FsbCh0aGlzKX1nZXQgcmVhZHlTdGF0ZSgpe3JldHVybiBwKHRoaXMsRCl9Z2V0IHVybCgpe3JldHVybiBwKHRoaXMsTSl9Z2V0IHdpdGhDcmVkZW50aWFscygpe3JldHVybiBwKHRoaXMsQil9Y2xvc2UoKXtyLmJyYW5kQ2hlY2sodGhpcyxtKSxwKHRoaXMsRCkhPT1jJiYoRUEodGhpcyxELGMpLGNsZWFyVGltZW91dChwKHRoaXMsZCkucmVjb25uZWN0aW9uVGltZXIpLHAodGhpcyxnKS5hYm9ydCgpLHAodGhpcyxHKSYmRUEodGhpcyxHLG51bGwpKX1nZXQgb25vcGVuKCl7cmV0dXJuIHAodGhpcyxVKS5vcGVufXNldCBvbm9wZW4oWil7cCh0aGlzLFUpLm9wZW4mJnRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9wZW5cIixwKHRoaXMsVSkub3BlbiksdHlwZW9mIFo9PVwiZnVuY3Rpb25cIj8ocCh0aGlzLFUpLm9wZW49Wix0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsWikpOnAodGhpcyxVKS5vcGVuPW51bGx9Z2V0IG9ubWVzc2FnZSgpe3JldHVybiBwKHRoaXMsVSkubWVzc2FnZX1zZXQgb25tZXNzYWdlKFope3AodGhpcyxVKS5tZXNzYWdlJiZ0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIscCh0aGlzLFUpLm1lc3NhZ2UpLHR5cGVvZiBaPT1cImZ1bmN0aW9uXCI/KHAodGhpcyxVKS5tZXNzYWdlPVosdGhpcy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLFopKTpwKHRoaXMsVSkubWVzc2FnZT1udWxsfWdldCBvbmVycm9yKCl7cmV0dXJuIHAodGhpcyxVKS5lcnJvcn1zZXQgb25lcnJvcihaKXtwKHRoaXMsVSkuZXJyb3ImJnRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIscCh0aGlzLFUpLmVycm9yKSx0eXBlb2YgWj09XCJmdW5jdGlvblwiPyhwKHRoaXMsVSkuZXJyb3I9Wix0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLFopKTpwKHRoaXMsVSkuZXJyb3I9bnVsbH19O1U9bmV3IFdlYWtNYXAsTT1uZXcgV2Vha01hcCxCPW5ldyBXZWFrTWFwLEQ9bmV3IFdlYWtNYXAsRz1uZXcgV2Vha01hcCxnPW5ldyBXZWFrTWFwLGQ9bmV3IFdlYWtNYXAsRj1uZXcgV2Vha1NldCwkZT1vKGZ1bmN0aW9uKCl7aWYocCh0aGlzLEQpPT09YylyZXR1cm47RUEodGhpcyxELGgpO2NvbnN0IFo9e3JlcXVlc3Q6cCh0aGlzLEcpfSxQPW8oQUE9PntRKEFBKSYmKHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJlcnJvclwiKSksdGhpcy5jbG9zZSgpKSxrQSh0aGlzLHUsX2UpLmNhbGwodGhpcyl9LFwicHJvY2Vzc0V2ZW50U291cmNlRW5kT2ZCb2R5XCIpO1oucHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5PVAsWi5wcm9jZXNzUmVzcG9uc2U9QUE9PntpZihRKEFBKSlpZihBQS5hYm9ydGVkKXt0aGlzLmNsb3NlKCksdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImVycm9yXCIpKTtyZXR1cm59ZWxzZXtrQSh0aGlzLHUsX2UpLmNhbGwodGhpcyk7cmV0dXJufWNvbnN0IEs9QUEuaGVhZGVyc0xpc3QuZ2V0KFwiY29udGVudC10eXBlXCIsITApLHRBPUshPT1udWxsP2koSyk6XCJmYWlsdXJlXCIsYUE9dEEhPT1cImZhaWx1cmVcIiYmdEEuZXNzZW5jZT09PVwidGV4dC9ldmVudC1zdHJlYW1cIjtpZihBQS5zdGF0dXMhPT0yMDB8fGFBPT09ITEpe3RoaXMuY2xvc2UoKSx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiZXJyb3JcIikpO3JldHVybn1FQSh0aGlzLEQsTCksdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcIm9wZW5cIikpLHAodGhpcyxkKS5vcmlnaW49QUEudXJsTGlzdFtBQS51cmxMaXN0Lmxlbmd0aC0xXS5vcmlnaW47Y29uc3QgWD1uZXcgcyh7ZXZlbnRTb3VyY2VTZXR0aW5nczpwKHRoaXMsZCkscHVzaDokPT57dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFKCQudHlwZSwkLm9wdGlvbnMpKX19KTtlKEFBLmJvZHkuc3RyZWFtLFgsJD0+eyQ/LmFib3J0ZWQ9PT0hMSYmKHRoaXMuY2xvc2UoKSx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiZXJyb3JcIikpKX0pfSxFQSh0aGlzLGcsQShaKSl9LFwiI2Nvbm5lY3RcIiksdT1uZXcgV2Vha1NldCxfZT1vKGFzeW5jIGZ1bmN0aW9uKCl7cCh0aGlzLEQpIT09YyYmKEVBKHRoaXMsRCxoKSx0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiZXJyb3JcIikpLGF3YWl0IEMocCh0aGlzLGQpLnJlY29ubmVjdGlvblRpbWUpLHAodGhpcyxEKT09PWgmJihwKHRoaXMsZCkubGFzdEV2ZW50SWQhPT1cIlwiJiZwKHRoaXMsRykuaGVhZGVyc0xpc3Quc2V0KFwibGFzdC1ldmVudC1pZFwiLHAodGhpcyxkKS5sYXN0RXZlbnRJZCwhMCksa0EodGhpcyxGLCRlKS5jYWxsKHRoaXMpKSl9LFwiI3JlY29ubmVjdFwiKSxvKG0sXCJFdmVudFNvdXJjZVwiKTtsZXQgaz1tO2NvbnN0IHc9e0NPTk5FQ1RJTkc6e19fcHJvdG9fXzpudWxsLGNvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLHZhbHVlOmgsd3JpdGFibGU6ITF9LE9QRU46e19fcHJvdG9fXzpudWxsLGNvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLHZhbHVlOkwsd3JpdGFibGU6ITF9LENMT1NFRDp7X19wcm90b19fOm51bGwsY29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsdmFsdWU6Yyx3cml0YWJsZTohMX19O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhrLHcpLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGsucHJvdG90eXBlLHcpLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGsucHJvdG90eXBlLHtjbG9zZTpJLG9uZXJyb3I6SSxvbm1lc3NhZ2U6SSxvbm9wZW46SSxyZWFkeVN0YXRlOkksdXJsOkksd2l0aENyZWRlbnRpYWxzOkl9KSxyLmNvbnZlcnRlcnMuRXZlbnRTb3VyY2VJbml0RGljdD1yLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW3trZXk6XCJ3aXRoQ3JlZGVudGlhbHNcIixjb252ZXJ0ZXI6ci5jb252ZXJ0ZXJzLmJvb2xlYW4sZGVmYXVsdFZhbHVlOiExfV0pLGV2ZW50c291cmNlPXtFdmVudFNvdXJjZTprLGRlZmF1bHRSZWNvbm5lY3Rpb25UaW1lOmZ9LGV2ZW50c291cmNlfW8ocmVxdWlyZUV2ZW50c291cmNlLFwicmVxdWlyZUV2ZW50c291cmNlXCIpO2NvbnN0IERpc3BhdGNoZXI9ZGlzcGF0Y2hlcixBZ2VudD1hZ2VudCxQcm94eUFnZW50PXByb3h5QWdlbnQsZXJyb3JzPWVycm9ycyQxLHV0aWw9dXRpbCRtLHtJbnZhbGlkQXJndW1lbnRFcnJvcn09ZXJyb3JzLGFwaT1hcGkkMSx7Z2V0R2xvYmFsRGlzcGF0Y2hlcixzZXRHbG9iYWxEaXNwYXRjaGVyfT1nbG9iYWw7T2JqZWN0LmFzc2lnbihEaXNwYXRjaGVyLnByb3RvdHlwZSxhcGkpO3ZhciBBZ2VudF8xPUFnZW50LFByb3h5QWdlbnRfMT1Qcm94eUFnZW50O3V0aWwucGFyc2VIZWFkZXJzLHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nO2Z1bmN0aW9uIG1ha2VEaXNwYXRjaGVyKGUpe3JldHVybihBLHQsbik9PntpZih0eXBlb2YgdD09XCJmdW5jdGlvblwiJiYobj10LHQ9bnVsbCksIUF8fHR5cGVvZiBBIT1cInN0cmluZ1wiJiZ0eXBlb2YgQSE9XCJvYmplY3RcIiYmIShBIGluc3RhbmNlb2YgVVJMKSl0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHVybFwiKTtpZih0IT1udWxsJiZ0eXBlb2YgdCE9XCJvYmplY3RcIil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9wdHNcIik7aWYodCYmdC5wYXRoIT1udWxsKXtpZih0eXBlb2YgdC5wYXRoIT1cInN0cmluZ1wiKXRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImludmFsaWQgb3B0cy5wYXRoXCIpO2xldCBpPXQucGF0aDt0LnBhdGguc3RhcnRzV2l0aChcIi9cIil8fChpPWAvJHtpfWApLEE9bmV3IFVSTCh1dGlsLnBhcnNlT3JpZ2luKEEpLm9yaWdpbitpKX1lbHNlIHR8fCh0PXR5cGVvZiBBPT1cIm9iamVjdFwiP0E6e30pLEE9dXRpbC5wYXJzZVVSTChBKTtjb25zdHthZ2VudDpyLGRpc3BhdGNoZXI6cz1nZXRHbG9iYWxEaXNwYXRjaGVyKCl9PXQ7aWYocil0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBvcHRzLmFnZW50LiBEaWQgeW91IG1lYW4gb3B0cy5jbGllbnQ/XCIpO3JldHVybiBlLmNhbGwocyx7Li4udCxvcmlnaW46QS5vcmlnaW4scGF0aDpBLnNlYXJjaD9gJHtBLnBhdGhuYW1lfSR7QS5zZWFyY2h9YDpBLnBhdGhuYW1lLG1ldGhvZDp0Lm1ldGhvZHx8KHQuYm9keT9cIlBVVFwiOlwiR0VUXCIpfSxuKX19byhtYWtlRGlzcGF0Y2hlcixcIm1ha2VEaXNwYXRjaGVyXCIpLHJlcXVpcmVGZXRjaCgpLmZldGNoLHJlcXVpcmVIZWFkZXJzKCkuSGVhZGVycyxyZXF1aXJlUmVzcG9uc2UoKS5SZXNwb25zZSxyZXF1aXJlUmVxdWVzdCgpLlJlcXVlc3QscmVxdWlyZUZvcm1kYXRhKCkuRm9ybURhdGEscmVxdWlyZUZpbGUoKS5GaWxlLHJlcXVpcmVGaWxlcmVhZGVyKCkuRmlsZVJlYWRlcixyZXF1aXJlR2xvYmFsKCk7Y29uc3R7Q2FjaGVTdG9yYWdlfT1yZXF1aXJlQ2FjaGVzdG9yYWdlKCkse2tDb25zdHJ1Y3R9PXJlcXVpcmVTeW1ib2xzJDEoKTtuZXcgQ2FjaGVTdG9yYWdlKGtDb25zdHJ1Y3QpLHJlcXVpcmVDb29raWVzKCkscmVxdWlyZURhdGFVcmwoKSxyZXF1aXJlRXZlbnRzKCkscmVxdWlyZVdlYnNvY2tldCgpLldlYlNvY2tldCxtYWtlRGlzcGF0Y2hlcihhcGkucmVxdWVzdCksbWFrZURpc3BhdGNoZXIoYXBpLnN0cmVhbSksbWFrZURpc3BhdGNoZXIoYXBpLnBpcGVsaW5lKSxtYWtlRGlzcGF0Y2hlcihhcGkuY29ubmVjdCksbWFrZURpc3BhdGNoZXIoYXBpLnVwZ3JhZGUpLHJlcXVpcmVFdmVudHNvdXJjZSgpLGV4cG9ydHMuQWdlbnRfMT1BZ2VudF8xLGV4cG9ydHMuUHJveHlBZ2VudF8xPVByb3h5QWdlbnRfMTtcbiJdLCJuYW1lcyI6WyJEdCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiRnQiLCJlIiwiQSIsInQiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsIm8iLCJOQSIsInplIiwiaGFzIiwiVHlwZUVycm9yIiwieXQiLCJwIiwiY2FsbCIsImdldCIsIkNBIiwiV2Vha1NldCIsImFkZCIsInNldCIsIkVBIiwibiIsImtBIiwibmUiLCJzZSIsIm9lIiwiaWUiLCJRZSIsIkVlIiwiZ2UiLCJCZSIsIkNlIiwiSWUiLCJhZSIsImNlIiwiaGUiLCJsZSIsInVlIiwiZGUiLCJmZSIsIkRlIiwieWUiLCJSZSIsIndlIiwia2UiLCJfQSIsIk5lIiwiRmUiLCJwZSIsIlNlIiwiVWUiLCJiZSIsIm1lIiwiTGUiLCJNZSIsIlllIiwiSmUiLCJPZSIsIlJ0IiwiR2UiLCJBZSIsIlRlIiwicmVxdWlyZSQkMCIsInJlcXVpcmUiLCJyZXF1aXJlJCQ0IiwiaHR0cCQxIiwiU3RyZWFtIiwicmVxdWlyZSQkNiIsInJlcXVpcmUkJDAkMSIsInJlcXVpcmUkJDgiLCJyZXF1aXJlJCQwJDIiLCJyZXF1aXJlJCQwJDMiLCJfY29tbW9uanNIZWxwZXJzIiwicmVxdWlyZSQkNCQxIiwiemxpYiIsInJlcXVpcmUkJDUiLCJyZXF1aXJlJCQ4JDEiLCJyZXF1aXJlJCQwJDQiLCJyZXF1aXJlJCQxIiwicmVxdWlyZSQkNSQxIiwicmVxdWlyZSQkNSQyIiwicmVxdWlyZSQkMiIsIl9pbnRlcm9wRGVmYXVsdENvbXBhdCIsImRlZmF1bHQiLCJyZXF1aXJlJCQwX19kZWZhdWx0IiwicmVxdWlyZSQkNF9fZGVmYXVsdCIsImh0dHBfX2RlZmF1bHQiLCJTdHJlYW1fX2RlZmF1bHQiLCJyZXF1aXJlJCQ2X19kZWZhdWx0IiwicmVxdWlyZSQkMF9fZGVmYXVsdCQxIiwicmVxdWlyZSQkOF9fZGVmYXVsdCIsInJlcXVpcmUkJDBfX2RlZmF1bHQkMiIsInJlcXVpcmUkJDBfX2RlZmF1bHQkMyIsInJlcXVpcmUkJDRfX2RlZmF1bHQkMSIsInpsaWJfX2RlZmF1bHQiLCJyZXF1aXJlJCQ1X19kZWZhdWx0IiwicmVxdWlyZSQkOF9fZGVmYXVsdCQxIiwicmVxdWlyZSQkMF9fZGVmYXVsdCQ0IiwicmVxdWlyZSQkMV9fZGVmYXVsdCIsInJlcXVpcmUkJDVfX2RlZmF1bHQkMSIsInJlcXVpcmUkJDVfX2RlZmF1bHQkMiIsInJlcXVpcmUkJDJfX2RlZmF1bHQiLCJzeW1ib2xzJDQiLCJrQ2xvc2UiLCJTeW1ib2wiLCJrRGVzdHJveSIsImtEaXNwYXRjaCIsImtVcmwiLCJrV3JpdGluZyIsImtSZXN1bWluZyIsImtRdWV1ZSIsImtDb25uZWN0Iiwia0Nvbm5lY3RpbmciLCJrSGVhZGVyc0xpc3QiLCJrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXQiLCJrS2VlcEFsaXZlTWF4VGltZW91dCIsImtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkIiwia0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSIsImtLZWVwQWxpdmUiLCJrSGVhZGVyc1RpbWVvdXQiLCJrQm9keVRpbWVvdXQiLCJrU2VydmVyTmFtZSIsImtMb2NhbEFkZHJlc3MiLCJrSG9zdCIsImtOb1JlZiIsImtCb2R5VXNlZCIsImtSdW5uaW5nIiwia0Jsb2NraW5nIiwia1BlbmRpbmciLCJrU2l6ZSIsImtCdXN5Iiwia1F1ZXVlZCIsImtGcmVlIiwia0Nvbm5lY3RlZCIsImtDbG9zZWQiLCJrTmVlZERyYWluIiwia1Jlc2V0Iiwia0Rlc3Ryb3llZCIsImZvciIsImtSZXN1bWUiLCJrT25FcnJvciIsImtNYXhIZWFkZXJzU2l6ZSIsImtSdW5uaW5nSWR4Iiwia1BlbmRpbmdJZHgiLCJrRXJyb3IiLCJrQ2xpZW50cyIsImtDbGllbnQiLCJrUGFyc2VyIiwia09uRGVzdHJveWVkIiwia1BpcGVsaW5pbmciLCJrU29ja2V0Iiwia0hvc3RIZWFkZXIiLCJrQ29ubmVjdG9yIiwia1N0cmljdENvbnRlbnRMZW5ndGgiLCJrTWF4UmVkaXJlY3Rpb25zIiwia01heFJlcXVlc3RzIiwia1Byb3h5Iiwia0NvdW50ZXIiLCJrSW50ZXJjZXB0b3JzIiwia01heFJlc3BvbnNlU2l6ZSIsImtIVFRQMlNlc3Npb24iLCJrSFRUUDJTZXNzaW9uU3RhdGUiLCJrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5Iiwia0NvbnN0cnVjdCIsImtMaXN0ZW5lcnMiLCJrSFRUUENvbnRleHQiLCJrTWF4Q29uY3VycmVudFN0cmVhbXMiLCJVbmRpY2lFcnJvciQxIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJjb2RlIiwiQ29ubmVjdFRpbWVvdXRFcnJvciQxIiwibWVzc2FnZSIsIkhlYWRlcnNUaW1lb3V0RXJyb3IkMSIsIkhlYWRlcnNPdmVyZmxvd0Vycm9yJDEiLCJCb2R5VGltZW91dEVycm9yJDEiLCJSZXNwb25zZVN0YXR1c0NvZGVFcnJvciQxIiwiciIsImJvZHkiLCJzdGF0dXMiLCJzdGF0dXNDb2RlIiwiaGVhZGVycyIsIkludmFsaWRBcmd1bWVudEVycm9yJGsiLCJJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciQyIiwiQWJvcnRFcnJvciQxIiwiUmVxdWVzdEFib3J0ZWRFcnJvciQ2IiwiSW5mb3JtYXRpb25hbEVycm9yJDMiLCJSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IkMiIsIlJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IkMSIsIkNsaWVudERlc3Ryb3llZEVycm9yJDIiLCJDbGllbnRDbG9zZWRFcnJvciQxIiwiU29ja2V0RXJyb3IkNCIsInNvY2tldCIsIk5vdFN1cHBvcnRlZEVycm9yJDIiLCJBdCIsIkJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yIiwiSFRUUFBhcnNlckVycm9yJDEiLCJkYXRhIiwidG9TdHJpbmciLCJSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yJDEiLCJldCIsIlJlcXVlc3RSZXRyeUVycm9yIiwiU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3IkMSIsImNhdXNlIiwiZXJyb3JzJDEiLCJBYm9ydEVycm9yIiwiSFRUUFBhcnNlckVycm9yIiwiVW5kaWNpRXJyb3IiLCJIZWFkZXJzVGltZW91dEVycm9yIiwiSGVhZGVyc092ZXJmbG93RXJyb3IiLCJCb2R5VGltZW91dEVycm9yIiwiUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIiwiQ29ubmVjdFRpbWVvdXRFcnJvciIsIlJlc3BvbnNlU3RhdHVzQ29kZUVycm9yIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJDbGllbnREZXN0cm95ZWRFcnJvciIsIkNsaWVudENsb3NlZEVycm9yIiwiSW5mb3JtYXRpb25hbEVycm9yIiwiU29ja2V0RXJyb3IiLCJOb3RTdXBwb3J0ZWRFcnJvciIsIlJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IiLCJSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yIiwiU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3IiLCJoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCQzIiwid2VsbGtub3duSGVhZGVyTmFtZXMkMSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwic2V0UHJvdG90eXBlT2YiLCJjb25zdGFudHMkNSIsIndlbGxrbm93bkhlYWRlck5hbWVzIiwiaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQiLCJoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCQyIiwieEEiLCJjaGFyQ29kZUF0IiwibWlkZGxlIiwicyIsImkiLCJsZWZ0IiwicmlnaHQiLCJzZWFyY2giLCJUc3ROb2RlIiwidHQiLCJpbnNlcnQiLCJub2RlIiwibG9va3VwIiwiVGVybmFyeVNlYXJjaFRyZWUiLCJ0cmVlJDEiLCJ0cmVlXzEiLCJ0cmVlIiwiYXNzZXJ0JGQiLCJrRGVzdHJveWVkJDEiLCJrQm9keVVzZWQkMSIsIkluY29taW5nTWVzc2FnZSIsInN0cmVhbSQxIiwibmV0JDIiLCJJbnZhbGlkQXJndW1lbnRFcnJvciRqIiwiQmxvYiIsIkJsb2IkMSIsIm5vZGVVdGlsIiwic3RyaW5naWZ5IiwiaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQkMSIsIm5vZGVNYWpvciIsIm5vZGVNaW5vciIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsInNwbGl0IiwibWFwIiwiTnVtYmVyIiwibm9wIiwiaXNTdHJlYW0kMSIsInBpcGUiLCJvbiIsImlzQmxvYkxpa2UkMSIsInRvU3RyaW5nVGFnIiwic3RyZWFtIiwiYXJyYXlCdWZmZXIiLCJidWlsZFVSTCQzIiwiaW5jbHVkZXMiLCJwYXJzZVVSTCIsIlVSTCIsInRlc3QiLCJvcmlnaW4iLCJwcm90b2NvbCIsInBvcnQiLCJpc0Zpbml0ZSIsInBhcnNlSW50IiwicGF0aCIsInBhdGhuYW1lIiwiaG9zdG5hbWUiLCJlbmRzV2l0aCIsInN1YnN0cmluZyIsInN0YXJ0c1dpdGgiLCJwYXJzZU9yaWdpbiIsImhhc2giLCJnZXRIb3N0bmFtZSIsImluZGV4T2YiLCJnZXRTZXJ2ZXJOYW1lJDEiLCJzdHJpY3RFcXVhbCIsImlzSVAiLCJkZWVwQ2xvbmUiLCJKU09OIiwicGFyc2UiLCJpc0FzeW5jSXRlcmFibGUiLCJhc3luY0l0ZXJhdG9yIiwiaXNJdGVyYWJsZSQxIiwiaXRlcmF0b3IiLCJib2R5TGVuZ3RoIiwiX3JlYWRhYmxlU3RhdGUiLCJvYmplY3RNb2RlIiwiZW5kZWQiLCJzaXplIiwiaXNCdWZmZXIkMSIsImJ5dGVMZW5ndGgiLCJpc0Rlc3Ryb3llZCIsImRlc3Ryb3llZCIsImlzUmVhZGFibGVBYm9ydGVkIiwiZW5kRW1pdHRlZCIsImRlc3Ryb3kkMSIsImRlc3Ryb3kiLCJnZXRQcm90b3R5cGVPZiIsInF1ZXVlTWljcm90YXNrIiwiZW1pdCIsIktFRVBBTElWRV9USU1FT1VUX0VYUFIiLCJwYXJzZUtlZXBBbGl2ZVRpbWVvdXQiLCJtYXRjaCIsImhlYWRlck5hbWVUb1N0cmluZyIsImJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUiLCJwYXJzZUhlYWRlcnMiLCJwdXNoIiwiQXJyYXkiLCJpc0FycmF5IiwiQnVmZmVyIiwiZnJvbSIsInBhcnNlUmF3SGVhZGVycyIsIkUiLCJRIiwiVWludDhBcnJheSIsImlzQnVmZmVyIiwidmFsaWRhdGVIYW5kbGVyJDEiLCJvbkNvbm5lY3QiLCJvbkVycm9yIiwib25Cb2R5U2VudCIsIm9uVXBncmFkZSIsIm9uSGVhZGVycyIsIm9uRGF0YSIsIm9uQ29tcGxldGUiLCJpc0Rpc3R1cmJlZCIsImlzRXJyb3JlZCIsImlzUmVhZGFibGUiLCJnZXRTb2NrZXRJbmZvIiwibG9jYWxBZGRyZXNzIiwibG9jYWxQb3J0IiwicmVtb3RlQWRkcmVzcyIsInJlbW90ZVBvcnQiLCJyZW1vdGVGYW1pbHkiLCJ0aW1lb3V0IiwiYnl0ZXNXcml0dGVuIiwiYnl0ZXNSZWFkIiwiUmVhZGFibGVTdHJlYW1Gcm9tJDEiLCJSZWFkYWJsZVN0cmVhbSIsInN0YXJ0IiwicHVsbCIsImRvbmUiLCJuZXh0IiwiY2xvc2UiLCJieW9iUmVxdWVzdCIsInJlc3BvbmQiLCJlbnF1ZXVlIiwiZGVzaXJlZFNpemUiLCJjYW5jZWwiLCJyZXR1cm4iLCJ0eXBlIiwiaXNGb3JtRGF0YUxpa2UkMSIsImFwcGVuZCIsImRlbGV0ZSIsImdldEFsbCIsImFkZEFib3J0TGlzdGVuZXIkMSIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJoYXNUb1dlbGxGb3JtZWQiLCJTdHJpbmciLCJwcm90b3R5cGUiLCJ0b1dlbGxGb3JtZWQiLCJoYXNJc1dlbGxGb3JtZWQiLCJpc1dlbGxGb3JtZWQiLCJ0b1VTVlN0cmluZyIsImlzVVNWU3RyaW5nIiwiaXNUb2tlbkNoYXJDb2RlIiwiaXNWYWxpZEhUVFBUb2tlbiQxIiwiaGVhZGVyQ2hhclJlZ2V4IiwiaXNWYWxpZEhlYWRlckNoYXIkMSIsInBhcnNlUmFuZ2VIZWFkZXIiLCJlbmQiLCJhZGRMaXN0ZW5lciQxIiwicmVtb3ZlQWxsTGlzdGVuZXJzJDEiLCJlcnJvclJlcXVlc3QiLCJhYm9ydGVkIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsImNyZWF0ZSIsInV0aWwkbSIsImlzQmxvYkxpa2UiLCJnZXRTZXJ2ZXJOYW1lIiwiaXNTdHJlYW0iLCJpc0l0ZXJhYmxlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiUmVhZGFibGVTdHJlYW1Gcm9tIiwidmFsaWRhdGVIYW5kbGVyIiwiaXNGb3JtRGF0YUxpa2UiLCJidWlsZFVSTCIsImFkZEFib3J0TGlzdGVuZXIiLCJpc1ZhbGlkSFRUUFRva2VuIiwiaXNWYWxpZEhlYWRlckNoYXIiLCJub2RlSGFzQXV0b1NlbGVjdEZhbWlseSIsInNhZmVIVFRQTWV0aG9kcyIsImRpYWdub3N0aWNzQ2hhbm5lbCIsInV0aWwkbCIsInVuZGljaURlYnVnTG9nIiwiZGVidWdsb2ciLCJmZXRjaERlYnVnbG9nIiwid2Vic29ja2V0RGVidWdsb2ciLCJpc0NsaWVudFNldCIsImNoYW5uZWxzJDMiLCJiZWZvcmVDb25uZWN0IiwiY2hhbm5lbCIsImNvbm5lY3RlZCIsImNvbm5lY3RFcnJvciIsInNlbmRIZWFkZXJzIiwiYm9keVNlbnQiLCJ0cmFpbGVycyIsImVycm9yIiwib3BlbiIsInNvY2tldEVycm9yIiwicGluZyIsInBvbmciLCJlbmFibGVkIiwic3Vic2NyaWJlIiwiY29ubmVjdFBhcmFtcyIsInZlcnNpb24iLCJob3N0IiwicmVxdWVzdCIsIm1ldGhvZCIsInJlc3BvbnNlIiwiYWRkcmVzcyIsIndlYnNvY2tldCIsInJlYXNvbiIsInVybCIsImRpYWdub3N0aWNzIiwiY2hhbm5lbHMiLCJJbnZhbGlkQXJndW1lbnRFcnJvciRpIiwiTm90U3VwcG9ydGVkRXJyb3IkMSIsImFzc2VydCRjIiwiYnVpbGRVUkwkMiIsImNoYW5uZWxzJDIiLCJpbnZhbGlkUGF0aFJlZ2V4Iiwia0hhbmRsZXIiLCJSZXF1ZXN0JDEiLCJxdWVyeSIsImlkZW1wb3RlbnQiLCJibG9ja2luZyIsInVwZ3JhZGUiLCJDIiwiaGVhZGVyc1RpbWVvdXQiLCJJIiwiYm9keVRpbWVvdXQiLCJhIiwicmVzZXQiLCJmIiwidGhyb3dPbkVycm9yIiwiaCIsImV4cGVjdENvbnRpbnVlIiwiTCIsInNlcnZlcm5hbWUiLCJjIiwibCIsImV4ZWMiLCJhYm9ydCIsIlMiLCJhdXRvRGVzdHJveSIsImVuZEhhbmRsZXIiLCJlcnJvckhhbmRsZXIiLCJrIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiY29tcGxldGVkIiwiY29udGVudExlbmd0aCIsImNvbnRlbnRUeXBlIiwicHJvY2Vzc0hlYWRlciIsImtleXMiLCJoYXNTdWJzY3JpYmVycyIsInB1Ymxpc2giLCJvblJlcXVlc3RTZW50Iiwib25SZXNwb25zZVN0YXJ0ZWQiLCJzdGF0dXNUZXh0Iiwib25GaW5hbGx5Iiwib2ZmIiwiYWRkSGVhZGVyIiwicmVxdWVzdCQyIiwiRXZlbnRFbWl0dGVyIiwiRGlzcGF0Y2hlciQyIiwiZGlzcGF0Y2giLCJjb21wb3NlIiwiYmluZCIsIkNvbXBvc2VkRGlzcGF0Y2hlciIsInJ0IiwiV2Vha01hcCIsImRpc3BhdGNoZXIiLCJEaXNwYXRjaGVyJDEiLCJDbGllbnREZXN0cm95ZWRFcnJvciQxIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IkaCIsImtEZXN0cm95JDQiLCJrQ2xvc2UkNiIsImtEaXNwYXRjaCQzIiwia0ludGVyY2VwdG9ycyQ0Iiwia09uQ2xvc2VkIiwia0ludGVyY2VwdGVkRGlzcGF0Y2giLCJEaXNwYXRjaGVyQmFzZSQ0IiwiY2xvc2VkIiwiaW50ZXJjZXB0b3JzIiwiUHJvbWlzZSIsInRoZW4iLCJkaXNwYXRjaGVyQmFzZSIsIm5ldCQxIiwiYXNzZXJ0JGIiLCJ1dGlsJGsiLCJJbnZhbGlkQXJndW1lbnRFcnJvciRnIiwidGxzIiwiU2Vzc2lvbkNhY2hlIiwiY29tbW9uanNHbG9iYWwiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsImVudiIsIk5PREVfVjhfQ09WRVJBR0UiLCJVTkRJQ0lfTk9fRkciLCJfbWF4Q2FjaGVkU2Vzc2lvbnMiLCJfc2Vzc2lvbkNhY2hlIiwiTWFwIiwiX3Nlc3Npb25SZWdpc3RyeSIsImRlcmVmIiwiV2Vha1JlZiIsInJlZ2lzdGVyIiwiYnVpbGRDb25uZWN0b3IkMyIsImFsbG93SDIiLCJtYXhDYWNoZWRTZXNzaW9ucyIsInNvY2tldFBhdGgiLCJpc0ludGVnZXIiLCJodHRwU29ja2V0IiwidyIsImNvbm5lY3QiLCJoaWdoV2F0ZXJNYXJrIiwic2Vzc2lvbiIsIkFMUE5Qcm90b2NvbHMiLCJVIiwia2VlcEFsaXZlIiwia2VlcEFsaXZlSW5pdGlhbERlbGF5Iiwic2V0S2VlcEFsaXZlIiwic2V0dXBUaW1lb3V0Iiwib25Db25uZWN0VGltZW91dCIsInNldE5vRGVsYXkiLCJzZXRUaW1lb3V0Iiwic2V0SW1tZWRpYXRlIiwicGxhdGZvcm0iLCJjbGVhclRpbWVvdXQiLCJjbGVhckltbWVkaWF0ZSIsImF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0ZWRBZGRyZXNzZXMiLCJqb2luIiwiY29ubmVjdCQyIiwiZmFzdE5vdyIsIkRhdGUiLCJub3ciLCJmYXN0Tm93VGltZW91dCIsImZhc3RUaW1lcnMiLCJvblRpbWVvdXQiLCJzdGF0ZSIsImRlbGF5IiwiY2FsbGJhY2siLCJvcGFxdWUiLCJwb3AiLCJyZWZyZXNoVGltZW91dCIsInJlZnJlc2giLCJ1bnJlZiIsIm50IiwiY2xlYXIiLCJUaW1lb3V0IiwidGltZXJzJDEiLCJjb25zdGFudHMkNCIsInV0aWxzIiwiZW51bVRvTWFwIiwiZm9yRWFjaCIsIlNQRUNJQUxfSEVBREVSUyIsIkhFQURFUl9TVEFURSIsIk1JTk9SIiwiTUFKT1IiLCJDT05ORUNUSU9OX1RPS0VOX0NIQVJTIiwiSEVBREVSX0NIQVJTIiwiVE9LRU4iLCJTVFJJQ1RfVE9LRU4iLCJIRVgiLCJVUkxfQ0hBUiIsIlNUUklDVF9VUkxfQ0hBUiIsIlVTRVJJTkZPX0NIQVJTIiwiTUFSSyIsIkFMUEhBTlVNIiwiTlVNIiwiSEVYX01BUCIsIk5VTV9NQVAiLCJBTFBIQSIsIkZJTklTSCIsIkhfTUVUSE9EX01BUCIsIk1FVEhPRF9NQVAiLCJNRVRIT0RTX1JUU1AiLCJNRVRIT0RTX0lDRSIsIk1FVEhPRFNfSFRUUCIsIk1FVEhPRFMiLCJMRU5JRU5UX0ZMQUdTIiwiRkxBR1MiLCJUWVBFIiwiRVJST1IiLCJPSyIsIklOVEVSTkFMIiwiU1RSSUNUIiwiTEZfRVhQRUNURUQiLCJVTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIIiwiQ0xPU0VEX0NPTk5FQ1RJT04iLCJJTlZBTElEX01FVEhPRCIsIklOVkFMSURfVVJMIiwiSU5WQUxJRF9DT05TVEFOVCIsIklOVkFMSURfVkVSU0lPTiIsIklOVkFMSURfSEVBREVSX1RPS0VOIiwiSU5WQUxJRF9DT05URU5UX0xFTkdUSCIsIklOVkFMSURfQ0hVTktfU0laRSIsIklOVkFMSURfU1RBVFVTIiwiSU5WQUxJRF9FT0ZfU1RBVEUiLCJJTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HIiwiQ0JfTUVTU0FHRV9CRUdJTiIsIkNCX0hFQURFUlNfQ09NUExFVEUiLCJDQl9NRVNTQUdFX0NPTVBMRVRFIiwiQ0JfQ0hVTktfSEVBREVSIiwiQ0JfQ0hVTktfQ09NUExFVEUiLCJQQVVTRUQiLCJQQVVTRURfVVBHUkFERSIsIlBBVVNFRF9IMl9VUEdSQURFIiwiVVNFUiIsIkJPVEgiLCJSRVFVRVNUIiwiUkVTUE9OU0UiLCJDT05ORUNUSU9OX0tFRVBfQUxJVkUiLCJDT05ORUNUSU9OX0NMT1NFIiwiQ09OTkVDVElPTl9VUEdSQURFIiwiQ0hVTktFRCIsIlVQR1JBREUiLCJDT05URU5UX0xFTkdUSCIsIlNLSVBCT0RZIiwiVFJBSUxJTkciLCJUUkFOU0ZFUl9FTkNPRElORyIsIkhFQURFUlMiLCJDSFVOS0VEX0xFTkdUSCIsIktFRVBfQUxJVkUiLCJERUxFVEUiLCJHRVQiLCJIRUFEIiwiUE9TVCIsIlBVVCIsIkNPTk5FQ1QiLCJPUFRJT05TIiwiVFJBQ0UiLCJDT1BZIiwiTE9DSyIsIk1LQ09MIiwiTU9WRSIsIlBST1BGSU5EIiwiUFJPUFBBVENIIiwiU0VBUkNIIiwiVU5MT0NLIiwiQklORCIsIlJFQklORCIsIlVOQklORCIsIkFDTCIsIlJFUE9SVCIsIk1LQUNUSVZJVFkiLCJDSEVDS09VVCIsIk1FUkdFIiwiTk9USUZZIiwiU1VCU0NSSUJFIiwiVU5TVUJTQ1JJQkUiLCJQQVRDSCIsIlBVUkdFIiwiTUtDQUxFTkRBUiIsIkxJTksiLCJVTkxJTksiLCJTT1VSQ0UiLCJQUkkiLCJERVNDUklCRSIsIkFOTk9VTkNFIiwiU0VUVVAiLCJQTEFZIiwiUEFVU0UiLCJURUFSRE9XTiIsIkdFVF9QQVJBTUVURVIiLCJTRVRfUEFSQU1FVEVSIiwiUkVESVJFQ1QiLCJSRUNPUkQiLCJGTFVTSCIsIlNBRkUiLCJTQUZFX1dJVEhfQ0IiLCJVTlNBRkUiLCJmcm9tQ2hhckNvZGUiLCJCIiwiRCIsIkYiLCJiIiwiZCIsImNvbmNhdCIsImZpbHRlciIsIkdFTkVSQUwiLCJDT05ORUNUSU9OIiwiVFJBTlNGRVJfRU5DT0RJTkdfQ0hVTktFRCIsImNvbm5lY3Rpb24iLCJsbGh0dHBXYXNtIiwiaGFzUmVxdWlyZWRMbGh0dHBXYXNtIiwicmVxdWlyZUxsaHR0cFdhc20iLCJsbGh0dHBfc2ltZFdhc20iLCJoYXNSZXF1aXJlZExsaHR0cF9zaW1kV2FzbSIsInJlcXVpcmVMbGh0dHBfc2ltZFdhc20iLCJjb25zdGFudHMkMyIsImhhc1JlcXVpcmVkQ29uc3RhbnRzJDIiLCJyZXF1aXJlQ29uc3RhbnRzJDIiLCJTZXQiLCJzdWJyZXNvdXJjZSIsImZvcmJpZGRlbk1ldGhvZHMiLCJyZXF1ZXN0Qm9keUhlYWRlciIsInJlZmVycmVyUG9saWN5IiwicmVxdWVzdFJlZGlyZWN0IiwicmVxdWVzdE1vZGUiLCJyZXF1ZXN0Q3JlZGVudGlhbHMiLCJyZXF1ZXN0Q2FjaGUiLCJyZWRpcmVjdFN0YXR1cyIsImNvcnNTYWZlTGlzdGVkTWV0aG9kcyIsIm51bGxCb2R5U3RhdHVzIiwic2FmZU1ldGhvZHMiLCJiYWRQb3J0cyIsInJlcXVlc3REdXBsZXgiLCJzdWJyZXNvdXJjZVNldCIsImJhZFBvcnRzU2V0IiwicmVkaXJlY3RTdGF0dXNTZXQiLCJjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQiLCJzYWZlTWV0aG9kc1NldCIsImZvcmJpZGRlbk1ldGhvZHNTZXQiLCJyZWZlcnJlclBvbGljeVNldCIsImdsb2JhbCQxIiwiaGFzUmVxdWlyZWRHbG9iYWwiLCJyZXF1aXJlR2xvYmFsIiwiZ2xvYmFsVGhpcyIsImdldEdsb2JhbE9yaWdpbiIsInNldEdsb2JhbE9yaWdpbiIsImRhdGFVcmwiLCJoYXNSZXF1aXJlZERhdGFVcmwiLCJyZXF1aXJlRGF0YVVybCIsIlRleHRFbmNvZGVyIiwiZyIsInNsaWNlIiwicG9zaXRpb24iLCJOIiwidSIsIk0iLCJtIiwidiIsInJlcGxhY2UiLCJUIiwibWltZVR5cGUiLCJocmVmIiwiZW5jb2RlIiwic3ViYXJyYXkiLCJzdWJ0eXBlIiwicGFyYW1ldGVycyIsImVzc2VuY2UiLCJaIiwiZW50cmllcyIsImFwcGx5IiwiRyIsImRhdGFVUkxQcm9jZXNzb3IiLCJVUkxTZXJpYWxpemVyIiwiY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyIsImNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0Iiwic3RyaW5nUGVyY2VudERlY29kZSIsInBhcnNlTUlNRVR5cGUiLCJjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nIiwic2VyaWFsaXplQU1pbWVUeXBlIiwicmVtb3ZlQ2hhcnMiLCJtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlIiwiSFRUUF9UT0tFTl9DT0RFUE9JTlRTIiwiaXNvbW9ycGhpY0RlY29kZSIsIndlYmlkbF8xIiwiaGFzUmVxdWlyZWRXZWJpZGwiLCJyZXF1aXJlV2ViaWRsIiwidHlwZXMiLCJpbnNwZWN0IiwiY29udmVydGVycyIsInV0aWwiLCJlcnJvcnMiLCJleGNlcHRpb24iLCJoZWFkZXIiLCJjb252ZXJzaW9uRmFpbGVkIiwiYXJndW1lbnQiLCJwcmVmaXgiLCJpbnZhbGlkQXJndW1lbnQiLCJicmFuZENoZWNrIiwic3RyaWN0IiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImlsbGVnYWxDb25zdHJ1Y3RvciIsIlR5cGUiLCJDb252ZXJ0VG9JbnQiLCJNYXRoIiwicG93IiwiZW5mb3JjZVJhbmdlIiwiaXNOYU4iLCJQT1NJVElWRV9JTkZJTklUWSIsIk5FR0FUSVZFX0lORklOSVRZIiwiU3RyaW5naWZ5IiwiSW50ZWdlclBhcnQiLCJjbGFtcCIsIm1pbiIsIm1heCIsImZsb29yIiwiY2VpbCIsImlzIiwiYWJzIiwiZGVzY3JpcHRpb24iLCJzZXF1ZW5jZUNvbnZlcnRlciIsInJlY29yZENvbnZlcnRlciIsImlzUHJveHkiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiUmVmbGVjdCIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpbnRlcmZhY2VDb252ZXJ0ZXIiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwia2V5IiwiZGVmYXVsdFZhbHVlIiwicmVxdWlyZWQiLCJjb252ZXJ0ZXIiLCJoYXNPd24iLCJhbGxvd2VkVmFsdWVzIiwibnVsbGFibGVDb252ZXJ0ZXIiLCJET01TdHJpbmciLCJsZWdhY3lOdWxsVG9FbXB0eVN0cmluZyIsIkJ5dGVTdHJpbmciLCJVU1ZTdHJpbmciLCJib29sZWFuIiwiYW55IiwiaXNBbnlBcnJheUJ1ZmZlciIsImFsbG93U2hhcmVkIiwiaXNTaGFyZWRBcnJheUJ1ZmZlciIsInJlc2l6YWJsZSIsImdyb3dhYmxlIiwiVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsIkRhdGFWaWV3IiwiaXNEYXRhVmlldyIsIkJ1ZmZlclNvdXJjZSIsIndlYmlkbCIsInV0aWwkaiIsImhhc1JlcXVpcmVkVXRpbCQ1IiwicmVxdWlyZVV0aWwkNSIsIlRyYW5zZm9ybSIsInBlcmZvcm1hbmNlIiwiaXNVaW50OEFycmF5IiwieSIsImdldEhhc2hlcyIsIlkiLCJ1cmxMaXN0IiwiVyIsImhlYWRlcnNMaXN0IiwiWkEiLCJqIiwibkEiLCJSIiwiTyIsInRyaW0iLCJtb2RlIiwicmVzcG9uc2VUYWludGluZyIsImVlIiwieUEiLCJQIiwiQUEiLCJzdGFydFRpbWUiLCJkb21haW5Mb29rdXBTdGFydFRpbWUiLCJkb21haW5Mb29rdXBFbmRUaW1lIiwiY29ubmVjdGlvblN0YXJ0VGltZSIsImNvbm5lY3Rpb25FbmRUaW1lIiwic2VjdXJlQ29ubmVjdGlvblN0YXJ0VGltZSIsIkFMUE5OZWdvdGlhdGVkUHJvdG9jb2wiLCJLIiwidEEiLCJyZWRpcmVjdFN0YXJ0VGltZSIsInJlZGlyZWN0RW5kVGltZSIsInBvc3RSZWRpcmVjdFN0YXJ0VGltZSIsImZpbmFsU2VydmljZVdvcmtlclN0YXJ0VGltZSIsImZpbmFsTmV0d29ya1Jlc3BvbnNlU3RhcnRUaW1lIiwiZmluYWxOZXR3b3JrUmVxdWVzdFN0YXJ0VGltZSIsImVuZFRpbWUiLCJlbmNvZGVkQm9keVNpemUiLCJkZWNvZGVkQm9keVNpemUiLCJmaW5hbENvbm5lY3Rpb25UaW1pbmdJbmZvIiwiYUEiLCJYIiwiJCIsInJlZmVycmVyIiwiSCIsIlYiLCJxIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInoiLCJpQSIsImdBIiwiQkEiLCJhbGdvIiwiSiIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJkaWdlc3QiLCJzQSIsInJBIiwiZ3JvdXBzIiwiZUEiLCJXQSIsInByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwid0EiLCJjb250cm9sbGVyIiwicUEiLCJNQSIsImhlYWQiLCJvcHRpb25zIiwicG9zdCIsInB1dCIsIkhBIiwicGF0Y2giLCJwQSIsIllBIiwiVUEiLCJKQSIsIngiLCJRQSIsImxBIiwidUEiLCJjQSIsImZBIiwiZGVmaW5lUHJvcGVydGllcyIsIl8iLCJWQSIsInZhbHVlcyIsImFyZ3VtZW50cyIsIk9BIiwiZ2V0UmVhZGVyIiwiUEEiLCJJQSIsInRlZSIsImhBIiwiU0EiLCJyZWFkIiwiUGUiLCJYQSIsInJhbmdlU3RhcnRWYWx1ZSIsInJhbmdlRW5kVmFsdWUiLCJaZSIsInZBIiwiX3RyYW5zZm9ybSIsIl9pbmZsYXRlU3RyZWFtIiwiY3JlYXRlSW5mbGF0ZSIsImNyZWF0ZUluZmxhdGVSYXciLCJ3cml0ZSIsIl9maW5hbCIsIktBIiwiSGUiLCJ0ZSIsInJlIiwiVmUiLCJ2ZSIsIlRleHREZWNvZGVyIiwiWGUiLCJkZWNvZGUiLCJpc0Fib3J0ZWQiLCJpc0NhbmNlbGxlZCIsImNyZWF0ZURlZmVycmVkUHJvbWlzZSIsInRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCIsImNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvIiwiY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUiLCJkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIiwibWFrZVBvbGljeUNvbnRhaW5lciIsImNsb25lUG9saWN5Q29udGFpbmVyIiwiYXBwZW5kRmV0Y2hNZXRhZGF0YSIsImFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIiLCJUQU9DaGVjayIsImNvcnNDaGVjayIsImNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayIsImNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8iLCJzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0IiwicmVxdWVzdEJhZFBvcnQiLCJyZXF1ZXN0Q3VycmVudFVSTCIsInJlc3BvbnNlVVJMIiwicmVzcG9uc2VMb2NhdGlvblVSTCIsImlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeSIsImlzVmFsaWRSZWFzb25QaHJhc2UiLCJzYW1lT3JpZ2luIiwibm9ybWFsaXplTWV0aG9kIiwic2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nIiwiaXRlcmF0b3JNaXhpbiIsImNyZWF0ZUl0ZXJhdG9yIiwiaXNWYWxpZEhlYWRlck5hbWUiLCJpc1ZhbGlkSGVhZGVyVmFsdWUiLCJpc0Vycm9yTGlrZSIsImZ1bGx5UmVhZEJvZHkiLCJieXRlc01hdGNoIiwiaXNSZWFkYWJsZVN0cmVhbUxpa2UiLCJyZWFkYWJsZVN0cmVhbUNsb3NlIiwiaXNvbW9ycGhpY0VuY29kZSIsInVybElzTG9jYWwiLCJ1cmxIYXNIdHRwc1NjaGVtZSIsInVybElzSHR0cEh0dHBzU2NoZW1lIiwicmVhZEFsbEJ5dGVzIiwibm9ybWFsaXplTWV0aG9kUmVjb3JkIiwic2ltcGxlUmFuZ2VIZWFkZXJWYWx1ZSIsImJ1aWxkQ29udGVudFJhbmdlIiwicGFyc2VNZXRhZGF0YSIsImV4dHJhY3RNaW1lVHlwZSIsImdldERlY29kZVNwbGl0IiwidXRmOERlY29kZUJ5dGVzIiwic3ltYm9scyQzIiwiaGFzUmVxdWlyZWRTeW1ib2xzJDMiLCJyZXF1aXJlU3ltYm9scyQzIiwia0hlYWRlcnMiLCJrU2lnbmFsIiwia1N0YXRlIiwia0d1YXJkIiwia1JlYWxtIiwia0Rpc3BhdGNoZXIiLCJmaWxlIiwiaGFzUmVxdWlyZWRGaWxlIiwicmVxdWlyZUZpbGUiLCJFT0wiLCJGaWxlIiwiRmlsZVByb3BlcnR5QmFnIiwibGFzdE1vZGlmaWVkIiwiYmxvYkxpa2UiLCJ0ZXh0IiwiQmxvYlBhcnQiLCJlbmRpbmdzIiwiaXNBcnJheUJ1ZmZlciIsIkZpbGVMaWtlIiwiaXNGaWxlTGlrZSIsImZvcm1kYXRhIiwiaGFzUmVxdWlyZWRGb3JtZGF0YSIsInJlcXVpcmVGb3JtZGF0YSIsImZpbmRJbmRleCIsImN1c3RvbSIsInJlZHVjZSIsIl9fcHJvdG9fXyIsImRlcHRoIiwiY29sb3JzIiwiZm9ybWF0V2l0aE9wdGlvbnMiLCJGb3JtRGF0YSIsIm1ha2VFbnRyeSIsImZvcm1kYXRhUGFyc2VyIiwiaGFzUmVxdWlyZWRGb3JtZGF0YVBhcnNlciIsInJlcXVpcmVGb3JtZGF0YVBhcnNlciIsImlzRW5jb2RpbmciLCJlcXVhbHMiLCJmaWxlbmFtZSIsImVuY29kaW5nIiwibXVsdGlwYXJ0Rm9ybURhdGFQYXJzZXIiLCJ2YWxpZGF0ZUJvdW5kYXJ5IiwiZXNjYXBlRm9ybURhdGFOYW1lIiwiaGFzUmVxdWlyZWRCb2R5IiwicmVxdWlyZUJvZHkiLCJVUkxTZWFyY2hQYXJhbXMiLCJyYW5kb20iLCJwYWRTdGFydCIsImxvY2tlZCIsInNvdXJjZSIsIkRPTUV4Y2VwdGlvbiIsImJsb2IiLCJqc29uIiwiZm9ybURhdGEiLCJhc3NpZ24iLCJleHRyYWN0Qm9keSIsInNhZmVseUV4dHJhY3RCb2R5IiwiY2xvbmVCb2R5IiwibWl4aW5Cb2R5IiwiYXNzZXJ0JGEiLCJ1dGlsJGkiLCJjaGFubmVscyQxIiwidGltZXJzIiwiUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJDEiLCJSZXF1ZXN0QWJvcnRlZEVycm9yJDUiLCJTb2NrZXRFcnJvciQzIiwiSW5mb3JtYXRpb25hbEVycm9yJDIiLCJrVXJsJDQiLCJrUmVzZXQkMSIsImtDbGllbnQkMyIsImtSdW5uaW5nJDUiLCJrUGVuZGluZyQ0Iiwia1NpemUkNCIsImtRdWV1ZSQzIiwia0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0JDEiLCJrSG9zdEhlYWRlciQxIiwia1BlbmRpbmdJZHgkMiIsImtSdW5uaW5nSWR4JDIiLCJrRXJyb3IkMiIsImtQaXBlbGluaW5nJDEiLCJrU29ja2V0JDEiLCJrS2VlcEFsaXZlVGltZW91dFZhbHVlJDEiLCJrTWF4SGVhZGVyc1NpemUkMSIsImtLZWVwQWxpdmVNYXhUaW1lb3V0JDEiLCJrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCQxIiwia0hlYWRlcnNUaW1lb3V0JDEiLCJrQm9keVRpbWVvdXQkMSIsImtTdHJpY3RDb250ZW50TGVuZ3RoJDIiLCJrTWF4UmVxdWVzdHMkMSIsImtDb3VudGVyJDEiLCJrTWF4UmVzcG9uc2VTaXplJDEiLCJrT25FcnJvciQyIiwia1Jlc3VtZSQzIiwia0hUVFBDb250ZXh0JDEiLCJjb25zdGFudHMkMiIsIkVNUFRZX0JVRiIsImFsbG9jIiwiRmFzdEJ1ZmZlciIsInNwZWNpZXMiLCJsYXp5bGxodHRwIiwiSkVTVF9XT1JLRVJfSUQiLCJXZWJBc3NlbWJseSIsImNvbXBpbGUiLCJpbnN0YW50aWF0ZSIsIndhc21fb25fdXJsIiwid2FzbV9vbl9zdGF0dXMiLCJjdXJyZW50UGFyc2VyIiwicHRyIiwiY3VycmVudEJ1ZmZlclB0ciIsImN1cnJlbnRCdWZmZXJSZWYiLCJvblN0YXR1cyIsIndhc21fb25fbWVzc2FnZV9iZWdpbiIsIm9uTWVzc2FnZUJlZ2luIiwid2FzbV9vbl9oZWFkZXJfZmllbGQiLCJvbkhlYWRlckZpZWxkIiwid2FzbV9vbl9oZWFkZXJfdmFsdWUiLCJvbkhlYWRlclZhbHVlIiwid2FzbV9vbl9oZWFkZXJzX2NvbXBsZXRlIiwib25IZWFkZXJzQ29tcGxldGUiLCJ3YXNtX29uX2JvZHkiLCJvbkJvZHkiLCJ3YXNtX29uX21lc3NhZ2VfY29tcGxldGUiLCJvbk1lc3NhZ2VDb21wbGV0ZSIsImxsaHR0cEluc3RhbmNlIiwibGxodHRwUHJvbWlzZSIsImNhdGNoIiwiY3VycmVudEJ1ZmZlclNpemUiLCJUSU1FT1VUX0hFQURFUlMiLCJUSU1FT1VUX0JPRFkiLCJUSU1FT1VUX0lETEUiLCJzdCIsImV4cG9ydHMiLCJsbGh0dHAiLCJsbGh0dHBfYWxsb2MiLCJjbGllbnQiLCJ0aW1lb3V0VmFsdWUiLCJ0aW1lb3V0VHlwZSIsImhlYWRlcnNTaXplIiwiaGVhZGVyc01heFNpemUiLCJzaG91bGRLZWVwQWxpdmUiLCJwYXVzZWQiLCJyZXN1bWUiLCJtYXhSZXNwb25zZVNpemUiLCJvblBhcnNlclRpbWVvdXQiLCJsbGh0dHBfcmVzdW1lIiwiZXhlY3V0ZSIsInJlYWRNb3JlIiwiZnJlZSIsIm1hbGxvYyIsIm1lbW9yeSIsImxsaHR0cF9leGVjdXRlIiwibGxodHRwX2dldF9lcnJvcl9wb3MiLCJ1bnNoaWZ0IiwibGxodHRwX2dldF9lcnJvcl9yZWFzb24iLCJsbGh0dHBfZnJlZSIsInRyYWNrSGVhZGVyIiwiUGFyc2VyIiwid3JpdGFibGVOZWVkRHJhaW4iLCJjb25uZWN0SDEkMSIsInNwbGljZSIsImRlZmF1bHRQaXBlbGluaW5nIiwid3JpdGVIMSIsInJlc3VtZUgxIiwiYnVzeSIsInJlZiIsInNob3VsZFNlbmRDb250ZW50TGVuZ3RoJDEiLCJlbWl0V2FybmluZyIsIndyaXRlQnVmZmVyIiwiZXhwZWN0c1BheWxvYWQiLCJ3cml0ZUl0ZXJhYmxlJDEiLCJ3cml0ZUJsb2IkMSIsIndyaXRlU3RyZWFtJDEiLCJBc3luY1dyaXRlciIsInBhdXNlIiwiZXJyb3JFbWl0dGVkIiwiZXJyb3JlZCIsInJlYWRhYmxlRW5kZWQiLCJjbG9zZUVtaXR0ZWQiLCJjb3JrIiwidW5jb3JrIiwib3QiLCJjbGllbnRIMSIsImFzc2VydCQ5IiwicGlwZWxpbmUiLCJwaXBlbGluZSQxIiwidXRpbCRoIiwiUmVxdWVzdEFib3J0ZWRFcnJvciQ0IiwiU29ja2V0RXJyb3IkMiIsIkluZm9ybWF0aW9uYWxFcnJvciQxIiwia1VybCQzIiwia0NsaWVudCQyIiwia1J1bm5pbmckNCIsImtQZW5kaW5nJDMiLCJrUXVldWUkMiIsImtQZW5kaW5nSWR4JDEiLCJrUnVubmluZ0lkeCQxIiwia0Vycm9yJDEiLCJrU3RyaWN0Q29udGVudExlbmd0aCQxIiwia09uRXJyb3IkMSIsImtNYXhDb25jdXJyZW50U3RyZWFtcyQxIiwia1Jlc3VtZSQyIiwia09wZW5TdHJlYW1zIiwiaDJFeHBlcmltZW50YWxXYXJuZWQiLCJodHRwMiIsImNvbnN0YW50cyIsIkhUVFAyX0hFQURFUl9BVVRIT1JJVFkiLCJIVFRQMl9IRUFERVJfTUVUSE9EIiwiSFRUUDJfSEVBREVSX1BBVEgiLCJIVFRQMl9IRUFERVJfU0NIRU1FIiwiSFRUUDJfSEVBREVSX0NPTlRFTlRfTEVOR1RIIiwiSFRUUDJfSEVBREVSX0VYUEVDVCIsIkhUVFAyX0hFQURFUl9TVEFUVVMiLCJwYXJzZUgySGVhZGVycyIsImNvbm5lY3RIMiQxIiwiY3JlYXRlQ29ubmVjdGlvbiIsInBlZXJNYXhDb25jdXJyZW50U3RyZWFtcyIsIm9uSHR0cDJTZXNzaW9uRXJyb3IiLCJvbkh0dHAyRnJhbWVFcnJvciIsIm9uSHR0cDJTZXNzaW9uRW5kIiwib25IVFRQMkdvQXdheSIsIndyaXRlSDIiLCJzaG91bGRTZW5kQ29udGVudExlbmd0aCIsInNpZ25hbCIsImVuZFN0cmVhbSIsImlkIiwicGVuZGluZyIsIndyaXRlSXRlcmFibGUiLCJoMnN0cmVhbSIsIndyaXRlQmxvYiIsIndyaXRlU3RyZWFtIiwiY2xpZW50SDIiLCJ1dGlsJGciLCJhc3NlcnQkOCIsIkludmFsaWRBcmd1bWVudEVycm9yJGYiLCJFRSIsInJlZGlyZWN0YWJsZVN0YXR1c0NvZGVzIiwia0JvZHkkMSIsIml0IiwiQm9keUFzeW5jSXRlcmFibGUiLCJSZWRpcmVjdEhhbmRsZXIkMSIsImxvY2F0aW9uIiwib3B0cyIsIm1heFJlZGlyZWN0aW9ucyIsImhhbmRsZXIiLCJoaXN0b3J5IiwicmVkaXJlY3Rpb25MaW1pdFJlYWNoZWQiLCJyZWFkYWJsZURpZFJlYWQiLCJwaXBlVG8iLCJwYXJzZUxvY2F0aW9uIiwidGhyb3dPbk1heFJlZGlyZWN0IiwiY2xlYW5SZXF1ZXN0SGVhZGVycyIsInNob3VsZFJlbW92ZUhlYWRlciIsInJlZGlyZWN0SGFuZGxlciIsIlJlZGlyZWN0SGFuZGxlciIsImNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IkMiIsInJlZGlyZWN0SW50ZXJjZXB0b3IiLCJhc3NlcnQkNyIsIm5ldCIsImh0dHAiLCJ1dGlsJGYiLCJSZXF1ZXN0IiwiRGlzcGF0Y2hlckJhc2UkMyIsIkludmFsaWRBcmd1bWVudEVycm9yJGUiLCJidWlsZENvbm5lY3RvciQyIiwia1VybCQyIiwia0NsaWVudCQxIiwia0J1c3kkMSIsImtSdW5uaW5nJDMiLCJrUGVuZGluZyQyIiwia1NpemUkMyIsImtRdWV1ZSQxIiwia0Nvbm5lY3RlZCQ0Iiwia05lZWREcmFpbiQyIiwia01heFJlZGlyZWN0aW9ucyQxIiwia0Nsb3NlJDUiLCJrRGVzdHJveSQzIiwia0Rpc3BhdGNoJDIiLCJrSW50ZXJjZXB0b3JzJDMiLCJrUmVzdW1lJDEiLCJjb25uZWN0SDEiLCJjb25uZWN0SDIiLCJkZXByZWNhdGVkSW50ZXJjZXB0b3JXYXJuZWQiLCJrQ2xvc2VkUmVzb2x2ZSQxIiwiZ2V0UGlwZWxpbmluZyIsIkNsaWVudCQzIiwibWF4SGVhZGVyU2l6ZSIsInNvY2tldFRpbWVvdXQiLCJyZXF1ZXN0VGltZW91dCIsImNvbm5lY3RUaW1lb3V0IiwiaWRsZVRpbWVvdXQiLCJrZWVwQWxpdmVUaW1lb3V0IiwibWF4S2VlcEFsaXZlVGltZW91dCIsImtlZXBBbGl2ZU1heFRpbWVvdXQiLCJrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkIiwicGlwZWxpbmluZyIsInN0cmljdENvbnRlbnRMZW5ndGgiLCJtYXhSZXF1ZXN0c1BlckNsaWVudCIsImF1dG9TZWxlY3RGYW1pbHkiLCJhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQiLCJtYXhDb25jdXJyZW50U3RyZWFtcyIsIkNsaWVudCIsImNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IkMSIsImNvbm5lY3QkMSIsImNvbm5lY3RvciIsImFscG5Qcm90b2NvbCIsImVtaXREcmFpbiIsIl9yZXN1bWUiLCJrU2l6ZSQyIiwia01hc2siLCJRdCIsImJvdHRvbSIsInRvcCIsImxpc3QiLCJpc0VtcHR5IiwiaXNGdWxsIiwic2hpZnQiLCJGaXhlZENpcmN1bGFyQnVmZmVyIiwiZml4ZWRRdWV1ZSIsInRhaWwiLCJrRnJlZSQxIiwia0Nvbm5lY3RlZCQzIiwia1BlbmRpbmckMSIsImtRdWV1ZWQkMSIsImtSdW5uaW5nJDIiLCJrU2l6ZSQxIiwia1Bvb2wiLCJQb29sU3RhdHMkMSIsInF1ZXVlZCIsInJ1bm5pbmciLCJwb29sU3RhdHMiLCJEaXNwYXRjaGVyQmFzZSQyIiwiRml4ZWRRdWV1ZSIsImtDb25uZWN0ZWQkMiIsImtSdW5uaW5nJDEiLCJrVXJsJDEiLCJrQ2xvc2UkNCIsImtEZXN0cm95JDIiLCJrRGlzcGF0Y2gkMSIsIlBvb2xTdGF0cyIsImtDbGllbnRzJDIiLCJrTmVlZERyYWluJDEiLCJrQ2xvc2VkUmVzb2x2ZSIsImtPbkRyYWluJDEiLCJrT25Db25uZWN0JDEiLCJrT25EaXNjb25uZWN0JDEiLCJrT25Db25uZWN0aW9uRXJyb3IkMSIsImtHZXREaXNwYXRjaGVyJDEiLCJrQWRkQ2xpZW50JDEiLCJrUmVtb3ZlQ2xpZW50Iiwia1N0YXRzIiwiUG9vbEJhc2UkMSIsImFsbCIsInN0YXRzIiwic29tZSIsInBvb2xCYXNlIiwiUG9vbEJhc2UiLCJrQWRkQ2xpZW50Iiwia0dldERpc3BhdGNoZXIiLCJrQ2xpZW50cyQxIiwiQ2xpZW50JDIiLCJJbnZhbGlkQXJndW1lbnRFcnJvciRkIiwidXRpbCRlIiwia0ludGVyY2VwdG9ycyQyIiwiYnVpbGRDb25uZWN0b3IkMSIsImtPcHRpb25zJDEiLCJrQ29ubmVjdGlvbnMiLCJrRmFjdG9yeSQxIiwiZGVmYXVsdEZhY3RvcnkkMiIsIlBvb2wkMyIsImNvbm5lY3Rpb25zIiwiZmFjdG9yeSIsIlBvb2wiLCJwb29sIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IkYyIsImtDbG9zZSQzIiwia0Rlc3Ryb3kkMSIsImtJbnRlcmNlcHRvcnMkMSIsIkRpc3BhdGNoZXJCYXNlJDEiLCJQb29sJDIiLCJDbGllbnQkMSIsInV0aWwkZCIsImNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IiLCJrT25Db25uZWN0Iiwia09uRGlzY29ubmVjdCIsImtPbkNvbm5lY3Rpb25FcnJvciIsImtPbkRyYWluIiwia0ZhY3RvcnkiLCJrT3B0aW9ucyIsImRlZmF1bHRGYWN0b3J5JDEiLCJBZ2VudCQzIiwiQWdlbnQiLCJhZ2VudCIsImtDbG9zZSQyIiwiVVJMJDEiLCJBZ2VudCQyIiwiUG9vbCQxIiwiRGlzcGF0Y2hlckJhc2UiLCJJbnZhbGlkQXJndW1lbnRFcnJvciRiIiwiUmVxdWVzdEFib3J0ZWRFcnJvciQzIiwiYnVpbGRDb25uZWN0b3IiLCJrQWdlbnQiLCJrUHJveHlIZWFkZXJzIiwia1JlcXVlc3RUbHMiLCJrUHJveHlUbHMiLCJrQ29ubmVjdEVuZHBvaW50IiwiZGVmYXVsdFByb3RvY29sUG9ydCIsImRlZmF1bHRGYWN0b3J5IiwiUHJveHlBZ2VudCQxIiwidXJpIiwiY2xpZW50RmFjdG9yeSIsIlByb3h5QWdlbnQiLCJyZXF1ZXN0VGxzIiwicHJveHlUbHMiLCJhdXRoIiwidG9rZW4iLCJkZWNvZGVVUklDb21wb25lbnQiLCJidWlsZEhlYWRlcnMiLCJ0aHJvd0lmUHJveHlBdXRoSXNTZW50IiwiZmluZCIsInByb3h5QWdlbnQiLCJhcGkkMSIsImFwaVJlcXVlc3QiLCJhc3NlcnQkNiIsIlJlYWRhYmxlIiwiUmVhZGFibGUkMiIsIlJlcXVlc3RBYm9ydGVkRXJyb3IkMiIsIkludmFsaWRBcmd1bWVudEVycm9yJGEiLCJ1dGlsJGMiLCJrQ29uc3VtZSIsImtSZWFkaW5nIiwia0JvZHkiLCJrQWJvcnQiLCJrQ29udGVudFR5cGUiLCJrQ29udGVudExlbmd0aCQxIiwibm9vcCIsIkV0IiwiZGF0YUVtaXR0ZWQiLCJfZGVzdHJveSIsImxpc3RlbmVyQ291bnQiLCJjb25zdW1lUHVzaCIsImNvbnN1bWUiLCJib2R5VXNlZCIsImR1bXAiLCJsaW1pdCIsInRocm93SWZBYm9ydGVkIiwiQm9keVJlYWRhYmxlIiwiaXNMb2NrZWQiLCJpc1VudXNhYmxlIiwiY29uc3VtZUZpbmlzaCIsImNvbnN1bWVTdGFydCIsImJ1ZmZlckluZGV4IiwiY29uc3VtZUVuZCIsImNodW5rc0RlY29kZSQxIiwidXRmOFNsaWNlIiwicmVhZGFibGUiLCJjaHVua3NEZWNvZGUiLCJhc3NlcnQkNSIsIkNIVU5LX0xJTUlUIiwiZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrJDIiLCJzdGF0dXNNZXNzYWdlIiwic3RhY2tUcmFjZUxpbWl0IiwiaXNDb250ZW50VHlwZUFwcGxpY2F0aW9uSnNvbiIsImlzQ29udGVudFR5cGVUZXh0IiwidXRpbCRiIiwiZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrIiwiUmVxdWVzdEFib3J0ZWRFcnJvciQxIiwia0xpc3RlbmVyIiwicmVtb3ZlU2lnbmFsJDUiLCJhZGRTaWduYWwkNSIsImFib3J0U2lnbmFsIiwiYWRkU2lnbmFsIiwicmVtb3ZlU2lnbmFsIiwiYXNzZXJ0JDQiLCJSZWFkYWJsZSQxIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IkOSIsInV0aWwkYSIsImdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayQxIiwiQXN5bmNSZXNvdXJjZSIsIkFzeW5jUmVzb3VyY2UkNCIsImFkZFNpZ25hbCQ0IiwicmVtb3ZlU2lnbmFsJDQiLCJndCIsIm9uSW5mbyIsInJlc3BvbnNlSGVhZGVycyIsInJlcyIsImNvbnRleHQiLCJydW5JbkFzeW5jU2NvcGUiLCJSZXF1ZXN0SGFuZGxlciIsInJlcXVlc3QkMSIsImFwaVJlcXVlc3RFeHBvcnRzIiwiYXNzZXJ0JDMiLCJmaW5pc2hlZCIsIlBhc3NUaHJvdWdoIiwiUGFzc1Rocm91Z2gkMSIsIkludmFsaWRBcmd1bWVudEVycm9yJDgiLCJJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciQxIiwidXRpbCQ5IiwiQXN5bmNSZXNvdXJjZSQzIiwiYWRkU2lnbmFsJDMiLCJyZW1vdmVTaWduYWwkMyIsIkJ0IiwiX3dyaXRhYmxlU3RhdGUiLCJuZWVkRHJhaW4iLCJTdHJlYW1IYW5kbGVyIiwiYXBpU3RyZWFtIiwiRHVwbGV4IiwiSW52YWxpZEFyZ3VtZW50RXJyb3IkNyIsInV0aWwkOCIsIkFzeW5jUmVzb3VyY2UkMiIsImFkZFNpZ25hbCQyIiwicmVtb3ZlU2lnbmFsJDIiLCJhc3NlcnQkMiIsIkN0IiwiX3JlYWQiLCJQaXBlbGluZVJlcXVlc3QiLCJJdCIsIlBpcGVsaW5lUmVzcG9uc2UiLCJhdCIsInJlcSIsInJldCIsInJlYWRhYmxlT2JqZWN0TW9kZSIsIlBpcGVsaW5lSGFuZGxlciIsImFwaVBpcGVsaW5lIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IkNiIsIlNvY2tldEVycm9yJDEiLCJBc3luY1Jlc291cmNlJDEiLCJ1dGlsJDciLCJhZGRTaWduYWwkMSIsInJlbW92ZVNpZ25hbCQxIiwiYXNzZXJ0JDEiLCJjdCIsIlVwZ3JhZGVIYW5kbGVyIiwiYXBpVXBncmFkZSIsImFzc2VydCIsIkludmFsaWRBcmd1bWVudEVycm9yJDUiLCJ1dGlsJDYiLCJodCIsIkNvbm5lY3RIYW5kbGVyIiwiYXBpQ29ubmVjdCIsIk1vY2tOb3RNYXRjaGVkRXJyb3IkMSIsImNhcHR1cmVTdGFja1RyYWNlIiwibW9ja0Vycm9ycyIsIk1vY2tOb3RNYXRjaGVkRXJyb3IiLCJtb2NrU3ltYm9scyIsImtEaXNwYXRjaGVzIiwia0Rpc3BhdGNoS2V5Iiwia0RlZmF1bHRIZWFkZXJzIiwia0RlZmF1bHRUcmFpbGVycyIsImtDb250ZW50TGVuZ3RoIiwia01vY2tBZ2VudCIsImtNb2NrQWdlbnRTZXQiLCJrTW9ja0FnZW50R2V0Iiwia01vY2tEaXNwYXRjaCIsImtPcmlnaW5hbENsb3NlIiwia09yaWdpbiIsImtJc01vY2tBY3RpdmUiLCJrTmV0Q29ubmVjdCIsImtHZXROZXRDb25uZWN0Iiwia0Rpc3BhdGNoZXMkMyIsImtNb2NrQWdlbnQkMiIsImtPcmlnaW5hbERpc3BhdGNoIiwia09yaWdpbmFsRGlzcGF0Y2gkMiIsImtPcmlnaW4kMiIsImJ1aWxkVVJMJDEiLCJTVEFUVVNfQ09ERVMiLCJpc1Byb21pc2UiLCJtYXRjaFZhbHVlIiwiUmVnRXhwIiwibG93ZXJDYXNlRW50cmllcyIsImZyb21FbnRyaWVzIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJnZXRIZWFkZXJCeU5hbWUiLCJidWlsZEhlYWRlcnNGcm9tQXJyYXkiLCJtYXRjaEhlYWRlcnMiLCJzYWZlVXJsIiwic29ydCIsIm1hdGNoS2V5IiwiZ2V0UmVzcG9uc2VEYXRhJDEiLCJnZXRNb2NrRGlzcGF0Y2giLCJjb25zdW1lZCIsImFkZE1vY2tEaXNwYXRjaCQxIiwidGltZXNJbnZva2VkIiwidGltZXMiLCJwZXJzaXN0IiwiZGVsZXRlTW9ja0Rpc3BhdGNoIiwiYnVpbGRLZXkkMSIsImdlbmVyYXRlS2V5VmFsdWVzIiwiZ2V0U3RhdHVzVGV4dCIsImdldFJlc3BvbnNlIiwibW9ja0Rpc3BhdGNoIiwiYnVpbGRNb2NrRGlzcGF0Y2gkMiIsImlzTW9ja0FjdGl2ZSIsImNoZWNrTmV0Q29ubmVjdCIsImJ1aWxkTW9ja09wdGlvbnMiLCJtb2NrVXRpbHMiLCJnZXRSZXNwb25zZURhdGEiLCJhZGRNb2NrRGlzcGF0Y2giLCJidWlsZEtleSIsImJ1aWxkTW9ja0Rpc3BhdGNoIiwibW9ja0ludGVyY2VwdG9yIiwia0Rpc3BhdGNoZXMkMiIsIkludmFsaWRBcmd1bWVudEVycm9yJDQiLCJsdCIsIk1vY2tTY29wZSIsIk1vY2tJbnRlcmNlcHRvciQyIiwidG9VcHBlckNhc2UiLCJjcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEiLCJyZXNwb25zZU9wdGlvbnMiLCJ2YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyIsInJlcGx5IiwicmVwbHlXaXRoRXJyb3IiLCJkZWZhdWx0UmVwbHlIZWFkZXJzIiwiZGVmYXVsdFJlcGx5VHJhaWxlcnMiLCJyZXBseUNvbnRlbnRMZW5ndGgiLCJNb2NrSW50ZXJjZXB0b3IiLCJwcm9taXNpZnkiLCJwcm9taXNpZnkkMSIsImJ1aWxkTW9ja0Rpc3BhdGNoJDEiLCJrRGlzcGF0Y2hlcyQxIiwia01vY2tBZ2VudCQxIiwia0Nsb3NlJDEiLCJrT3JpZ2luYWxDbG9zZSQxIiwia09yaWdpbiQxIiwia09yaWdpbmFsRGlzcGF0Y2gkMSIsImtDb25uZWN0ZWQkMSIsIk1vY2tJbnRlcmNlcHRvciQxIiwiU3ltYm9scyQxIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IkMyIsInV0IiwiaW50ZXJjZXB0IiwiTW9ja0NsaWVudCIsIlN5bWJvbHMiLCJJbnZhbGlkQXJndW1lbnRFcnJvciQyIiwiZHQiLCJNb2NrUG9vbCIsImljdSIsImdsb2JhbERpc3BhdGNoZXIiLCJJbnZhbGlkQXJndW1lbnRFcnJvciQxIiwiQWdlbnQkMSIsImdldEdsb2JhbERpc3BhdGNoZXIkMSIsInNldEdsb2JhbERpc3BhdGNoZXIkMSIsImdsb2JhbCIsInNldEdsb2JhbERpc3BhdGNoZXIiLCJnZXRHbG9iYWxEaXNwYXRjaGVyIiwiaGFzUmVxdWlyZWRIZWFkZXJzIiwicmVxdWlyZUhlYWRlcnMiLCJjb29raWVzIiwiY29udGFpbnMiLCJ0b1NvcnRlZEFycmF5IiwiSGVhZGVyc0luaXQiLCJnZXRTZXRDb29raWUiLCJmaWxsIiwiY29tcGFyZUhlYWRlck5hbWUiLCJIZWFkZXJzIiwiSGVhZGVyc0xpc3QiLCJoYXNSZXF1aXJlZFJlc3BvbnNlIiwicmVxdWlyZVJlc3BvbnNlIiwic2V0dGluZ3NPYmplY3QiLCJSZXNwb25zZUluaXQiLCJyZWRpcmVjdCIsIlJhbmdlRXJyb3IiLCJCb2R5SW5pdCIsInJlZGlyZWN0ZWQiLCJvayIsImNsb25lIiwiaW50ZXJuYWxSZXNwb25zZSIsInJhbmdlUmVxdWVzdGVkIiwidGltaW5nQWxsb3dQYXNzZWQiLCJyZXF1ZXN0SW5jbHVkZXNDcmVkZW50aWFscyIsInRpbWluZ0luZm8iLCJjYWNoZVN0YXRlIiwiUHJveHkiLCJmcmVlemUiLCJYTUxIdHRwUmVxdWVzdEJvZHlJbml0IiwiaXNOZXR3b3JrRXJyb3IiLCJtYWtlTmV0d29ya0Vycm9yIiwibWFrZVJlc3BvbnNlIiwibWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yIiwiZmlsdGVyUmVzcG9uc2UiLCJSZXNwb25zZSIsImNsb25lUmVzcG9uc2UiLCJmcm9tSW5uZXJSZXNwb25zZSIsImRpc3BhdGNoZXJXZWFrcmVmIiwiaGFzUmVxdWlyZWREaXNwYXRjaGVyV2Vha3JlZiIsInJlcXVpcmVEaXNwYXRjaGVyV2Vha3JlZiIsImZpbmFsaXplciIsInVucmVnaXN0ZXIiLCJoYXNSZXF1aXJlZFJlcXVlc3QiLCJyZXF1aXJlUmVxdWVzdCIsImdldE1heExpc3RlbmVycyIsInNldE1heExpc3RlbmVycyIsImdldEV2ZW50TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsIlJlcXVlc3RJbmZvIiwiUmVxdWVzdEluaXQiLCJiYXNlVXJsIiwicG9saWN5Q29udGFpbmVyIiwid2luZG93IiwidW5zYWZlUmVxdWVzdCIsInByaW9yaXR5IiwiY3JlZGVudGlhbHMiLCJjYWNoZSIsImludGVncml0eSIsImtlZXBhbGl2ZSIsInJlbG9hZE5hdmlnYXRpb24iLCJoaXN0b3J5TmF2aWdhdGlvbiIsIkFib3J0Q29udHJvbGxlciIsImR1cGxleCIsInVzZUNPUlNQcmVmbGlnaHRGbGFnIiwiVHJhbnNmb3JtU3RyZWFtIiwicGlwZVRocm91Z2giLCJkZXN0aW5hdGlvbiIsImlzUmVsb2FkTmF2aWdhdGlvbiIsImlzSGlzdG9yeU5hdmlnYXRpb24iLCJsb2NhbFVSTHNPbmx5IiwicmVzZXJ2ZWRDbGllbnQiLCJyZXBsYWNlc0NsaWVudElkIiwic2VydmljZVdvcmtlcnMiLCJpbml0aWF0b3IiLCJ1c2VDcmVkZW50aWFscyIsImNyeXB0b0dyYXBoaWNzTm9uY2VNZXRhZGF0YSIsInBhcnNlck1ldGFkYXRhIiwidXNlckFjdGl2YXRpb24iLCJ0YWludGVkT3JpZ2luIiwicmVkaXJlY3RDb3VudCIsInByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uIiwidGltaW5nQWxsb3dGYWlsZWQiLCJhdHRyaWJ1dGUiLCJBYm9ydFNpZ25hbCIsIm1ha2VSZXF1ZXN0IiwiZnJvbUlubmVyUmVxdWVzdCIsImNsb25lUmVxdWVzdCIsImZldGNoXzEiLCJoYXNSZXF1aXJlZEZldGNoIiwicmVxdWlyZUZldGNoIiwiX19VTkRJQ0lfSVNfTk9ERV9fIiwiZXNidWlsZERldGVjdGlvbiIsInRlcm1pbmF0ZSIsInNlcmlhbGl6ZWRBYm9ydFJlYXNvbiIsIm9BIiwiZ2xvYmFsT2JqZWN0IiwicHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IiwicHJvY2Vzc1Jlc3BvbnNlIiwibWFya1Jlc291cmNlVGltaW5nIiwicHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgiLCJwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSIsInByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5IiwidXNlUGFyYWxsZWxRdWV1ZSIsImNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5IiwibUEiLCJ0YXNrRGVzdGluYXRpb24iLCJSQSIsInJlc29sdmVPYmplY3RVUkwiLCJiQSIsImRBIiwiR0EiLCJwcm9jZXNzUmVzcG9uc2VEb25lIiwiZnVsbFRpbWluZ0luZm8iLCJyZXBvcnRUaW1pbmdTdGVwcyIsImJvZHlJbmZvIiwiaGFzQ3Jvc3NPcmlnaW5SZWRpcmVjdHMiLCJpbml0aWF0b3JUeXBlIiwidHJhbnNmb3JtIiwiZmx1c2giLCJyZWFkYWJsZVN0cmVhbSIsIl9ib2R5UmVhZGVyIiwiREEiLCJvbkFib3J0ZWQiLCJGQSIsIktlIiwieGUiLCJUQSIsImZ0IiwiV2UiLCJMQSIsImpBIiwiekEiLCJOdCIsImNyZWF0ZUd1bnppcCIsIlpfU1lOQ19GTFVTSCIsImZpbmlzaEZsdXNoIiwiY3JlYXRlQnJvdGxpRGVjb21wcmVzcyIsImZldGNoIiwiRmV0Y2giLCJmZXRjaGluZyIsImZpbmFsaXplQW5kUmVwb3J0VGltaW5nIiwic3ltYm9scyQyIiwiaGFzUmVxdWlyZWRTeW1ib2xzJDIiLCJyZXF1aXJlU3ltYm9scyQyIiwia1Jlc3VsdCIsImtMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkIiwia0V2ZW50cyIsImtBYm9ydGVkIiwicHJvZ3Jlc3NldmVudCIsImhhc1JlcXVpcmVkUHJvZ3Jlc3NldmVudCIsInJlcXVpcmVQcm9ncmVzc2V2ZW50IiwiRXZlbnQiLCJQcm9ncmVzc0V2ZW50SW5pdCIsImxlbmd0aENvbXB1dGFibGUiLCJsb2FkZWQiLCJ0b3RhbCIsIlByb2dyZXNzRXZlbnQiLCJoYXNSZXF1aXJlZEVuY29kaW5nIiwicmVxdWlyZUVuY29kaW5nIiwiZ2V0RW5jb2RpbmciLCJ1dGlsJDUiLCJoYXNSZXF1aXJlZFV0aWwkNCIsInJlcXVpcmVVdGlsJDQiLCJTdHJpbmdEZWNvZGVyIiwiYnRvYSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZGlzcGF0Y2hFdmVudCIsInN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMiLCJyZWFkT3BlcmF0aW9uIiwiZmlyZUFQcm9ncmVzc0V2ZW50IiwiZmlsZXJlYWRlciIsImhhc1JlcXVpcmVkRmlsZXJlYWRlciIsInJlcXVpcmVGaWxlcmVhZGVyIiwiRXZlbnRUYXJnZXQiLCJsb2FkZW5kIiwibG9hZCIsInByb2dyZXNzIiwibG9hZHN0YXJ0IiwicmVhZEFzQXJyYXlCdWZmZXIiLCJyZWFkQXNCaW5hcnlTdHJpbmciLCJyZWFkQXNUZXh0IiwicmVhZEFzRGF0YVVSTCIsInJlYWR5U3RhdGUiLCJFTVBUWSIsIkxPQURJTkciLCJET05FIiwicmVzdWx0Iiwib25sb2FkZW5kIiwib25lcnJvciIsIm9ubG9hZHN0YXJ0Iiwib25wcm9ncmVzcyIsIm9ubG9hZCIsIm9uYWJvcnQiLCJGaWxlUmVhZGVyIiwic3ltYm9scyQxIiwiaGFzUmVxdWlyZWRTeW1ib2xzJDEiLCJyZXF1aXJlU3ltYm9scyQxIiwidXRpbCQ0IiwiaGFzUmVxdWlyZWRVdGlsJDMiLCJyZXF1aXJlVXRpbCQzIiwidXJsRXF1YWxzIiwiZ2V0RmllbGRWYWx1ZXMiLCJoYXNSZXF1aXJlZENhY2hlIiwicmVxdWlyZUNhY2hlIiwicWUiLCIkQSIsInd0IiwiamUiLCJDYWNoZVF1ZXJ5T3B0aW9ucyIsIm1hdGNoQWxsIiwiYWRkQWxsIiwiaWdub3JlTWV0aG9kIiwiaWdub3JlU2VhcmNoIiwiaWdub3JlVmFyeSIsIk11bHRpQ2FjaGVRdWVyeU9wdGlvbnMiLCJDYWNoZSIsImNhY2hlc3RvcmFnZSIsImhhc1JlcXVpcmVkQ2FjaGVzdG9yYWdlIiwicmVxdWlyZUNhY2hlc3RvcmFnZSIsImNhY2hlTmFtZSIsIkNhY2hlU3RvcmFnZSIsImNvbnN0YW50cyQxIiwiaGFzUmVxdWlyZWRDb25zdGFudHMkMSIsInJlcXVpcmVDb25zdGFudHMkMSIsIm1heEF0dHJpYnV0ZVZhbHVlU2l6ZSIsIm1heE5hbWVWYWx1ZVBhaXJTaXplIiwidXRpbCQzIiwiaGFzUmVxdWlyZWRVdGlsJDIiLCJyZXF1aXJlVXRpbCQyIiwiZ2V0VVRDRGF5IiwiZ2V0VVRDRGF0ZSIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwic2VjdXJlIiwiZG9tYWluIiwiaHR0cE9ubHkiLCJtYXhBZ2UiLCJleHBpcmVzIiwic2FtZVNpdGUiLCJ1bnBhcnNlZCIsImlzQ1RMRXhjbHVkaW5nSHRhYiIsInZhbGlkYXRlQ29va2llTmFtZSIsInZhbGlkYXRlQ29va2llUGF0aCIsInZhbGlkYXRlQ29va2llVmFsdWUiLCJ0b0lNRkRhdGUiLCJnZXRIZWFkZXJzTGlzdCIsImhhc1JlcXVpcmVkUGFyc2UiLCJyZXF1aXJlUGFyc2UiLCJwYXJzZVNldENvb2tpZSIsInBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzIiwiaGFzUmVxdWlyZWRDb29raWVzIiwicmVxdWlyZUNvb2tpZXMiLCJEZWxldGVDb29raWVBdHRyaWJ1dGVzIiwiQ29va2llIiwiZ2V0Q29va2llcyIsImRlbGV0ZUNvb2tpZSIsImdldFNldENvb2tpZXMiLCJzZXRDb29raWUiLCJldmVudHMiLCJoYXNSZXF1aXJlZEV2ZW50cyIsInJlcXVpcmVFdmVudHMiLCJNZXNzYWdlUG9ydCIsIk1lc3NhZ2VFdmVudEluaXQiLCJsYXN0RXZlbnRJZCIsInBvcnRzIiwiaXNGcm96ZW4iLCJpbml0TWVzc2FnZUV2ZW50IiwiQ2xvc2VFdmVudEluaXQiLCJ3YXNDbGVhbiIsIkVycm9yRXZlbnRJbml0IiwibGluZW5vIiwiY29sbm8iLCJNZXNzYWdlRXZlbnQiLCJDbG9zZUV2ZW50IiwiRXJyb3JFdmVudCIsImhhc1JlcXVpcmVkQ29uc3RhbnRzIiwicmVxdWlyZUNvbnN0YW50cyIsIkNPTk5FQ1RJTkciLCJPUEVOIiwiQ0xPU0lORyIsIkNMT1NFRCIsIk5PVF9TRU5UIiwiUFJPQ0VTU0lORyIsIlNFTlQiLCJDT05USU5VQVRJT04iLCJURVhUIiwiQklOQVJZIiwiQ0xPU0UiLCJQSU5HIiwiUE9ORyIsIklORk8iLCJQQVlMT0FETEVOR1RIXzE2IiwiUEFZTE9BRExFTkdUSF82NCIsIlJFQURfREFUQSIsImFsbG9jVW5zYWZlIiwidWlkIiwic2VudENsb3NlRnJhbWVTdGF0ZSIsInN0YXRlcyIsIm9wY29kZXMiLCJtYXhVbnNpZ25lZDE2Qml0IiwicGFyc2VyU3RhdGVzIiwiZW1wdHlCdWZmZXIiLCJzeW1ib2xzIiwiaGFzUmVxdWlyZWRTeW1ib2xzIiwicmVxdWlyZVN5bWJvbHMiLCJrV2ViU29ja2V0VVJMIiwia1JlYWR5U3RhdGUiLCJrQ29udHJvbGxlciIsImtSZXNwb25zZSIsImtCaW5hcnlUeXBlIiwia1NlbnRDbG9zZSIsImtSZWNlaXZlZENsb3NlIiwia0J5dGVQYXJzZXIiLCJ1dGlsJDIiLCJoYXNSZXF1aXJlZFV0aWwkMSIsInJlcXVpcmVVdGlsJDEiLCJpc1V0ZjgiLCJmYXRhbCIsImlzQ29ubmVjdGluZyIsImlzRXN0YWJsaXNoZWQiLCJpc0Nsb3NpbmciLCJpc0Nsb3NlZCIsImZpcmVFdmVudCIsImlzVmFsaWRTdWJwcm90b2NvbCIsImlzVmFsaWRTdGF0dXNDb2RlIiwiZmFpbFdlYnNvY2tldENvbm5lY3Rpb24iLCJ3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQiLCJ1dGY4RGVjb2RlIiwiaGFzUmVxdWlyZWRDb25uZWN0aW9uIiwicmVxdWlyZUNvbm5lY3Rpb24iLCJyYW5kb21CeXRlcyIsImV4dGVuc2lvbnMiLCJ3cyIsImNsb3NpbmdJbmZvIiwiZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbiIsImZyYW1lIiwiaGFzUmVxdWlyZWRGcmFtZSIsInJlcXVpcmVGcmFtZSIsImZyYW1lRGF0YSIsIm1hc2tLZXkiLCJjcmVhdGVGcmFtZSIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVJbnRCRSIsIldlYnNvY2tldEZyYW1lU2VuZCIsInJlY2VpdmVyIiwiaGFzUmVxdWlyZWRSZWNlaXZlciIsInJlcXVpcmVSZWNlaXZlciIsIldyaXRhYmxlIiwiX3dyaXRlIiwicnVuIiwiZmluIiwib3Bjb2RlIiwib3JpZ2luYWxPcGNvZGUiLCJmcmFnbWVudGVkIiwicGF5bG9hZExlbmd0aCIsImNsb3NlSW5mbyIsInBhcnNlQ2xvc2VCb2R5IiwicGF5bG9hZCIsInJlYWRVSW50MTZCRSIsInJlYWRVSW50MzJCRSIsIkJ5dGVQYXJzZXIiLCJoYXNSZXF1aXJlZFdlYnNvY2tldCIsInJlcXVpcmVXZWJzb2NrZXQiLCJrdCIsInByb3RvY29scyIsImV2ZXJ5Iiwic2VuZCIsIldlYlNvY2tldFNlbmREYXRhIiwiYnVmZmVyZWRBbW91bnQiLCJvbm9wZW4iLCJvbmNsb3NlIiwib25tZXNzYWdlIiwiYmluYXJ5VHlwZSIsIldlYlNvY2tldEluaXQiLCJXZWJTb2NrZXQiLCJ1dGlsJDEiLCJoYXNSZXF1aXJlZFV0aWwiLCJyZXF1aXJlVXRpbCIsImlzVmFsaWRMYXN0RXZlbnRJZCIsImlzQVNDSUlOdW1iZXIiLCJldmVudHNvdXJjZVN0cmVhbSIsImhhc1JlcXVpcmVkRXZlbnRzb3VyY2VTdHJlYW0iLCJyZXF1aXJlRXZlbnRzb3VyY2VTdHJlYW0iLCJldmVudCIsInJldHJ5IiwiZXZlbnRTb3VyY2VTZXR0aW5ncyIsImNoZWNrQk9NIiwicG9zIiwiZXZlbnRFbmRDaGVjayIsImNybGZDaGVjayIsInByb2Nlc3NFdmVudCIsImNsZWFyRXZlbnQiLCJwYXJzZUxpbmUiLCJyZWNvbm5lY3Rpb25UaW1lIiwiRXZlbnRTb3VyY2VTdHJlYW0iLCJldmVudHNvdXJjZSIsImhhc1JlcXVpcmVkRXZlbnRzb3VyY2UiLCJyZXF1aXJlRXZlbnRzb3VyY2UiLCIkZSIsIl9lIiwiRXZlbnRTb3VyY2VJbml0RGljdCIsIndpdGhDcmVkZW50aWFscyIsInJlY29ubmVjdGlvblRpbWVyIiwiRXZlbnRTb3VyY2UiLCJkZWZhdWx0UmVjb25uZWN0aW9uVGltZSIsIkRpc3BhdGNoZXIiLCJhcGkiLCJBZ2VudF8xIiwiUHJveHlBZ2VudF8xIiwibWFrZURpc3BhdGNoZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.df7e6bd6.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native-with-agent/lib/index.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/node-fetch-native-with-agent/lib/index.cjs ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst nodeFetch = __webpack_require__(/*! ../dist/index.cjs */ \"(rsc)/./node_modules/node-fetch-native-with-agent/dist/index.cjs\");\nfunction fetch(input, options) {\n    return nodeFetch.fetch(input, options);\n}\nfor(const key in nodeFetch){\n    fetch[key] = nodeFetch[key];\n}\nmodule.exports = fetch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudC9saWIvaW5kZXguY2pzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxZQUFZQyxtQkFBT0EsQ0FBQywyRkFBbUI7QUFFN0MsU0FBU0MsTUFBTUMsS0FBSyxFQUFFQyxPQUFPO0lBQzNCLE9BQU9KLFVBQVVFLEtBQUssQ0FBQ0MsT0FBT0M7QUFDaEM7QUFFQSxJQUFLLE1BQU1DLE9BQU9MLFVBQVc7SUFDM0JFLEtBQUssQ0FBQ0csSUFBSSxHQUFHTCxTQUFTLENBQUNLLElBQUk7QUFDN0I7QUFFQUMsT0FBT0MsT0FBTyxHQUFHTCIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVvLWVkaXRvci1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUtd2l0aC1hZ2VudC9saWIvaW5kZXguY2pzPzc3NmEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgbm9kZUZldGNoID0gcmVxdWlyZShcIi4uL2Rpc3QvaW5kZXguY2pzXCIpO1xuXG5mdW5jdGlvbiBmZXRjaChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbm9kZUZldGNoLmZldGNoKGlucHV0LCBvcHRpb25zKTtcbn1cblxuZm9yIChjb25zdCBrZXkgaW4gbm9kZUZldGNoKSB7XG4gIGZldGNoW2tleV0gPSBub2RlRmV0Y2hba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmZXRjaDtcbiJdLCJuYW1lcyI6WyJub2RlRmV0Y2giLCJyZXF1aXJlIiwiZmV0Y2giLCJpbnB1dCIsIm9wdGlvbnMiLCJrZXkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native-with-agent/lib/index.cjs\n");

/***/ })

};
;